# 阶段零：基础设施准备（详细实施文档）

> 适用范围：`Qwen2.5-Coder-0.5B 基于 GRPO 的 Phaser3 代码生成强化训练方案` 的 **2.2 阶段零：基础设施准备**  
> 本文目标：把“能跑通后续 SFT/GRPO 所需的底座”拆成可执行的工程任务与验收标准。

---

## 0. 本阶段产出（DoD）

本阶段结束时应具备以下可交付物（建议全部可复现构建）：

1) **Phaser3 API 索引库**  
   - 机器可读：`JSONL`（或 `SQLite`）格式  
   - 可检索：提供 `query(prompt)->topK APIs` 的检索接口（命令行或 Python/Node SDK 均可）  
   - 可校验：提供 `validate(code_ast)->api_usage_report` 的 API 使用校验能力

2) **Prompt 种子库（≥2000 条）**  
   - 覆盖 Phaser3 主要模块（Scene / Physics / Input / Animations / Tilemap / Particles …）  
   - 难度分布：基础 40% / 中等 40% / 困难 20%  
   - 统一结构化格式（推荐 `JSONL`），包含标签、约束、预期可验证点

3) **验证环境（静态+运行时）**  
   - ESLint：声明 `Phaser` 全局 + 基础规范与危险用法拦截  
   - Babel AST：可对生成代码做结构与 API 规则校验  
   - Phaser.HEADLESS：可无渲染运行，输出可用于过滤与奖励计算的结构化结果（JSON）

> 注：本阶段只搭基础设施与数据底座，不要求完成 SFT/GRPO 训练代码，但要保证后续阶段“接上就能跑”。

---

## 1. 环境与约定

### 1.1 版本锁定（强约束）

- Node.js：建议 `>=18`（用于 ESLint/Babel/HEADLESS runner）
- Python：建议 `>=3.10`（用于索引构建、数据集生成与后续训练编排）
- Phaser：**锁定一个具体版本**（例如 `3.70.x` / `3.80.x`），并在索引与验证环境中保持一致

### 1.2 仓库目录结构（建议）

为减少后续阶段的“路径/格式”摩擦，建议采用如下结构（可按团队习惯调整，但要固定下来）：

```text
.
├─ 代码能力训练.md
├─ 阶段零-基础设施准备-详细实施文档.md
├─ data/
│  ├─ api_index/                # Phaser3 API 索引产物（JSONL/SQLite + 元信息）
│  ├─ prompt_seeds/             # Prompt 种子库（JSONL）
│  └─ reports/                  # 构建报告/抽检结果/覆盖率统计
├─ scripts/
│  ├─ build_api_index.ts|js     # 构建索引（推荐 Node + TypeScript）
│  ├─ query_api.ts|py           # API 检索（prompt/text -> topK APIs）
│  ├─ build_prompt_seeds.py     # 生成/合并种子 Prompt（推荐 Python）
│  └─ validate_sample.py        # 端到端验证（调用 Node runner）
└─ validator/                   # Node 工程：ESLint + AST + HEADLESS
   ├─ package.json
   ├─ eslint.config.js
   └─ src/
      ├─ ast_check.ts|js
      ├─ run_headless.ts|js
      └─ cli.ts|js
```

### 1.3 数据格式统一（强约束）

后续蒸馏、过滤、训练、评估都会大量消费这些数据，建议统一为 **JSONL**（一行一个对象）：

- 便于流式处理、分片、并行、追加
- 可无痛写入 `SQLite`/`Parquet` 作为加速层（后续阶段再做也可以）

### 1.4 一次性初始化（示例命令）

> 仅提供“可跑通”的参考命令；你可以用 `pnpm/uv/poetry/conda` 等替换，但务必把版本锁定策略落到文件里（`package-lock.json` / `pnpm-lock.yaml` / `poetry.lock` 等）。

- 创建目录：`mkdir -p data/{api_index,prompt_seeds,reports} scripts validator/src`
- 初始化 validator（Node）：`cd validator && npm init -y`
- 安装验证依赖（示例）：`npm i phaser@<LOCKED_VERSION> eslint @babel/parser @babel/traverse`
- 安装开发依赖（示例）：`npm i -D typescript ts-node`

---

## 2. Phaser3 API 索引构建

### 2.1 数据源选择（推荐路径）

优先级建议如下：

1) **TypeScript 类型声明（推荐）**：从 `phaser` npm 包或 Phaser 源码中的 `types/*.d.ts` 提取  
   - 优点：结构化强、签名稳定、易解析、与真实 API 更贴近  
   - 缺点：文档描述可能不完整（可选补充 JSDoc/官方示例链接）

2) 官方文档 HTML 抓取（备选/补充）  
   - 优点：描述丰富、含示例  
   - 缺点：易受页面结构变更影响；解析成本高

本方案建议：**以 d.ts 为“真源”，HTML/JSDoc 为可选补充字段**。

### 2.2 索引 Schema（建议）

每条 API 记录建议具备以下字段（最小集 + 可选扩展）：

```json
{
  "symbol_id": "Phaser.GameObjects.Sprite#setTexture",
  "name": "setTexture",
  "kind": "method",
  "owner": "Phaser.GameObjects.Sprite",
  "signature": "setTexture(key: string, frame?: string | number): this",
  "params": [
    {"name": "key", "type": "string", "optional": false},
    {"name": "frame", "type": "string | number", "optional": true}
  ],
  "returns": {"type": "this"},
  "tags": ["GameObjects", "Sprite", "Texture"],
  "since": "3.x",
  "source": {
    "origin": "dts",
    "version": "3.80.0",
    "path": "types/phaser.d.ts",
    "loc": {"start_line": 0, "end_line": 0}
  },
  "doc": "",
  "examples": []
}
```

关键点：

- `symbol_id` 要 **全局唯一**，且与 AST 校验时的“解析命中逻辑”一致  
- `owner` 统一用完整命名空间（`Phaser.*`），减少歧义  
- `signature` 建议存“可读签名”，便于 Prompt 注入与人工抽检

### 2.3 构建流程（实现步骤）

#### Step A：获取 Phaser 源（锁版本）

任选一种方式，但要把版本写入产物元信息：

- npm 安装固定版本（更适合 CI 构建）
- 直接拉取 Phaser 源码仓库并固定 tag/commit（更适合深度补充 JSDoc/示例）

示例（npm，锁版本）：

```bash
npm i phaser@<LOCKED_VERSION>
# d.ts 通常位于：node_modules/phaser/types/phaser.d.ts
```

#### Step B：解析 d.ts 生成结构化记录

推荐实现方式：

- 使用 TypeScript 编译器 API（或 `ts-morph`）读取 `phaser.d.ts`
- 遍历导出的 `namespace/module` → `class/interface/type` → `method/property`
- 归一化：
  - 统一 `owner` 表达（全限定名）
  - 重载：拆分成多条记录或合并为一条（推荐合并到 `signature_overloads` 字段）
  - 泛型/联合类型：保留原始字符串即可（后续只做“弱类型”校验）

输出建议：

- `data/api_index/phaser_api.jsonl`：主索引（每行一条 API）
- `data/api_index/meta.json`：版本、构建时间、统计摘要、源路径

建议把构建脚本做成 CLI（便于 CI 复现），参数示例：

```bash
# 示例：Node 脚本（输出 JSONL + meta；无外部依赖的轻量解析器）
node scripts/build_api_index.js \
  --dts node_modules/phaser/types/phaser.d.ts \
  --out data/api_index/phaser_api.jsonl \
  --meta data/api_index/meta.json \
  --phaser-version <LOCKED_VERSION>
```

#### Step C：构建检索层（用于 Prompt 注入）

最小可行方案（优先实现）：

- 将 `JSONL` 载入内存（或 mmap）  
- 建立 `name/owner/tags/doc` 的倒排索引（Python/Node 均可）
- 提供 `query(text, top_k=20)`：返回最相关的 API 条目（按简单 BM25/TF-IDF 即可）

增强方案（可选）：

- SQLite FTS5：`apis(symbol_id, owner, name, signature, doc, tags)` + `fts5` 虚表  
- 向量检索：后续如引入 embeddings 再做（本阶段不强求）

建议把检索也做成一个稳定的 CLI（后续教师模型蒸馏直接调用）：

```bash
python scripts/query_api.py \
  --index data/api_index/phaser_api.jsonl \
  --text "实现一个带重力与跳跃的角色控制" \
  --top-k 20
```

输出建议：打印 JSON 到 stdout（数组或对象），至少包含 `symbol_id/owner/name/signature`。

### 2.4 API 校验接口（用于过滤与奖励）

最小能力定义：

- 输入：代码 AST（或原始代码字符串 + 解析器配置）
- 输出：结构化报告（JSON），包含：
  - 命中到的 API 调用/属性访问列表（带位置）
  - 未命中（疑似不存在）的符号
  - 参数数量检查（弱校验：`args_len` 与可选参数）
  - 关键 API 覆盖率（按 Prompt 要求的 must-use 列表）

注意：

- Phaser 动态特性很多，严格类型校验会误杀；建议先做 **存在性 + 常见误用** 的“弱校验”
- 校验逻辑要与索引 Schema 对齐（例如 `owner+name`、或“调用链”解析规则）

### 2.5 质量校验与抽检（验收）

建议输出一份 `data/reports/api_index_report.json`，至少包含：

- 统计：类/方法/属性数量、tag 分布、owner TopN  
- 随机抽检：随机 50 条记录打印（或输出到 markdown）  
- 版本一致性：`meta.json` 中包含 Phaser 版本，并在 validator 工程里校验一致

---

## 3. Prompt 种子库设计（≥2000 条）

### 3.1 Prompt 结构（建议 JSONL）

每条 Prompt 建议包含如下字段（可按需要增减，但要固定 schema）：

```json
{
  "id": "seed_000123",
  "difficulty": "easy",
  "modules": ["Scene", "Input"],
  "task": "实现一个可拖拽的方块精灵，拖拽时改变颜色，松手后回到原位。",
  "constraints": [
    "使用 Phaser3",
    "必须包含 preload/create 生命周期",
    "不得依赖外部资源（用 Graphics 或内置形状代替图片）"
  ],
  "must_use_apis": [
    "Phaser.Input.Events.GAMEOBJECT_DRAG",
    "Phaser.GameObjects.Graphics"
  ],
  "eval_hints": [
    "应注册拖拽事件监听",
    "应在拖拽时更新位置并改变填充色",
    "松手恢复初始位置"
  ],
  "tags": ["drag", "graphics", "event"],
  "notes": ""
}
```

说明：

- `task`：写清“做什么”，避免把实现步骤写死（保持生成空间）
- `constraints`：约束越具体，后续过滤与奖励越可控
- `must_use_apis`：用于 Prompt 注入与后续奖励/过滤的对齐锚点（可为空，但建议中高难度至少给 1-3 个）
- `eval_hints`：用于构建可执行断言/AST 规则的线索（后续阶段消费）

### 3.2 覆盖规划（模块 × 难度）

建议先做一个覆盖矩阵（`data/reports/prompt_coverage.csv`），按模块规划数量：

- Scene（必须覆盖，生命周期/切场景）
- GameObjects（Sprite/Text/Graphics/Container）
- Input（pointer/keyboard/drag）
- Physics（Arcade 为主，Matter 可做扩展）
- Animations（sprite sheet / tween）
- Tilemap
- Camera
- Particles
- Sound（可选，若后续验证环境难以 headless，可降低占比）

难度定义建议（用于统一口径）：

- easy：单一模块、单场景、1-2 个交互点、无复杂状态机
- medium：跨 2-3 模块、需要状态管理/碰撞/动画组合、带约束（例如性能/边界）
- hard：跨模块组合 + 多场景/关卡 + 复杂约束（例如可复现随机、可配置参数、行为一致性）

### 3.3 种子生成方法（建议工作流）

1) **手工设计 200-400 条“母题”**（覆盖核心模块与典型玩法）  
2) **程序化扩展到 2000+**（同一母题做参数化变体）：
   - 主题变体：收集/躲避/射击/拼图/平台跳跃
   - 约束变体：资源限制（不用图片）、性能限制（对象池）、输入限制（仅键盘）
   - API 锚点变体：同目标用不同 API 实现（例如 Tween vs 手动 update）
3) 去重与质量审查：
   - 文本相似度去重（防止“换皮”）
   - 必要字段完整性检查（空字段/非法 difficulty/tag）
   - 抽检 5%：确认描述清晰、可实现、可验证

示例（生成 2000 条 JSONL + 覆盖率报告）：

```bash
python scripts/build_prompt_seeds.py \
  --count 2000 \
  --out data/prompt_seeds/prompt_seeds.jsonl \
  --report-json data/reports/prompt_seeds_report.json \
  --coverage-csv data/reports/prompt_coverage.csv
```

### 3.4 验收标准

- 数量：`>=2000`  
- 分布：easy/medium/hard 接近 40/40/20（允许 ±3% 波动）  
- 覆盖：核心模块均有样本，且每个模块至少覆盖 3 种不同任务类型  
- 可验证性：≥70% 的 Prompt 具备可转化为断言/AST 规则的 `eval_hints`

---

## 4. 验证环境搭建（ESLint + Babel AST + Phaser.HEADLESS）

### 4.1 验证管线目标

后续阶段会对候选代码做“自动化过滤/奖励”，验证环境至少要输出这些信号：

- `parse_ok`：语法可解析（Babel）
- `lint_ok`：满足基础规范/无明显危险用法（ESLint）
- `api_ok`：API 规则检查通过（索引对照 + AST 规则）
- `runtime_ok`：HEADLESS 可运行且不崩溃
- `metrics`：用于奖励与筛选的结构化指标（例如：是否创建 Game、Scene 生命周期是否完整、是否注册输入事件、碰撞回调是否触发等）

建议统一输出：

```json
{
  "parse_ok": true,
  "lint_ok": true,
  "api_ok": true,
  "runtime_ok": true,
  "errors": [],
  "warnings": [],
  "api_usage": {"hits": [], "misses": []},
  "runtime": {"ms": 83, "crashed": false, "logs": []},
  "signals": {"has_preload": true, "has_create": true, "has_update": false}
}
```

#### CLI/输入输出约定（建议）

为便于 Python 数据管线/训练框架调用，建议 validator 提供一个稳定 CLI：

```bash
node validator/src/cli.js \
  --code-file /abs/path/to/generated.js \
  --api-index data/api_index/phaser_api.jsonl \
  --prompt-json '{"must_use_apis":["Phaser.GameObjects.Graphics"]}' \
  --timeout-ms 1500 \
  --frames 60
```

也可以用 Python 包一层（方便后续数据管线调用）：

```bash
python scripts/validate_sample.py \
  --code-file /abs/path/to/generated.js \
  --api-index data/api_index/phaser_api.jsonl \
  --prompt-json '{"must_use_apis":["Phaser.GameObjects.Graphics"]}' \
  --skip-eslint \
  --skip-runtime
```

约定：

- 所有结果输出到 stdout（单行 JSON），stderr 只打印调试信息
- 任何异常都要被捕获并落到 `errors[]`，避免进程静默退出
- `--prompt-json` 只需包含本阶段会用到的字段（至少 `must_use_apis`），不强依赖完整 Prompt schema

### 4.2 ESLint 配置要点

最低要求：

- 声明 Phaser 全局：避免 `no-undef` 误报
- 限制明显危险用法（建议）：
  - 禁用 `child_process` / `fs` / `net` / `http` 等（如果允许 `require`，务必拦截）
  - 禁止 `eval`/`Function`（降低注入风险）

建议把 ESLint 作为“门控”：失败直接淘汰或降分。

### 4.3 Babel AST 分析（规则集最小集）

建议先实现以下“高收益”规则：

- 结构规则：
  - 是否创建 `new Phaser.Game(config)`
  - `config.scene` 是否存在（Scene class/object/array）
  - 是否包含 `preload/create`（按 Prompt 难度可变）
- API 规则：
  - 识别 `this.add.* / this.physics.add.* / this.input.*` 等常见调用链
  - 与 `api_index` 对照检查存在性（弱校验）
  - 对 `must_use_apis` 做命中统计

### 4.4 Phaser.HEADLESS 运行（Node 环境）

核心原则：

- 所有运行应可设置 **超时**（例如 1-2 秒）与 **内存上限**  
- 运行应尽量 **确定性**（固定随机种子/固定 dt/固定帧数）  
- 运行在隔离环境（详见 4.5）

最小实现建议：

- Node 子进程执行（每条样本独立进程，或进程池复用但要有重置）
- 运行 N 帧（例如 60 帧），收集：
  - 是否成功创建 Game 实例
  - Scene 生命周期是否按预期触发
  - 是否抛异常/Promise rejection

如果 HEADLESS 在当前平台不稳定：

- 先只做 AST/Lint 过滤（不阻塞阶段推进）
- 同时准备备选：使用 `jsdom + canvas` 或 Docker 镜像中固定依赖版本

### 4.5 安全隔离（强建议）

后续会执行“模型生成的代码”，即使是内部训练也要按不可信对待：

- **进程级隔离**：验证运行放在独立 Node 子进程，主进程只收集 JSON 结果
- **容器级隔离（更推荐）**：Docker/Podman 中禁网、只读文件系统、限制 CPU/内存/进程数
- 禁止访问宿主机敏感路径与环境变量

最低可接受基线：子进程 + 禁止 `require` 敏感模块 + 超时杀进程。

### 4.6 验收标准（端到端）

给定一条“已知正确”的 Phaser3 示例代码：

- `lint_ok=true`（ESLint 可过）
- `parse_ok=true`（Babel 可解析）
- `api_ok=true`（API 命中正常，无大量 miss）
- `runtime_ok=true`（HEADLESS 运行不崩溃）
- 输出 JSON 结果稳定（重复跑 10 次结果一致）

---

## 5. 里程碑（建议 3-7 天）

可按实际资源压缩/扩展：

- Day 1：确定版本锁定 + 仓库目录结构 + validator Node 工程骨架
- Day 2：完成 d.ts 解析 → 生成 `api_index` + 基础 query 接口
- Day 3：完成 AST 规则最小集 + API 对照校验（弱校验）
- Day 4：完成 HEADLESS runner（或确认平台可行性 + 备选方案）
- Day 5-7：Prompt 母题设计 + 扩展到 2000+ + 去重 + 覆盖率报告

---

## 6. 风险与备选方案

- **HEADLESS 不稳定/依赖复杂**：先用 AST/Lint 做主过滤，HEADLESS 作为“加分项”逐步引入；同时用容器固化依赖
- **d.ts 与文档/实际行为不一致**：索引以 d.ts 为准，运行时行为差异通过 HEADLESS 与后续人工抽检校准
- **Prompt 可验证性不足**：强制 `eval_hints` 字段；对 hard 样本建立“可执行断言模板”库（后续阶段做）
- **API 校验误杀**：先弱校验（存在性/常见错误），把严格类型检查放到后续迭代
