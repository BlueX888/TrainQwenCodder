{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色椭圆以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色椭圆以360速度移动并在画布边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser 游戏配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制橙色椭圆并生成纹理\n3. 创建物理精灵，设置初始速度为 360\n4. 设置物理边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆\n  \n  // 生成纹理\n  graphics.generateTexture('orangeEllipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'orangeEllipse');\n  \n  // 设置速度（360 像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 360);\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, 'Orange Ellipse bouncing at 360 speed', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000432_v1", "prompt_id": "seed_000432", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 300 像素/秒速度移动\nAPI: Graphics.fillTriangle, input.keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象并应用三角形纹理\n3. 使用 addKey 监听 WASD 四个按键\n4. 在 update 中根据按键状态更新三角形位置，速度为 300 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个朝上的三角形（中心在原点）\n  graphics.fillTriangle(\n    0, -20,    // 顶点\n    -15, 20,   // 左下角\n    15, 20     // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 30, 40);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已保存\n  \n  // 创建三角形精灵，初始位置在屏幕中心\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置键盘输入\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文字\n  this.add.text(10, 10, 'Use WASD to move the triangle', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧移动距离（速度 * 时间差，delta 单位是毫秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动三角形\n  if (keys.W.isDown) {\n    triangle.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    triangle.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    triangle.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    triangle.x += distance; // 向右移动\n  }\n  \n  // 可选：限制三角形在屏幕范围内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000756_v2", "prompt_id": "seed_000756", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让红色矩形在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个红色矩形，使用 Tween 实现 2 秒抖动循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建抖动动画，通过快速改变 x/y 位置模拟抖动\n4. 设置 yoyo 和 loop 实现循环抖动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('redRect', 100, 100);\n  graphics.destroy();\n\n  // 创建红色矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'redRect');\n\n  // 记录原始位置\n  const originalX = rect.x;\n  const originalY = rect.y;\n\n  // 创建抖动动画\n  // 通过在短时间内快速改变位置来模拟抖动效果\n  this.tweens.add({\n    targets: rect,\n    x: originalX + 10, // 向右抖动\n    y: originalY + 10, // 向下抖动\n    duration: 50, // 每次抖动持续 50ms\n    ease: 'Linear',\n    yoyo: true, // 来回抖动\n    repeat: 19, // 重复 19 次（加上初始 1 次，共 20 次往返，总计约 2 秒）\n    loop: -1, // 无限循环\n    onRepeat: function() {\n      // 在每次重复时随机改变抖动方向，增加抖动的随机性\n      const randomX = originalX + Phaser.Math.Between(-10, 10);\n      const randomY = originalY + Phaser.Math.Between(-10, 10);\n      \n      this.updateTo('x', randomX, true);\n      this.updateTo('y', randomY, true);\n    }\n  });\n\n  // 添加说明文字\n  this.add.text(400, 50, '红色矩形抖动动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, '抖动周期: 2秒循环', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000652_v2", "prompt_id": "seed_000652", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到32%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.32\n4. 设置动画时长为 3000ms，yoyo 为 true 实现恢复效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150); // 200x150 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('rectTexture', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建使用该纹理的精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    scaleX: 0.32,           // X轴缩放到32%\n    scaleY: 0.32,           // Y轴缩放到32%\n    duration: 3000,         // 动画时长3秒\n    yoyo: true,             // 动画结束后反向播放（恢复原始大小）\n    loop: -1,               // 无限循环 (-1 表示永久循环)\n    ease: 'Linear'          // 线性缓动\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 50, 'Rectangle scaling to 32% and back\\nLooping forever', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000550_v2", "prompt_id": "seed_000550", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按WASD键发射灰色子弹的例子，子弹速度 200，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按WASD键发射灰色子弹，速度200，离开边界自动回收到对象池\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard.addKey, Phaser.GameObjects.Graphics.generateTexture\nSTEPS:\n1. 创建物理场景配置，启用 arcade 物理引擎\n2. 在 create 中使用 Graphics 生成灰色子弹纹理\n3. 创建物理组作为子弹对象池，配置边界检测回收\n4. 监听 WASD 键输入，按键时从对象池获取子弹并设置速度方向\n5. 在 update 中检测子弹是否离开边界，离开则回收到对象池\n6. 添加状态变量 bulletsFired 记录发射子弹总数用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 状态信号：发射子弹总数\n    this.activeBullets = 0; // 状态信号：当前活跃子弹数\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建灰色子弹纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillCircle(8, 8, 8); // 圆形子弹，半径8\n    graphics.generateTexture('bullet', 16, 16);\n    graphics.destroy();\n\n    // 创建玩家（用于发射子弹的中心点）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(-16, -16, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹对象池（物理组）\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50, // 对象池最大容量\n      runChildUpdate: false\n    });\n\n    // 配置 WASD 键\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 防止连续发射的冷却时间\n    this.lastFired = 0;\n    this.fireRate = 200; // 毫秒\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 检查是否可以发射（冷却时间）\n    const canFire = time > this.lastFired + this.fireRate;\n\n    // WASD 键发射子弹\n    if (canFire) {\n      let velocityX = 0;\n      let velocityY = 0;\n\n      if (this.keyW.isDown) {\n        velocityY = -200; // 向上\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      } else if (this.keyS.isDown) {\n        velocityY = 200; // 向下\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      } else if (this.keyA.isDown) {\n        velocityX = -200; // 向左\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      } else if (this.keyD.isDown) {\n        velocityX = 200; // 向右\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      }\n    }\n\n    // 检查并回收离开边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        const bounds = this.physics.world.bounds;\n        if (bullet.x < bounds.x - 20 || \n            bullet.x > bounds.x + bounds.width + 20 ||\n            bullet.y < bounds.y - 20 || \n            bullet.y > bounds.y + bounds.height + 20) {\n          this.recycleBullet(bullet);\n        }\n      }\n    });\n\n    this.updateStatusText();\n  }\n\n  fireBullet(velocityX, velocityY) {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.body.enable = true;\n      bullet.setVelocity(velocityX, velocityY);\n      \n      this.bulletsFired++;\n      this.activeBullets++;\n    }\n  }\n\n  recycleBullet(bullet) {\n    // 回收子弹到对象池\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.body.enable = false;\n    bullet.setVelocity(0, 0);\n    \n    this.activeBullets--;\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Bullets Fired: ${this.bulletsFired}`,\n      `Active Bullets: ${this.activeBullets}`,\n      `Pool Size: ${this.bullets.getLength()}`,\n      '',\n      'Press WASD to fire bullets'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000972_v3", "prompt_id": "seed_000972", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的三角形\nAPI: Graphics#fillTriangle, Camera#startFollow, Sprite#setVelocity, Physics.Arcade\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制三角形并生成纹理\n3. 创建物理精灵并设置向左下的速度\n4. 设置相机跟随该精灵对象\n5. 扩大世界边界以便三角形有足够移动空间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 扩大世界边界，让三角形有足够的移动空间\n  this.physics.world.setBounds(0, 0, 3200, 2400);\n  \n  // 使用 Graphics 绘制三角形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向右上的三角形\n  graphics.fillTriangle(\n    25, 0,   // 顶点（上）\n    0, 50,   // 左下\n    50, 50   // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵，放置在世界中心\n  this.player = this.physics.add.sprite(1600, 1200, 'triangle');\n  \n  // 设置向左下移动的速度\n  // 负 x 表示向左，正 y 表示向下\n  this.player.setVelocity(-150, 150);\n  \n  // 设置精灵的碰撞边界\n  this.player.setCollideWorldBounds(false);\n  \n  // 设置相机跟随三角形\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3200, 2400);\n  \n  // 添加背景网格以便观察移动效果\n  this.createGrid();\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '三角形自动向左下移动\\n相机跟随中...', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 当前示例中三角形通过物理速度自动移动，不需要手动更新\n}\n\n// 辅助函数：创建网格背景以便观察相机移动\nfunction createGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 3200; x += 100) {\n    graphics.lineBetween(x, 0, x, 2400);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 2400; y += 100) {\n    graphics.lineBetween(0, y, 3200, y);\n  }\n  \n  // 添加坐标标记\n  for (let x = 0; x <= 3200; x += 400) {\n    for (let y = 0; y <= 2400; y += 400) {\n      const label = this.add.text(x + 5, y + 5, `(${x},${y})`, {\n        fontSize: '12px',\n        color: '#666666'\n      });\n    }\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000239_v3", "prompt_id": "seed_000239", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.42}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现粉色角色按键切换 idle/run 状态，用帧动画和 tween 体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Animations.AnimationManager, Phaser.Input.Keyboard, Phaser.Tweens\nSTEPS:\n1. 使用 Graphics 程序化生成粉色角色的 idle 和 run 状态帧纹理\n2. 创建 idle 和 run 两个帧动画\n3. 监听键盘输入（空格键切换状态，方向键触发 run）\n4. 根据状态播放对应动画，并添加 tween 效果（idle 时上下浮动，run 时水平抖动）\n5. 显示当前状态文本作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle'; // 可验证的状态信号\n    this.stateChangeCount = 0; // 状态切换次数\n  }\n\n  preload() {\n    // 生成 idle 状态的帧纹理（3帧，粉色方块，大小变化）\n    for (let i = 0; i < 3; i++) {\n      const graphics = this.add.graphics();\n      const size = 60 + i * 5; // 大小从60到70渐变\n      const offsetX = (70 - size) / 2;\n      const offsetY = (70 - size) / 2;\n      \n      // 绘制粉色身体\n      graphics.fillStyle(0xff69b4, 1);\n      graphics.fillRoundedRect(offsetX, offsetY, size, size, 10);\n      \n      // 绘制眼睛\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(offsetX + size * 0.35, offsetY + size * 0.4, 4);\n      graphics.fillCircle(offsetX + size * 0.65, offsetY + size * 0.4, 4);\n      \n      // 绘制笑脸\n      graphics.lineStyle(2, 0x000000, 1);\n      graphics.beginPath();\n      graphics.arc(offsetX + size * 0.5, offsetY + size * 0.6, size * 0.2, 0, Math.PI, false);\n      graphics.strokePath();\n      \n      graphics.generateTexture(`idle_${i}`, 70, 70);\n      graphics.destroy();\n    }\n\n    // 生成 run 状态的帧纹理（4帧，倾斜姿态）\n    for (let i = 0; i < 4; i++) {\n      const graphics = this.add.graphics();\n      const angle = (i % 2 === 0) ? -10 : 10; // 左右倾斜\n      \n      // 保存变换状态\n      graphics.save();\n      graphics.translateCanvas(35, 35);\n      graphics.rotateCanvas(Phaser.Math.DegToRad(angle));\n      graphics.translateCanvas(-35, -35);\n      \n      // 绘制粉色身体（拉长形状表示奔跑）\n      graphics.fillStyle(0xff69b4, 1);\n      graphics.fillRoundedRect(10, 15, 50, 40, 8);\n      \n      // 绘制眼睛（更有活力的表情）\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(27, 30, 4);\n      graphics.fillCircle(43, 30, 4);\n      \n      // 绘制兴奋的笑脸\n      graphics.lineStyle(3, 0x000000, 1);\n      graphics.beginPath();\n      graphics.arc(35, 40, 10, 0, Math.PI, false);\n      graphics.strokePath();\n      \n      // 绘制运动线条\n      graphics.lineStyle(2, 0xffa0d0, 0.6);\n      graphics.lineBetween(5, 25 + i * 3, 15, 25 + i * 3);\n      graphics.lineBetween(5, 35 + i * 3, 15, 35 + i * 3);\n      \n      graphics.restore();\n      graphics.generateTexture(`run_${i}`, 70, 70);\n      graphics.destroy();\n    }\n  }\n\n  create() {\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x87ceeb, 1);\n    bg.fillRect(0, 0, 800, 600);\n\n    // 创建地面\n    const ground = this.add.graphics();\n    ground.fillStyle(0x90ee90, 1);\n    ground.fillRect(0, 500, 800, 100);\n\n    // 创建角色精灵\n    this.player = this.add.sprite(400, 450, 'idle_0');\n    this.player.setScale(2);\n\n    // 创建 idle 动画\n    this.anims.create({\n      key: 'idle_anim',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' },\n        { key: 'idle_2' },\n        { key: 'idle_1' }\n      ],\n      frameRate: 4,\n      repeat: -1\n    });\n\n    // 创建 run 动画\n    this.anims.create({\n      key: 'run_anim',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 8,\n      repeat: -1\n    });\n\n    // 播放初始 idle 动画\n    this.player.play('idle_anim');\n\n    // 创建 idle 状态的浮动 tween\n    this.idleTween = this.tweens.add({\n      targets: this.player,\n      y: 440,\n      duration: 1000,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 创建状态显示文本\n    this.stateText = this.add.text(400, 50, 'State: IDLE', {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#ff69b4',\n      stroke: '#ffffff',\n      strokeThickness: 4\n    });\n    this.stateText.setOrigin(0.5);\n\n    // 创建计数器文本\n    this.counterText = this.add.text(400, 100, 'State Changes: 0', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 3\n    });\n    this.counterText.setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 550, 'Press SPACE to toggle | Arrow Keys to RUN', {\n      fontSize: '20px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 2\n    }).setOrigin(0.5);\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 空格键切换状态\n    this.spaceKey.on('down', () => {\n      this.toggleState();\n    });\n  }\n\n  update() {\n    // 方向键触发 run 状态\n    if (this.cursors.left.isDown || this.cursors.right.isDown || \n        this.cursors.up.isDown || this.cursors.down.isDown) {\n      if (this.currentState !== 'run') {\n        this.setState('run');\n      }\n    }\n  }\n\n  toggleState() {\n    if (this.currentState === 'idle') {\n      this.setState('run');\n    } else {\n      this.setState('idle');\n    }\n  }\n\n  setState(newState) {\n    if (this.currentState === newState) return;\n\n    this.currentState = newState;\n    this.stateChangeCount++;\n    this.counterText.setText(`State Changes: ${this.stateChangeCount}`);\n\n    // 停止所有 tweens\n    this.tweens.killTweensOf(this.player);\n\n    if (newState === 'idle') {\n      // 切换到 idle 动画\n      this.player.play('idle_anim');\n      this.stateText.setText('State: IDLE');\n      this.stateText.setColor('#ff69b4');\n\n      // 重置位置并启动浮动 tween\n      this.player.y = 450;\n      this.tweens.add({\n        targets: this.player,\n        y: 440,\n        duration: 1000,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n\n    } else if (newState === 'run') {\n      // 切换到 run 动画\n      this.player.play('run_anim');\n      this.stateText.setText('State: RUN');\n      this.stateText.setColor('#ff0000');\n\n      // 重置位置并启动水平抖动 tween\n      this.player.y = 450;\n      this.tweens.add({\n        targets: this.player,\n        x: this.player.x + 10,\n        duration: 100,\n        ease: 'Linear',\n        yoyo: true,\n        repeat: -1\n      });\n\n      // 添加轻微的上下跳动\n      this.tweens.add({\n        targets: this.player,\n        y: 445,\n        duration: 200,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  scene: GameScene,\n  pixelArt: false,\n  antialias: true\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000805_v1", "prompt_id": "seed_000805", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.465}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每 2.5 秒从顶部随机位置生成一个橙色下落障碍物，速度为 200。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 每 2.5 秒从顶部随机位置生成橙色下落障碍物，速度为 200\nAPI: Phaser.Time.Clock#addEvent, Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics#generateTexture, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色方块并生成纹理\n3. 创建物理组用于管理障碍物\n4. 使用 TimerEvent 每 2.5 秒生成一个障碍物\n5. 在随机 x 位置生成障碍物，设置向下速度为 200\n6. 添加状态变量记录生成的障碍物数量\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.obstacleCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 创建橙色障碍物纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff8800, 1); // 橙色\n    graphics.fillRect(0, 0, 40, 40); // 40x40 的方块\n    graphics.generateTexture('obstacle', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组用于管理障碍物\n    this.obstacles = this.physics.add.group({\n      defaultKey: 'obstacle',\n      maxSize: 50 // 限制最大数量，避免内存泄漏\n    });\n\n    // 创建定时器，每 2.5 秒生成一个障碍物\n    this.time.addEvent({\n      delay: 2500, // 2.5 秒\n      callback: this.spawnObstacle,\n      callbackScope: this,\n      loop: true // 循环执行\n    });\n\n    // 添加文本显示障碍物数量（用于验证）\n    this.countText = this.add.text(10, 10, 'Obstacles: 0', {\n      fontSize: '24px',\n      color: '#ffffff'\n    });\n  }\n\n  spawnObstacle() {\n    // 在顶部随机 x 位置生成障碍物\n    const randomX = Phaser.Math.Between(20, this.scale.width - 20);\n    const obstacle = this.obstacles.create(randomX, -20, 'obstacle');\n    \n    if (obstacle) {\n      // 设置向下速度为 200\n      obstacle.setVelocityY(200);\n      \n      // 更新计数\n      this.obstacleCount++;\n      this.countText.setText(`Obstacles: ${this.obstacleCount}`);\n    }\n  }\n\n  update(time, delta) {\n    // 清理超出屏幕底部的障碍物\n    this.obstacles.children.entries.forEach((obstacle) => {\n      if (obstacle.y > this.scale.height + 50) {\n        obstacle.destroy();\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 不使用重力，手动设置速度\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001325_v2", "prompt_id": "seed_001325", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个白色圆形移动，移动速度为 360，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制白色圆形移动，速度360，限制在画布边界内\nAPI: this.add.graphics(), this.input.keyboard.createCursorKeys(), graphics.fillCircle(), Phaser.Math.Clamp()\nSTEPS:\n1. 使用 Graphics 绘制白色圆形并生成纹理\n2. 创建精灵对象并设置初始位置\n3. 创建方向键监听器\n4. 在 update 中根据方向键输入更新精灵位置\n5. 使用 Clamp 函数限制精灵在画布边界内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nconst SPEED = 360;\nconst RADIUS = 20;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(RADIUS, RADIUS, RADIUS);\n  graphics.generateTexture('playerCircle', RADIUS * 2, RADIUS * 2);\n  graphics.destroy();\n\n  // 创建玩家精灵，初始位置在画布中心\n  player = this.add.sprite(\n    config.width / 2,\n    config.height / 2,\n    'playerCircle'\n  );\n\n  // 创建方向键监听器\n  cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update(time, delta) {\n  // 计算移动增量（像素/秒 * 秒 = 像素）\n  const moveDistance = SPEED * (delta / 1000);\n\n  // 根据方向键输入更新位置\n  if (cursors.left.isDown) {\n    player.x -= moveDistance;\n  }\n  if (cursors.right.isDown) {\n    player.x += moveDistance;\n  }\n  if (cursors.up.isDown) {\n    player.y -= moveDistance;\n  }\n  if (cursors.down.isDown) {\n    player.y += moveDistance;\n  }\n\n  // 限制在画布边界内（考虑圆形半径）\n  player.x = Phaser.Math.Clamp(player.x, RADIUS, config.width - RADIUS);\n  player.y = Phaser.Math.Clamp(player.y, RADIUS, config.height - RADIUS);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000592_v3", "prompt_id": "seed_000592", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 0.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在0.5秒内缩放到80%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，从 1 缩放到 0.8 再回到 1\n4. 设置 loop: -1 实现无限循环，duration: 500 实现 0.5 秒动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setOrigin(0.5, 0.5);\n\n  // 创建缩放动画\n  // yoyo: true 使动画在到达目标后反向播放回到起点\n  // repeat: -1 无限循环\n  // duration: 500 表示单程 0.5 秒（往返总共 1 秒）\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 500,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Linear'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, 'Rectangle scaling to 80% and back (looping)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000181_v1", "prompt_id": "seed_000181", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 记录玩家 2 秒内的操作序列，按鼠标左键开始回放，回放速度可调。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 记录玩家2秒内的键盘/鼠标操作序列，鼠标左键触发回放，支持可调速度回放\nAPI: Scene, Input.Keyboard, Input.on, GameObjects.Graphics, GameObjects.Text, Time.addEvent\nSTEPS:\n1. 创建可控制的玩家角色（使用Graphics绘制）\n2. 监听键盘WASD和鼠标移动，记录时间戳和操作类型到序列数组\n3. 限制录制时长为2秒，超时后停止记录\n4. 鼠标左键点击触发回放模式，按时间戳重现操作\n5. 添加UI显示录制/回放状态、回放速度调节（1x/2x/0.5x）\n[/PLAN]\n\n```javascript\nclass RecordReplayScene extends Phaser.Scene {\n  constructor() {\n    super('RecordReplayScene');\n    this.recordDuration = 2000; // 2秒录制时长\n    this.recordedActions = [];\n    this.isRecording = false;\n    this.isReplaying = false;\n    this.recordStartTime = 0;\n    this.replaySpeed = 1; // 回放速度倍率\n    this.replayStartTime = 0;\n    this.currentReplayIndex = 0;\n    \n    // 可验证状态\n    this.actionCount = 0;\n    this.replayCount = 0;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建玩家角色（使用Graphics）\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillCircle(0, 0, 20);\n    graphics.generateTexture('player', 40, 40);\n    graphics.destroy();\n\n    this.player = this.add.sprite(400, 300, 'player');\n    this.playerSpeed = 200;\n    this.playerVelocity = { x: 0, y: 0 };\n\n    // 创建录制指示器\n    const recGraphics = this.add.graphics();\n    recGraphics.fillStyle(0xff0000, 1);\n    recGraphics.fillCircle(0, 0, 10);\n    recGraphics.generateTexture('recIndicator', 20, 20);\n    recGraphics.destroy();\n\n    this.recIndicator = this.add.sprite(30, 30, 'recIndicator');\n    this.recIndicator.setVisible(false);\n\n    // UI文本\n    this.statusText = this.add.text(60, 20, 'Press WASD to move, Mouse to look', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    this.infoText = this.add.text(10, 60, '', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n\n    this.statsText = this.add.text(10, 560, '', {\n      fontSize: '14px',\n      fill: '#00ffff'\n    });\n\n    // 速度控制UI\n    this.speedText = this.add.text(600, 20, 'Speed: 1x (1/2/3 to change)', {\n      fontSize: '14px',\n      fill: '#ffffff'\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D,\n      ONE: Phaser.Input.Keyboard.KeyCodes.ONE,\n      TWO: Phaser.Input.Keyboard.KeyCodes.TWO,\n      THREE: Phaser.Input.Keyboard.KeyCodes.THREE\n    });\n\n    // 监听按键按下事件\n    this.input.keyboard.on('keydown', (event) => {\n      if (this.isRecording && !this.isReplaying) {\n        const elapsed = Date.now() - this.recordStartTime;\n        if (elapsed <= this.recordDuration) {\n          this.recordAction('keydown', event.key, elapsed);\n        }\n      }\n\n      // 速度调节\n      if (event.key === '1') this.setReplaySpeed(1);\n      if (event.key === '2') this.setReplaySpeed(2);\n      if (event.key === '3') this.setReplaySpeed(0.5);\n    });\n\n    // 监听按键释放事件\n    this.input.keyboard.on('keyup', (event) => {\n      if (this.isRecording && !this.isReplaying) {\n        const elapsed = Date.now() - this.recordStartTime;\n        if (elapsed <= this.recordDuration) {\n          this.recordAction('keyup', event.key, elapsed);\n        }\n      }\n    });\n\n    // 监听鼠标移动\n    this.input.on('pointermove', (pointer) => {\n      if (this.isRecording && !this.isReplaying) {\n        const elapsed = Date.now() - this.recordStartTime;\n        if (elapsed <= this.recordDuration) {\n          this.recordAction('mousemove', { x: pointer.x, y: pointer.y }, elapsed);\n        }\n      }\n    });\n\n    // 监听鼠标左键点击（触发回放）\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        if (!this.isReplaying && this.recordedActions.length > 0) {\n          this.startReplay();\n        }\n      }\n    });\n\n    // 开始录制\n    this.startRecording();\n\n    this.updateStats();\n  }\n\n  recordAction(type, data, timestamp) {\n    this.recordedActions.push({\n      type: type,\n      data: data,\n      timestamp: timestamp\n    });\n    this.actionCount++;\n  }\n\n  startRecording() {\n    this.isRecording = true;\n    this.recordedActions = [];\n    this.recordStartTime = Date.now();\n    this.actionCount = 0;\n    this.recIndicator.setVisible(true);\n    \n    this.statusText.setText('RECORDING... (2 seconds)');\n    this.infoText.setText('Move with WASD, move mouse');\n\n    // 2秒后停止录制\n    this.time.delayedCall(this.recordDuration, () => {\n      this.stopRecording();\n    });\n  }\n\n  stopRecording() {\n    this.isRecording = false;\n    this.recIndicator.setVisible(false);\n    this.statusText.setText('Recording complete! Click LEFT MOUSE to replay');\n    this.infoText.setText(`Recorded ${this.recordedActions.length} actions`);\n  }\n\n  startReplay() {\n    if (this.recordedActions.length === 0) return;\n\n    this.isReplaying = true;\n    this.currentReplayIndex = 0;\n    this.replayStartTime = Date.now();\n    this.replayCount++;\n\n    // 重置玩家位置\n    this.player.setPosition(400, 300);\n    this.playerVelocity = { x: 0, y: 0 };\n\n    this.statusText.setText(`REPLAYING at ${this.replaySpeed}x speed...`);\n    this.infoText.setText(`Replay #${this.replayCount}`);\n\n    // 清除按键状态\n    this.activeKeys = new Set();\n  }\n\n  update(time, delta) {\n    if (this.isReplaying) {\n      this.updateReplay();\n    } else if (!this.isRecording) {\n      // 正常控制\n      this.updatePlayerMovement(delta);\n    } else {\n      // 录制中也允许移动\n      this.updatePlayerMovement(delta);\n    }\n\n    // 更新玩家位置\n    this.player.x += this.playerVelocity.x * delta / 1000;\n    this.player.y += this.playerVelocity.y * delta / 1000;\n\n    // 边界限制\n    this.player.x = Phaser.Math.Clamp(this.player.x, 20, 780);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 20, 580);\n\n    this.updateStats();\n  }\n\n  updateReplay() {\n    const elapsed = (Date.now() - this.replayStartTime) * this.replaySpeed;\n\n    // 处理所有应该执行的动作\n    while (this.currentReplayIndex < this.recordedActions.length) {\n      const action = this.recordedActions[this.currentReplayIndex];\n      \n      if (action.timestamp <= elapsed) {\n        this.executeAction(action);\n        this.currentReplayIndex++;\n      } else {\n        break;\n      }\n    }\n\n    // 回放结束\n    if (this.currentReplayIndex >= this.recordedActions.length) {\n      this.stopReplay();\n    }\n  }\n\n  executeAction(action) {\n    if (action.type === 'keydown') {\n      if (!this.activeKeys) this.activeKeys = new Set();\n      this.activeKeys.add(action.data.toLowerCase());\n    } else if (action.type === 'keyup') {\n      if (this.activeKeys) {\n        this.activeKeys.delete(action.data.toLowerCase());\n      }\n    } else if (action.type === 'mousemove') {\n      // 可视化鼠标位置（可选）\n      const angle = Phaser.Math.Angle.Between(\n        this.player.x, this.player.y,\n        action.data.x, action.data.y\n      );\n      this.player.setRotation(angle);\n    }\n\n    // 更新速度\n    this.updateReplayMovement();\n  }\n\n  updateReplayMovement() {\n    if (!this.activeKeys) return;\n\n    this.playerVelocity.x = 0;\n    this.playerVelocity.y = 0;\n\n    if (this.activeKeys.has('w')) this.playerVelocity.y = -this.playerSpeed;\n    if (this.activeKeys.has('s')) this.playerVelocity.y = this.playerSpeed;\n    if (this.activeKeys.has('a')) this.playerVelocity.x = -this.playerSpeed;\n    if (this.activeKeys.has('d')) this.playerVelocity.x = this.playerSpeed;\n\n    // 归一化对角线速度\n    if (this.playerVelocity.x !== 0 && this.playerVelocity.y !== 0) {\n      this.playerVelocity.x *= 0.707;\n      this.playerVelocity.y *= 0.707;\n    }\n  }\n\n  stopReplay() {\n    this.isReplaying = false;\n    this.activeKeys = new Set();\n    this.playerVelocity = { x: 0, y: 0 };\n    this.statusText.setText('Replay complete! Click LEFT MOUSE to replay again');\n  }\n\n  updatePlayerMovement(delta) {\n    this.playerVelocity.x = 0;\n    this.playerVelocity.y = 0;\n\n    if (this.cursors.W.isDown) this.playerVelocity.y = -this.playerSpeed;\n    if (this.cursors.S.isDown) this.playerVelocity.y = this.playerSpeed;\n    if (this.cursors.A.isDown) this.playerVelocity.x = -this.playerSpeed;\n    if (this.cursors.D.isDown) this.playerVelocity.x = this.playerSpeed;\n\n    // 归一化对角线速度\n    if (this.playerVelocity.x !== 0 && this.playerVelocity.y !== 0) {\n      this.playerVelocity.x *= 0.707;\n      this.playerVelocity.y *= 0.707;\n    }\n\n    // 鼠标朝向\n    const pointer = this.input.activePointer;\n    const angle = Phaser.Math.Angle.Between(\n      this.player.x, this.player.y,\n      pointer.x, pointer.y\n    );\n    this.player.setRotation(angle);\n  }\n\n  setReplaySpeed(speed) {\n    this.replaySpeed = speed;\n    this.speedText.setText(`Speed: ${speed}x (1/2/3 to change)`);\n  }\n\n  updateStats() {\n    this.statsText.setText(\n      `Actions Recorded: ${this.actionCount} | ` +\n      `Replay Count: ${this.replayCount} | ` +\n      `Player: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: RecordReplayScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001966_v1", "prompt_id": "seed_001966", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.4066666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现灰色技能冷却：按鼠标左键释放技能，冷却 3 秒内不可再次使用，显示冷却进度。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现技能冷却系统，点击释放技能后显示3秒冷却进度，冷却期间不可再次使用\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建技能图标（使用 Graphics 绘制圆形按钮）\n2. 监听鼠标点击事件，判断是否在技能图标范围内\n3. 释放技能时启动 3 秒冷却计时器，绘制灰色遮罩和冷却进度\n4. 在 update 中实时更新冷却进度显示（扇形遮罩）\n5. 冷却结束后移除遮罩，恢复可用状态\n[/PLAN]\n\n```javascript\nclass SkillCooldownScene extends Phaser.Scene {\n  constructor() {\n    super('SkillCooldownScene');\n    \n    // 状态变量\n    this.skillCooldown = 0; // 当前冷却剩余时间（毫秒）\n    this.maxCooldown = 3000; // 最大冷却时间 3 秒\n    this.isSkillReady = true; // 技能是否可用\n    this.skillUseCount = 0; // 技能使用次数（可验证状态）\n    \n    // 技能图标位置和大小\n    this.skillIconX = 400;\n    this.skillIconY = 300;\n    this.skillIconRadius = 60;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x1a1a2e, 1);\n    bg.fillRect(0, 0, 800, 600);\n\n    // 创建技能图标（底层）\n    this.skillIconBase = this.add.graphics();\n    this.drawSkillIcon(this.skillIconBase, 0x4a90e2, 1);\n\n    // 创建冷却遮罩层\n    this.cooldownMask = this.add.graphics();\n    \n    // 创建技能边框\n    this.skillBorder = this.add.graphics();\n    this.skillBorder.lineStyle(4, 0xffffff, 1);\n    this.skillBorder.strokeCircle(this.skillIconX, this.skillIconY, this.skillIconRadius);\n\n    // 冷却文本\n    this.cooldownText = this.add.text(this.skillIconX, this.skillIconY, '', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      align: 'center'\n    });\n    this.cooldownText.setOrigin(0.5);\n    this.cooldownText.setVisible(false);\n\n    // 状态显示文本\n    this.statusText = this.add.text(400, 100, 'Click the skill icon to use skill', {\n      fontSize: '20px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      align: 'center'\n    });\n    this.statusText.setOrigin(0.5);\n\n    // 使用次数显示\n    this.useCountText = this.add.text(400, 500, 'Skills used: 0', {\n      fontSize: '18px',\n      fontFamily: 'Arial',\n      color: '#00ff00',\n      align: 'center'\n    });\n    this.useCountText.setOrigin(0.5);\n\n    // 提示文本\n    this.add.text(400, 550, 'Cooldown: 3 seconds', {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#888888',\n      align: 'center'\n    }).setOrigin(0.5);\n\n    // 监听鼠标点击\n    this.input.on('pointerdown', (pointer) => {\n      this.handleSkillClick(pointer.x, pointer.y);\n    });\n\n    // 鼠标悬停效果\n    this.input.on('pointermove', (pointer) => {\n      const distance = Phaser.Math.Distance.Between(\n        pointer.x, pointer.y,\n        this.skillIconX, this.skillIconY\n      );\n      \n      if (distance <= this.skillIconRadius) {\n        this.input.setDefaultCursor('pointer');\n      } else {\n        this.input.setDefaultCursor('default');\n      }\n    });\n  }\n\n  drawSkillIcon(graphics, color, alpha) {\n    graphics.clear();\n    graphics.fillStyle(color, alpha);\n    graphics.fillCircle(this.skillIconX, this.skillIconY, this.skillIconRadius);\n    \n    // 绘制技能图标内部图案（闪电符号）\n    graphics.fillStyle(0xffffff, alpha);\n    graphics.fillTriangle(\n      this.skillIconX - 10, this.skillIconY - 30,\n      this.skillIconX - 10, this.skillIconY,\n      this.skillIconX + 15, this.skillIconY - 15\n    );\n    graphics.fillTriangle(\n      this.skillIconX + 10, this.skillIconY + 30,\n      this.skillIconX + 10, this.skillIconY,\n      this.skillIconX - 15, this.skillIconY + 15\n    );\n  }\n\n  handleSkillClick(x, y) {\n    // 检查点击是否在技能图标范围内\n    const distance = Phaser.Math.Distance.Between(\n      x, y,\n      this.skillIconX, this.skillIconY\n    );\n\n    if (distance <= this.skillIconRadius && this.isSkillReady) {\n      this.useSkill();\n    }\n  }\n\n  useSkill() {\n    // 释放技能\n    this.isSkillReady = false;\n    this.skillCooldown = this.maxCooldown;\n    this.skillUseCount++;\n\n    // 更新状态文本\n    this.statusText.setText('Skill activated! Cooling down...');\n    this.statusText.setColor('#ff6b6b');\n    this.useCountText.setText(`Skills used: ${this.skillUseCount}`);\n\n    // 显示冷却文本\n    this.cooldownText.setVisible(true);\n\n    // 创建技能效果动画（可选）\n    this.createSkillEffect();\n\n    // 启动冷却计时器\n    this.time.addEvent({\n      delay: this.maxCooldown,\n      callback: this.onCooldownComplete,\n      callbackScope: this\n    });\n  }\n\n  createSkillEffect() {\n    // 创建技能释放特效（扩散圆环）\n    const effectCircle = this.add.graphics();\n    effectCircle.lineStyle(3, 0xffff00, 1);\n    effectCircle.strokeCircle(this.skillIconX, this.skillIconY, this.skillIconRadius);\n\n    this.tweens.add({\n      targets: effectCircle,\n      alpha: 0,\n      duration: 500,\n      ease: 'Power2',\n      onUpdate: (tween) => {\n        const progress = tween.progress;\n        const radius = this.skillIconRadius + progress * 100;\n        effectCircle.clear();\n        effectCircle.lineStyle(3, 0xffff00, 1 - progress);\n        effectCircle.strokeCircle(this.skillIconX, this.skillIconY, radius);\n      },\n      onComplete: () => {\n        effectCircle.destroy();\n      }\n    });\n  }\n\n  onCooldownComplete() {\n    // 冷却完成\n    this.isSkillReady = true;\n    this.skillCooldown = 0;\n    this.cooldownText.setVisible(false);\n    this.statusText.setText('Skill ready! Click to use');\n    this.statusText.setColor('#00ff00');\n\n    // 播放就绪动画\n    this.tweens.add({\n      targets: this.skillBorder,\n      alpha: 0.3,\n      duration: 200,\n      yoyo: true,\n      repeat: 2\n    });\n  }\n\n  update(time, delta) {\n    if (!this.isSkillReady) {\n      // 更新冷却时间\n      this.skillCooldown = Math.max(0, this.skillCooldown - delta);\n      \n      // 计算冷却进度 (0-1)\n      const progress = 1 - (this.skillCooldown / this.maxCooldown);\n      \n      // 更新冷却文本\n      const secondsLeft = Math.ceil(this.skillCooldown / 1000);\n      this.cooldownText.setText(secondsLeft.toString());\n\n      // 绘制冷却遮罩（灰色扇形）\n      this.drawCooldownMask(progress);\n    }\n  }\n\n  drawCooldownMask(progress) {\n    this.cooldownMask.clear();\n    \n    // 绘制灰色遮罩（从上方开始顺时针扫过）\n    if (progress < 1) {\n      this.cooldownMask.fillStyle(0x000000, 0.6);\n      \n      // 计算扇形角度（从 -90 度开始，顺时针）\n      const startAngle = -Math.PI / 2; // -90度（12点方向）\n      const endAngle = startAngle + (1 - progress) * Math.PI * 2;\n      \n      // 绘制扇形遮罩\n      this.cooldownMask.beginPath();\n      this.cooldownMask.moveTo(this.skillIconX, this.skillIconY);\n      this.cooldownMask.arc(\n        this.skillIconX,\n        this.skillIconY,\n        this.skillIconRadius,\n        startAngle,\n        endAngle,\n        false\n      );\n      this.cooldownMask.closePath();\n      this.cooldownMask.fillPath();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: SkillCooldownScene,\n  parent: 'game-container'\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001769_v2", "prompt_id": "seed_001769", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.Scene#update, Phaser.GameObjects.Graphics#setRotation\nSTEPS:\n1. 创建 Phaser Game 配置，设置 Scene 生命周期方法\n2. 在 create 方法中使用 Graphics 绘制一个方块\n3. 在 update 方法中根据 delta 时间累加旋转角度（每秒 80 度），并应用到方块上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块\n  square = this.add.graphics();\n  square.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在 (0, 0)\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 设置方块位置到屏幕中心\n  square.x = 400;\n  square.y = 300;\n  \n  // 添加边框以便更清楚地看到旋转效果\n  square.lineStyle(3, 0xffffff, 1);\n  square.strokeRect(-50, -50, 100, 100);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 80 度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 角度转弧度：Phaser.Math.DegToRad(80)\n  const rotationSpeed = Phaser.Math.DegToRad(80); // 每秒 80 度（弧度制）\n  \n  // 累加旋转角度\n  currentRotation += rotationSpeed * (delta / 1000);\n  \n  // 应用旋转\n  square.setRotation(currentRotation);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000404_v3", "prompt_id": "seed_000404", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现灰色技能冷却：按鼠标右键释放技能，冷却 1.5 秒内不可再次使用，显示冷却进度。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现右键释放技能，1.5秒冷却期间显示灰色遮罩和进度条\nAPI: Phaser.Input.Mouse, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建技能按钮UI（使用Graphics绘制圆形按钮）\n2. 监听鼠标右键点击事件，触发技能释放\n3. 使用TimerEvent实现1.5秒冷却计时器\n4. 在冷却期间绘制灰色遮罩覆盖按钮\n5. 显示冷却进度条和剩余时间文本\n6. 冷却结束后恢复按钮可用状态\n[/PLAN]\n\n```javascript\nclass SkillCooldownScene extends Phaser.Scene {\n  constructor() {\n    super('SkillCooldownScene');\n    this.skillOnCooldown = false;\n    this.cooldownDuration = 1500; // 1.5秒\n    this.skillUseCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 不需要外部资源\n  }\n\n  create() {\n    // 背景\n    this.add.rectangle(400, 300, 800, 600, 0x2c3e50);\n\n    // 标题\n    this.add.text(400, 50, 'Skill Cooldown System', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 说明文字\n    this.add.text(400, 100, 'Right Click to use skill (1.5s cooldown)', {\n      fontSize: '18px',\n      color: '#ecf0f1'\n    }).setOrigin(0.5);\n\n    // 技能使用次数显示\n    this.useCountText = this.add.text(400, 150, `Skills Used: ${this.skillUseCount}`, {\n      fontSize: '20px',\n      color: '#3498db',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建技能按钮容器\n    this.createSkillButton();\n\n    // 创建冷却遮罩层（初始隐藏）\n    this.createCooldownOverlay();\n\n    // 创建进度条\n    this.createProgressBar();\n\n    // 监听鼠标右键\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown()) {\n        this.useSkill();\n      }\n    });\n\n    // 状态文本\n    this.statusText = this.add.text(400, 500, 'Ready', {\n      fontSize: '24px',\n      color: '#2ecc71',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n  }\n\n  createSkillButton() {\n    // 技能按钮背景\n    this.skillButton = this.add.graphics();\n    this.skillButton.fillStyle(0x3498db, 1);\n    this.skillButton.fillCircle(400, 300, 80);\n    \n    // 按钮边框\n    this.skillButton.lineStyle(4, 0x2980b9, 1);\n    this.skillButton.strokeCircle(400, 300, 80);\n\n    // 技能图标（简单的闪电符号）\n    const icon = this.add.graphics();\n    icon.lineStyle(6, 0xf1c40f, 1);\n    icon.beginPath();\n    icon.moveTo(400, 260);\n    icon.lineTo(380, 300);\n    icon.lineTo(395, 300);\n    icon.lineTo(380, 340);\n    icon.lineTo(420, 290);\n    icon.lineTo(405, 290);\n    icon.closePath();\n    icon.strokePath();\n    icon.fillStyle(0xf39c12, 1);\n    icon.fillPath();\n\n    // 技能文字\n    this.add.text(400, 390, 'Ultimate Skill', {\n      fontSize: '18px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n  }\n\n  createCooldownOverlay() {\n    // 灰色遮罩\n    this.cooldownMask = this.add.graphics();\n    this.cooldownMask.fillStyle(0x000000, 0.7);\n    this.cooldownMask.fillCircle(400, 300, 80);\n    this.cooldownMask.setVisible(false);\n\n    // 冷却时间文字\n    this.cooldownText = this.add.text(400, 300, '', {\n      fontSize: '28px',\n      color: '#e74c3c',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n    this.cooldownText.setVisible(false);\n  }\n\n  createProgressBar() {\n    // 进度条背景\n    this.progressBg = this.add.graphics();\n    this.progressBg.fillStyle(0x34495e, 1);\n    this.progressBg.fillRoundedRect(250, 430, 300, 30, 15);\n    this.progressBg.setVisible(false);\n\n    // 进度条填充\n    this.progressBar = this.add.graphics();\n    this.progressBar.setVisible(false);\n\n    // 进度条文字\n    this.progressText = this.add.text(400, 445, '', {\n      fontSize: '16px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n    this.progressText.setVisible(false);\n  }\n\n  useSkill() {\n    // 如果正在冷却，不能使用\n    if (this.skillOnCooldown) {\n      // 震动效果提示\n      this.cameras.main.shake(100, 0.005);\n      return;\n    }\n\n    // 使用技能\n    this.skillOnCooldown = true;\n    this.skillUseCount++;\n    this.useCountText.setText(`Skills Used: ${this.skillUseCount}`);\n\n    // 技能释放特效\n    this.createSkillEffect();\n\n    // 更新状态\n    this.statusText.setText('On Cooldown!');\n    this.statusText.setColor('#e74c3c');\n\n    // 显示冷却UI\n    this.cooldownMask.setVisible(true);\n    this.cooldownText.setVisible(true);\n    this.progressBg.setVisible(true);\n    this.progressBar.setVisible(true);\n    this.progressText.setVisible(true);\n\n    // 创建冷却计时器\n    const startTime = this.time.now;\n    \n    this.cooldownTimer = this.time.addEvent({\n      delay: this.cooldownDuration,\n      callback: () => {\n        this.onCooldownComplete();\n      },\n      callbackScope: this\n    });\n\n    // 更新进度条（在update中处理）\n    this.cooldownStartTime = startTime;\n  }\n\n  createSkillEffect() {\n    // 技能释放的视觉效果\n    const effect = this.add.graphics();\n    effect.lineStyle(4, 0xf1c40f, 1);\n    \n    // 创建扩散圆环\n    let radius = 80;\n    const effectTween = this.tweens.add({\n      targets: { r: radius },\n      r: 150,\n      duration: 500,\n      ease: 'Power2',\n      onUpdate: (tween) => {\n        effect.clear();\n        const alpha = 1 - tween.progress;\n        effect.lineStyle(4, 0xf1c40f, alpha);\n        effect.strokeCircle(400, 300, tween.targets[0].r);\n      },\n      onComplete: () => {\n        effect.destroy();\n      }\n    });\n  }\n\n  update(time, delta) {\n    // 更新冷却进度\n    if (this.skillOnCooldown && this.cooldownStartTime) {\n      const elapsed = time - this.cooldownStartTime;\n      const remaining = Math.max(0, this.cooldownDuration - elapsed);\n      const progress = 1 - (remaining / this.cooldownDuration);\n\n      // 更新进度条\n      this.progressBar.clear();\n      this.progressBar.fillStyle(0x3498db, 1);\n      const barWidth = 300 * progress;\n      this.progressBar.fillRoundedRect(250, 430, barWidth, 30, 15);\n\n      // 更新冷却时间文字\n      const remainingSeconds = (remaining / 1000).toFixed(1);\n      this.cooldownText.setText(remainingSeconds + 's');\n\n      // 更新进度百分比\n      this.progressText.setText(`${Math.floor(progress * 100)}%`);\n    }\n  }\n\n  onCooldownComplete() {\n    // 冷却完成\n    this.skillOnCooldown = false;\n    \n    // 隐藏冷却UI\n    this.cooldownMask.setVisible(false);\n    this.cooldownText.setVisible(false);\n    this.progressBg.setVisible(false);\n    this.progressBar.setVisible(false);\n    this.progressText.setVisible(false);\n\n    // 更新状态\n    this.statusText.setText('Ready');\n    this.statusText.setColor('#2ecc71');\n\n    // 恢复动画\n    this.tweens.add({\n      targets: this.skillButton,\n      alpha: { from: 0.5, to: 1 },\n      duration: 300,\n      ease: 'Power2'\n    });\n\n    // 清理计时器引用\n    this.cooldownStartTime = null;\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: SkillCooldownScene,\n  parent: 'game-container'\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001823_v1", "prompt_id": "seed_001823", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让红色六边形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色六边形并使用 Tween 实现 4 秒旋转一次的循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setRotation\nSTEPS:\n1. 使用 Graphics 绘制红色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 4000ms，rotation 从 0 到 2π\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建红色六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制六边形\n  graphics.fillStyle(0xff0000, 1);\n  graphics.beginPath();\n  \n  const hexRadius = 50;\n  const centerX = 60;\n  const centerY = 60;\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 120, 120);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建六边形精灵并放置在屏幕中心\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: hexagon,\n    rotation: Math.PI * 2, // 旋转 360 度（2π 弧度）\n    duration: 4000, // 4 秒完成一次旋转\n    ease: 'Linear', // 线性缓动，保持匀速旋转\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '红色六边形旋转动画 (4秒/圈)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000629_v3", "prompt_id": "seed_000629", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 240 像素/秒的速度移动\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建 Scene 配置，设置画布尺寸\n2. 在 create 中使用 Graphics 绘制一个方块并生成纹理\n3. 创建 Sprite 或 Rectangle 对象作为可控制的方块\n4. 使用 this.input.keyboard.addKey 监听 WASD 键\n5. 在 update 中根据按键状态更新方块位置，速度为 240 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块，初始位置在画布中心\n  player = this.add.image(400, 300, 'playerBlock');\n\n  // 设置 WASD 键监听\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态移动方块\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n\n  // 限制方块在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000004_v2", "prompt_id": "seed_000004", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 300，移动速度 360，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色可左右移动和跳跃，具有重力和地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 300\n2. 使用 Graphics 创建玩家角色和地面平台的纹理\n3. 创建玩家精灵并应用物理属性，设置碰撞边界\n4. 创建地面平台静态物理组\n5. 设置玩家与地面的碰撞检测\n6. 监听键盘输入（方向键），实现左右移动（速度 360）和跳跃\n7. 添加状态变量（jumpCount）用于验证游戏状态\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8B4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0);\n\n    // 创建地面和平台静态组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加地面\n    this.platforms.create(400, 575, 'ground');\n    \n    // 添加多个平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(400, 300, 'platform');\n    this.platforms.create(100, 250, 'platform');\n    this.platforms.create(700, 250, 'platform');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加空格键用于跳跃\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 550, '方向键左右移动，上键或空格键跳跃', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 重置接地状态\n    const touching = this.player.body.touching.down;\n    if (touching) {\n      this.isGrounded = true;\n    }\n\n    // 左右移动控制（速度 360）\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-360);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(360);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.isGrounded) {\n      this.player.setVelocityY(-500);\n      this.jumpCount++;\n      this.isGrounded = false;\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `跳跃次数: ${this.jumpCount}`,\n      `位置: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      `速度: (${Math.floor(this.player.body.velocity.x)}, ${Math.floor(this.player.body.velocity.y)})`,\n      `接地状态: ${this.isGrounded ? '是' : '否'}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001270_v1", "prompt_id": "seed_001270", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色三角形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色三角形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置蓝色填充\n5. 使用 fillTriangle 绘制等边三角形，顶点在中心点周围，边长约32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形大小（从中心点到顶点的距离）\n  const size = 32;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size * 0.6;\n  \n  // 顶点2：左下角\n  const x2 = centerX - size * 0.866;\n  const y2 = centerY + size * 0.5;\n  \n  // 顶点3：右下角\n  const x3 = centerX + size * 0.866;\n  const y3 = centerY + size * 0.5;\n  \n  // 设置蓝色填充 (0x0000ff)\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 绘制填充的三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加白色描边使三角形更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000616_v2", "prompt_id": "seed_000616", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (30, 30)，三角形顶点向上\n  graphics.beginPath();\n  graphics.moveTo(30, 10);  // 顶点\n  graphics.lineTo(10, 50);  // 左下角\n  graphics.lineTo(50, 50);  // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 60);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 500,               // 持续时间 0.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    repeat: -1                   // 无限循环（-1 表示永远重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000416_v2", "prompt_id": "seed_000416", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按WASD键发射子弹，速度 160，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现WASD四方向发射子弹射击敌人，显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard.addKey, Phaser.Physics.Arcade.overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家（Graphics绘制矩形）和敌人组（随机生成移动的敌人）\n2. 监听WASD键盘输入，按键时从玩家位置发射对应方向的子弹\n3. 使用物理碰撞检测子弹与敌人的overlap，命中时销毁双方并增加击杀数\n4. 在屏幕上显示击杀数文本，实时更新\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 初始生成敌人\n    this.spawnEnemies();\n\n    // 定时生成敌人\n    this.time.addEvent({\n      delay: 2000,\n      callback: this.spawnEnemies,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 设置WASD键\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 防止连续发射的冷却时间\n    this.shootCooldown = 0;\n\n    // 碰撞检测：子弹与敌人\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.killText.setDepth(100);\n\n    // 显示操作提示\n    this.add.text(16, 50, 'Press WASD to shoot', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  update(time, delta) {\n    // 更新冷却时间\n    if (this.shootCooldown > 0) {\n      this.shootCooldown -= delta;\n    }\n\n    // 检测WASD按键发射子弹\n    if (this.shootCooldown <= 0) {\n      if (this.keyW.isDown) {\n        this.shootBullet(0, -1); // 向上\n        this.shootCooldown = 200;\n      } else if (this.keyS.isDown) {\n        this.shootBullet(0, 1); // 向下\n        this.shootCooldown = 200;\n      } else if (this.keyA.isDown) {\n        this.shootBullet(-1, 0); // 向左\n        this.shootCooldown = 200;\n      } else if (this.keyD.isDown) {\n        this.shootBullet(1, 0); // 向右\n        this.shootCooldown = 200;\n      }\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -20 || bullet.x > 820 || bullet.y < -20 || bullet.y > 620) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 敌人随机移动\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active) {\n        // 简单的追踪玩家逻辑\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n        enemy.setVelocity(\n          Math.cos(angle) * 50,\n          Math.sin(angle) * 50\n        );\n      }\n    });\n  }\n\n  shootBullet(dirX, dirY) {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocity(dirX * 160, dirY * 160);\n      \n      // 设置子弹生命周期\n      this.time.delayedCall(3000, () => {\n        if (bullet.active) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      });\n    }\n  }\n\n  spawnEnemies() {\n    // 随机生成2-4个敌人\n    const count = Phaser.Math.Between(2, 4);\n    \n    for (let i = 0; i < count; i++) {\n      // 随机位置（在边缘生成）\n      let x, y;\n      const edge = Phaser.Math.Between(0, 3);\n      \n      switch(edge) {\n        case 0: // 上边\n          x = Phaser.Math.Between(0, 800);\n          y = -30;\n          break;\n        case 1: // 右边\n          x = 830;\n          y = Phaser.Math.Between(0, 600);\n          break;\n        case 2: // 下边\n          x = Phaser.Math.Between(0, 800);\n          y = 630;\n          break;\n        case 3: // 左边\n          x = -30;\n          y = Phaser.Math.Between(0, 600);\n          break;\n      }\n      \n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹命中敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    \n    enemy.destroy();\n    \n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n    \n    // 击杀特效（简单的闪光）\n    const flash = this.add.graphics();\n    flash.fillStyle(0xffffff, 0.8);\n    flash.fillCircle(enemy.x, enemy.y, 20);\n    \n    this.tweens.add({\n      targets: flash,\n      alpha: 0,\n      duration: 200,\n      onComplete: () => {\n        flash.destroy();\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000874_v1", "prompt_id": "seed_000874", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现黄色角色冲刺：按空格键进行短距离冲刺，冲刺速度为 240*3，冷却 2.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现黄色角色按空格键冲刺，冲刺速度为720，冷却2.5秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建黄色角色精灵并启用物理系统\n2. 监听空格键输入事件\n3. 实现冲刺逻辑：检测冷却状态，设置冲刺速度和持续时间\n4. 使用 TimerEvent 实现冷却计时器\n5. 添加状态显示文本用于验证冲刺状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet cursors;\nlet spaceKey;\nlet isDashing = false;\nlet canDash = true;\nlet dashCooldownTimer = null;\nlet statusText;\nlet cooldownText;\n\n// 状态信号变量（用于验证）\nlet dashCount = 0;\nlet totalDistance = 0;\n\nconst NORMAL_SPEED = 240;\nconst DASH_SPEED = 240 * 3; // 720\nconst DASH_DURATION = 200; // 冲刺持续时间（毫秒）\nconst DASH_COOLDOWN = 2500; // 冷却时间（毫秒）\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建黄色角色纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setDamping(true);\n  player.setDrag(0.9);\n\n  // 设置输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 监听空格键按下事件\n  spaceKey.on('down', () => {\n    if (canDash && !isDashing) {\n      performDash.call(this);\n    }\n  });\n\n  // 创建状态显示文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  cooldownText = this.add.text(16, 50, '', {\n    fontSize: '16px',\n    fill: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(16, 550, '方向键移动 | 空格键冲刺', {\n    fontSize: '16px',\n    fill: '#aaaaaa'\n  });\n}\n\nfunction performDash() {\n  if (!canDash || isDashing) return;\n\n  isDashing = true;\n  canDash = false;\n  dashCount++;\n\n  // 获取当前移动方向\n  let dashVelocityX = 0;\n  let dashVelocityY = 0;\n\n  if (cursors.left.isDown) {\n    dashVelocityX = -DASH_SPEED;\n  } else if (cursors.right.isDown) {\n    dashVelocityX = DASH_SPEED;\n  }\n\n  if (cursors.up.isDown) {\n    dashVelocityY = -DASH_SPEED;\n  } else if (cursors.down.isDown) {\n    dashVelocityY = DASH_SPEED;\n  }\n\n  // 如果没有方向输入，默认向右冲刺\n  if (dashVelocityX === 0 && dashVelocityY === 0) {\n    dashVelocityX = DASH_SPEED;\n  }\n\n  // 归一化对角线速度\n  if (dashVelocityX !== 0 && dashVelocityY !== 0) {\n    const factor = Math.sqrt(2) / 2;\n    dashVelocityX *= factor;\n    dashVelocityY *= factor;\n  }\n\n  // 设置冲刺速度\n  player.setVelocity(dashVelocityX, dashVelocityY);\n\n  // 改变颜色表示冲刺状态\n  player.setTint(0xff8800);\n\n  // 冲刺持续时间计时器\n  this.time.delayedCall(DASH_DURATION, () => {\n    isDashing = false;\n    player.clearTint();\n    // 恢复正常移动\n  });\n\n  // 冷却计时器\n  if (dashCooldownTimer) {\n    dashCooldownTimer.destroy();\n  }\n\n  dashCooldownTimer = this.time.addEvent({\n    delay: DASH_COOLDOWN,\n    callback: () => {\n      canDash = true;\n      dashCooldownTimer = null;\n    }\n  });\n}\n\nfunction update(time, delta) {\n  // 普通移动（非冲刺状态）\n  if (!isDashing) {\n    let velocityX = 0;\n    let velocityY = 0;\n\n    if (cursors.left.isDown) {\n      velocityX = -NORMAL_SPEED;\n    } else if (cursors.right.isDown) {\n      velocityX = NORMAL_SPEED;\n    }\n\n    if (cursors.up.isDown) {\n      velocityY = -NORMAL_SPEED;\n    } else if (cursors.down.isDown) {\n      velocityY = NORMAL_SPEED;\n    }\n\n    // 归一化对角线速度\n    if (velocityX !== 0 && velocityY !== 0) {\n      const factor = Math.sqrt(2) / 2;\n      velocityX *= factor;\n      velocityY *= factor;\n    }\n\n    player.setVelocity(velocityX, velocityY);\n  }\n\n  // 计算总移动距离\n  const speed = Math.sqrt(player.body.velocity.x ** 2 + player.body.velocity.y ** 2);\n  totalDistance += (speed * delta) / 1000;\n\n  // 更新状态显示\n  const currentSpeed = Math.round(speed);\n  const dashStatus = isDashing ? '冲刺中!' : (canDash ? '准备就绪' : '冷却中');\n  \n  statusText.setText([\n    `冲刺次数: ${dashCount}`,\n    `当前速度: ${currentSpeed}`,\n    `状态: ${dashStatus}`,\n    `总距离: ${Math.round(totalDistance)}px`\n  ]);\n\n  // 显示冷却进度\n  if (dashCooldownTimer && !canDash) {\n    const progress = dashCooldownTimer.getProgress();\n    const remaining = ((1 - progress) * DASH_COOLDOWN / 1000).toFixed(1);\n    cooldownText.setText(`冷却剩余: ${remaining}秒`);\n    cooldownText.setVisible(true);\n  } else {\n    cooldownText.setVisible(false);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001523_v1", "prompt_id": "seed_001523", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色方块，使用补间动画实现左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建方块精灵，初始位置在左侧\n  const square = this.add.sprite(100, 300, 'whiteSquare');\n\n  // 创建补间动画：从左到右移动，1秒完成，往返循环\n  this.tweens.add({\n    targets: square,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 1000, // 动画时长 1 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000407_v1", "prompt_id": "seed_000407", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.fillStyle, Phaser.GameObjects.Graphics.beginPath, Phaser.GameObjects.Graphics.moveTo, Phaser.GameObjects.Graphics.lineTo, Phaser.GameObjects.Graphics.closePath, Phaser.GameObjects.Graphics.fillPath, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 使用 Graphics 绘制一个菱形（四个顶点连接成菱形）\n2. 将菱形放置在画布中心位置\n3. 在 update 方法中根据 delta 时间增量更新 rotation 属性，实现每秒 80 度的旋转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置填充颜色\n  diamond.fillStyle(0x00ffff, 1);\n  \n  // 绘制菱形（中心点在原点）\n  diamond.beginPath();\n  diamond.moveTo(0, -80);    // 上顶点\n  diamond.lineTo(60, 0);     // 右顶点\n  diamond.lineTo(0, 80);     // 下顶点\n  diamond.lineTo(-60, 0);    // 左顶点\n  diamond.closePath();\n  diamond.fillPath();\n  \n  // 将菱形移动到画布中心\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 初始旋转角度为 0\n  diamond.rotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 80 度\n  // delta 是毫秒，需要转换为秒\n  // 80 度转换为弧度：80 * (Math.PI / 180)\n  const rotationSpeed = 80 * (Math.PI / 180); // 弧度/秒\n  diamond.rotation += rotationSpeed * (delta / 1000);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000796_v1", "prompt_id": "seed_000796", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的三角形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象作为可移动的游戏对象\n3. 在 update 中让三角形向右上方移动\n4. 使用 Camera.startFollow 让相机跟随三角形\n5. 设置世界边界以展示相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nconst moveSpeed = 100; // 每秒移动的像素\n\nfunction preload() {\n  // 使用 Graphics 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个向上的三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(25, 0);      // 顶点\n  graphics.lineTo(50, 50);     // 右下角\n  graphics.lineTo(0, 50);      // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，让场景更大以展示相机跟随效果\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n  \n  // 创建三角形 Sprite\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 让相机跟随三角形，并保持居中\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（这里设置为 0,0 表示居中）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 2000; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(2000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加坐标文本以便观察位置\n  this.add.text(10, 10, 'Camera follows triangle', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setScrollFactor(0); // 固定在屏幕上，不随相机移动\n  \n  // 创建动态文本显示三角形位置\n  this.positionText = this.add.text(10, 50, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 让三角形向右上方移动\n  // 右上方向：x 增加，y 减少（Phaser 的 y 轴向下为正）\n  const moveDistance = moveSpeed * deltaSeconds;\n  triangle.x += moveDistance;\n  triangle.y -= moveDistance;\n  \n  // 限制三角形在世界边界内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 2000);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 2000);\n  \n  // 更新位置显示\n  this.positionText.setText(\n    `Triangle Position: (${Math.floor(triangle.x)}, ${Math.floor(triangle.y)})`\n  );\n  \n  // 当三角形到达边界时，可以重置位置（可选）\n  if (triangle.x >= 2000 || triangle.y <= 0) {\n    triangle.setPosition(100, 500);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000193_v1", "prompt_id": "seed_000193", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色圆形在2.5秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制红色圆形\n2. 创建补间动画，设置 x 坐标从左到右移动，持续2.5秒\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制红色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色，不透明\n  graphics.fillCircle(0, 0, 30); // 在原点绘制半径为30的圆形\n  \n  // 将 graphics 转换为纹理，方便后续操作\n  graphics.generateTexture('redCircle', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建使用该纹理的精灵，初始位置在左侧\n  const circle = this.add.sprite(100, 300, 'redCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,        // 动画目标对象\n    x: 700,                 // 目标 x 坐标（右侧）\n    duration: 2500,         // 持续时间 2.5 秒（2500 毫秒）\n    ease: 'Linear',         // 线性缓动\n    yoyo: true,             // 启用往返效果（到达终点后反向播放）\n    repeat: -1              // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000076_v2", "prompt_id": "seed_000076", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 300，移动速度 160，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动与跳跃，具有重力和地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 300\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建物理精灵作为角色和静态地面平台\n4. 设置键盘输入监听（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑（速度 160）和跳跃逻辑\n6. 配置角色与地面的碰撞检测\n7. 添加状态变量记录跳跃次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色方块）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 64, 32);\n    groundGraphics.generateTexture('ground', 64, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加主地面\n    this.platforms.create(400, 568, 'ground').setScale(12.5, 1).refreshBody();\n    \n    // 添加几个悬浮平台\n    this.platforms.create(600, 450, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(200, 450, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(400, 350, 'ground').setScale(2, 1).refreshBody();\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, 'Controls: Arrow Keys to Move, Space to Jump', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置接地状态（将在碰撞时更新）\n    const wasGrounded = this.isGrounded;\n    this.isGrounded = this.player.body.touching.down;\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只在接地时可以跳跃）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.isGrounded) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n      this.updateStatusText();\n    }\n\n    // 更新状态文本\n    if (wasGrounded !== this.isGrounded) {\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Jump Count: ${this.jumpCount} | Grounded: ${this.isGrounded ? 'Yes' : 'No'} | ` +\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    );\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001085_v2", "prompt_id": "seed_001085", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 3 个移动平台组成路径，玩家需要跳跃通过，平台速度 160。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 3个移动平台组成路径，玩家需要跳跃通过，平台速度160\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.StaticGroup\nSTEPS:\n1. 创建玩家精灵，添加物理属性和重力\n2. 创建3个移动平台，使用Graphics绘制纹理，设置循环移动路径\n3. 添加玩家与平台的碰撞检测\n4. 实现键盘控制玩家左右移动和跳跃\n5. 添加状态信号（跳跃次数、成功通过平台数）\n6. 实现平台循环移动逻辑，速度160\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.jumpCount = 0;\n    this.platformsPassed = 0;\n    this.isOnPlatform = false;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    platformGraphics.fillStyle(0xff6600, 1);\n    platformGraphics.fillRect(0, 0, 120, 20);\n    platformGraphics.generateTexture('platform', 120, 20);\n    platformGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#87ceeb');\n\n    // 创建地面\n    this.ground = this.physics.add.staticSprite(400, 580, 'ground');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setGravityY(800);\n\n    // 创建移动平台组\n    this.platforms = this.physics.add.group({\n      allowGravity: false,\n      immovable: true\n    });\n\n    // 平台配置：位置和移动路径\n    const platformConfigs = [\n      { startX: 200, startY: 450, endX: 400, endY: 450 },\n      { startX: 450, startY: 350, endX: 250, endY: 350 },\n      { startX: 300, startY: 250, endX: 500, endY: 250 }\n    ];\n\n    // 创建3个移动平台\n    platformConfigs.forEach((config, index) => {\n      const platform = this.platforms.create(config.startX, config.startY, 'platform');\n      platform.body.setSize(120, 20);\n      platform.setData('config', config);\n      platform.setData('direction', 1); // 1: 向右/向终点, -1: 向左/向起点\n      platform.setData('index', index);\n      platform.setData('passed', false);\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.platforms, this.onPlatformCollision, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n\n    // 添加说明文本\n    this.add.text(400, 100, '使用方向键移动，空格键跳跃', {\n      fontSize: '20px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5);\n\n    this.add.text(400, 140, '目标：跳跃通过所有3个移动平台！', {\n      fontSize: '16px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5);\n  }\n\n  onPlatformCollision(player, platform) {\n    // 只有当玩家从上方落到平台时才标记为站在平台上\n    if (player.body.touching.down && platform.body.touching.up) {\n      this.isOnPlatform = true;\n      \n      // 检查是否首次通过此平台\n      const index = platform.getData('index');\n      const passed = platform.getData('passed');\n      \n      if (!passed) {\n        platform.setData('passed', true);\n        this.platformsPassed++;\n        this.updateStatusText();\n        \n        // 平台变色表示已通过\n        platform.setTint(0x00ff00);\n        \n        // 检查是否通过所有平台\n        if (this.platformsPassed >= 3) {\n          this.showVictory();\n        }\n      }\n    }\n  }\n\n  update(time, delta) {\n    // 更新平台移动\n    this.platforms.getChildren().forEach(platform => {\n      const config = platform.getData('config');\n      const direction = platform.getData('direction');\n      const speed = 160;\n\n      // 计算移动方向\n      const dx = config.endX - config.startX;\n      const dy = config.endY - config.startY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance > 0) {\n        const vx = (dx / distance) * speed * direction;\n        const vy = (dy / distance) * speed * direction;\n        \n        platform.body.setVelocity(vx, vy);\n\n        // 检查是否到达终点或起点\n        if (direction === 1) {\n          // 向终点移动\n          const distToEnd = Phaser.Math.Distance.Between(\n            platform.x, platform.y, config.endX, config.endY\n          );\n          if (distToEnd < 5) {\n            platform.setPosition(config.endX, config.endY);\n            platform.setData('direction', -1);\n          }\n        } else {\n          // 向起点移动\n          const distToStart = Phaser.Math.Distance.Between(\n            platform.x, platform.y, config.startX, config.startY\n          );\n          if (distToStart < 5) {\n            platform.setPosition(config.startX, config.startY);\n            platform.setData('direction', 1);\n          }\n        }\n      }\n    });\n\n    // 重置站在平台状态\n    this.isOnPlatform = false;\n\n    // 玩家左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      // 在地面或平台上可以跳跃\n      if (this.player.body.touching.down) {\n        this.player.setVelocityY(-400);\n        this.jumpCount++;\n        this.updateStatusText();\n      }\n    }\n\n    // 检查玩家是否掉落\n    if (this.player.y > 600) {\n      this.resetPlayer();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount}\\n` +\n      `通过平台: ${this.platformsPassed}/3`\n    );\n  }\n\n  resetPlayer() {\n    this.player.setPosition(100, 500);\n    this.player.setVelocity(0, 0);\n  }\n\n  showVictory() {\n    // 显示胜利信息\n    const victoryText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '48px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 20, y: 10 }\n    }).setOrigin(0.5);\n\n    const statsText = this.add.text(400, 360, `总跳跃次数: ${this.jumpCount}`, {\n      fontSize: '24px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 15, y: 8 }\n    }).setOrigin(0.5);\n\n    // 暂停物理系统\n    this.physics.pause();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001765_v2", "prompt_id": "seed_001765", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.4}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色圆形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置目标 x 坐标到右侧\n4. 配置动画时长为 2.5 秒，启用 yoyo 实现往返，loop 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径为25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'purpleCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 目标 x 坐标（右侧位置）\n    duration: 2500, // 2.5 秒 = 2500 毫秒\n    yoyo: true, // 启用往返效果\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性运动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000794_v1", "prompt_id": "seed_000794", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色方块，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的黄色方块，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 使用 Phaser.Math.Between 生成随机 x, y 坐标（确保方块完全在画布内）\n4. 使用 fillStyle 设置黄色（0xffff00），使用 fillRect 绘制 24x24 的方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制8个随机位置的黄色方块\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 生成随机位置（确保方块完全在画布内）\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const randomX = Phaser.Math.Between(0, 776);\n    const randomY = Phaser.Math.Between(0, 576);\n    \n    // 设置黄色填充\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制 24x24 的方块\n    graphics.fillRect(randomX, randomY, 24, 24);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000278_v3", "prompt_id": "seed_000278", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色菱形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色菱形以160速度移动并在边界反弹\nAPI: Graphics.fillStyle, Graphics.fillPath, Physics.Arcade.Sprite, Physics.World.setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建 Arcade 物理精灵并设置速度为160\n3. 启用物理世界边界碰撞和精灵边界反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形路径（中心在 32, 32，大小为 64x64）\n  const path = new Phaser.Geom.Polygon([\n    32, 0,    // 顶点\n    64, 32,   // 右点\n    32, 64,   // 底点\n    0, 32     // 左点\n  ]);\n  \n  graphics.fillPoints(path.points, true);\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始速度（160像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  this.physics.velocityFromAngle(angle, 160, diamond.body.velocity);\n  \n  // 启用世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置边界反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000171_v3", "prompt_id": "seed_000171", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现白色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现白色血条 UI，显示 10 格生命值，空格键扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化生命值变量为 10\n2. 使用 Graphics 绘制 10 个白色方格作为血条，每格代表 1 点生命值\n3. 监听空格键输入事件，每次按下扣除 1 点生命值\n4. 根据当前生命值动态更新血条显示（已损失的血格变为灰色或透明）\n5. 当生命值降至 0 时，显示 \"Game Over\" 文本并禁用输入\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 可验证的状态信号\n    this.maxHealth = 10;\n    this.healthBars = [];\n    this.gameOver = false;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, 'Press SPACE to take damage', {\n      fontSize: '20px',\n      color: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 创建显示当前血量的文本\n    this.healthText = this.add.text(400, 350, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.spaceKey.on('down', this.takeDamage, this);\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setVisible(false);\n  }\n\n  createHealthBar() {\n    const barWidth = 50;\n    const barHeight = 30;\n    const barSpacing = 10;\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing) - barSpacing) / 2;\n    const startY = 200;\n\n    // 创建 10 个血格\n    for (let i = 0; i < this.maxHealth; i++) {\n      const graphics = this.add.graphics();\n      \n      // 绘制白色边框\n      graphics.lineStyle(3, 0xffffff, 1);\n      graphics.strokeRect(0, 0, barWidth, barHeight);\n      \n      // 绘制白色填充\n      graphics.fillStyle(0xffffff, 1);\n      graphics.fillRect(2, 2, barWidth - 4, barHeight - 4);\n      \n      // 设置位置\n      graphics.setPosition(startX + i * (barWidth + barSpacing), startY);\n      \n      // 保存到数组中以便后续更新\n      this.healthBars.push(graphics);\n    }\n  }\n\n  takeDamage() {\n    // 如果游戏已结束，不再处理输入\n    if (this.gameOver) {\n      return;\n    }\n\n    // 扣除生命值\n    if (this.health > 0) {\n      this.health--;\n      this.updateHealthBar();\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n\n      // 检查是否死亡\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  updateHealthBar() {\n    // 更新血条显示\n    for (let i = 0; i < this.maxHealth; i++) {\n      const graphics = this.healthBars[i];\n      graphics.clear();\n      \n      if (i < this.health) {\n        // 剩余的血量：白色\n        graphics.lineStyle(3, 0xffffff, 1);\n        graphics.strokeRect(0, 0, 50, 30);\n        graphics.fillStyle(0xffffff, 1);\n        graphics.fillRect(2, 2, 46, 26);\n      } else {\n        // 已损失的血量：深灰色边框 + 暗灰色填充\n        graphics.lineStyle(3, 0x666666, 1);\n        graphics.strokeRect(0, 0, 50, 30);\n        graphics.fillStyle(0x333333, 0.5);\n        graphics.fillRect(2, 2, 46, 26);\n      }\n    }\n  }\n\n  triggerGameOver() {\n    this.gameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 禁用空格键输入\n    this.spaceKey.off('down', this.takeDamage, this);\n    \n    // 添加重启提示\n    this.add.text(400, 400, 'Refresh to restart', {\n      fontSize: '20px',\n      color: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 每帧更新逻辑（本例中不需要）\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: HealthBarScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000910_v3", "prompt_id": "seed_000910", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按鼠标右键发射橙色子弹的例子，子弹速度 120，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按鼠标右键发射橙色子弹，速度120，离开边界回收（对象池）\nAPI: Phaser.Physics.Arcade.Group, this.input.on('pointerdown'), Graphics.generateTexture, sprite.setVelocity, Group.killAndHide\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制橙色圆形子弹纹理\n3. 创建物理组作为子弹对象池，配置回收条件\n4. 监听鼠标右键点击事件（button === 2）\n5. 发射子弹：从对象池获取子弹，设置位置和速度\n6. 在 update 中检测子弹是否离开边界，自动回收\n[/PLAN]\n\n```javascript\nclass BulletScene extends Phaser.Scene {\n  constructor() {\n    super('BulletScene');\n    this.bulletsFired = 0; // 可验证的状态信号\n    this.activeBullets = 0; // 当前活跃子弹数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建橙色子弹纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff8800, 1); // 橙色\n    graphics.fillCircle(8, 8, 8); // 半径8的圆形\n    graphics.generateTexture('bullet', 16, 16);\n    graphics.destroy();\n\n    // 创建子弹对象池（物理组）\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50, // 对象池最大容量\n      runChildUpdate: false\n    });\n\n    // 添加提示文本\n    this.add.text(10, 10, '右键点击发射橙色子弹', {\n      fontSize: '18px',\n      color: '#ffffff'\n    });\n\n    // 显示统计信息\n    this.statsText = this.add.text(10, 40, '', {\n      fontSize: '16px',\n      color: '#00ff00'\n    });\n\n    // 监听鼠标右键点击事件\n    this.input.on('pointerdown', (pointer) => {\n      // 检查是否是右键（button === 2）\n      if (pointer.rightButtonDown()) {\n        this.fireBullet(pointer.x, pointer.y);\n      }\n    });\n\n    // 启用右键菜单禁用（可选，防止浏览器右键菜单弹出）\n    this.input.mouse.disableContextMenu();\n\n    this.updateStats();\n  }\n\n  fireBullet(x, y) {\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(x, y);\n\n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n\n      // 设置子弹速度（向右发射）\n      bullet.body.setVelocity(120, 0);\n\n      // 更新统计\n      this.bulletsFired++;\n      this.activeBullets = this.bullets.countActive(true);\n      this.updateStats();\n    }\n  }\n\n  update(time, delta) {\n    // 检查子弹是否离开边界，如果离开则回收\n    this.bullets.children.entries.forEach((bullet) => {\n      if (bullet.active) {\n        // 检查是否离开屏幕边界\n        if (\n          bullet.x < -20 ||\n          bullet.x > this.scale.width + 20 ||\n          bullet.y < -20 ||\n          bullet.y > this.scale.height + 20\n        ) {\n          // 回收子弹到对象池\n          this.bullets.killAndHide(bullet);\n          bullet.body.reset(0, 0);\n\n          // 更新活跃子弹数\n          this.activeBullets = this.bullets.countActive(true);\n          this.updateStats();\n        }\n      }\n    });\n  }\n\n  updateStats() {\n    // 更新统计信息显示\n    this.statsText.setText([\n      `已发射子弹: ${this.bulletsFired}`,\n      `活跃子弹: ${this.activeBullets}`,\n      `对象池总数: ${this.bullets.getLength()}`,\n      `对象池可用: ${this.bullets.getTotalFree()}`\n    ]);\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BulletScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001362_v1", "prompt_id": "seed_001362", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现15个物体的同步弹跳动画，持续 2 秒后停止。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现15个物体的同步弹跳动画，持续2秒后停止\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建15个使用Graphics绘制的圆形物体\n2. 使用Tween系统为所有物体添加同步的y轴弹跳动画\n3. 设置定时器在2秒后停止所有动画\n4. 添加状态变量记录动画状态和弹跳次数\n[/PLAN]\n\n```javascript\nclass BounceScene extends Phaser.Scene {\n  constructor() {\n    super('BounceScene');\n    this.animationActive = false; // 动画状态标志\n    this.bounceCount = 0; // 弹跳计数器\n    this.objectsCreated = 0; // 创建的物体数量\n  }\n\n  preload() {\n    // 创建圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x3498db, 1);\n    graphics.fillCircle(20, 20, 20);\n    graphics.generateTexture('ball', 40, 40);\n    graphics.destroy();\n  }\n\n  create() {\n    const width = this.cameras.main.width;\n    const height = this.cameras.main.height;\n    \n    // 存储所有物体和补间动画\n    this.balls = [];\n    this.tweens = [];\n    \n    // 创建15个球形物体，排列成3行5列\n    const cols = 5;\n    const rows = 3;\n    const spacing = 120;\n    const startX = (width - (cols - 1) * spacing) / 2;\n    const startY = (height - (rows - 1) * spacing) / 2;\n    \n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = startX + col * spacing;\n        const y = startY + row * spacing;\n        \n        // 创建球形精灵\n        const ball = this.add.sprite(x, y, 'ball');\n        ball.setTint(Phaser.Display.Color.GetColor(\n          100 + row * 50,\n          150 + col * 20,\n          200 + (row + col) * 10\n        ));\n        \n        this.balls.push(ball);\n        this.objectsCreated++;\n      }\n    }\n    \n    // 启动同步弹跳动画\n    this.startBounceAnimation();\n    \n    // 2秒后停止动画\n    this.time.delayedCall(2000, () => {\n      this.stopBounceAnimation();\n    });\n    \n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.updateStatusText();\n  }\n\n  startBounceAnimation() {\n    this.animationActive = true;\n    \n    // 为所有球创建同步的弹跳动画\n    this.balls.forEach((ball, index) => {\n      const tween = this.tweens.add({\n        targets: ball,\n        y: ball.y - 80, // 向上弹跳80像素\n        duration: 400, // 单次弹跳持续400ms\n        ease: 'Sine.easeInOut',\n        yoyo: true, // 自动返回原位\n        repeat: -1, // 无限重复\n        onYoyo: () => {\n          // 只在第一个球触底时增加计数\n          if (index === 0) {\n            this.bounceCount++;\n            this.updateStatusText();\n          }\n        }\n      });\n      \n      this.tweens.push(tween);\n    });\n  }\n\n  stopBounceAnimation() {\n    this.animationActive = false;\n    \n    // 停止所有补间动画\n    this.tweens.forEach(tween => {\n      tween.stop();\n    });\n    \n    // 将所有球平滑归位到初始位置\n    this.balls.forEach(ball => {\n      this.tweens.add({\n        targets: ball,\n        y: ball.getData('initialY') || ball.y,\n        duration: 300,\n        ease: 'Sine.easeOut'\n      });\n    });\n    \n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    const status = this.animationActive ? '运行中' : '已停止';\n    this.statusText.setText([\n      `物体数量: ${this.objectsCreated}`,\n      `弹跳次数: ${this.bounceCount}`,\n      `动画状态: ${status}`\n    ]);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: BounceScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001521_v1", "prompt_id": "seed_001521", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的粉色菱形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的粉色菱形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillPoints, Phaser.Geom.Point\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 为每个菱形生成随机位置（考虑菱形大小，避免超出边界）\n4. 使用 fillStyle 设置粉色填充（0xff69b4）\n5. 使用 fillPoints 绘制菱形的4个顶点（上、右、下、左）\n6. 将菱形定位到随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const diamondSize = 48; // 菱形大小\n  const halfSize = diamondSize / 2; // 菱形半径\n  \n  // 绘制8个随机位置的粉色菱形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机位置（确保菱形完全在画布内）\n    const x = Phaser.Math.Between(halfSize, this.scale.width - halfSize);\n    const y = Phaser.Math.Between(halfSize, this.scale.height - halfSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 定义菱形的4个顶点（相对于中心点）\n    const points = [\n      new Phaser.Geom.Point(0, -halfSize),      // 上顶点\n      new Phaser.Geom.Point(halfSize, 0),       // 右顶点\n      new Phaser.Geom.Point(0, halfSize),       // 下顶点\n      new Phaser.Geom.Point(-halfSize, 0)       // 左顶点\n    ];\n    \n    // 绘制填充的菱形\n    graphics.fillPoints(points, true);\n    \n    // 设置菱形位置\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000167_v3", "prompt_id": "seed_000167", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的紫色六边形，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个可拖拽的紫色六边形，拖拽时改变颜色，松手后回到初始位置\nAPI: Graphics.fillStyle, Graphics.fillPoints, InputPlugin.setDraggable, Events.DRAG_START, Events.DRAG, Events.DRAG_END\nSTEPS:\n1. 使用 Graphics 绘制紫色六边形并生成纹理\n2. 创建 Sprite 并设置为可拖拽\n3. 监听 DRAG_START 事件改变颜色为亮紫色\n4. 监听 DRAG 事件更新六边形位置\n5. 监听 DRAG_END 事件恢复颜色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n  \n  // 创建紫色六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点\n  const hexRadius = 50;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    hexPoints.push({\n      x: hexRadius + Math.cos(angle) * hexRadius,\n      y: hexRadius + Math.sin(angle) * hexRadius\n    });\n  }\n  \n  // 绘制紫色六边形\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0].x, hexPoints[0].y);\n  for (let i = 1; i < hexPoints.length; i++) {\n    graphics.lineTo(hexPoints[i].x, hexPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建六边形精灵\n  const hexagon = this.add.sprite(initialX, initialY, 'hexagon');\n  \n  // 设置为可交互和可拖拽\n  hexagon.setInteractive({ draggable: true });\n  \n  // 存储初始位置\n  hexagon.initialX = initialX;\n  hexagon.initialY = initialY;\n  \n  // 监听拖拽开始事件\n  this.input.on(Phaser.Input.Events.DRAG_START, (pointer, gameObject) => {\n    // 改变颜色为亮紫色\n    const brightGraphics = this.add.graphics();\n    brightGraphics.fillStyle(0xd98ce0, 1); // 亮紫色\n    brightGraphics.beginPath();\n    brightGraphics.moveTo(hexPoints[0].x, hexPoints[0].y);\n    for (let i = 1; i < hexPoints.length; i++) {\n      brightGraphics.lineTo(hexPoints[i].x, hexPoints[i].y);\n    }\n    brightGraphics.closePath();\n    brightGraphics.fillPath();\n    brightGraphics.generateTexture('hexagonBright', hexRadius * 2, hexRadius * 2);\n    brightGraphics.destroy();\n    \n    gameObject.setTexture('hexagonBright');\n  });\n  \n  // 监听拖拽事件\n  this.input.on(Phaser.Input.Events.DRAG, (pointer, gameObject, dragX, dragY) => {\n    // 更新位置跟随鼠标\n    gameObject.x = dragX;\n    gameObject.y = dragY;\n  });\n  \n  // 监听拖拽结束事件\n  this.input.on(Phaser.Input.Events.DRAG_END, (pointer, gameObject) => {\n    // 恢复原始颜色\n    gameObject.setTexture('hexagon');\n    \n    // 添加缓动动画回到初始位置\n    this.tweens.add({\n      targets: gameObject,\n      x: gameObject.initialX,\n      y: gameObject.initialY,\n      duration: 300,\n      ease: 'Power2'\n    });\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '拖拽六边形试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000713_v2", "prompt_id": "seed_000713", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色方块左右往返循环移动的补间动画\nAPI: this.add.graphics(), graphics.generateTexture(), this.add.image(), this.tweens.add(), Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制白色方块并生成纹理\n2. 创建 Image 对象显示方块\n3. 使用 tweens.add() 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo: true 实现往返效果\n5. 配置 loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建方块图像，初始位置在左侧\n  const square = this.add.image(100, 300, 'whiteSquare');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 2000,            // 持续时间 2 秒\n    yoyo: true,                // 启用往返效果（到达目标后反向播放）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动函数，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'White Square Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'The square moves left-right in a loop', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000737_v2", "prompt_id": "seed_000737", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现重力场效果：20 个小球受中心点吸引，吸引力与距离成反比，吸引速度基准 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 实现20个小球受中心点吸引的重力场效果，吸引力与距离成反比\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Math.Distance.Between, Phaser.Physics.Arcade.Body.setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统场景，关闭全局重力\n2. 使用 Graphics 生成小球纹理，创建20个物理精灵随机分布\n3. 在 update 中计算每个小球到中心点的距离和方向\n4. 根据距离计算吸引力（基准速度160/距离），应用到小球速度\n5. 添加状态信号：记录小球平均速度和到中心的平均距离\n[/PLAN]\n\n```javascript\nclass GravityFieldScene extends Phaser.Scene {\n  constructor() {\n    super('GravityFieldScene');\n    this.balls = [];\n    this.centerX = 400;\n    this.centerY = 300;\n    this.baseAttractionSpeed = 160;\n    \n    // 状态信号\n    this.averageSpeed = 0;\n    this.averageDistance = 0;\n    this.frameCount = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建中心点标记\n    const centerGraphics = this.add.graphics();\n    centerGraphics.fillStyle(0xff0000, 1);\n    centerGraphics.fillCircle(this.centerX, this.centerY, 8);\n    centerGraphics.lineStyle(2, 0xff0000, 0.3);\n    centerGraphics.strokeCircle(this.centerX, this.centerY, 50);\n    centerGraphics.strokeCircle(this.centerX, this.centerY, 100);\n    centerGraphics.strokeCircle(this.centerX, this.centerY, 150);\n\n    // 使用 Graphics 创建小球纹理\n    const ballGraphics = this.add.graphics();\n    ballGraphics.fillStyle(0x00aaff, 1);\n    ballGraphics.fillCircle(10, 10, 10);\n    ballGraphics.generateTexture('ball', 20, 20);\n    ballGraphics.destroy();\n\n    // 创建20个小球\n    for (let i = 0; i < 20; i++) {\n      // 随机位置（避免太靠近中心）\n      const angle = Math.random() * Math.PI * 2;\n      const distance = 100 + Math.random() * 200;\n      const x = this.centerX + Math.cos(angle) * distance;\n      const y = this.centerY + Math.sin(angle) * distance;\n\n      const ball = this.physics.add.sprite(x, y, 'ball');\n      ball.setCollideWorldBounds(true);\n      ball.setBounce(0.8);\n      \n      // 给小球初始随机速度\n      const initialVelX = (Math.random() - 0.5) * 100;\n      const initialVelY = (Math.random() - 0.5) * 100;\n      ball.setVelocity(initialVelX, initialVelY);\n\n      this.balls.push(ball);\n    }\n\n    // 添加小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    this.frameCount++;\n    \n    let totalSpeed = 0;\n    let totalDistance = 0;\n\n    // 对每个小球应用重力吸引\n    this.balls.forEach(ball => {\n      // 计算到中心点的距离\n      const distance = Phaser.Math.Distance.Between(\n        ball.x, \n        ball.y, \n        this.centerX, \n        this.centerY\n      );\n\n      // 防止除零和过强的吸引力\n      const safeDist = Math.max(distance, 20);\n\n      // 计算方向向量\n      const dirX = (this.centerX - ball.x) / safeDist;\n      const dirY = (this.centerY - ball.y) / safeDist;\n\n      // 计算吸引力强度（与距离成反比）\n      const attractionForce = this.baseAttractionSpeed / safeDist;\n\n      // 应用吸引力到速度\n      const accelerationX = dirX * attractionForce * 60 * (delta / 1000);\n      const accelerationY = dirY * attractionForce * 60 * (delta / 1000);\n\n      ball.setVelocity(\n        ball.body.velocity.x + accelerationX,\n        ball.body.velocity.y + accelerationY\n      );\n\n      // 限制最大速度，防止失控\n      const maxSpeed = 300;\n      const currentSpeed = Math.sqrt(\n        ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2\n      );\n      \n      if (currentSpeed > maxSpeed) {\n        const scale = maxSpeed / currentSpeed;\n        ball.setVelocity(\n          ball.body.velocity.x * scale,\n          ball.body.velocity.y * scale\n        );\n      }\n\n      // 统计数据\n      totalSpeed += currentSpeed;\n      totalDistance += distance;\n    });\n\n    // 更新状态信号\n    this.averageSpeed = totalSpeed / this.balls.length;\n    this.averageDistance = totalDistance / this.balls.length;\n\n    // 每30帧更新一次显示\n    if (this.frameCount % 30 === 0) {\n      this.statusText.setText([\n        `Balls: ${this.balls.length}`,\n        `Avg Speed: ${this.averageSpeed.toFixed(2)}`,\n        `Avg Distance: ${this.averageDistance.toFixed(2)}`,\n        `Base Attraction: ${this.baseAttractionSpeed}`,\n        `Frame: ${this.frameCount}`\n      ]);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 关闭全局重力\n      debug: false\n    }\n  },\n  scene: GravityFieldScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001278_v3", "prompt_id": "seed_001278", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现场景弹跳效果：场景开始时弹跳，持续 2.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera", "output": "[PLAN]\nREQ: 场景开始时实现弹跳效果，持续2.5秒\nAPI: Phaser.Cameras.Scene2D.Camera, Phaser.Tweens.TweenManager, Phaser.Scene\nSTEPS:\n1. 创建场景并添加可视化元素（使用Graphics绘制）\n2. 在create中使用camera.shake或tween实现弹跳效果\n3. 使用zoom缩放配合y轴移动模拟弹跳\n4. 设置持续时间为2.5秒，使用easing函数实现弹跳感\n5. 添加状态变量bounceComplete标记弹跳完成状态\n[/PLAN]\n\n```javascript\nclass BounceScene extends Phaser.Scene {\n  constructor() {\n    super('BounceScene');\n    this.bounceComplete = false; // 状态信号：弹跳是否完成\n    this.bounceProgress = 0; // 状态信号：弹跳进度 0-100\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x2d2d2d, 1);\n    bg.fillRect(0, 0, width, height);\n\n    // 创建标题文字\n    const titleText = this.add.text(width / 2, height / 2 - 100, 'BOUNCE EFFECT', {\n      fontSize: '48px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建多个装饰圆形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff6b6b, 1);\n    graphics.fillCircle(width / 2, height / 2, 80);\n    \n    graphics.fillStyle(0x4ecdc4, 0.7);\n    graphics.fillCircle(width / 2 - 150, height / 2 + 100, 50);\n    \n    graphics.fillStyle(0xffe66d, 0.7);\n    graphics.fillCircle(width / 2 + 150, height / 2 + 100, 50);\n\n    // 创建状态显示文字\n    this.statusText = this.add.text(width / 2, height - 50, 'Bouncing: 0%', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 实现弹跳效果 - 使用相机缩放和位置变化\n    const camera = this.cameras.main;\n    \n    // 方案1: 使用相机震动效果（轻微抖动）\n    camera.shake(2500, 0.002);\n\n    // 方案2: 使用Tween实现弹跳缩放效果\n    this.tweens.add({\n      targets: camera,\n      zoom: { from: 0.8, to: 1 },\n      duration: 2500,\n      ease: 'Bounce.easeOut',\n      onUpdate: (tween) => {\n        // 更新弹跳进度\n        this.bounceProgress = Math.floor(tween.progress * 100);\n        this.statusText.setText(`Bouncing: ${this.bounceProgress}%`);\n      },\n      onComplete: () => {\n        this.bounceComplete = true;\n        this.bounceProgress = 100;\n        this.statusText.setText('Bounce Complete!');\n        this.statusText.setColor('#4ecdc4');\n        \n        // 弹跳完成后的提示动画\n        this.tweens.add({\n          targets: this.statusText,\n          scale: { from: 1, to: 1.2 },\n          duration: 300,\n          yoyo: true,\n          repeat: 2\n        });\n      }\n    });\n\n    // 额外添加Y轴位置弹跳，增强效果\n    this.tweens.add({\n      targets: camera,\n      scrollY: { from: -50, to: 0 },\n      duration: 2500,\n      ease: 'Bounce.easeOut'\n    });\n\n    // 添加装饰元素的旋转动画\n    this.tweens.add({\n      targets: graphics,\n      angle: 360,\n      duration: 2500,\n      ease: 'Linear'\n    });\n\n    // 添加标题的缩放弹跳\n    this.tweens.add({\n      targets: titleText,\n      scale: { from: 0.5, to: 1 },\n      duration: 2500,\n      ease: 'Bounce.easeOut'\n    });\n\n    // 添加调试信息\n    const debugText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 更新调试信息\n    this.time.addEvent({\n      delay: 100,\n      callback: () => {\n        debugText.setText([\n          `Bounce Complete: ${this.bounceComplete}`,\n          `Progress: ${this.bounceProgress}%`,\n          `Camera Zoom: ${camera.zoom.toFixed(2)}`,\n          `Camera Y: ${camera.scrollY.toFixed(2)}`\n        ]);\n      },\n      loop: true\n    });\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: BounceScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001400_v2", "prompt_id": "seed_001400", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Camera"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每 1.5 秒从顶部随机位置生成一个灰色下落障碍物，速度为 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 每1.5秒从顶部随机位置生成灰色下落障碍物，速度300\nAPI: Phaser.Time.Clock#addEvent, Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics#generateTexture, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 在 create 中使用 Graphics 生成灰色障碍物纹理\n3. 创建物理组用于管理障碍物\n4. 使用 TimerEvent 每1.5秒触发生成逻辑\n5. 在回调中随机 x 坐标生成障碍物，设置速度为300向下\n6. 添加计数器验证生成状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.obstacleCount = 0; // 用于验证的状态信号\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 生成灰色障碍物纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 40, 40); // 40x40 的方块\n    graphics.generateTexture('obstacleTexture', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组用于管理障碍物\n    this.obstacles = this.physics.add.group();\n\n    // 创建定时器，每1.5秒生成一个障碍物\n    this.time.addEvent({\n      delay: 1500, // 1.5秒 = 1500毫秒\n      callback: this.spawnObstacle,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示状态信息（用于验证）\n    this.statusText = this.add.text(10, 10, 'Obstacles: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n  }\n\n  spawnObstacle() {\n    // 随机生成 x 坐标（考虑障碍物宽度，避免超出边界）\n    const randomX = Phaser.Math.Between(20, 780);\n    \n    // 创建障碍物精灵，位置在顶部\n    const obstacle = this.obstacles.create(randomX, -20, 'obstacleTexture');\n    \n    // 设置向下的速度为 300\n    obstacle.setVelocityY(300);\n    \n    // 增加计数器\n    this.obstacleCount++;\n    \n    // 更新状态文本\n    this.statusText.setText(`Obstacles: ${this.obstacleCount}`);\n  }\n\n  update(time, delta) {\n    // 清理超出屏幕底部的障碍物\n    this.obstacles.children.entries.forEach((obstacle) => {\n      if (obstacle.y > 650) { // 超出屏幕底部50像素\n        obstacle.destroy();\n      }\n    });\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 不使用重力，手动设置速度\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001290_v2", "prompt_id": "seed_001290", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制圆形，并添加一个标记线以便观察旋转\n2. 将 Graphics 添加到 Container 中以便控制旋转中心\n3. 在 update 方法中根据 delta 时间累加旋转角度（240度/秒 = 每毫秒 0.24 度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建一个容器，用于控制旋转中心\n  circle = this.add.container(400, 300);\n  \n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制圆形主体\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的线，用于观察旋转\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, 0);\n  graphics.lineTo(80, 0);\n  graphics.strokePath();\n  \n  // 在圆边缘添加一个小圆点作为旋转标记\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(80, 0, 10);\n  \n  // 将 graphics 添加到容器中\n  circle.add(graphics);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形以 240°/秒 的速度旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 将每秒 240 度转换为弧度：240° = 240 * (Math.PI / 180) ≈ 4.189 弧度/秒\n  // delta 是毫秒，所以需要除以 1000\n  const rotationSpeed = Phaser.Math.DegToRad(240); // 每秒的弧度\n  const rotationThisFrame = rotationSpeed * (delta / 1000); // 本帧的旋转量\n  \n  // 累加旋转角度\n  circle.rotation += rotationThisFrame;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000238_v3", "prompt_id": "seed_000238", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现场景抖动效果：场景开始时抖动，持续 1 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera", "output": "[PLAN]\nREQ: 场景开始时相机抖动1秒，使用程序化生成的图形验证效果\nAPI: Camera.shake, Graphics.fillRect, Scene.cameras\nSTEPS:\n1. 创建场景并使用 Graphics 绘制可视化元素（背景和参考物体）\n2. 在 create 方法中获取主相机并调用 shake 方法\n3. 设置抖动参数：持续时间1000ms，强度0.01\n4. 添加状态变量记录抖动状态，监听抖动完成事件\n5. 在场景中显示抖动状态文本用于验证\n[/PLAN]\n\n```javascript\nclass ShakeScene extends Phaser.Scene {\n  constructor() {\n    super('ShakeScene');\n    this.shakeStatus = 'pending'; // 状态信号：pending, shaking, completed\n    this.shakeCount = 0; // 抖动次数计数器\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建背景网格用于更明显地观察抖动效果\n    const graphics = this.add.graphics();\n    \n    // 绘制背景色\n    graphics.fillStyle(0x1a1a2e, 1);\n    graphics.fillRect(0, 0, width, height);\n\n    // 绘制网格线\n    graphics.lineStyle(2, 0x16213e, 0.8);\n    const gridSize = 50;\n    \n    // 垂直线\n    for (let x = 0; x <= width; x += gridSize) {\n      graphics.lineBetween(x, 0, x, height);\n    }\n    \n    // 水平线\n    for (let y = 0; y <= height; y += gridSize) {\n      graphics.lineBetween(0, y, width, y);\n    }\n\n    // 创建中心参考物体 - 一个彩色方块\n    const centerBox = this.add.graphics();\n    centerBox.fillStyle(0xff6b6b, 1);\n    centerBox.fillRect(-50, -50, 100, 100);\n    centerBox.setPosition(width / 2, height / 2);\n\n    // 添加边框\n    centerBox.lineStyle(4, 0xffffff, 1);\n    centerBox.strokeRect(-50, -50, 100, 100);\n\n    // 添加四个角落的标记点\n    const cornerSize = 20;\n    const corners = [\n      { x: cornerSize, y: cornerSize },\n      { x: width - cornerSize, y: cornerSize },\n      { x: cornerSize, y: height - cornerSize },\n      { x: width - cornerSize, y: height - cornerSize }\n    ];\n\n    corners.forEach(pos => {\n      const corner = this.add.graphics();\n      corner.fillStyle(0x4ecdc4, 1);\n      corner.fillCircle(pos.x, pos.y, 10);\n    });\n\n    // 创建状态显示文本\n    this.statusText = this.add.text(width / 2, 50, '', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5);\n\n    this.instructionText = this.add.text(width / 2, height - 50, \n      'Watch the grid and objects shake!', {\n      fontSize: '18px',\n      color: '#4ecdc4',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5);\n\n    // 更新初始状态\n    this.updateStatusText();\n\n    // 获取主相机并开始抖动\n    const camera = this.cameras.main;\n    \n    // 设置抖动状态\n    this.shakeStatus = 'shaking';\n    this.shakeCount++;\n    this.updateStatusText();\n\n    // 执行抖动效果\n    // 参数：duration(ms), intensity(抖动强度), force(是否强制重新开始)\n    camera.shake(1000, 0.01);\n\n    // 监听抖动完成事件\n    camera.once('camerashakecomplete', () => {\n      this.shakeStatus = 'completed';\n      this.updateStatusText();\n      \n      // 抖动完成后，显示提示信息\n      this.time.delayedCall(500, () => {\n        this.instructionText.setText('Shake completed! Click to shake again.');\n      });\n    });\n\n    // 添加点击重新抖动功能\n    this.input.on('pointerdown', () => {\n      if (this.shakeStatus === 'completed') {\n        this.shakeStatus = 'shaking';\n        this.shakeCount++;\n        this.updateStatusText();\n        \n        camera.shake(1000, 0.01);\n        \n        camera.once('camerashakecomplete', () => {\n          this.shakeStatus = 'completed';\n          this.updateStatusText();\n        });\n      }\n    });\n  }\n\n  updateStatusText() {\n    const statusMessages = {\n      'pending': 'Status: Pending',\n      'shaking': `Status: SHAKING... (Count: ${this.shakeCount})`,\n      'completed': `Status: Completed (Total: ${this.shakeCount})`\n    };\n\n    this.statusText.setText(statusMessages[this.shakeStatus]);\n    \n    // 根据状态改变文本颜色\n    const colors = {\n      'pending': '#ffffff',\n      'shaking': '#ff6b6b',\n      'completed': '#4ecdc4'\n    };\n    this.statusText.setColor(colors[this.shakeStatus]);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加其他更新逻辑\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: ShakeScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001543_v3", "prompt_id": "seed_001543", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Camera"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现绿色角色冲刺：按鼠标右键进行短距离冲刺，冲刺速度为 200*3，冷却 2 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现绿色角色按鼠标右键进行短距离冲刺，速度为600，冷却2秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Pointer, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建绿色角色精灵并启用物理引擎\n2. 监听鼠标右键点击事件\n3. 实现冲刺逻辑：计算冲刺方向，设置速度为600\n4. 使用 TimerEvent 实现2秒冷却机制\n5. 添加状态信号显示冲刺冷却状态和冲刺次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet dashCount = 0; // 冲刺次数\nlet canDash = true; // 是否可以冲刺\nlet cooldownRemaining = 0; // 剩余冷却时间\n\nlet player;\nlet cursors;\nlet dashSpeed = 200 * 3; // 冲刺速度 600\nlet normalSpeed = 200; // 正常速度\nlet dashDuration = 200; // 冲刺持续时间(毫秒)\nlet dashCooldown = 2000; // 冷却时间2秒\nlet isDashing = false;\nlet statusText;\nlet cooldownTimer;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建绿色角色纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 监听鼠标右键点击\n  this.input.on('pointerdown', (pointer) => {\n    if (pointer.rightButtonDown()) {\n      performDash.call(this, pointer);\n    }\n  });\n\n  // 创建状态显示文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  updateStatusText();\n}\n\nfunction update(time, delta) {\n  // 如果正在冲刺，不处理正常移动\n  if (isDashing) {\n    return;\n  }\n\n  // 正常移动控制\n  player.setVelocity(0);\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-normalSpeed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(normalSpeed);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-normalSpeed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(normalSpeed);\n  }\n\n  // 更新冷却时间显示\n  if (!canDash && cooldownTimer) {\n    cooldownRemaining = Math.max(0, (cooldownTimer.getRemaining() / 1000).toFixed(1));\n    updateStatusText();\n  }\n}\n\nfunction performDash(pointer) {\n  // 检查是否可以冲刺\n  if (!canDash || isDashing) {\n    return;\n  }\n\n  // 计算从玩家到鼠标位置的方向\n  const dx = pointer.x - player.x;\n  const dy = pointer.y - player.y;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n\n  if (distance === 0) {\n    return;\n  }\n\n  // 归一化方向向量\n  const dirX = dx / distance;\n  const dirY = dy / distance;\n\n  // 设置冲刺速度\n  player.setVelocity(dirX * dashSpeed, dirY * dashSpeed);\n\n  // 标记正在冲刺\n  isDashing = true;\n  canDash = false;\n  dashCount++;\n\n  // 改变颜色表示冲刺状态\n  player.setTint(0xffff00);\n\n  // 冲刺持续时间结束后恢复正常\n  this.time.delayedCall(dashDuration, () => {\n    isDashing = false;\n    player.setVelocity(0);\n    player.clearTint();\n  });\n\n  // 开始冷却计时\n  cooldownTimer = this.time.addEvent({\n    delay: dashCooldown,\n    callback: () => {\n      canDash = true;\n      cooldownRemaining = 0;\n      updateStatusText();\n    }\n  });\n\n  updateStatusText();\n}\n\nfunction updateStatusText() {\n  const dashStatus = canDash ? '✓ Ready' : `✗ Cooldown: ${cooldownRemaining}s`;\n  statusText.setText([\n    `Dash Count: ${dashCount}`,\n    `Dash Status: ${dashStatus}`,\n    `Speed: ${isDashing ? dashSpeed : normalSpeed}`,\n    '',\n    'Controls:',\n    '- Arrow Keys: Move',\n    '- Right Click: Dash to cursor'\n  ]);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001234_v2", "prompt_id": "seed_001234", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个16像素的橙色星形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置生成16像素橙色星形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Phaser.GameObjects.Star\nSTEPS:\n1. 创建 Scene 并配置 Game 实例\n2. 在 create 中监听 pointerdown 事件\n3. 在点击回调中使用 Graphics 绘制橙色星形或使用 Star 对象\n4. 将星形定位到点击坐标位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 监听画布点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 在点击位置创建橙色星形\n    createStar(this, pointer.x, pointer.y);\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 300, '点击画布任意位置生成星形', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n/**\n * 在指定位置创建橙色星形\n * @param {Phaser.Scene} scene - 场景对象\n * @param {number} x - X坐标\n * @param {number} y - Y坐标\n */\nfunction createStar(scene, x, y) {\n  // 使用 Graphics 绘制星形\n  const graphics = scene.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 绘制星形（5个顶点）\n  const points = [];\n  const numPoints = 5;\n  const outerRadius = 16;\n  const innerRadius = 8;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius\n    });\n  }\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  \n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加淡入动画效果\n  graphics.setAlpha(0);\n  scene.tweens.add({\n    targets: graphics,\n    alpha: 1,\n    duration: 200,\n    ease: 'Power2'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000518_v3", "prompt_id": "seed_000518", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形以360速度移动并在画布边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建带有 Arcade 物理引擎的 Phaser 游戏配置\n2. 使用 Graphics 绘制橙色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为 360（斜向移动以体现反弹效果）\n5. 启用世界边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1);  // 橙色\n  \n  // 绘制星形（中心点在 50, 50，半径 50）\n  graphics.fillStar(50, 50, 5, 20, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();  // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（斜向移动，速度分量使用勾股定理计算）\n  // 总速度 360，分解为 x 和 y 方向\n  const angle = Phaser.Math.DegToRad(45);  // 45度角\n  const velocityX = Math.cos(angle) * 360;\n  const velocityY = Math.sin(angle) * 360;\n  star.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞，不损失速度）\n  star.setBounce(1, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000798_v1", "prompt_id": "seed_000798", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色六边形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制绿色六边形\n  const hexagonRadius = 40;\n  const sides = 6;\n  const angle = (Math.PI * 2) / sides;\n  \n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.beginPath();\n  \n  // 计算六边形的各个顶点\n  for (let i = 0; i < sides; i++) {\n    const x = hexagonRadius + hexagonRadius * Math.cos(angle * i - Math.PI / 2);\n    const y = hexagonRadius + hexagonRadius * Math.sin(angle * i - Math.PI / 2);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexagonRadius * 2, hexagonRadius * 2);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建六边形精灵\n  const hexagon = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，往返循环\n  this.tweens.add({\n    targets: hexagon,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 2500, // 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 往返效果\n    loop: -1 // 无限循环（-1 表示永久循环）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000482_v1", "prompt_id": "seed_000482", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现菜单和游戏双场景：MenuScene 显示粉色\"开始游戏\" 按钮，点击后切换到 GameScene。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Scene\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现菜单和游戏双场景切换，MenuScene 显示粉色按钮，点击后进入 GameScene\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin, this.scene.start()\nSTEPS:\n1. 创建 MenuScene，使用 Graphics 绘制粉色矩形按钮和文字\n2. 在 MenuScene 中添加点击事件监听，点击按钮后切换场景\n3. 创建 GameScene，显示游戏内容和状态信号\n4. 配置 Phaser.Game，包含两个场景并从 MenuScene 启动\n[/PLAN]\n\n```javascript\n// MenuScene - 菜单场景\nclass MenuScene extends Phaser.Scene {\n  constructor() {\n    super('MenuScene');\n    this.menuState = 'idle'; // 状态信号：idle, hover, clicked\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n    \n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x1a1a2e, 1);\n    bg.fillRect(0, 0, width, height);\n    \n    // 创建按钮容器\n    const buttonWidth = 300;\n    const buttonHeight = 80;\n    const buttonX = width / 2 - buttonWidth / 2;\n    const buttonY = height / 2 - buttonHeight / 2;\n    \n    // 绘制按钮背景（粉色）\n    const button = this.add.graphics();\n    button.fillStyle(0xff69b4, 1); // 粉色\n    button.fillRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 16);\n    \n    // 添加按钮边框\n    button.lineStyle(4, 0xff1493, 1);\n    button.strokeRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 16);\n    \n    // 添加按钮文字\n    const buttonText = this.add.text(width / 2, height / 2, '开始游戏', {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    });\n    buttonText.setOrigin(0.5, 0.5);\n    \n    // 添加标题\n    const title = this.add.text(width / 2, height / 3, 'Phaser3 游戏', {\n      fontSize: '48px',\n      fontFamily: 'Arial',\n      color: '#ff69b4',\n      fontStyle: 'bold'\n    });\n    title.setOrigin(0.5, 0.5);\n    \n    // 添加状态指示器\n    this.stateText = this.add.text(width / 2, height - 50, 'State: idle', {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#888888'\n    });\n    this.stateText.setOrigin(0.5, 0.5);\n    \n    // 创建交互区域\n    const interactiveZone = this.add.zone(\n      buttonX + buttonWidth / 2,\n      buttonY + buttonHeight / 2,\n      buttonWidth,\n      buttonHeight\n    );\n    interactiveZone.setInteractive({ useHandCursor: true });\n    \n    // 鼠标悬停效果\n    interactiveZone.on('pointerover', () => {\n      this.menuState = 'hover';\n      this.stateText.setText('State: hover');\n      button.clear();\n      button.fillStyle(0xff1493, 1); // 深粉色\n      button.fillRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 16);\n      button.lineStyle(4, 0xff69b4, 1);\n      button.strokeRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 16);\n    });\n    \n    // 鼠标移出效果\n    interactiveZone.on('pointerout', () => {\n      this.menuState = 'idle';\n      this.stateText.setText('State: idle');\n      button.clear();\n      button.fillStyle(0xff69b4, 1);\n      button.fillRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 16);\n      button.lineStyle(4, 0xff1493, 1);\n      button.strokeRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 16);\n    });\n    \n    // 点击事件\n    interactiveZone.on('pointerdown', () => {\n      this.menuState = 'clicked';\n      this.stateText.setText('State: clicked');\n      \n      // 按钮按下效果\n      button.clear();\n      button.fillStyle(0xc71585, 1); // 更深的粉色\n      button.fillRoundedRect(buttonX + 2, buttonY + 2, buttonWidth, buttonHeight, 16);\n      \n      // 延迟切换场景，显示点击效果\n      this.time.delayedCall(150, () => {\n        this.scene.start('GameScene');\n      });\n    });\n  }\n\n  update() {\n    // MenuScene 不需要每帧更新逻辑\n  }\n}\n\n// GameScene - 游戏场景\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0; // 状态信号：分数\n    this.level = 1; // 状态信号：关卡\n    this.health = 100; // 状态信号：生命值\n    this.gameState = 'playing'; // 状态信号：playing, paused, gameover\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n    \n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x0f3460, 1);\n    bg.fillRect(0, 0, width, height);\n    \n    // 添加游戏标题\n    const gameTitle = this.add.text(width / 2, 50, '游戏场景', {\n      fontSize: '36px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    });\n    gameTitle.setOrigin(0.5, 0.5);\n    \n    // 创建状态显示面板\n    const panelWidth = 400;\n    const panelHeight = 200;\n    const panelX = width / 2 - panelWidth / 2;\n    const panelY = height / 2 - panelHeight / 2;\n    \n    const panel = this.add.graphics();\n    panel.fillStyle(0x16213e, 0.9);\n    panel.fillRoundedRect(panelX, panelY, panelWidth, panelHeight, 12);\n    panel.lineStyle(3, 0xff69b4, 1);\n    panel.strokeRoundedRect(panelX, panelY, panelWidth, panelHeight, 12);\n    \n    // 状态文本\n    this.scoreText = this.add.text(width / 2, height / 2 - 50, `分数: ${this.score}`, {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n    this.scoreText.setOrigin(0.5, 0.5);\n    \n    this.levelText = this.add.text(width / 2, height / 2, `关卡: ${this.level}`, {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n    this.levelText.setOrigin(0.5, 0.5);\n    \n    this.healthText = this.add.text(width / 2, height / 2 + 50, `生命值: ${this.health}`, {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#00ff00'\n    });\n    this.healthText.setOrigin(0.5, 0.5);\n    \n    // 返回菜单按钮\n    const backButtonWidth = 200;\n    const backButtonHeight = 50;\n    const backButtonX = width / 2 - backButtonWidth / 2;\n    const backButtonY = height - 100;\n    \n    const backButton = this.add.graphics();\n    backButton.fillStyle(0xff69b4, 1);\n    backButton.fillRoundedRect(backButtonX, backButtonY, backButtonWidth, backButtonHeight, 8);\n    \n    const backButtonText = this.add.text(width / 2, backButtonY + backButtonHeight / 2, '返回菜单', {\n      fontSize: '20px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n    backButtonText.setOrigin(0.5, 0.5);\n    \n    const backZone = this.add.zone(\n      backButtonX + backButtonWidth / 2,\n      backButtonY + backButtonHeight / 2,\n      backButtonWidth,\n      backButtonHeight\n    );\n    backZone.setInteractive({ useHandCursor: true });\n    \n    backZone.on('pointerdown', () => {\n      this.scene.start('MenuScene');\n    });\n    \n    // 模拟游戏逻辑：每秒增加分数\n    this.time.addEvent({\n      delay: 1000,\n      callback: () => {\n        if (this.gameState === 'playing') {\n          this.score += 10;\n          this.scoreText.setText(`分数: ${this.score}`);\n          \n          // 每100分升级\n          if (this.score % 100 === 0 && this.score > 0) {\n            this.level++;\n            this.levelText.setText(`关卡: ${this.level}`);\n          }\n        }\n      },\n      loop: true\n    });\n    \n    // 添加键盘控制提示\n    const hint = this.add.text(width / 2, height - 30, '游戏运行中...', {\n      fontSize: '14px',\n      fontFamily: 'Arial',\n      color: '#888888'\n    });\n    hint.setOrigin(0.5, 0.5);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加游戏逻辑\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: [MenuScene, GameScene], // 场景数组，MenuScene 为默认启动场景\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001890_v2", "prompt_id": "seed_001890", "source": "distill", "difficulty": "hard", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 1.5 秒在随机位置生成一个青色星形，最多生成 8 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔1.5秒在随机位置生成青色星形，最多8个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Star\nSTEPS:\n1. 创建场景并初始化星形计数器\n2. 使用Graphics绘制青色星形纹理\n3. 使用TimerEvent每1.5秒触发一次生成逻辑\n4. 在随机位置创建星形图像对象\n5. 当星形数量达到8个时停止生成\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nlet starCount = 0;\nlet timerEvent = null;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 初始化星形计数器\n  starCount = 0;\n  \n  // 使用Graphics绘制青色星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.lineStyle(2, 0x00cccc, 1);\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push(\n      32 + radius * Math.cos(angle),\n      32 + radius * Math.sin(angle)\n    );\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(starPoints[0], starPoints[1]);\n  for (let i = 2; i < starPoints.length; i += 2) {\n    graphics.lineTo(starPoints[i], starPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n  \n  // 创建定时器事件，每1.5秒生成一个星形\n  timerEvent = this.time.addEvent({\n    delay: 1500, // 1.5秒\n    callback: generateStar,\n    callbackScope: this,\n    loop: true\n  });\n  \n  // 添加文本显示当前星形数量\n  this.starCountText = this.add.text(10, 10, 'Stars: 0 / 8', {\n    fontSize: '24px',\n    color: '#00ffff'\n  });\n}\n\nfunction generateStar() {\n  // 检查是否已达到最大数量\n  if (starCount >= 8) {\n    // 停止定时器\n    if (timerEvent) {\n      timerEvent.remove();\n      timerEvent = null;\n    }\n    return;\n  }\n  \n  // 生成随机位置（确保星形完全在屏幕内）\n  const x = Phaser.Math.Between(50, 750);\n  const y = Phaser.Math.Between(50, 550);\n  \n  // 创建星形图像\n  const star = this.add.image(x, y, 'star');\n  \n  // 添加缩放动画效果\n  this.tweens.add({\n    targets: star,\n    scale: { from: 0, to: 1 },\n    duration: 300,\n    ease: 'Back.easeOut'\n  });\n  \n  // 增加计数\n  starCount++;\n  \n  // 更新文本显示\n  this.starCountText.setText(`Stars: ${starCount} / 8`);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000127_v2", "prompt_id": "seed_000127", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现青色角色冲刺：按鼠标左键进行短距离冲刺，冲刺速度为 240*3，冷却 2 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现青色角色按鼠标左键进行短距离冲刺，速度为720，冷却2秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Pointer, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建青色角色精灵，使用Graphics绘制青色矩形作为纹理\n2. 监听鼠标左键点击事件，触发冲刺逻辑\n3. 冲刺时计算鼠标方向，设置角色速度为720（240*3）\n4. 使用TimerEvent实现0.3秒冲刺持续时间和2秒冷却机制\n5. 添加状态变量dashCooldown和dashCount用于验证功能\n[/PLAN]\n\n```javascript\nclass DashScene extends Phaser.Scene {\n  constructor() {\n    super('DashScene');\n    this.dashSpeed = 240 * 3; // 720\n    this.normalSpeed = 200;\n    this.dashDuration = 300; // 冲刺持续时间 300ms\n    this.dashCooldown = 2000; // 冷却时间 2秒\n    this.canDash = true;\n    this.isDashing = false;\n    this.dashCount = 0; // 用于验证的状态信号\n  }\n\n  preload() {\n    // 创建青色角色纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('player', 40, 40);\n    graphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x333333, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 创建物理世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 创建地面\n    const ground = this.physics.add.staticSprite(400, 575, 'ground');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0.2);\n    \n    // 添加重力\n    this.player.body.setGravityY(500);\n\n    // 玩家与地面碰撞\n    this.physics.add.collider(this.player, ground);\n\n    // 监听鼠标左键点击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        this.performDash(pointer);\n      }\n    });\n\n    // 添加键盘控制（WASD移动）\n    this.cursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 创建UI文本显示状态\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建冷却指示器\n    this.cooldownBar = this.add.graphics();\n  }\n\n  performDash(pointer) {\n    // 检查是否可以冲刺\n    if (!this.canDash || this.isDashing) {\n      return;\n    }\n\n    // 计算冲刺方向（从玩家指向鼠标位置）\n    const angle = Phaser.Math.Angle.Between(\n      this.player.x,\n      this.player.y,\n      pointer.x,\n      pointer.y\n    );\n\n    // 设置冲刺状态\n    this.isDashing = true;\n    this.canDash = false;\n    this.dashCount++; // 增加冲刺计数\n\n    // 计算冲刺速度向量\n    const velocityX = Math.cos(angle) * this.dashSpeed;\n    const velocityY = Math.sin(angle) * this.dashSpeed;\n\n    // 应用冲刺速度\n    this.player.setVelocity(velocityX, velocityY);\n\n    // 改变颜色表示冲刺状态\n    this.player.setTint(0xffff00); // 黄色表示冲刺中\n\n    // 冲刺持续时间结束后恢复正常\n    this.time.addEvent({\n      delay: this.dashDuration,\n      callback: () => {\n        this.isDashing = false;\n        this.player.clearTint();\n        // 恢复正常速度（保持方向但降低速度）\n        const currentVelocity = this.player.body.velocity;\n        if (currentVelocity.length() > this.normalSpeed) {\n          currentVelocity.normalize().scale(this.normalSpeed);\n          this.player.setVelocity(currentVelocity.x, currentVelocity.y);\n        }\n      }\n    });\n\n    // 冷却时间结束后可以再次冲刺\n    this.time.addEvent({\n      delay: this.dashCooldown,\n      callback: () => {\n        this.canDash = true;\n      }\n    });\n  }\n\n  update(time, delta) {\n    // 正常移动控制（非冲刺时）\n    if (!this.isDashing) {\n      if (this.cursors.left.isDown) {\n        this.player.setVelocityX(-this.normalSpeed);\n      } else if (this.cursors.right.isDown) {\n        this.player.setVelocityX(this.normalSpeed);\n      } else {\n        // 保持X轴速度衰减\n        this.player.setVelocityX(this.player.body.velocity.x * 0.9);\n      }\n\n      // 跳跃（只在地面时）\n      if (this.cursors.up.isDown && this.player.body.touching.down) {\n        this.player.setVelocityY(-400);\n      }\n    }\n\n    // 更新状态文本\n    const cooldownStatus = this.canDash ? '就绪' : '冷却中';\n    const dashStatus = this.isDashing ? '冲刺中' : '正常';\n    this.statusText.setText([\n      `冲刺状态: ${dashStatus}`,\n      `冷却状态: ${cooldownStatus}`,\n      `冲刺次数: ${this.dashCount}`,\n      `速度: ${Math.round(this.player.body.velocity.length())}`,\n      '',\n      '操作说明:',\n      '鼠标左键: 向鼠标方向冲刺',\n      'WASD: 移动和跳跃'\n    ]);\n\n    // 绘制冷却条\n    this.cooldownBar.clear();\n    if (!this.canDash) {\n      // 计算冷却进度（需要追踪冷却开始时间）\n      this.cooldownBar.fillStyle(0xff0000, 0.7);\n      this.cooldownBar.fillRect(10, 180, 200, 20);\n      this.cooldownBar.fillStyle(0x00ff00, 0.7);\n      // 简化显示：用isDashing状态近似\n      const progress = this.isDashing ? 0 : 0.5;\n      this.cooldownBar.fillRect(10, 180, 200 * progress, 20);\n    } else {\n      this.cooldownBar.fillStyle(0x00ff00, 0.7);\n      this.cooldownBar.fillRect(10, 180, 200, 20);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DashScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001387_v3", "prompt_id": "seed_001387", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按方向键触发相机旋转效果，持续 2.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按方向键触发相机旋转效果，持续 2.5 秒\nAPI: Phaser.Input.Keyboard.KeyCodes, Phaser.Cameras.Scene2D.Camera.rotateTo, Phaser.Input.Keyboard.createCursorKeys\nSTEPS:\n1. 创建场景并绘制参考图形（用于观察旋转效果）\n2. 设置键盘输入监听（方向键）\n3. 在 update 中检测方向键按下，触发相机 rotateTo 效果\n4. 添加状态信号变量记录旋转次数和当前旋转状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.rotationCount = 0; // 状态信号：旋转触发次数\n    this.isRotating = false; // 状态信号：是否正在旋转\n    this.currentRotation = 0; // 当前目标旋转角度\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建背景网格作为参考（便于观察旋转效果）\n    const graphics = this.add.graphics();\n    \n    // 绘制网格线\n    graphics.lineStyle(1, 0x333333, 0.5);\n    for (let x = 0; x <= 800; x += 50) {\n      graphics.lineBetween(x, 0, x, 600);\n    }\n    for (let y = 0; y <= 600; y += 50) {\n      graphics.lineBetween(0, y, 800, y);\n    }\n\n    // 绘制中心参考点\n    graphics.fillStyle(0xff0000, 1);\n    graphics.fillCircle(400, 300, 10);\n\n    // 绘制方向指示器（箭头）\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillTriangle(\n      400, 250,  // 顶点\n      380, 280,  // 左下\n      420, 280   // 右下\n    );\n\n    // 添加文字说明\n    this.instructionText = this.add.text(400, 50, \n      'Press Arrow Keys to Rotate Camera\\n(Rotation lasts 2.5 seconds)', \n      {\n        fontSize: '20px',\n        color: '#ffffff',\n        align: 'center',\n        backgroundColor: '#000000',\n        padding: { x: 10, y: 10 }\n      }\n    ).setOrigin(0.5);\n\n    // 状态显示文本\n    this.statusText = this.add.text(400, 550, \n      'Rotation Count: 0 | Status: Ready', \n      {\n        fontSize: '18px',\n        color: '#ffff00',\n        backgroundColor: '#000000',\n        padding: { x: 10, y: 5 }\n      }\n    ).setOrigin(0.5);\n\n    // 创建方向键输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 记录上一帧的按键状态（避免重复触发）\n    this.lastKeyState = {\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n\n    // 获取主相机\n    this.mainCamera = this.cameras.main;\n  }\n\n  update(time, delta) {\n    // 检测方向键按下（边缘触发，避免持续触发）\n    const upPressed = this.cursors.up.isDown && !this.lastKeyState.up;\n    const downPressed = this.cursors.down.isDown && !this.lastKeyState.down;\n    const leftPressed = this.cursors.left.isDown && !this.lastKeyState.left;\n    const rightPressed = this.cursors.right.isDown && !this.lastKeyState.right;\n\n    // 更新按键状态\n    this.lastKeyState.up = this.cursors.up.isDown;\n    this.lastKeyState.down = this.cursors.down.isDown;\n    this.lastKeyState.left = this.cursors.left.isDown;\n    this.lastKeyState.right = this.cursors.right.isDown;\n\n    // 如果正在旋转，不处理新的输入\n    if (this.isRotating) {\n      return;\n    }\n\n    // 根据方向键设置旋转目标角度\n    let targetRotation = null;\n\n    if (upPressed) {\n      // 上键：顺时针旋转 90 度\n      targetRotation = this.currentRotation + Phaser.Math.DegToRad(90);\n    } else if (downPressed) {\n      // 下键：逆时针旋转 90 度\n      targetRotation = this.currentRotation - Phaser.Math.DegToRad(90);\n    } else if (leftPressed) {\n      // 左键：逆时针旋转 45 度\n      targetRotation = this.currentRotation - Phaser.Math.DegToRad(45);\n    } else if (rightPressed) {\n      // 右键：顺时针旋转 45 度\n      targetRotation = this.currentRotation + Phaser.Math.DegToRad(45);\n    }\n\n    // 如果有目标旋转角度，触发旋转效果\n    if (targetRotation !== null) {\n      this.isRotating = true;\n      this.rotationCount++;\n      this.currentRotation = targetRotation;\n\n      // 触发相机旋转效果，持续 2.5 秒\n      this.mainCamera.rotateTo(targetRotation, false, 2500, 'Sine.easeInOut', false, (camera, progress) => {\n        // 旋转完成回调\n        if (progress === 1) {\n          this.isRotating = false;\n          this.updateStatus();\n        }\n      });\n\n      this.updateStatus();\n    }\n  }\n\n  updateStatus() {\n    // 更新状态显示\n    const status = this.isRotating ? 'Rotating...' : 'Ready';\n    const rotationDegrees = Math.round(Phaser.Math.RadToDeg(this.currentRotation));\n    this.statusText.setText(\n      `Rotation Count: ${this.rotationCount} | Status: ${status} | Angle: ${rotationDegrees}°`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001326_v2", "prompt_id": "seed_001326", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形移动，速度 240 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.Math.Vector2\nSTEPS:\n1. 创建 Scene 并初始化 Phaser.Game 配置\n2. 使用 Graphics 绘制菱形形状并生成纹理\n3. 创建 Sprite 对象作为可移动的菱形\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态计算移动方向并更新位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点为原点）\n  const size = 30;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置键盘输入监听 WASD\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the diamond', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动方向向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  if (keys.W.isDown) {\n    velocityY = -1;\n  } else if (keys.S.isDown) {\n    velocityY = 1;\n  }\n  \n  if (keys.A.isDown) {\n    velocityX = -1;\n  } else if (keys.D.isDown) {\n    velocityX = 1;\n  }\n  \n  // 如果有移动输入，归一化向量并应用速度\n  if (velocityX !== 0 || velocityY !== 0) {\n    // 创建向量并归一化（确保对角线移动速度一致）\n    const velocity = new Phaser.Math.Vector2(velocityX, velocityY);\n    velocity.normalize();\n    \n    // 根据 delta 时间计算实际移动距离\n    const moveDistance = SPEED * (delta / 1000);\n    \n    // 更新菱形位置\n    diamond.x += velocity.x * moveDistance;\n    diamond.y += velocity.y * moveDistance;\n    \n    // 限制在屏幕范围内\n    diamond.x = Phaser.Math.Clamp(diamond.x, 0, 800);\n    diamond.y = Phaser.Math.Clamp(diamond.y, 0, 600);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000236_v2", "prompt_id": "seed_000236", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 3 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成3个白色可收集物体，玩家碰到后消失并加分，显示score\nAPI: Phaser.Physics.Arcade.Factory#sprite, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Graphics#generateTexture\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制玩家和收集物纹理（玩家用绿色矩形，收集物用白色圆形）\n3. 创建玩家物理精灵，添加键盘控制\n4. 创建物理组，生成3个白色收集物随机分布在场景中\n5. 添加 overlap 碰撞检测，碰撞时销毁收集物并增加分数\n6. 创建文本对象显示当前分数，每次收集后更新显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（绿色矩形）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（白色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0xffffff, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 生成3个收集物，随机位置\n  const positions = [\n    { x: 200, y: 150 },\n    { x: 600, y: 450 },\n    { x: 400, y: 100 }\n  ];\n\n  positions.forEach(pos => {\n    const collectible = collectibles.create(pos.x, pos.y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    // 添加轻微漂浮动画\n    this.tweens.add({\n      targets: collectible,\n      y: collectible.y - 10,\n      duration: 1000,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  });\n\n  // 添加碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect White Circles', {\n    fontSize: '18px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  player.setVelocity(0);\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n\n  // 检查是否收集完所有物品\n  if (score === 3 && collectibles.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - All Collected!');\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 1;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 添加收集特效（简单的粒子效果）\n  const particle = this.add.graphics();\n  particle.fillStyle(0xffffff, 1);\n  particle.fillCircle(collectible.x, collectible.y, 5);\n\n  this.tweens.add({\n    targets: particle,\n    alpha: 0,\n    scale: 3,\n    duration: 500,\n    onComplete: () => {\n      particle.destroy();\n    }\n  });\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000935_v1", "prompt_id": "seed_000935", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现紫色圆形左右往返循环补间动画\nAPI: this.add.graphics, graphics.fillCircle, graphics.generateTexture, this.add.sprite, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建精灵对象放置在左侧起始位置\n3. 使用 tweens.add 创建 x 轴移动补间，设置 duration 为 2500ms\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建精灵对象，放置在屏幕左侧\n  const circle = this.add.sprite(100, 300, 'purpleCircle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 移动到右侧位置\n    duration: 2500, // 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加文字说明\n  this.add.text(10, 10, 'Purple Circle Tween Animation', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000794_v3", "prompt_id": "seed_000794", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色圆形以300速度移动并在边界反弹\nAPI: Graphics, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制绿色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为300\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('greenCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'greenCircle');\n  \n  // 设置圆形为圆形碰撞体（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置初始速度（斜向移动，速度大小约为300）\n  // 使用勾股定理：sqrt(212^2 + 212^2) ≈ 300\n  circle.setVelocity(212, 212);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000557_v3", "prompt_id": "seed_000557", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色六边形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现粉色六边形在4秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 创建使用该纹理的 Sprite 对象并定位到左侧\n3. 使用 tweens 创建补间动画，设置 4 秒移动到右侧，yoyo 模式实现往返，loop -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制六边形\n  const hexagonSize = 40;\n  const hexagonPoints = [];\n  \n  // 计算六边形的六个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角60度\n    const x = hexagonSize + hexagonSize * Math.cos(angle);\n    const y = hexagonSize + hexagonSize * Math.sin(angle);\n    hexagonPoints.push(x, y);\n  }\n  \n  // 绘制多边形\n  graphics.fillPoints(hexagonPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexagonSize * 2, hexagonSize * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexagonSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: hexagonSprite,\n    x: 700, // 移动到右侧（考虑精灵宽度，留出边距）\n    duration: 4000, // 4秒\n    ease: 'Linear', // 线性移动\n    yoyo: true, // 启用往返（到达终点后反向播放）\n    loop: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(10, 10, '粉色六边形左右往返循环动画\\n单程时间: 4秒', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000704_v2", "prompt_id": "seed_000704", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 3 秒在随机位置生成一个粉色三角形，最多生成 5 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔3秒在随机位置生成粉色三角形，最多5个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Triangle\nSTEPS:\n1. 创建 Scene 并初始化三角形计数器\n2. 使用 Graphics 绘制粉色三角形并生成纹理\n3. 在 create 中使用 addEvent 创建定时器，每3秒触发一次\n4. 在回调函数中检查数量限制，随机位置生成三角形\n5. 达到5个后移除定时器事件\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n// 三角形计数器\nlet triangleCount = 0;\nlet timerEvent = null;\n\nfunction preload() {\n  // 使用 Graphics 生成粉色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(30, 10);  // 顶点\n  graphics.lineTo(10, 50);  // 左下\n  graphics.lineTo(50, 50);  // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('pinkTriangle', 60, 60);\n  \n  // 清除 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 添加标题文本\n  this.add.text(400, 30, '每3秒生成一个粉色三角形（最多5个）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 显示当前数量\n  const countText = this.add.text(400, 60, `当前数量: ${triangleCount}/5`, {\n    fontSize: '18px',\n    color: '#ffff00'\n  }).setOrigin(0.5);\n  \n  // 创建定时器事件，每3秒触发一次\n  timerEvent = this.time.addEvent({\n    delay: 3000,           // 3秒\n    callback: spawnTriangle,\n    callbackScope: this,\n    loop: true,\n    args: [countText]      // 传递文本对象用于更新显示\n  });\n  \n  // 立即生成第一个三角形\n  spawnTriangle.call(this, countText);\n}\n\nfunction spawnTriangle(countText) {\n  // 检查是否已达到最大数量\n  if (triangleCount >= 5) {\n    // 移除定时器\n    if (timerEvent) {\n      timerEvent.remove();\n      timerEvent = null;\n    }\n    \n    // 显示完成消息\n    this.add.text(400, 550, '已生成5个三角形！', {\n      fontSize: '24px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n    \n    return;\n  }\n  \n  // 生成随机位置（留出边距）\n  const x = Phaser.Math.Between(50, 750);\n  const y = Phaser.Math.Between(100, 550);\n  \n  // 创建三角形图像\n  const triangle = this.add.image(x, y, 'pinkTriangle');\n  \n  // 添加缩放动画效果\n  this.tweens.add({\n    targets: triangle,\n    scale: { from: 0, to: 1 },\n    duration: 300,\n    ease: 'Back.easeOut'\n  });\n  \n  // 增加计数\n  triangleCount++;\n  \n  // 更新显示文本\n  countText.setText(`当前数量: ${triangleCount}/5`);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000047_v2", "prompt_id": "seed_000047", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个倒计时 3 秒的计时器，在屏幕中央显示剩余时间，归零时显示 \"时间到\"。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个倒计时3秒的计时器，在屏幕中央显示剩余时间，归零时显示\"时间到\"\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 在 create 中创建文本对象显示倒计时数字，居中显示\n2. 使用 this.time.addEvent 创建定时器，每秒触发一次，重复3次\n3. 在定时器回调中更新文本内容，递减倒计时数字\n4. 倒计时结束后将文本改为\"时间到\"\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 初始倒计时秒数\n  let countdown = 3;\n  \n  // 创建文本对象，显示初始倒计时\n  const countdownText = this.add.text(\n    400, \n    300, \n    countdown.toString(), \n    {\n      fontSize: '128px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }\n  );\n  \n  // 设置文本居中对齐\n  countdownText.setOrigin(0.5, 0.5);\n  \n  // 创建定时器，每1000毫秒（1秒）触发一次\n  this.time.addEvent({\n    delay: 1000,           // 延迟1秒\n    callback: () => {\n      countdown--;         // 递减倒计时\n      \n      if (countdown > 0) {\n        // 更新显示的数字\n        countdownText.setText(countdown.toString());\n      } else {\n        // 倒计时结束，显示\"时间到\"\n        countdownText.setText('时间到');\n        countdownText.setFontSize('64px');\n      }\n    },\n    callbackScope: this,\n    repeat: 3              // 重复3次（总共触发4次：3秒递减 + 1次显示\"时间到\"）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000244_v3", "prompt_id": "seed_000244", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在1秒内缩放到32%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建缩放动画，从 scale 1 到 0.32 再回到 1\n4. 设置 loop: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('squareTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'squareTexture');\n\n  // 创建缩放动画\n  // 使用 yoyo 实现来回缩放效果\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 1000,  // 1秒缩小到32%\n    yoyo: true,      // 自动反向播放（恢复到原始大小）\n    loop: -1,        // -1 表示无限循环\n    ease: 'Linear'   // 线性缓动\n  });\n\n  // 添加文字提示\n  this.add.text(400, 500, '方块循环缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000516_v2", "prompt_id": "seed_000516", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 12 个金币，重力 1000，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集12个金币，重力1000，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建带物理系统的游戏配置，设置重力为1000\n2. 使用Graphics绘制玩家角色、平台和金币纹理\n3. 创建玩家精灵并添加物理属性，创建静态平台组\n4. 生成12个金币并添加到物理组中\n5. 添加键盘输入控制（左右移动和跳跃）\n6. 设置玩家与平台、金币的碰撞检测\n7. 实现金币收集逻辑，更新分数显示\n8. 在update中处理玩家移动和跳跃逻辑\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet platforms;\nlet coins;\nlet cursors;\nlet score = 0;\nlet scoreText;\n\nfunction preload() {\n  // 创建玩家纹理 - 蓝色方块\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x0088ff, 1);\n  playerGraphics.fillRect(0, 0, 32, 48);\n  playerGraphics.generateTexture('player', 32, 48);\n  playerGraphics.destroy();\n\n  // 创建平台纹理 - 绿色矩形\n  const platformGraphics = this.add.graphics();\n  platformGraphics.fillStyle(0x00aa00, 1);\n  platformGraphics.fillRect(0, 0, 200, 32);\n  platformGraphics.generateTexture('platform', 200, 32);\n  platformGraphics.destroy();\n\n  // 创建金币纹理 - 黄色圆形\n  const coinGraphics = this.add.graphics();\n  coinGraphics.fillStyle(0xffdd00, 1);\n  coinGraphics.fillCircle(16, 16, 16);\n  coinGraphics.generateTexture('coin', 32, 32);\n  coinGraphics.destroy();\n}\n\nfunction create() {\n  // 创建静态平台组\n  platforms = this.physics.add.staticGroup();\n\n  // 地面平台\n  platforms.create(400, 568, 'platform').setScale(4, 1).refreshBody();\n  \n  // 中层平台\n  platforms.create(600, 450, 'platform');\n  platforms.create(200, 450, 'platform');\n  platforms.create(400, 350, 'platform');\n  \n  // 上层平台\n  platforms.create(100, 250, 'platform');\n  platforms.create(700, 250, 'platform');\n  platforms.create(400, 150, 'platform');\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 500, 'player');\n  player.setBounce(0.1);\n  player.setCollideWorldBounds(true);\n\n  // 玩家与平台碰撞\n  this.physics.add.collider(player, platforms);\n\n  // 创建金币组\n  coins = this.physics.add.group();\n\n  // 在不同位置生成12个金币\n  const coinPositions = [\n    { x: 100, y: 200 },\n    { x: 700, y: 200 },\n    { x: 400, y: 100 },\n    { x: 200, y: 400 },\n    { x: 600, y: 400 },\n    { x: 400, y: 300 },\n    { x: 300, y: 150 },\n    { x: 500, y: 150 },\n    { x: 150, y: 450 },\n    { x: 650, y: 450 },\n    { x: 400, y: 500 },\n    { x: 250, y: 300 }\n  ];\n\n  coinPositions.forEach(pos => {\n    const coin = coins.create(pos.x, pos.y, 'coin');\n    coin.setBounce(0.3);\n  });\n\n  // 金币与平台碰撞\n  this.physics.add.collider(coins, platforms);\n\n  // 玩家收集金币\n  this.physics.add.overlap(player, coins, collectCoin, null, this);\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0 / 12', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontStyle: 'bold'\n  });\n}\n\nfunction update() {\n  // 左右移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-200);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(200);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃控制 - 只有在地面或平台上才能跳跃\n  if (cursors.up.isDown && player.body.touching.down) {\n    player.setVelocityY(-500);\n  }\n}\n\nfunction collectCoin(player, coin) {\n  // 移除金币\n  coin.disableBody(true, true);\n  \n  // 增加分数\n  score += 1;\n  \n  // 更新分数显示\n  scoreText.setText('Score: ' + score + ' / 12');\n  \n  // 检查是否收集完所有金币\n  if (score === 12) {\n    scoreText.setText('Score: 12 / 12 - YOU WIN!');\n    scoreText.setStyle({ fill: '#00ff00' });\n  }\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001451_v1", "prompt_id": "seed_001451", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象应用六边形纹理\n3. 使用 Tween 实现缩放动画：从 scale=1 到 scale=0.32 再回到 scale=1\n4. 设置 Tween 循环播放（loop: -1）和 yoyo 效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形（6个顶点）\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 从原始大小(1)缩放到32%(0.32)，然后恢复，循环播放\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 1000, // 1秒\n    yoyo: true, // 自动返回原始值\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 50, '六边形缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 32%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000443_v2", "prompt_id": "seed_000443", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现关卡+限时：8 关，每关限时 1 秒，超时失败，通关显示总用时。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现8关限时游戏，每关1秒倒计时，超时失败，通关显示总用时\nAPI: Phaser.Time.Clock#addEvent, Phaser.Scene#scene.start, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建主游戏场景，包含关卡编号、倒计时显示、总用时记录\n2. 使用 Graphics 绘制关卡目标（点击区域）和视觉反馈\n3. 为每关添加1秒倒计时 TimerEvent，超时则失败\n4. 点击目标后进入下一关，记录累计用时\n5. 完成8关后显示胜利场景和总用时\n6. 创建失败场景显示失败信息和重试按钮\n[/PLAN]\n\n```javascript\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: [GameScene, WinScene, LoseScene]\n};\n\n// 主游戏场景\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentLevel = 1;\n    this.maxLevel = 8;\n    this.totalTime = 0;\n    this.levelStartTime = 0;\n    this.levelTimeLimit = 1000; // 1秒 = 1000毫秒\n    this.timer = null;\n    this.isLevelActive = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 重置游戏状态（用于重新开始）\n    if (this.scene.settings.data && this.scene.settings.data.restart) {\n      this.currentLevel = 1;\n      this.totalTime = 0;\n    }\n\n    this.levelStartTime = this.time.now;\n    this.isLevelActive = true;\n\n    // 创建UI文本\n    this.levelText = this.add.text(400, 50, `关卡: ${this.currentLevel}/${this.maxLevel}`, {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    this.timerText = this.add.text(400, 100, '剩余时间: 1.00s', {\n      fontSize: '28px',\n      color: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    this.totalTimeText = this.add.text(400, 150, `总用时: ${(this.totalTime / 1000).toFixed(2)}s`, {\n      fontSize: '24px',\n      color: '#00ff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    this.instructionText = this.add.text(400, 250, '点击目标通关！', {\n      fontSize: '20px',\n      color: '#aaaaaa',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建目标区域（使用 Graphics）\n    this.createTarget();\n\n    // 创建倒计时器\n    this.timer = this.time.addEvent({\n      delay: this.levelTimeLimit,\n      callback: this.onTimeOut,\n      callbackScope: this,\n      loop: false\n    });\n\n    // 状态信号（用于验证）\n    this.registry.set('currentLevel', this.currentLevel);\n    this.registry.set('totalTime', this.totalTime);\n    this.registry.set('isLevelActive', this.isLevelActive);\n  }\n\n  createTarget() {\n    // 使用固定位置确保行为确定性\n    const positions = [\n      { x: 400, y: 350 },\n      { x: 300, y: 400 },\n      { x: 500, y: 400 },\n      { x: 350, y: 450 },\n      { x: 450, y: 450 },\n      { x: 400, y: 500 },\n      { x: 250, y: 350 },\n      { x: 550, y: 350 }\n    ];\n\n    const pos = positions[this.currentLevel - 1];\n    \n    // 绘制目标\n    this.targetGraphics = this.add.graphics();\n    this.targetGraphics.fillStyle(0xff0000, 1);\n    this.targetGraphics.fillCircle(pos.x, pos.y, 40);\n    \n    // 添加边框\n    this.targetGraphics.lineStyle(4, 0xffffff, 1);\n    this.targetGraphics.strokeCircle(pos.x, pos.y, 40);\n\n    // 添加交互区域\n    const hitArea = new Phaser.Geom.Circle(pos.x, pos.y, 40);\n    this.targetGraphics.setInteractive(hitArea, Phaser.Geom.Circle.Contains);\n\n    // 点击事件\n    this.targetGraphics.on('pointerdown', () => {\n      if (this.isLevelActive) {\n        this.onTargetClicked();\n      }\n    });\n\n    // 鼠标悬停效果\n    this.targetGraphics.on('pointerover', () => {\n      if (this.isLevelActive) {\n        this.targetGraphics.clear();\n        this.targetGraphics.fillStyle(0xff6600, 1);\n        this.targetGraphics.fillCircle(pos.x, pos.y, 40);\n        this.targetGraphics.lineStyle(4, 0xffffff, 1);\n        this.targetGraphics.strokeCircle(pos.x, pos.y, 40);\n      }\n    });\n\n    this.targetGraphics.on('pointerout', () => {\n      if (this.isLevelActive) {\n        this.targetGraphics.clear();\n        this.targetGraphics.fillStyle(0xff0000, 1);\n        this.targetGraphics.fillCircle(pos.x, pos.y, 40);\n        this.targetGraphics.lineStyle(4, 0xffffff, 1);\n        this.targetGraphics.strokeCircle(pos.x, pos.y, 40);\n      }\n    });\n  }\n\n  onTargetClicked() {\n    this.isLevelActive = false;\n\n    // 计算本关用时\n    const levelTime = this.time.now - this.levelStartTime;\n    this.totalTime += levelTime;\n\n    // 移除计时器\n    if (this.timer) {\n      this.timer.remove();\n    }\n\n    // 成功反馈\n    this.targetGraphics.clear();\n    this.targetGraphics.fillStyle(0x00ff00, 1);\n    const pos = this.targetGraphics.x || 400;\n    this.targetGraphics.fillCircle(\n      this.currentLevel === 1 ? 400 : \n      this.currentLevel === 2 ? 300 :\n      this.currentLevel === 3 ? 500 :\n      this.currentLevel === 4 ? 350 :\n      this.currentLevel === 5 ? 450 :\n      this.currentLevel === 6 ? 400 :\n      this.currentLevel === 7 ? 250 : 550,\n      this.currentLevel === 1 ? 350 :\n      this.currentLevel === 2 ? 400 :\n      this.currentLevel === 3 ? 400 :\n      this.currentLevel === 4 ? 450 :\n      this.currentLevel === 5 ? 450 :\n      this.currentLevel === 6 ? 500 :\n      this.currentLevel === 7 ? 350 : 350,\n      40\n    );\n\n    // 检查是否通关\n    if (this.currentLevel >= this.maxLevel) {\n      this.time.delayedCall(300, () => {\n        this.scene.start('WinScene', { totalTime: this.totalTime });\n      });\n    } else {\n      // 进入下一关\n      this.currentLevel++;\n      this.time.delayedCall(300, () => {\n        this.scene.restart();\n      });\n    }\n\n    // 更新状态信号\n    this.registry.set('currentLevel', this.currentLevel);\n    this.registry.set('totalTime', this.totalTime);\n  }\n\n  onTimeOut() {\n    if (!this.isLevelActive) return;\n\n    this.isLevelActive = false;\n    \n    // 失败，进入失败场景\n    this.scene.start('LoseScene', { \n      level: this.currentLevel,\n      totalTime: this.totalTime\n    });\n  }\n\n  update() {\n    if (this.isLevelActive && this.timer) {\n      // 更新倒计时显示\n      const remaining = this.levelTimeLimit - this.timer.getElapsed();\n      const remainingSeconds = Math.max(0, remaining / 1000);\n      this.timerText.setText(`剩余时间: ${remainingSeconds.toFixed(2)}s`);\n\n      // 时间紧张时变红\n      if (remainingSeconds < 0.3) {\n        this.timerText.setColor('#ff0000');\n      } else if (remainingSeconds < 0.5) {\n        this.timerText.setColor('#ff6600');\n      } else {\n        this.timerText.setColor('#ffff00');\n      }\n\n      // 更新总用时显示\n      const currentTotal = this.totalTime + (this.time.now - this.levelStartTime);\n      this.totalTimeText.setText(`总用时: ${(currentTotal / 1000).toFixed(2)}s`);\n    }\n  }\n}\n\n// 胜利场景\nclass WinScene extends Phaser.Scene {\n  constructor() {\n    super('WinScene');\n  }\n\n  preload() {}\n\n  create(data) {\n    const totalTime = data.totalTime || 0;\n\n    // 背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x004400, 1);\n    bg.fillRect(0, 0, 800, 600);\n\n    // 胜利文本\n    this.add.text(400, 200, '恭喜通关！', {\n      fontSize: '48px',\n      color: '#00ff00',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 总用时\n    this.add.text(400, 280, `总用时: ${(totalTime / 1000).toFixed(2)} 秒`, {\n      fontSize: '36px',\n      color: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 评价\n    let rating = '';\n    const seconds = totalTime / 1000;\n    if (seconds < 4) {\n      rating = '神速！S 级';\n    } else if (seconds < 5) {\n      rating = '优秀！A 级';\n    } else if (seconds < 6) {\n      rating = '良好！B 级';\n    } else {\n      rating = '通过！C 级';\n    }\n\n    this.add.text(400, 350, rating, {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 重新开始按钮\n    const restartButton = this.add.graphics();\n    restartButton.fillStyle(0x0066ff, 1);\n    restartButton.fillRoundedRect(300, 450, 200, 60, 10);\n    restartButton.lineStyle(3, 0xffffff, 1);\n    restartButton.strokeRoundedRect(300, 450, 200, 60, 10);\n    restartButton.setInteractive(\n      new Phaser.Geom.Rectangle(300, 450, 200, 60),\n      Phaser.Geom.Rectangle.Contains\n    );\n\n    this.add.text(400, 480, '重新开始', {\n      fontSize: '28px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    restartButton.on('pointerdown', () => {\n      this.scene.start('GameScene', { restart: true });\n    });\n\n    // 状态信号\n    this.registry.set('gameState', 'win');\n    this.registry.set('finalTime', totalTime);\n  }\n}\n\n// 失败场景\nclass LoseScene extends Phaser.Scene {\n  constructor() {\n    super('LoseScene');\n  }\n\n  preload() {}\n\n  create(data) {\n    const level = data.level || 1;\n    const totalTime = data.totalTime || 0;\n\n    // 背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x440000, 1);\n    bg.fillRect(0, 0, 800, 600);\n\n    // 失败文本\n    this.add.text(400, 200, '挑战失败！', {\n      fontSize: '48px',\n      color: '#ff0000',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 失败关卡\n    this.add.text(400, 280, `失败于第 ${level} 关`, {\n      fontSize: '32px',\n      color: '#ffaa00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 提示\n    this.add.text(400, 340, '超时了！请在1秒内点击目标', {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 重试按钮\n    const retryButton = this.add.graphics();\n    retryButton.fillStyle(0xff6600, 1);\n    retryButton.fillRoundedRect(300, 420, 200, 60, 10);\n    retryButton.lineStyle(3, 0xffffff, 1);\n    retryButton.strokeRoundedRect(300, 420, 200, 60, 10);\n    retryButton.setInteractive(\n      new Phaser.Geom.Rectangle(300, 420, 200, 60),\n      Phaser.Geom.Rectangle.Contains\n    );\n\n    this.add.text(400, 450, '重试', {\n      fontSize: '28px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    retryButton.on('pointerdown', () => {\n      this.scene.start('GameScene', { restart: true });\n    });\n\n    // 状态信号\n    this.registry.set('gameState', 'lose');\n    this.registry.set('failedLevel', level);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001813_v2", "prompt_id": "seed_001813", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.37}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：灰色敌人从上方以 120 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，灰色敌人从上方以120速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（灰色方块）的纹理\n3. 创建玩家精灵，设置键盘控制（左右方向键）\n4. 创建敌人组，定时从顶部随机位置生成敌人，设置下落速度120\n5. 添加碰撞检测，碰撞时显示游戏结束文本并停止游戏\n6. 在 update 中处理玩家移动和清理超出屏幕的敌人\n7. 添加得分系统，根据存活时间计分\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.enemies = null;\n    this.cursors = null;\n    this.gameOver = false;\n    this.score = 0;\n    this.scoreText = null;\n    this.gameOverText = null;\n    this.enemyTimer = null;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（灰色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x808080, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每1秒生成一个）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 创建得分文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 创建游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 添加重新开始提示文本\n    this.restartText = this.add.text(400, 370, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 添加空格键重启功能\n    this.input.keyboard.on('keydown-SPACE', () => {\n      if (this.gameOver) {\n        this.scene.restart();\n      }\n    });\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 更新得分（基于存活时间）\n    this.score += delta / 100;\n    this.scoreText.setText('Score: ' + Math.floor(this.score));\n\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 620) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 在顶部随机位置生成敌人\n    const x = Phaser.Math.Between(30, 770);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    // 设置敌人下落速度为120\n    enemy.setVelocityY(120);\n    enemy.body.setSize(30, 30);\n  }\n\n  hitEnemy(player, enemy) {\n    // 游戏结束\n    this.gameOver = true;\n\n    // 停止物理系统\n    this.physics.pause();\n\n    // 停止敌人生成\n    if (this.enemyTimer) {\n      this.enemyTimer.remove();\n    }\n\n    // 玩家变红\n    player.setTint(0xff0000);\n\n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000909_v3", "prompt_id": "seed_000909", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的紫色椭圆，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现可拖拽的紫色椭圆，拖拽时变色，松手后回到初始位置\nAPI: Graphics.fillEllipse, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制紫色椭圆并生成纹理\n2. 创建 Sprite 并设置为可交互和可拖拽\n3. 监听 dragstart 事件改变颜色为亮紫色\n4. 监听 drag 事件更新椭圆位置\n5. 监听 dragend 事件恢复原始颜色和位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建紫色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1);\n  graphics.fillEllipse(50, 40, 100, 80);\n  graphics.generateTexture('ellipse_purple', 100, 80);\n  graphics.destroy();\n\n  // 创建亮紫色椭圆纹理（拖拽时使用）\n  const graphicsDrag = this.add.graphics();\n  graphicsDrag.fillStyle(0xcc99ff, 1);\n  graphicsDrag.fillEllipse(50, 40, 100, 80);\n  graphicsDrag.generateTexture('ellipse_light', 100, 80);\n  graphicsDrag.destroy();\n}\n\nfunction create() {\n  // 初始位置\n  const initialX = 400;\n  const initialY = 300;\n\n  // 创建椭圆精灵\n  const ellipse = this.add.sprite(initialX, initialY, 'ellipse_purple');\n\n  // 设置为可交互和可拖拽\n  ellipse.setInteractive({ draggable: true });\n\n  // 添加提示文本\n  const text = this.add.text(400, 50, '拖拽椭圆试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n\n  // 拖拽开始事件 - 改变颜色\n  ellipse.on('dragstart', (pointer) => {\n    ellipse.setTexture('ellipse_light');\n  });\n\n  // 拖拽中事件 - 更新位置\n  ellipse.on('drag', (pointer, dragX, dragY) => {\n    ellipse.x = dragX;\n    ellipse.y = dragY;\n  });\n\n  // 拖拽结束事件 - 恢复颜色和位置\n  ellipse.on('dragend', (pointer) => {\n    ellipse.setTexture('ellipse_purple');\n    \n    // 使用 tween 平滑回到初始位置\n    this.tweens.add({\n      targets: ellipse,\n      x: initialX,\n      y: initialY,\n      duration: 300,\n      ease: 'Back.easeOut'\n    });\n  });\n\n  // 添加鼠标悬停效果\n  ellipse.on('pointerover', () => {\n    ellipse.setScale(1.1);\n  });\n\n  ellipse.on('pointerout', () => {\n    ellipse.setScale(1);\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000622_v2", "prompt_id": "seed_000622", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：15 个椭圆随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色收集15个随机分布的椭圆，收集完成后显示通关文字\nAPI: Phaser.Physics.Arcade.Factory#sprite, Phaser.Physics.Arcade.Factory#group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World#overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 使用 Graphics 创建玩家和椭圆的纹理\n2. 创建物理系统中的玩家精灵，支持键盘控制移动\n3. 创建物理组包含15个随机位置的椭圆\n4. 使用 overlap 检测玩家与椭圆的碰撞，碰撞后移除椭圆并增加计数\n5. 当收集数量达到15时显示\"恭喜通关\"文字\n[/PLAN]\n\n```javascript\nclass CollectionGame extends Phaser.Scene {\n  constructor() {\n    super('CollectionGame');\n    this.collectedCount = 0;\n    this.totalItems = 15;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色圆形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillCircle(20, 20, 20);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建椭圆纹理（黄色椭圆）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillEllipse(15, 10, 30, 20);\n    itemGraphics.lineStyle(2, 0xff9900, 1);\n    itemGraphics.strokeEllipse(15, 10, 30, 20);\n    itemGraphics.generateTexture('item', 30, 20);\n    itemGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setCircle(20);\n\n    // 创建椭圆收集物组\n    this.items = this.physics.add.group();\n    \n    // 随机分布15个椭圆\n    for (let i = 0; i < this.totalItems; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const item = this.items.create(x, y, 'item');\n      item.setScale(1.5);\n      item.body.setSize(30, 20);\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.items,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建计数文本\n    this.scoreText = this.add.text(16, 16, `收集: 0/${this.totalItems}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.scoreText.setDepth(1);\n\n    // 创建控制提示\n    this.add.text(16, 560, '使用方向键移动', {\n      fontSize: '18px',\n      fill: '#cccccc'\n    });\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '64px',\n      fill: '#00ff00',\n      stroke: '#000000',\n      strokeThickness: 6,\n      fontStyle: 'bold'\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n    this.winText.setDepth(2);\n  }\n\n  update() {\n    // 玩家移动控制\n    const speed = 200;\n    \n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 归一化对角线速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(speed);\n    }\n  }\n\n  collectItem(player, item) {\n    // 移除收集到的椭圆\n    item.destroy();\n    \n    // 增加计数\n    this.collectedCount++;\n    \n    // 更新文本\n    this.scoreText.setText(`收集: ${this.collectedCount}/${this.totalItems}`);\n    \n    // 检查是否通关\n    if (this.collectedCount >= this.totalItems) {\n      this.winGame();\n    }\n  }\n\n  winGame() {\n    // 停止玩家移动\n    this.player.setVelocity(0);\n    this.physics.pause();\n    \n    // 显示通关文本\n    this.winText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.winText,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectionGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001501_v2", "prompt_id": "seed_001501", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现小地图：主相机跟随玩家（速度 300），右上角显示一个缩小的全局视角小地图。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现主相机跟随玩家移动，右上角显示缩小的全局视角小地图\nAPI: Phaser.Cameras.Scene2D.Camera, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard\nSTEPS:\n1. 创建大地图场景（1600x1200），使用 Graphics 绘制地图元素（边界、障碍物、目标点）\n2. 创建玩家精灵，配置物理属性和键盘控制（速度 300）\n3. 设置主相机跟随玩家，限制在地图边界内\n4. 创建小地图相机，固定在右上角，缩放比例显示全局视图\n5. 添加状态信号（玩家位置、移动距离）用于验证\n[/PLAN]\n\n```javascript\nclass MinimapScene extends Phaser.Scene {\n  constructor() {\n    super('MinimapScene');\n    this.player = null;\n    this.cursors = null;\n    this.miniCam = null;\n    this.totalDistance = 0; // 状态信号：总移动距离\n    this.lastPosition = { x: 0, y: 0 };\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 世界边界\n    const WORLD_WIDTH = 1600;\n    const WORLD_HEIGHT = 1200;\n    this.physics.world.setBounds(0, 0, WORLD_WIDTH, WORLD_HEIGHT);\n\n    // 绘制地图背景\n    this.createMapBackground(WORLD_WIDTH, WORLD_HEIGHT);\n\n    // 创建地图元素（障碍物、目标点）\n    this.createMapElements();\n\n    // 创建玩家\n    this.createPlayer();\n\n    // 配置主相机\n    this.setupMainCamera(WORLD_WIDTH, WORLD_HEIGHT);\n\n    // 创建小地图相机\n    this.createMinimap(WORLD_WIDTH, WORLD_HEIGHT);\n\n    // 设置键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加调试信息显示\n    this.createDebugText();\n\n    // 初始化位置记录\n    this.lastPosition = { x: this.player.x, y: this.player.y };\n  }\n\n  createMapBackground(width, height) {\n    const graphics = this.add.graphics();\n    \n    // 绘制草地背景（绿色网格）\n    graphics.fillStyle(0x2d5016, 1);\n    graphics.fillRect(0, 0, width, height);\n    \n    // 绘制网格线\n    graphics.lineStyle(1, 0x3d6026, 0.5);\n    for (let x = 0; x < width; x += 100) {\n      graphics.lineBetween(x, 0, x, height);\n    }\n    for (let y = 0; y < height; y += 100) {\n      graphics.lineBetween(0, y, width, y);\n    }\n\n    // 绘制边界\n    graphics.lineStyle(4, 0xff0000, 1);\n    graphics.strokeRect(2, 2, width - 4, height - 4);\n  }\n\n  createMapElements() {\n    // 创建障碍物（树木/岩石）\n    const obstacles = [\n      { x: 300, y: 300, size: 60, color: 0x8b4513 },\n      { x: 800, y: 400, size: 80, color: 0x654321 },\n      { x: 1200, y: 600, size: 70, color: 0x8b4513 },\n      { x: 500, y: 800, size: 50, color: 0x654321 },\n      { x: 1400, y: 300, size: 65, color: 0x8b4513 },\n      { x: 200, y: 1000, size: 55, color: 0x654321 }\n    ];\n\n    obstacles.forEach(obs => {\n      const graphics = this.add.graphics();\n      graphics.fillStyle(obs.color, 1);\n      graphics.fillCircle(obs.x, obs.y, obs.size);\n      \n      // 添加阴影效果\n      graphics.fillStyle(0x000000, 0.3);\n      graphics.fillEllipse(obs.x + 10, obs.y + obs.size - 5, obs.size * 0.8, obs.size * 0.3);\n    });\n\n    // 创建目标点（金币）\n    const targets = [\n      { x: 400, y: 200 },\n      { x: 1300, y: 500 },\n      { x: 700, y: 900 },\n      { x: 1500, y: 1100 }\n    ];\n\n    targets.forEach(target => {\n      const graphics = this.add.graphics();\n      graphics.fillStyle(0xffff00, 1);\n      graphics.fillCircle(target.x, target.y, 20);\n      graphics.lineStyle(3, 0xffa500, 1);\n      graphics.strokeCircle(target.x, target.y, 20);\n      \n      // 添加闪烁效果\n      this.tweens.add({\n        targets: graphics,\n        alpha: 0.5,\n        duration: 800,\n        yoyo: true,\n        repeat: -1\n      });\n    });\n  }\n\n  createPlayer() {\n    // 程序化生成玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0000ff, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(12, 12, 4); // 左眼\n    graphics.fillCircle(20, 12, 4); // 右眼\n    graphics.lineStyle(2, 0xffffff, 1);\n    graphics.arc(16, 16, 8, 0.2, Math.PI - 0.2); // 笑脸\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(200, 200, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDrag(800, 800); // 添加拖拽效果使移动更平滑\n    this.player.setMaxVelocity(300, 300);\n  }\n\n  setupMainCamera(worldWidth, worldHeight) {\n    const mainCamera = this.cameras.main;\n    mainCamera.setBounds(0, 0, worldWidth, worldHeight);\n    mainCamera.startFollow(this.player, true, 0.1, 0.1); // 平滑跟随\n    mainCamera.setZoom(1);\n  }\n\n  createMinimap(worldWidth, worldHeight) {\n    // 计算小地图尺寸和位置\n    const minimapWidth = 200;\n    const minimapHeight = 150;\n    const padding = 10;\n    const x = this.cameras.main.width - minimapWidth - padding;\n    const y = padding;\n\n    // 创建小地图相机\n    this.miniCam = this.cameras.add(x, y, minimapWidth, minimapHeight);\n    this.miniCam.setZoom(Math.min(minimapWidth / worldWidth, minimapHeight / worldHeight));\n    this.miniCam.setBounds(0, 0, worldWidth, worldHeight);\n    this.miniCam.setBackgroundColor(0x000000);\n    \n    // 小地图显示全局视图（不跟随）\n    this.miniCam.scrollX = (worldWidth - minimapWidth / this.miniCam.zoom) / 2;\n    this.miniCam.scrollY = (worldHeight - minimapHeight / this.miniCam.zoom) / 2;\n\n    // 绘制小地图边框（使用固定相机）\n    const border = this.add.graphics();\n    border.lineStyle(3, 0xffffff, 1);\n    border.strokeRect(x - 2, y - 2, minimapWidth + 4, minimapHeight + 4);\n    border.fillStyle(0x000000, 0.5);\n    border.fillRect(x - 2, y - 2, minimapWidth + 4, minimapHeight + 4);\n    border.setScrollFactor(0); // 固定在屏幕上\n    border.setDepth(1000);\n\n    // 在小地图上绘制玩家指示器\n    this.createPlayerIndicator();\n  }\n\n  createPlayerIndicator() {\n    // 创建小地图上的玩家指示器\n    const indicator = this.add.graphics();\n    indicator.fillStyle(0xff0000, 1);\n    indicator.fillCircle(0, 0, 8);\n    indicator.lineStyle(2, 0xffffff, 1);\n    indicator.strokeCircle(0, 0, 8);\n    indicator.setDepth(1001);\n    \n    this.playerIndicator = indicator;\n  }\n\n  createDebugText() {\n    // 创建调试信息文本\n    this.debugText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.debugText.setScrollFactor(0);\n    this.debugText.setDepth(1000);\n  }\n\n  update(time, delta) {\n    if (!this.player || !this.cursors) return;\n\n    // 玩家移动控制\n    const speed = 300;\n    let velocityX = 0;\n    let velocityY = 0;\n\n    if (this.cursors.left.isDown) {\n      velocityX = -speed;\n    } else if (this.cursors.right.isDown) {\n      velocityX = speed;\n    }\n\n    if (this.cursors.up.isDown) {\n      velocityY = -speed;\n    } else if (this.cursors.down.isDown) {\n      velocityY = speed;\n    }\n\n    // 对角线移动速度归一化\n    if (velocityX !== 0 && velocityY !== 0) {\n      const factor = Math.sqrt(2) / 2;\n      velocityX *= factor;\n      velocityY *= factor;\n    }\n\n    this.player.setVelocity(velocityX, velocityY);\n\n    // 计算移动距离\n    const dx = this.player.x - this.lastPosition.x;\n    const dy = this.player.y - this.lastPosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    this.totalDistance += distance;\n    this.lastPosition = { x: this.player.x, y: this.player.y };\n\n    // 更新玩家指示器位置\n    if (this.playerIndicator) {\n      this.playerIndicator.x = this.player.x;\n      this.playerIndicator.y = this.player.y;\n    }\n\n    // 更新调试信息\n    this.debugText.setText([\n      `Player: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `Distance: ${Math.round(this.totalDistance)}`,\n      `Velocity: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`,\n      `Use Arrow Keys to Move`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: MinimapScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001838_v3", "prompt_id": "seed_001838", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Camera", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个橙色物体以 200 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 10个橙色物体以200速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity, setCollideWorldBounds\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成橙色圆形纹理\n3. 创建物理组，添加 10 个橙色物体\n4. 为每个物体设置随机速度（200）和完全反弹\n5. 设置物体间碰撞检测和世界边界碰撞\n6. 添加状态变量记录碰撞次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff8800, 1); // 橙色\n    graphics.fillCircle(20, 20, 20); // 半径20的圆\n    graphics.generateTexture('orangeCircle', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.orangeGroup = this.physics.add.group({\n      defaultKey: 'orangeCircle',\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 创建10个橙色物体\n    for (let i = 0; i < 10; i++) {\n      // 随机位置（避免边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      const orangeObj = this.orangeGroup.create(x, y, 'orangeCircle');\n      \n      // 设置随机方向的速度，总速度为200\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 200;\n      const velocityY = Math.sin(angle) * 200;\n      \n      orangeObj.setVelocity(velocityX, velocityY);\n      orangeObj.setBounce(1, 1); // 完全反弹\n      orangeObj.setCollideWorldBounds(true);\n      orangeObj.setCircle(20); // 设置圆形碰撞体\n    }\n\n    // 设置物体间的碰撞检测\n    this.physics.add.collider(\n      this.orangeGroup,\n      this.orangeGroup,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 显示碰撞计数（用于验证）\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n  }\n\n  handleCollision(obj1, obj2) {\n    // 记录碰撞次数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保物体速度保持在200左右（由于浮点误差可能会有微小变化）\n    this.orangeGroup.children.entries.forEach(obj => {\n      const currentSpeed = Math.sqrt(obj.body.velocity.x ** 2 + obj.body.velocity.y ** 2);\n      \n      // 如果速度偏离200太多，重新标准化\n      if (Math.abs(currentSpeed - 200) > 5) {\n        const angle = Math.atan2(obj.body.velocity.y, obj.body.velocity.x);\n        obj.setVelocity(Math.cos(angle) * 200, Math.sin(angle) * 200);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000937_v3", "prompt_id": "seed_000937", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：3 个蓝色小球以 80 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 3个蓝色小球以80速度在封闭空间内移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.sprite, Physics.add.collider, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 配置 Arcade 物理系统，设置世界边界\n2. 使用 Graphics 创建蓝色圆形纹理\n3. 创建 3 个物理精灵，设置随机初始速度（速度为80）\n4. 设置边界碰撞反弹系数为1（完全弹性）\n5. 添加小球之间的碰撞检测，反弹系数为1\n6. 添加碰撞计数器作为可验证状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 碰撞计数器（可验证状态）\n    this.ballCount = 3; // 小球数量（可验证状态）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    // 创建蓝色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0066ff, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('blueBall', 32, 32);\n    graphics.destroy();\n\n    // 创建小球组\n    this.balls = this.physics.add.group();\n\n    // 创建3个小球\n    for (let i = 0; i < this.ballCount; i++) {\n      const x = Phaser.Math.Between(100, width - 100);\n      const y = Phaser.Math.Between(100, height - 100);\n      \n      const ball = this.physics.add.sprite(x, y, 'blueBall');\n      \n      // 设置完全弹性碰撞\n      ball.setBounce(1, 1);\n      \n      // 设置与世界边界碰撞\n      ball.setCollideWorldBounds(true);\n      \n      // 设置随机方向的速度，速度大小为80\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 80;\n      const velocityY = Math.sin(angle) * 80;\n      ball.setVelocity(velocityX, velocityY);\n      \n      // 添加到组\n      this.balls.add(ball);\n    }\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 绘制边界提示\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0xffffff, 0.5);\n    borderGraphics.strokeRect(0, 0, width, height);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞计数\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    // 更新状态显示\n    let statusInfo = `Ball Count: ${this.ballCount}\\n`;\n    statusInfo += `Collisions: ${this.collisionCount}\\n`;\n    \n    // 显示每个小球的速度（验证速度保持在80左右）\n    this.balls.children.entries.forEach((ball, index) => {\n      const speed = Math.sqrt(\n        ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2\n      ).toFixed(1);\n      statusInfo += `Ball ${index + 1} Speed: ${speed}\\n`;\n    });\n    \n    this.statusText.setText(statusInfo);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001212_v1", "prompt_id": "seed_001212", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.4042857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现蓝色血条 UI：显示 3 格生命值，按方向键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现蓝色血条 UI，显示 3 格生命值，按方向键扣血，血量为 0 时显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化游戏配置\n2. 在 create 中使用 Graphics 绘制 3 格蓝色血条\n3. 监听方向键输入事件，每次按键扣除 1 格血量\n4. 更新血条显示，根据当前血量重绘\n5. 当血量为 0 时显示 Game Over 文本并停止输入\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 3; // 当前生命值\n    this.maxHealth = 3; // 最大生命值\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, 'Press Arrow Keys to Take Damage', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.healthBarGraphics = this.add.graphics();\n    this.drawHealthBar();\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold',\n      stroke: '#000000',\n      strokeThickness: 6\n    }).setOrigin(0.5).setVisible(false);\n\n    // 创建重启提示文本（初始隐藏）\n    this.restartText = this.add.text(400, 380, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5).setVisible(false);\n\n    // 创建当前血量显示文本\n    this.healthText = this.add.text(400, 250, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 监听方向键输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加空格键用于重启\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 标记按键是否已按下（防止连续触发）\n    this.keyPressed = {\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n  }\n\n  update() {\n    if (this.isGameOver) {\n      // 游戏结束后检测空格键重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.restartGame();\n      }\n      return;\n    }\n\n    // 检测方向键按下（使用 JustDown 避免连续触发）\n    if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) {\n      this.takeDamage();\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) {\n      this.takeDamage();\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) {\n      this.takeDamage();\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) {\n      this.takeDamage();\n    }\n  }\n\n  // 绘制血条\n  drawHealthBar() {\n    this.healthBarGraphics.clear();\n\n    const barWidth = 80; // 每格血条宽度\n    const barHeight = 40; // 血条高度\n    const barSpacing = 10; // 血条间距\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing) - barSpacing) / 2; // 居中起始位置\n    const startY = 150;\n\n    // 绘制每格血条\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + barSpacing);\n      \n      // 绘制血条背景（深灰色边框）\n      this.healthBarGraphics.lineStyle(3, 0x333333, 1);\n      this.healthBarGraphics.strokeRect(x, startY, barWidth, barHeight);\n\n      // 根据当前血量决定是否填充蓝色\n      if (i < this.health) {\n        // 有血量：填充蓝色\n        this.healthBarGraphics.fillStyle(0x0088ff, 1);\n        this.healthBarGraphics.fillRect(x + 3, startY + 3, barWidth - 6, barHeight - 6);\n      } else {\n        // 无血量：填充深色\n        this.healthBarGraphics.fillStyle(0x222222, 1);\n        this.healthBarGraphics.fillRect(x + 3, startY + 3, barWidth - 6, barHeight - 6);\n      }\n    }\n  }\n\n  // 扣血逻辑\n  takeDamage() {\n    if (this.health > 0) {\n      this.health--;\n      this.drawHealthBar(); // 重绘血条\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n\n      // 添加受伤闪烁效果\n      this.cameras.main.shake(200, 0.005);\n\n      // 检查是否游戏结束\n      if (this.health <= 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  // 触发游戏结束\n  triggerGameOver() {\n    this.isGameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 添加 Game Over 动画效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 屏幕闪烁效果\n    this.cameras.main.flash(500, 255, 0, 0);\n  }\n\n  // 重启游戏\n  restartGame() {\n    this.scene.restart();\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: HealthBarScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001097_v1", "prompt_id": "seed_001097", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 四向重力切换：按不同方向键切换重力方向，重力大小 200，玩家和 10 个物体都受影响。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 四向重力切换游戏，按方向键改变重力方向，玩家和10个物体受影响\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World\nSTEPS:\n1. 创建带物理系统的 Scene，初始重力向下(y:200)\n2. 使用 Graphics 生成玩家和10个物体的纹理\n3. 创建玩家精灵和10个物理物体，随机分布\n4. 监听方向键输入，切换世界重力方向(上下左右)\n5. 添加状态信号记录当前重力方向和切换次数\n[/PLAN]\n\n```javascript\nclass GravityScene extends Phaser.Scene {\n  constructor() {\n    super('GravityScene');\n    this.gravitySwitchCount = 0; // 状态信号：重力切换次数\n    this.currentGravityDirection = 'down'; // 状态信号：当前重力方向\n    this.seed = 12345; // 固定随机种子\n  }\n\n  // 简单的伪随机数生成器（保证确定性）\n  seededRandom() {\n    this.seed = (this.seed * 9301 + 49297) % 233280;\n    return this.seed / 233280;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0099ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建物体纹理（红色圆形）\n    const objectGraphics = this.add.graphics();\n    objectGraphics.fillStyle(0xff3333, 1);\n    objectGraphics.fillCircle(15, 15, 15);\n    objectGraphics.generateTexture('object', 30, 30);\n    objectGraphics.destroy();\n\n    // 创建玩家（中心位置）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0.3);\n\n    // 创建10个物体\n    this.objects = [];\n    for (let i = 0; i < 10; i++) {\n      const x = 100 + this.seededRandom() * 600;\n      const y = 100 + this.seededRandom() * 400;\n      const obj = this.physics.add.sprite(x, y, 'object');\n      obj.setCollideWorldBounds(true);\n      obj.setBounce(0.5);\n      this.objects.push(obj);\n    }\n\n    // 添加物体之间的碰撞\n    this.physics.add.collider(this.player, this.objects);\n    this.physics.add.collider(this.objects, this.objects);\n\n    // 设置初始重力（向下）\n    this.physics.world.gravity.y = 200;\n\n    // 创建方向键监听\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.updateStatusText();\n\n    // 添加提示文本\n    this.add.text(10, 560, 'Use Arrow Keys to change gravity direction', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n  }\n\n  update() {\n    // 检测方向键按下（使用 justDown 避免重复触发）\n    if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) {\n      this.setGravity(0, -200, 'up');\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) {\n      this.setGravity(0, 200, 'down');\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) {\n      this.setGravity(-200, 0, 'left');\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) {\n      this.setGravity(200, 0, 'right');\n    }\n  }\n\n  setGravity(x, y, direction) {\n    // 设置世界重力\n    this.physics.world.gravity.x = x;\n    this.physics.world.gravity.y = y;\n\n    // 更新状态\n    this.currentGravityDirection = direction;\n    this.gravitySwitchCount++;\n\n    // 更新显示\n    this.updateStatusText();\n\n    // 给所有物体一个小的初始速度，让效果更明显\n    this.player.setVelocity(0, 0);\n    this.objects.forEach(obj => {\n      obj.setVelocity(\n        (this.seededRandom() - 0.5) * 50,\n        (this.seededRandom() - 0.5) * 50\n      );\n    });\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Gravity Direction: ${this.currentGravityDirection.toUpperCase()}`,\n      `Switch Count: ${this.gravitySwitchCount}`,\n      `Gravity: (${this.physics.world.gravity.x}, ${this.physics.world.gravity.y})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 初始重力在 create 中设置\n      debug: false\n    }\n  },\n  scene: GravityScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001730_v3", "prompt_id": "seed_001730", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现自动加分系统：每 2.5 秒 score +15，字体大小 80，在屏幕右上角显示分数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现自动加分系统，每2.5秒加15分，在右上角显示80号字体分数\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建 Scene 并初始化 score 变量为 0\n2. 在 create 中使用 this.add.text 在右上角创建分数文本（字体大小80）\n3. 使用 this.time.addEvent 创建定时器，每2500ms触发一次回调\n4. 在回调中 score += 15，并更新文本显示\n5. 设置 loop: true 使定时器循环执行\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet score = 0;\nlet scoreText;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 初始化分数\n  score = 0;\n  \n  // 在右上角创建分数文本\n  // 使用 originX: 1 让文本右对齐，便于固定在右上角\n  scoreText = this.add.text(780, 20, 'Score: 0', {\n    fontSize: '80px',\n    fontFamily: 'Arial',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  });\n  scoreText.setOrigin(1, 0); // 右上角对齐\n  \n  // 创建定时器，每2.5秒（2500毫秒）加15分\n  this.time.addEvent({\n    delay: 2500,           // 延迟时间：2.5秒\n    callback: addScore,    // 回调函数\n    callbackScope: this,   // 回调作用域\n    loop: true            // 循环执行\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 300, 'Auto Score System\\n+15 every 2.5 seconds', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#00ff00',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nfunction addScore() {\n  // 每次调用增加15分\n  score += 15;\n  \n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n  \n  // 添加简单的缩放动画效果\n  this.tweens.add({\n    targets: scoreText,\n    scaleX: 1.1,\n    scaleY: 1.1,\n    duration: 100,\n    yoyo: true,\n    ease: 'Power1'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001157_v2", "prompt_id": "seed_001157", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色敌人追踪：敌人以 300 速度追踪玩家位置，玩家速度 300*1.2 可躲避。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现粉色敌人以300速度追踪玩家，玩家以360速度可躲避\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.ArcadePhysics#moveToObject, Phaser.Input.Keyboard.createCursorKeys\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（粉色圆形）纹理\n3. 在 create 中创建玩家精灵（速度360）和敌人精灵（速度300）\n4. 设置键盘输入控制玩家移动\n5. 在 update 中使用 moveToObject 让敌人追踪玩家\n6. 添加碰撞检测，记录被追上次数作为状态信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerSpeed = 300 * 1.2; // 360\n    this.enemySpeed = 300;\n    this.catchCount = 0; // 状态信号：被追上次数\n    this.escapeTime = 0; // 状态信号：成功躲避时间\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成敌人纹理（粉色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff69b4, 1); // 粉色\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人\n    this.enemy = this.physics.add.sprite(100, 100, 'enemy');\n    this.enemy.setCollideWorldBounds(true);\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加 WASD 控制\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 碰撞检测\n    this.physics.add.overlap(this.player, this.enemy, this.onCatch, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加提示文本\n    this.add.text(400, 550, '使用方向键或 WASD 移动，躲避粉色敌人！', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 更新状态文本\n    this.statusText.setText([\n      `被追上次数: ${this.catchCount}`,\n      `躲避时间: ${(this.escapeTime / 1000).toFixed(1)}s`,\n      `玩家速度: ${this.playerSpeed}`,\n      `敌人速度: ${this.enemySpeed}`\n    ]);\n\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    let moving = false;\n    if (this.cursors.left.isDown || this.keys.a.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n      moving = true;\n    } else if (this.cursors.right.isDown || this.keys.d.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n      moving = true;\n    }\n\n    if (this.cursors.up.isDown || this.keys.w.isDown) {\n      this.player.setVelocityY(-this.playerSpeed);\n      moving = true;\n    } else if (this.cursors.down.isDown || this.keys.s.isDown) {\n      this.player.setVelocityY(this.playerSpeed);\n      moving = true;\n    }\n\n    // 对角线移动时标准化速度\n    if (moving) {\n      this.player.body.velocity.normalize().scale(this.playerSpeed);\n    }\n\n    // 敌人追踪玩家\n    this.physics.moveToObject(this.enemy, this.player, this.enemySpeed);\n\n    // 计算距离，如果没有碰撞则累加躲避时间\n    const distance = Phaser.Math.Distance.Between(\n      this.player.x, this.player.y,\n      this.enemy.x, this.enemy.y\n    );\n\n    if (distance > 40) { // 超过碰撞范围\n      this.escapeTime += delta;\n    }\n  }\n\n  onCatch() {\n    // 被追上时的处理\n    this.catchCount++;\n    \n    // 重置位置\n    this.player.setPosition(\n      Phaser.Math.Between(100, 700),\n      Phaser.Math.Between(100, 500)\n    );\n    this.enemy.setPosition(\n      Phaser.Math.Between(100, 700),\n      Phaser.Math.Between(100, 500)\n    );\n\n    // 短暂闪烁效果\n    this.player.setAlpha(0.5);\n    this.time.delayedCall(200, () => {\n      this.player.setAlpha(1);\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001280_v2", "prompt_id": "seed_001280", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Arcade 物理精灵并应用三角形纹理\n3. 设置精灵速度为160，启用世界边界碰撞和反弹\n4. 配置物理系统使精灵在碰到边界时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心对齐）\n  // 三角形顶点：上(0, -20), 左下(-20, 20), 右下(20, 20)\n  graphics.fillTriangle(\n    0, -20,    // 顶点\n    -20, 20,   // 左下\n    20, 20     // 右下\n  );\n  \n  // 生成纹理（40x40 像素，包含三角形）\n  graphics.generateTexture('triangle', 40, 40);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（160像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 160;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 160;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 确保三角形不会因为摩擦而减速\n  triangle.body.setDamping(false);\n  \n  // 可选：让三角形旋转以增强视觉效果\n  triangle.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000060_v1", "prompt_id": "seed_000060", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个蓝色六边形移动，移动速度为 360，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制蓝色六边形在画布边界内移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.createCursorKeys, Graphics.fillStyle, Graphics.fillCircle, Graphics.generateTexture\nSTEPS:\n1. 创建 Scene 配置，设置画布大小为 800x600\n2. 在 create 中使用 Graphics 绘制蓝色六边形并生成纹理\n3. 创建 Sprite 对象使用该纹理，设置初始位置在画布中心\n4. 使用 createCursorKeys 创建方向键输入\n5. 在 update 中检测方向键状态，更新六边形位置（速度 360 * delta）\n6. 限制六边形位置在画布边界内（考虑六边形半径）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet hexagon;\nlet cursors;\nconst SPEED = 360; // 每秒移动像素数\nconst HEX_RADIUS = 30; // 六边形半径\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色六边形\n  const graphics = this.add.graphics();\n  \n  // 绘制六边形\n  graphics.fillStyle(0x0066ff, 1); // 蓝色\n  graphics.beginPath();\n  \n  // 六边形的六个顶点（中心在 HEX_RADIUS, HEX_RADIUS）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶点开始\n    const x = HEX_RADIUS + HEX_RADIUS * Math.cos(angle);\n    const y = HEX_RADIUS + HEX_RADIUS * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', HEX_RADIUS * 2, HEX_RADIUS * 2);\n  graphics.destroy();\n  \n  // 创建六边形精灵，放置在画布中心\n  hexagon = this.add.sprite(\n    config.width / 2,\n    config.height / 2,\n    'hexagon'\n  );\n  \n  // 创建方向键输入\n  cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 检测方向键并移动六边形\n  if (cursors.left.isDown) {\n    hexagon.x -= moveDistance;\n  }\n  if (cursors.right.isDown) {\n    hexagon.x += moveDistance;\n  }\n  if (cursors.up.isDown) {\n    hexagon.y -= moveDistance;\n  }\n  if (cursors.down.isDown) {\n    hexagon.y += moveDistance;\n  }\n  \n  // 限制在画布边界内\n  const minX = HEX_RADIUS;\n  const maxX = config.width - HEX_RADIUS;\n  const minY = HEX_RADIUS;\n  const maxY = config.height - HEX_RADIUS;\n  \n  hexagon.x = Phaser.Math.Clamp(hexagon.x, minX, maxX);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, minY, maxY);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000298_v2", "prompt_id": "seed_000298", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 240。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 橙色玩家在边界循环出现，移动速度240\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Graphics.fillRect, Sprite.setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制橙色方块并生成纹理作为玩家\n3. 创建物理精灵，设置碰撞边界\n4. 监听键盘输入（WASD/方向键）控制玩家移动\n5. 在 update 中检测玩家位置，实现边界循环效果\n6. 添加状态变量记录玩家穿越边界次数作为验证信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nlet wasd;\nlet crossBorderCount = 0; // 状态信号：穿越边界次数\nlet statusText;\n\nconst PLAYER_SPEED = 240;\nconst PLAYER_SIZE = 32;\n\nfunction preload() {\n  // 使用 Graphics 创建橙色玩家纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8C00, 1); // 橙色\n  graphics.fillRect(0, 0, PLAYER_SIZE, PLAYER_SIZE);\n  graphics.generateTexture('player', PLAYER_SIZE, PLAYER_SIZE);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 关闭世界边界碰撞，允许移出边界\n  \n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  wasd = this.input.keyboard.addKeys({\n    up: Phaser.Input.Keyboard.KeyCodes.W,\n    down: Phaser.Input.Keyboard.KeyCodes.S,\n    left: Phaser.Input.Keyboard.KeyCodes.A,\n    right: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 显示状态信息\n  statusText = this.add.text(10, 10, 'Border Crosses: 0', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys or WASD to move', {\n    fontSize: '16px',\n    fill: '#aaaaaa'\n  }).setOrigin(0.5);\n  \n  // 绘制边界参考线\n  const borderGraphics = this.add.graphics();\n  borderGraphics.lineStyle(2, 0x00ff00, 0.3);\n  borderGraphics.strokeRect(0, 0, 800, 600);\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0);\n  \n  // 处理键盘输入\n  if (cursors.left.isDown || wasd.left.isDown) {\n    player.setVelocityX(-PLAYER_SPEED);\n  } else if (cursors.right.isDown || wasd.right.isDown) {\n    player.setVelocityX(PLAYER_SPEED);\n  }\n  \n  if (cursors.up.isDown || wasd.up.isDown) {\n    player.setVelocityY(-PLAYER_SPEED);\n  } else if (cursors.down.isDown || wasd.down.isDown) {\n    player.setVelocityY(PLAYER_SPEED);\n  }\n  \n  // 边界循环检测\n  const halfSize = PLAYER_SIZE / 2;\n  let crossed = false;\n  \n  // 左右边界循环\n  if (player.x < -halfSize) {\n    player.x = config.width + halfSize;\n    crossed = true;\n  } else if (player.x > config.width + halfSize) {\n    player.x = -halfSize;\n    crossed = true;\n  }\n  \n  // 上下边界循环\n  if (player.y < -halfSize) {\n    player.y = config.height + halfSize;\n    crossed = true;\n  } else if (player.y > config.height + halfSize) {\n    player.y = -halfSize;\n    crossed = true;\n  }\n  \n  // 更新穿越计数\n  if (crossed) {\n    crossBorderCount++;\n    statusText.setText(`Border Crosses: ${crossBorderCount}`);\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001448_v2", "prompt_id": "seed_001448", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现白色移动平台：平台以 300 速度水平往返移动，玩家可站在上面并跟随移动，重力 300。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现白色移动平台，以300速度水平往返移动，玩家可站在上面并跟随移动，重力300\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard\nSTEPS:\n1. 配置物理系统，设置重力为300\n2. 创建玩家精灵和移动平台精灵，使用Graphics生成纯色纹理\n3. 为平台添加水平往返移动逻辑（速度300，碰到边界反向）\n4. 设置玩家与平台的碰撞检测，启用平台的immovable属性\n5. 添加键盘控制让玩家可以左右移动和跳跃\n6. 在update中更新平台位置并检测边界反弹\n7. 添加状态信号变量记录玩家位置和平台状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    // 状态信号变量\n    this.playerX = 0;\n    this.playerY = 0;\n    this.platformX = 0;\n    this.platformDirection = 1; // 1=右移, -1=左移\n    this.isPlayerOnPlatform = false;\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建平台纹理（白色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0xffffff, 1);\n    platformGraphics.fillRect(0, 0, 150, 20);\n    platformGraphics.generateTexture('platform', 150, 20);\n    platformGraphics.destroy();\n\n    // 创建地面纹理（灰色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x666666, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 创建地面\n    this.ground = this.physics.add.sprite(400, 580, 'ground');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(200, 350, 'platform');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.body.setVelocityX(300); // 初始速度向右300\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 200, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.platform);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加说明文字\n    this.add.text(16, 16, 'Arrow Keys: Move | Up: Jump', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加状态显示\n    this.statusText = this.add.text(16, 40, '', {\n      fontSize: '14px',\n      fill: '#00ff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新平台移动逻辑\n    this.updatePlatformMovement();\n\n    // 玩家控制\n    this.updatePlayerControl();\n\n    // 更新状态信号\n    this.updateStatus();\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Player: (${Math.floor(this.playerX)}, ${Math.floor(this.playerY)})`,\n      `Platform: ${Math.floor(this.platformX)} | Dir: ${this.platformDirection > 0 ? 'Right' : 'Left'}`,\n      `On Platform: ${this.isPlayerOnPlatform}`\n    ]);\n  }\n\n  updatePlatformMovement() {\n    // 平台往返移动逻辑\n    const platformLeft = this.platform.x - this.platform.width / 2;\n    const platformRight = this.platform.x + this.platform.width / 2;\n\n    // 检测边界并反向\n    if (platformRight >= 800 && this.platform.body.velocity.x > 0) {\n      this.platform.body.setVelocityX(-300);\n      this.platformDirection = -1;\n    } else if (platformLeft <= 0 && this.platform.body.velocity.x < 0) {\n      this.platform.body.setVelocityX(300);\n      this.platformDirection = 1;\n    }\n\n    // 更新平台位置状态\n    this.platformX = this.platform.x;\n  }\n\n  updatePlayerControl() {\n    // 检测玩家是否在平台上\n    this.isPlayerOnPlatform = this.physics.world.overlap(\n      this.player, \n      this.platform\n    ) && this.player.body.touching.down;\n\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      // 如果在平台上，跟随平台移动\n      if (this.isPlayerOnPlatform) {\n        this.player.setVelocityX(this.platform.body.velocity.x);\n      } else {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n\n  updateStatus() {\n    // 更新状态信号变量\n    this.playerX = this.player.x;\n    this.playerY = this.player.y;\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001996_v3", "prompt_id": "seed_001996", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色移动平台：平台以 80 速度水平往返移动，玩家可站在上面并跟随移动，重力 600。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现粉色移动平台，以80速度水平往返移动，玩家可站在上面并跟随移动，重力600\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard\nSTEPS:\n1. 创建物理系统配置，设置重力为600\n2. 使用Graphics绘制粉色平台和绿色玩家纹理\n3. 创建移动平台精灵，设置immovable和velocityX为80\n4. 创建玩家精灵，添加碰撞器使其能站在平台上\n5. 在update中检测平台边界并反转速度实现往返移动\n6. 添加键盘控制让玩家可以左右移动\n7. 添加状态变量记录平台移动次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.platformBounces = 0; // 状态信号：平台反弹次数\n    this.playerOnPlatform = false; // 状态信号：玩家是否在平台上\n  }\n\n  preload() {\n    // 创建粉色平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0xFF69B4, 1); // 粉色\n    platformGraphics.fillRect(0, 0, 150, 20);\n    platformGraphics.generateTexture('platform', 150, 20);\n    platformGraphics.destroy();\n\n    // 创建绿色玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00FF00, 1); // 绿色\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8B4513, 1); // 棕色\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 添加状态文本显示\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建地面\n    this.ground = this.physics.add.sprite(400, 580, 'ground');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(200, 400, 'platform');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.setVelocityX(80); // 初始速度向右\n    \n    // 设置平台移动范围\n    this.platformMinX = 100;\n    this.platformMaxX = 700;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 100, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.platform, () => {\n      // 当玩家站在平台上时，标记状态\n      if (this.player.body.touching.down && this.platform.body.touching.up) {\n        this.playerOnPlatform = true;\n      }\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加说明文本\n    this.add.text(400, 50, '使用方向键移动玩家', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    }).setOrigin(0.5);\n\n    this.add.text(400, 80, '站在粉色平台上体验移动', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 重置平台状态标记\n    this.playerOnPlatform = false;\n\n    // 平台往返移动逻辑\n    if (this.platform.x <= this.platformMinX) {\n      this.platform.setVelocityX(80); // 向右移动\n      this.platformBounces++;\n    } else if (this.platform.x >= this.platformMaxX) {\n      this.platform.setVelocityX(-80); // 向左移动\n      this.platformBounces++;\n    }\n\n    // 玩家控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      // 如果玩家在平台上，跟随平台移动\n      if (this.player.body.touching.down && this.platform.body.touching.up) {\n        this.playerOnPlatform = true;\n        this.player.setVelocityX(this.platform.body.velocity.x);\n      } else {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃控制\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `平台反弹次数: ${this.platformBounces}`,\n      `玩家在平台上: ${this.playerOnPlatform ? '是' : '否'}`,\n      `平台位置: ${Math.round(this.platform.x)}`,\n      `平台速度: ${this.platform.body.velocity.x}`,\n      `玩家位置: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB', // 天蓝色背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 }, // 设置重力为600\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001840_v2", "prompt_id": "seed_001840", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 12 种不同颜色的粒子效果，可按空格键切换当前粒子类型。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.GameObjects.Particles.ParticleEmitter", "output": "[PLAN]\nREQ: 实现12种不同颜色的粒子效果，按空格键切换粒子类型\nAPI: ParticleEmitter, Graphics, Keyboard, setText, fillStyle\nSTEPS:\n1. 创建12种颜色配置数组，每种颜色对应一个粒子发射器配置\n2. 使用Graphics生成纯色圆形纹理作为粒子\n3. 在create中初始化粒子发射器和UI文本\n4. 监听空格键事件，切换当前激活的粒子类型\n5. 更新粒子发射器配置和显示文本\n[/PLAN]\n\n```javascript\nclass ParticleColorScene extends Phaser.Scene {\n  constructor() {\n    super('ParticleColorScene');\n    this.currentIndex = 0;\n    this.particleColors = [\n      { name: 'Red', color: 0xff0000, tint: 0xff0000 },\n      { name: 'Green', color: 0x00ff00, tint: 0x00ff00 },\n      { name: 'Blue', color: 0x0000ff, tint: 0x0000ff },\n      { name: 'Yellow', color: 0xffff00, tint: 0xffff00 },\n      { name: 'Cyan', color: 0x00ffff, tint: 0x00ffff },\n      { name: 'Magenta', color: 0xff00ff, tint: 0xff00ff },\n      { name: 'Orange', color: 0xff8800, tint: 0xff8800 },\n      { name: 'Purple', color: 0x8800ff, tint: 0x8800ff },\n      { name: 'Pink', color: 0xff88ff, tint: 0xff88ff },\n      { name: 'Lime', color: 0x88ff00, tint: 0x88ff00 },\n      { name: 'Teal', color: 0x008888, tint: 0x008888 },\n      { name: 'White', color: 0xffffff, tint: 0xffffff }\n    ];\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建白色圆形纹理作为粒子基础（后续通过tint着色）\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(8, 8, 8);\n    graphics.generateTexture('particle', 16, 16);\n    graphics.destroy();\n\n    // 创建粒子发射器\n    this.emitter = this.add.particles(400, 300, 'particle', {\n      speed: { min: 100, max: 200 },\n      angle: { min: 0, max: 360 },\n      scale: { start: 1, end: 0 },\n      lifespan: 2000,\n      frequency: 50,\n      maxParticles: 100,\n      tint: this.particleColors[0].tint,\n      blendMode: 'ADD'\n    });\n\n    // 创建UI文本显示当前颜色\n    this.colorText = this.add.text(20, 20, '', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建提示文本\n    this.add.text(20, 60, 'Press SPACE to switch color', {\n      fontSize: '18px',\n      color: '#cccccc',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建状态显示文本（可验证的状态信号）\n    this.statusText = this.add.text(20, 100, '', {\n      fontSize: '16px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.spaceKey.on('down', () => {\n      this.switchParticleColor();\n    });\n\n    // 初始化显示\n    this.updateDisplay();\n  }\n\n  switchParticleColor() {\n    // 切换到下一个颜色\n    this.currentIndex = (this.currentIndex + 1) % this.particleColors.length;\n    \n    // 更新粒子发射器的颜色\n    const currentColor = this.particleColors[this.currentIndex];\n    this.emitter.setParticleTint(currentColor.tint);\n    \n    // 更新显示\n    this.updateDisplay();\n  }\n\n  updateDisplay() {\n    const currentColor = this.particleColors[this.currentIndex];\n    \n    // 更新颜色文本\n    this.colorText.setText(`Color: ${currentColor.name} (${this.currentIndex + 1}/12)`);\n    \n    // 更新状态文本（可验证的状态信号）\n    this.statusText.setText(\n      `Index: ${this.currentIndex}\\n` +\n      `Hex: 0x${currentColor.color.toString(16).toUpperCase().padStart(6, '0')}\\n` +\n      `Active: ${this.emitter.getAliveParticleCount()} particles`\n    );\n  }\n\n  update(time, delta) {\n    // 每帧更新粒子数量显示\n    const currentColor = this.particleColors[this.currentIndex];\n    this.statusText.setText(\n      `Index: ${this.currentIndex}\\n` +\n      `Hex: 0x${currentColor.color.toString(16).toUpperCase().padStart(6, '0')}\\n` +\n      `Active: ${this.emitter.getAliveParticleCount()} particles`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: ParticleColorScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001912_v1", "prompt_id": "seed_001912", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Particles"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 无尽模式波次：每波敌人数从 15 开始，每波增加 1 个，速度从 120 逐渐提升，显示波次和击杀数。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现无尽模式波次系统，敌人数量和速度递增，显示波次和击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Time.TimerEvent, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建玩家和敌人的纹理（使用 Graphics 生成）\n2. 初始化物理系统和玩家角色，支持键盘控制\n3. 实现波次管理系统：追踪当前波次、敌人数量、速度参数\n4. 创建敌人生成逻辑：根据波次动态生成敌人组\n5. 实现碰撞检测：玩家子弹击中敌人增加击杀数\n6. 显示 UI：波次数、击杀数、剩余敌人数\n7. 波次完成后自动开始下一波，速度和数量递增\n[/PLAN]\n\n```javascript\nclass EndlessWaveScene extends Phaser.Scene {\n  constructor() {\n    super('EndlessWaveScene');\n    \n    // 游戏状态\n    this.currentWave = 0;\n    this.killCount = 0;\n    this.baseEnemyCount = 15;\n    this.baseEnemySpeed = 120;\n    this.enemiesRemaining = 0;\n    \n    // 随机种子（可配置）\n    this.seed = 12345;\n  }\n\n  preload() {\n    // 无需外部资源\n  }\n\n  create() {\n    // 创建纹理\n    this.createTextures();\n    \n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n    \n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 30\n    });\n    \n    // 输入控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    // 射击冷却\n    this.canShoot = true;\n    this.shootCooldown = 200;\n    \n    // 碰撞检测\n    this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);\n    this.physics.add.overlap(this.player, this.enemies, this.gameOver, null, this);\n    \n    // UI 文本\n    this.waveText = this.add.text(16, 16, '', {\n      fontSize: '24px',\n      fill: '#fff',\n      fontStyle: 'bold'\n    });\n    \n    this.killText = this.add.text(16, 48, '', {\n      fontSize: '20px',\n      fill: '#0f0'\n    });\n    \n    this.enemyCountText = this.add.text(16, 76, '', {\n      fontSize: '20px',\n      fill: '#ff0'\n    });\n    \n    this.statusText = this.add.text(400, 300, '', {\n      fontSize: '32px',\n      fill: '#fff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n    \n    // 开始第一波\n    this.startNextWave();\n  }\n\n  createTextures() {\n    // 玩家纹理（蓝色三角形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00aaff, 1);\n    playerGraphics.fillTriangle(16, 0, 0, 32, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n    \n    // 敌人纹理（红色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(12, 12, 12);\n    enemyGraphics.generateTexture('enemy', 24, 24);\n    enemyGraphics.destroy();\n    \n    // 子弹纹理（黄色小圆）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n  }\n\n  startNextWave() {\n    this.currentWave++;\n    \n    // 计算本波敌人数量和速度\n    const enemyCount = this.baseEnemyCount + (this.currentWave - 1);\n    const enemySpeed = this.baseEnemySpeed + (this.currentWave - 1) * 5;\n    \n    this.enemiesRemaining = enemyCount;\n    \n    // 显示波次开始提示\n    this.statusText.setText(`Wave ${this.currentWave} Start!`);\n    this.statusText.setAlpha(1);\n    \n    this.tweens.add({\n      targets: this.statusText,\n      alpha: 0,\n      duration: 2000,\n      ease: 'Power2'\n    });\n    \n    // 生成敌人\n    this.spawnEnemies(enemyCount, enemySpeed);\n    \n    // 更新 UI\n    this.updateUI();\n  }\n\n  spawnEnemies(count, speed) {\n    // 使用确定性随机\n    let rng = this.createSeededRandom(this.seed + this.currentWave);\n    \n    for (let i = 0; i < count; i++) {\n      this.time.delayedCall(i * 500, () => {\n        const x = rng() * 760 + 20; // 20-780\n        const y = -30;\n        \n        const enemy = this.enemies.create(x, y, 'enemy');\n        enemy.setVelocityY(speed);\n        \n        // 添加左右移动\n        const moveDirection = (rng() > 0.5 ? 1 : -1);\n        enemy.setVelocityX(moveDirection * (speed * 0.3));\n        \n        // 边界反弹\n        enemy.setBounce(1, 0);\n        enemy.setCollideWorldBounds(true);\n      });\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    bullet.destroy();\n    enemy.destroy();\n    \n    this.killCount++;\n    this.enemiesRemaining--;\n    \n    // 创建爆炸效果\n    const explosion = this.add.graphics();\n    explosion.fillStyle(0xff8800, 1);\n    explosion.fillCircle(enemy.x, enemy.y, 20);\n    \n    this.tweens.add({\n      targets: explosion,\n      alpha: 0,\n      scaleX: 2,\n      scaleY: 2,\n      duration: 300,\n      onComplete: () => explosion.destroy()\n    });\n    \n    this.updateUI();\n    \n    // 检查是否完成本波\n    if (this.enemiesRemaining <= 0) {\n      this.time.delayedCall(2000, () => {\n        this.startNextWave();\n      });\n    }\n  }\n\n  gameOver(player, enemy) {\n    this.physics.pause();\n    this.statusText.setText('GAME OVER!');\n    this.statusText.setAlpha(1);\n    this.statusText.setStyle({ fill: '#f00' });\n    \n    // 3秒后重启\n    this.time.delayedCall(3000, () => {\n      this.scene.restart();\n    });\n  }\n\n  updateUI() {\n    this.waveText.setText(`Wave: ${this.currentWave}`);\n    this.killText.setText(`Kills: ${this.killCount}`);\n    this.enemyCountText.setText(`Enemies: ${this.enemiesRemaining}`);\n  }\n\n  shoot() {\n    if (!this.canShoot) return;\n    \n    const bullet = this.bullets.get(this.player.x, this.player.y - 20, 'bullet');\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocityY(-400);\n      \n      this.canShoot = false;\n      this.time.delayedCall(this.shootCooldown, () => {\n        this.canShoot = true;\n      });\n    }\n  }\n\n  update(time, delta) {\n    // 玩家移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n    \n    // 射击\n    if (this.spaceKey.isDown) {\n      this.shoot();\n    }\n    \n    // 清理超出屏幕的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active && bullet.y < -10) {\n        bullet.destroy();\n      }\n    });\n    \n    // 清理超出屏幕的敌人（失败条件）\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active && enemy.y > 610) {\n        enemy.destroy();\n        this.enemiesRemaining--;\n        this.updateUI();\n        \n        if (this.enemiesRemaining <= 0) {\n          this.time.delayedCall(2000, () => {\n            this.startNextWave();\n          });\n        }\n      }\n    });\n  }\n\n  // 确定性随机数生成器\n  createSeededRandom(seed) {\n    let state = seed;\n    return function() {\n      state = (state * 9301 + 49297) % 233280;\n      return state / 233280;\n    };\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: EndlessWaveScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001909_v3", "prompt_id": "seed_001909", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个带关卡的黄色收集玩法：共 20 关，每关收集完物品后进入下一关，显示 level 与 score。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现20关黄色收集玩法，收集完物品进入下一关，显示level与score\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建GameScene类，初始化level和score状态\n2. 使用Graphics生成玩家（蓝色方块）和收集物（黄色圆形）纹理\n3. 添加物理系统，实现玩家键盘控制移动\n4. 随机生成当前关卡的收集物（数量随关卡递增）\n5. 检测碰撞，收集物品增加分数，全部收集后进入下一关\n6. 显示UI文本展示当前level和score\n7. 通关20关后显示胜利信息\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.level = 1;\n    this.score = 0;\n    this.maxLevel = 20;\n    this.collectibles = null;\n    this.player = null;\n    this.levelText = null;\n    this.scoreText = null;\n    this.seed = 12345; // 固定随机种子\n  }\n\n  preload() {\n    // 使用Graphics生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（黄色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffff00, 1);\n    collectibleGraphics.fillCircle(12, 12, 12);\n    collectibleGraphics.generateTexture('collectible', 24, 24);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDamping(true);\n    this.player.setDrag(0.8);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 初始化收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 生成当前关卡的收集物\n    this.generateLevel();\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // UI文本\n    this.levelText = this.add.text(16, 16, `Level: ${this.level}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    this.scoreText = this.add.text(16, 48, `Score: ${this.score}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加背景色\n    this.cameras.main.setBackgroundColor(0x222222);\n  }\n\n  generateLevel() {\n    // 清除现有收集物\n    this.collectibles.clear(true, true);\n\n    // 根据关卡生成收集物数量（每关3-5个，随关卡递增）\n    const baseCount = 3;\n    const bonusCount = Math.floor(this.level / 5);\n    const itemCount = baseCount + bonusCount;\n\n    // 使用固定种子生成伪随机位置\n    const rng = this.seededRandom(this.seed + this.level);\n\n    for (let i = 0; i < itemCount; i++) {\n      const x = 50 + rng() * 700;\n      const y = 50 + rng() * 500;\n      \n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCircle(12);\n      collectible.body.setAllowGravity(false);\n      \n      // 添加轻微浮动效果\n      this.tweens.add({\n        targets: collectible,\n        y: collectible.y + 10,\n        duration: 1000 + rng() * 500,\n        yoyo: true,\n        repeat: -1,\n        ease: 'Sine.easeInOut'\n      });\n    }\n\n    // 更新UI\n    this.levelText.setText(`Level: ${this.level}`);\n  }\n\n  collectItem(player, collectible) {\n    // 收集物品\n    collectible.destroy();\n    \n    // 增加分数（每关分数递增）\n    this.score += 10 * this.level;\n    this.scoreText.setText(`Score: ${this.score}`);\n\n    // 播放收集效果（缩放动画）\n    this.tweens.add({\n      targets: player,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 100,\n      yoyo: true\n    });\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0) {\n      this.nextLevel();\n    }\n  }\n\n  nextLevel() {\n    this.level++;\n\n    if (this.level > this.maxLevel) {\n      // 通关\n      this.showVictory();\n    } else {\n      // 进入下一关\n      this.showLevelTransition();\n    }\n  }\n\n  showLevelTransition() {\n    // 显示关卡过渡文本\n    const transitionText = this.add.text(400, 300, `Level ${this.level}`, {\n      fontSize: '48px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n    transitionText.setOrigin(0.5);\n\n    // 重置玩家位置\n    this.player.setPosition(400, 300);\n    this.player.setVelocity(0, 0);\n\n    // 动画效果\n    this.tweens.add({\n      targets: transitionText,\n      alpha: 0,\n      scale: 2,\n      duration: 1500,\n      ease: 'Power2',\n      onComplete: () => {\n        transitionText.destroy();\n        this.generateLevel();\n      }\n    });\n  }\n\n  showVictory() {\n    // 显示胜利信息\n    const victoryText = this.add.text(400, 250, 'Victory!', {\n      fontSize: '64px',\n      fill: '#00ff00',\n      fontFamily: 'Arial'\n    });\n    victoryText.setOrigin(0.5);\n\n    const finalScoreText = this.add.text(400, 350, `Final Score: ${this.score}`, {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    finalScoreText.setOrigin(0.5);\n\n    // 禁用玩家控制\n    this.player.body.setVelocity(0, 0);\n    this.player.body.enable = false;\n\n    // 胜利动画\n    this.tweens.add({\n      targets: [victoryText, finalScoreText],\n      scale: 1.1,\n      duration: 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n\n  update(time, delta) {\n    if (!this.player || !this.player.body.enable) return;\n\n    // 玩家移动控制\n    const speed = 300;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n  }\n\n  // 伪随机数生成器（使用种子）\n  seededRandom(seed) {\n    let currentSeed = seed;\n    return function() {\n      currentSeed = (currentSeed * 9301 + 49297) % 233280;\n      return currentSeed / 233280;\n    };\n  }\n}\n\n// Phaser游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n\n// 暴露状态用于验证\ngame.getState = function() {\n  const scene = game.scene.scenes[0];\n  return {\n    level: scene.level,\n    score: scene.score,\n    collectiblesRemaining: scene.collectibles ? scene.collectibles.countActive(true) : 0,\n    playerPosition: scene.player ? { x: scene.player.x, y: scene.player.y } : null\n  };\n};\n```", "metadata": {"id": "distill_seed_001686_v3", "prompt_id": "seed_001686", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "Input", "GameObjects"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个80像素的紫色圆形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置生成80像素紫色圆形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Graphics.fillCircle\nSTEPS:\n1. 配置 Phaser.Game 和 Scene，设置画布尺寸\n2. 在 create 中监听 POINTER_DOWN 事件\n3. 事件回调中获取点击坐标，使用 Graphics 绘制紫色圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 监听画布点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 创建 Graphics 对象用于绘制圆形\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充样式 (0x800080 是紫色的十六进制值)\n    graphics.fillStyle(0x800080, 1);\n    \n    // 在点击位置绘制半径为40像素的圆形（直径80像素）\n    // fillCircle(x, y, radius)\n    graphics.fillCircle(pointer.x, pointer.y, 40);\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 30, '点击画布任意位置生成紫色圆形', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000448_v2", "prompt_id": "seed_000448", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 AI 对战：灰色AI 角色以 120 速度追踪玩家，玩家收集 10 个物品获胜，被 AI 碰到失败。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现玩家收集物品躲避AI追踪的对战游戏，收集10个物品获胜，被AI碰到失败\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.World#overlap, Phaser.Math.Angle.Between, Graphics#generateTexture\nSTEPS:\n1. 创建玩家（绿色方块）和AI敌人（灰色方块），使用Graphics生成纹理\n2. 生成10个可收集物品（黄色圆形），随机分布在场景中\n3. 在update中实现AI追踪逻辑：计算玩家与AI角度，设置AI速度为120朝向玩家\n4. 检测玩家与物品的碰撞，收集后移除物品并增加分数\n5. 检测玩家与AI碰撞，触发失败状态\n6. 当分数达到10时触发胜利状态，显示游戏结果文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.gameWon = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建AI纹理（灰色方块）\n    const aiGraphics = this.add.graphics();\n    aiGraphics.fillStyle(0x808080, 1);\n    aiGraphics.fillRect(0, 0, 32, 32);\n    aiGraphics.generateTexture('ai', 32, 32);\n    aiGraphics.destroy();\n\n    // 创建物品纹理（黄色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('item', 24, 24);\n    itemGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建AI敌人\n    this.ai = this.physics.add.sprite(100, 100, 'ai');\n    this.ai.setCollideWorldBounds(true);\n\n    // 创建物品组\n    this.items = this.physics.add.group();\n    \n    // 使用固定种子生成物品位置（确保确定性）\n    const seed = 12345;\n    const random = new Phaser.Math.RandomDataGenerator([seed]);\n    \n    for (let i = 0; i < 10; i++) {\n      const x = random.between(50, width - 50);\n      const y = random.between(50, height - 50);\n      const item = this.items.create(x, y, 'item');\n      item.setCircle(12); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(this.player, this.items, this.collectItem, null, this);\n    this.physics.add.overlap(this.player, this.ai, this.hitAI, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 创建UI文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0/10', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.resultText = this.add.text(width / 2, height / 2, '', {\n      fontSize: '48px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 }\n    });\n    this.resultText.setOrigin(0.5);\n    this.resultText.setVisible(false);\n\n    // 添加提示文本\n    this.add.text(16, height - 40, 'Use Arrow Keys or WASD to move', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    if (this.gameOver || this.gameWon) {\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // AI追踪逻辑\n    const angle = Phaser.Math.Angle.Between(\n      this.ai.x,\n      this.ai.y,\n      this.player.x,\n      this.player.y\n    );\n\n    const aiSpeed = 120;\n    this.physics.velocityFromRotation(angle, aiSpeed, this.ai.body.velocity);\n  }\n\n  collectItem(player, item) {\n    item.destroy();\n    this.score++;\n    this.scoreText.setText(`Score: ${this.score}/10`);\n\n    if (this.score >= 10) {\n      this.winGame();\n    }\n  }\n\n  hitAI(player, ai) {\n    if (!this.gameOver && !this.gameWon) {\n      this.loseGame();\n    }\n  }\n\n  winGame() {\n    this.gameWon = true;\n    this.player.setVelocity(0);\n    this.ai.setVelocity(0);\n    this.resultText.setText('YOU WIN!');\n    this.resultText.setStyle({ fill: '#00ff00' });\n    this.resultText.setVisible(true);\n  }\n\n  loseGame() {\n    this.gameOver = true;\n    this.player.setVelocity(0);\n    this.ai.setVelocity(0);\n    this.resultText.setText('GAME OVER!');\n    this.resultText.setStyle({ fill: '#ff0000' });\n    this.resultText.setVisible(true);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001929_v2", "prompt_id": "seed_001929", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色星形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色星形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的五个外顶点和五个内顶点坐标（使用三角函数）\n4. 使用 Graphics API 绘制星形路径并填充白色\n5. 将星形定位在画布中央（400, 300）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 星形参数\n  const centerX = 400;  // 画布中央 X 坐标\n  const centerY = 300;  // 画布中央 Y 坐标\n  const outerRadius = 24;  // 外半径（星形尖端到中心的距离）\n  const innerRadius = 12;  // 内半径（星形凹陷点到中心的距离）\n  const points = 5;  // 五角星\n  \n  // 设置填充颜色为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算星形的顶点坐标\n  for (let i = 0; i < points * 2; i++) {\n    // 每个点的角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000155_v3", "prompt_id": "seed_000155", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按空格键发射子弹，速度 120，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现射击敌人游戏，按空格键发射子弹击杀敌人并显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家、子弹组和敌人组，使用 Graphics 生成纹理\n2. 监听空格键输入，发射子弹（速度 120）\n3. 设置子弹与敌人的碰撞检测，命中时销毁双方\n4. 维护击杀计数器并实时显示在屏幕上\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（黄色圆形）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(5, 5, 5);\n    bulletGraphics.generateTexture('bullet', 10, 10);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理（红色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 20\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 生成初始敌人\n    this.spawnEnemies();\n\n    // 定时生成敌人\n    this.time.addEvent({\n      delay: 2000,\n      callback: this.spawnEnemies,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 子弹发射冷却\n    this.canShoot = true;\n    this.shootCooldown = 300;\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数\n    this.scoreText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, 'Arrow Keys: Move | Space: Shoot', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  spawnEnemies() {\n    // 随机生成 2-4 个敌人\n    const count = Phaser.Math.Between(2, 4);\n    for (let i = 0; i < count; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const enemy = this.enemies.create(x, 50, 'enemy');\n      enemy.setVelocityY(Phaser.Math.Between(50, 100));\n    }\n  }\n\n  shootBullet() {\n    if (!this.canShoot) return;\n\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y - 30);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocityY(-120); // 子弹速度 120\n\n      // 设置冷却\n      this.canShoot = false;\n      this.time.delayedCall(this.shootCooldown, () => {\n        this.canShoot = true;\n      });\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹命中敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.setVelocity(0, 0);\n    \n    enemy.destroy();\n\n    // 增加击杀数\n    this.killCount++;\n    this.scoreText.setText('Kills: ' + this.killCount);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 空格键发射子弹\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      this.shootBullet();\n    }\n\n    // 清理超出屏幕的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active && bullet.y < -10) {\n        bullet.setActive(false);\n        bullet.setVisible(false);\n      }\n    });\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 610) {\n        enemy.destroy();\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001025_v2", "prompt_id": "seed_001025", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让黄色方块在 3 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个黄色方块，使用 Tween 动画实现 3 秒循环抖动效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene\nSTEPS:\n1. 使用 Graphics 创建黄色方块纹理\n2. 创建 Sprite 对象并应用纹理\n3. 使用 Tween 动画实现抖动效果（通过快速改变 x/y 位置）\n4. 设置 Tween 为循环模式，持续时间 3 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成黄色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  graphics.generateTexture('yellowBox', 80, 80);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建黄色方块精灵\n  const box = this.add.sprite(400, 300, 'yellowBox');\n  \n  // 创建抖动动画\n  // 使用多个关键帧在 3 秒内快速改变位置，形成抖动效果\n  this.tweens.add({\n    targets: box,\n    duration: 3000,\n    ease: 'Linear',\n    repeat: -1, // 无限循环\n    yoyo: false,\n    // 使用 x 和 y 的随机偏移来创建抖动效果\n    props: {\n      x: {\n        value: '+=0', // 基准位置\n        duration: 3000,\n        ease: (t) => {\n          // 自定义缓动函数：在 0-1 之间产生随机抖动\n          // 使用正弦波叠加随机值创建抖动效果\n          const shake = Math.sin(t * 50) * 5 + (Math.random() - 0.5) * 10;\n          return shake / 400; // 归一化偏移量\n        }\n      },\n      y: {\n        value: '+=0',\n        duration: 3000,\n        ease: (t) => {\n          const shake = Math.cos(t * 50) * 5 + (Math.random() - 0.5) * 10;\n          return shake / 300;\n        }\n      }\n    }\n  });\n  \n  // 另一种更简单的实现方式：使用时间轴快速切换位置\n  // 注释掉上面的 tween，使用下面这种方式也可以\n  /*\n  const timeline = this.tweens.timeline({\n    loop: -1,\n    targets: box\n  });\n  \n  // 在 3 秒内添加多个快速抖动关键帧\n  const shakeCount = 30; // 抖动次数\n  const duration = 3000 / shakeCount; // 每次抖动持续时间\n  \n  for (let i = 0; i < shakeCount; i++) {\n    const offsetX = (Math.random() - 0.5) * 20;\n    const offsetY = (Math.random() - 0.5) * 20;\n    \n    timeline.add({\n      x: 400 + offsetX,\n      y: 300 + offsetY,\n      duration: duration,\n      ease: 'Linear'\n    });\n  }\n  \n  // 最后回到原始位置\n  timeline.add({\n    x: 400,\n    y: 300,\n    duration: duration,\n    ease: 'Linear'\n  });\n  \n  timeline.play();\n  */\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '黄色方块抖动动画（3秒循环）', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000598_v2", "prompt_id": "seed_000598", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 5 个金币，重力 600，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集5个金币，重力600，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建带 Arcade 物理系统的游戏配置，设置重力为 600\n2. 使用 Graphics 绘制玩家（矩形）和金币（圆形），生成纹理\n3. 创建地面平台和空中平台，设置为静态物理体\n4. 在空中随机位置创建 5 个金币物理体\n5. 添加键盘控制（方向键），实现左右移动和跳跃\n6. 添加玩家与金币的碰撞检测，收集时增加分数并销毁金币\n7. 创建文本显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色矩形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 400, 32);\n    platformGraphics.generateTexture('platform', 400, 32);\n    platformGraphics.destroy();\n\n    // 创建小平台纹理\n    const smallPlatformGraphics = this.add.graphics();\n    smallPlatformGraphics.fillStyle(0x888888, 1);\n    smallPlatformGraphics.fillRect(0, 0, 200, 24);\n    smallPlatformGraphics.generateTexture('smallPlatform', 200, 24);\n    smallPlatformGraphics.destroy();\n\n    // 创建地面平台\n    this.platforms = this.physics.add.staticGroup();\n    this.platforms.create(400, 584, 'platform').setScale(2, 1).refreshBody();\n    \n    // 创建空中平台\n    this.platforms.create(600, 450, 'smallPlatform');\n    this.platforms.create(200, 380, 'smallPlatform');\n    this.platforms.create(700, 300, 'smallPlatform');\n    this.platforms.create(150, 250, 'smallPlatform');\n    this.platforms.create(500, 200, 'smallPlatform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加玩家与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在空中平台上方创建5个金币\n    const coinPositions = [\n      { x: 600, y: 400 },\n      { x: 200, y: 330 },\n      { x: 700, y: 250 },\n      { x: 150, y: 200 },\n      { x: 500, y: 150 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.3);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 金币与平台碰撞\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 玩家与金币碰撞检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontStyle: 'bold',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.scoreText.setScrollFactor(0);\n\n    // 创建提示文本\n    this.hintText = this.add.text(400, 50, 'Use Arrow Keys to Move and Jump!\\nCollect all 5 coins!', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      align: 'center',\n      stroke: '#000000',\n      strokeThickness: 3\n    });\n    this.hintText.setOrigin(0.5);\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 检查是否收集完所有金币\n    if (this.score >= 5 && this.coins.countActive(true) === 0) {\n      if (!this.winText) {\n        this.winText = this.add.text(400, 300, 'YOU WIN!\\nAll coins collected!', {\n          fontSize: '48px',\n          fill: '#00ff00',\n          align: 'center',\n          fontStyle: 'bold',\n          stroke: '#000000',\n          strokeThickness: 6\n        });\n        this.winText.setOrigin(0.5);\n      }\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 1;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 添加收集音效的视觉反馈（闪烁效果）\n    this.cameras.main.flash(100, 255, 255, 0);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000820_v1", "prompt_id": "seed_000820", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的粉色椭圆，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的粉色椭圆，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环 20 次\n3. 每次循环创建一个 Graphics 对象，设置粉色填充样式\n4. 使用 fillEllipse 绘制椭圆（中心点为0,0，半径为32像素）\n5. 使用 setRandomPosition 随机设置椭圆位置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建 20 个粉色椭圆\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式 (粉色 RGB: 255, 192, 203 -> Hex: 0xFFC0CB)\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 绘制椭圆，中心点在 (0, 0)，宽高各为 64 像素（半径 32）\n    graphics.fillEllipse(0, 0, 64, 64);\n    \n    // 随机设置椭圆位置\n    // 确保椭圆完全在画布内，留出半径的边距\n    graphics.setRandomPosition(32, 32, this.scale.width - 64, this.scale.height - 64);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000727_v3", "prompt_id": "seed_000727", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 同时控制 5 个粉色对象：按方向键时所有对象同步移动，速度 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 同时控制5个粉色对象，按方向键同步移动，速度160\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.createCursorKeys, Phaser.GameObjects.Container\nSTEPS:\n1. 创建5个粉色圆形对象，使用Graphics绘制并生成纹理\n2. 将5个对象存储在数组中，分散放置在场景中\n3. 使用createCursorKeys创建方向键监听\n4. 在update中检测方向键状态，同步更新所有对象的位置\n5. 添加状态变量记录总移动距离作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.objects = [];\n    this.speed = 160;\n    this.totalDistance = 0; // 可验证的状态信号\n    this.objectCount = 5;\n  }\n\n  preload() {\n    // 使用Graphics创建粉色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff69b4, 1); // 粉色\n    graphics.fillCircle(20, 20, 20);\n    graphics.generateTexture('pinkCircle', 40, 40);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建5个粉色对象，分散排列\n    const positions = [\n      { x: 200, y: 200 },\n      { x: 400, y: 150 },\n      { x: 600, y: 200 },\n      { x: 300, y: 400 },\n      { x: 500, y: 400 }\n    ];\n\n    for (let i = 0; i < this.objectCount; i++) {\n      const obj = this.add.sprite(\n        positions[i].x, \n        positions[i].y, \n        'pinkCircle'\n      );\n      this.objects.push(obj);\n    }\n\n    // 创建方向键控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n\n    // 添加提示文本\n    this.add.text(10, 550, '使用方向键控制所有粉色对象移动', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n  }\n\n  update(time, delta) {\n    let moved = false;\n    let velocityX = 0;\n    let velocityY = 0;\n\n    // 检测方向键状态\n    if (this.cursors.left.isDown) {\n      velocityX = -this.speed;\n      moved = true;\n    } else if (this.cursors.right.isDown) {\n      velocityX = this.speed;\n      moved = true;\n    }\n\n    if (this.cursors.up.isDown) {\n      velocityY = -this.speed;\n      moved = true;\n    } else if (this.cursors.down.isDown) {\n      velocityY = this.speed;\n      moved = true;\n    }\n\n    // 同步移动所有对象\n    if (moved) {\n      const deltaSeconds = delta / 1000;\n      const moveX = velocityX * deltaSeconds;\n      const moveY = velocityY * deltaSeconds;\n\n      this.objects.forEach(obj => {\n        obj.x += moveX;\n        obj.y += moveY;\n\n        // 边界限制（可选）\n        obj.x = Phaser.Math.Clamp(obj.x, 20, 780);\n        obj.y = Phaser.Math.Clamp(obj.y, 20, 580);\n      });\n\n      // 计算移动距离\n      const distance = Math.sqrt(moveX * moveX + moveY * moveY);\n      this.totalDistance += distance;\n\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `对象数量: ${this.objectCount} | ` +\n      `速度: ${this.speed} | ` +\n      `总移动距离: ${Math.floor(this.totalDistance)}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001546_v3", "prompt_id": "seed_001546", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 15 个青色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理15个青色可复用对象，离开屏幕后自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.Scene\nSTEPS:\n1. 创建青色方块纹理使用Graphics生成\n2. 使用Physics.Arcade.Group创建对象池，初始化15个可复用对象\n3. 在create中启动定时器，定期从对象池获取对象并发射\n4. 在update中检测对象是否离开屏幕，离开后调用kill回收到对象池\n5. 添加状态变量追踪活跃对象数量和总发射次数作为验证信号\n[/PLAN]\n\n```javascript\nclass PoolScene extends Phaser.Scene {\n  constructor() {\n    super('PoolScene');\n    this.activeCount = 0; // 当前活跃对象数\n    this.totalLaunched = 0; // 总发射次数\n    this.recycledCount = 0; // 回收次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建青色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('cyanBlock', 32, 32);\n    graphics.destroy();\n\n    // 创建物理对象池，最多15个对象\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'cyanBlock',\n      maxSize: 15,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 预创建15个对象到池中\n    for (let i = 0; i < 15; i++) {\n      const obj = this.objectPool.create(0, 0, 'cyanBlock');\n      obj.setActive(false);\n      obj.setVisible(false);\n    }\n\n    // 定时发射对象（每500ms发射一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.launchObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(10, 550, '青色方块从池中获取，离开屏幕后自动回收', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n\n    this.updateStatusText();\n  }\n\n  launchObject() {\n    // 从对象池获取一个不活跃的对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 随机起始位置（屏幕顶部）\n      const startX = Phaser.Math.Between(50, 750);\n      obj.setPosition(startX, -32);\n      \n      // 激活并显示对象\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 设置随机速度\n      const velocityX = Phaser.Math.Between(-100, 100);\n      const velocityY = Phaser.Math.Between(100, 300);\n      obj.setVelocity(velocityX, velocityY);\n      \n      // 添加旋转效果\n      obj.setAngularVelocity(Phaser.Math.Between(-200, 200));\n      \n      this.activeCount++;\n      this.totalLaunched++;\n      this.updateStatusText();\n    }\n  }\n\n  update() {\n    // 检查所有活跃对象\n    this.objectPool.getChildren().forEach((obj) => {\n      if (obj.active) {\n        // 检测是否离开屏幕边界（上下左右都检测）\n        if (obj.y > 650 || obj.y < -50 || obj.x < -50 || obj.x > 850) {\n          // 回收对象到池中\n          this.killObject(obj);\n        }\n      }\n    });\n  }\n\n  killObject(obj) {\n    // 停止物理运动\n    obj.setVelocity(0, 0);\n    obj.setAngularVelocity(0);\n    \n    // 取消激活和隐藏\n    obj.setActive(false);\n    obj.setVisible(false);\n    \n    this.activeCount--;\n    this.recycledCount++;\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `对象池大小: 15`,\n      `活跃对象: ${this.activeCount}`,\n      `可用对象: ${15 - this.activeCount}`,\n      `总发射次数: ${this.totalLaunched}`,\n      `回收次数: ${this.recycledCount}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: PoolScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001582_v2", "prompt_id": "seed_001582", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的六边形\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建精灵对象并设置初始位置\n3. 在 update 中让六边形持续向左下移动\n4. 使用相机的 startFollow 方法跟随六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst moveSpeed = 2; // 每帧移动的像素数\n\nfunction preload() {\n  // 创建六边形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  const hexRadius = 30;\n  const centerX = hexRadius + 5;\n  const centerY = hexRadius + 5;\n  \n  // 绘制六边形的6个顶点\n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', (hexRadius + 5) * 2, (hexRadius + 5) * 2);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建六边形精灵，初始位置在场景中心偏右上\n  hexagon = this.add.sprite(600, 200, 'hexagon');\n  \n  // 设置相机边界为一个更大的区域，允许六边形移动\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  \n  // 设置世界边界\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n  \n  // 让相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 添加提示文字（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随六边形\\n六边形向左下移动', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n  \n  // 添加网格参考线，帮助观察移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 2000);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 2000; y += 100) {\n    gridGraphics.lineBetween(0, y, 2000, y);\n  }\n}\n\nfunction update(time, delta) {\n  // 让六边形向左下移动\n  // 左：x减小，下：y增大\n  hexagon.x -= moveSpeed;\n  hexagon.y += moveSpeed;\n  \n  // 可选：当六边形移出边界时重置位置\n  if (hexagon.x < -50 || hexagon.y > 2050) {\n    hexagon.setPosition(600, 200);\n  }\n  \n  // 可选：添加旋转效果使移动更明显\n  hexagon.rotation += 0.02;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000445_v2", "prompt_id": "seed_000445", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个敌人同时追踪玩家，敌人速度 120，玩家需躲避。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 15个敌人以120速度追踪玩家，玩家需躲避\nAPI: Physics.Arcade, Graphics, Input.Keyboard, Math.Angle.Between, Physics.MoveTo\nSTEPS:\n1. 创建玩家精灵（绿色方块）和15个敌人精灵（红色圆形）\n2. 使用Graphics程序化生成玩家和敌人纹理\n3. 启用Arcade物理系统，为玩家和敌人添加物理体\n4. 在update中计算每个敌人到玩家的角度，设置敌人朝向玩家移动\n5. 使用键盘控制玩家移动（WASD或方向键）\n6. 检测玩家与敌人碰撞，碰撞后游戏结束\n7. 添加存活时间计分和游戏状态变量\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.enemies = null;\n    this.cursors = null;\n    this.wasd = null;\n    this.gameOver = false;\n    this.survivalTime = 0;\n    this.score = 0;\n    this.health = 100;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 在随机位置生成15个敌人\n    for (let i = 0; i < 15; i++) {\n      let x, y;\n      // 确保敌人不在玩家附近生成\n      do {\n        x = Phaser.Math.Between(50, 750);\n        y = Phaser.Math.Between(50, 550);\n      } while (Phaser.Math.Distance.Between(x, y, 400, 300) < 150);\n      \n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0.2);\n    }\n\n    // 设置玩家与敌人的碰撞检测\n    this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 创建UI文本\n    this.scoreText = this.add.text(16, 16, 'Time: 0s', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    this.healthText = this.add.text(16, 50, 'Health: 100', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    this.instructionText = this.add.text(400, 16, 'Use Arrow Keys or WASD to move. Avoid red enemies!', {\n      fontSize: '18px',\n      fill: '#ffff00'\n    }).setOrigin(0.5, 0);\n\n    // 初始化计时器\n    this.startTime = this.time.now;\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 更新存活时间和分数\n    this.survivalTime = Math.floor((time - this.startTime) / 1000);\n    this.score = this.survivalTime * 10;\n    this.scoreText.setText('Time: ' + this.survivalTime + 's (Score: ' + this.score + ')');\n\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 标准化对角线移动速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(playerSpeed);\n    }\n\n    // 让每个敌人追踪玩家\n    const enemySpeed = 120;\n    this.enemies.children.entries.forEach(enemy => {\n      // 计算敌人到玩家的角度\n      const angle = Phaser.Math.Angle.Between(\n        enemy.x, enemy.y,\n        this.player.x, this.player.y\n      );\n\n      // 设置敌人朝向玩家的速度\n      this.physics.velocityFromRotation(angle, enemySpeed, enemy.body.velocity);\n\n      // 旋转敌人朝向玩家（可选的视觉效果）\n      enemy.rotation = angle;\n    });\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 游戏结束\n    this.gameOver = true;\n    this.health = 0;\n    this.healthText.setText('Health: 0');\n\n    // 停止所有物理对象\n    this.physics.pause();\n\n    // 玩家变红表示被击中\n    player.setTint(0xff0000);\n\n    // 显示游戏结束文本\n    const gameOverText = this.add.text(400, 300, 'GAME OVER!\\nSurvived: ' + this.survivalTime + 's\\nScore: ' + this.score, {\n      fontSize: '48px',\n      fill: '#ff0000',\n      align: 'center'\n    }).setOrigin(0.5);\n\n    const restartText = this.add.text(400, 400, 'Click to Restart', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 点击重启游戏\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001491_v3", "prompt_id": "seed_001491", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.45}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现确定性生成：基于固定 seed 生成 5 个粉色障碍物布局，相同 seed 下布局一致，显示当前 seed。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Math.RND\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 基于固定 seed 生成 5 个粉色障碍物，相同 seed 下布局一致，显示当前 seed\nAPI: Phaser.Math.RND.sow, Phaser.Math.RND.between, this.add.graphics, this.add.text\nSTEPS:\n1. 配置 Game 时设置固定 seed，初始化确定性随机数生成器\n2. 在 create 中使用 RND 生成 5 个障碍物的随机位置和尺寸\n3. 使用 Graphics 绘制粉色矩形障碍物\n4. 显示当前 seed 文本用于验证\n5. 添加重置按钮，可切换 seed 重新生成布局\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentSeed = 12345; // 初始固定 seed\n    this.obstacles = [];\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 设置随机种子，确保确定性生成\n    this.game.config.seed = [this.currentSeed.toString()];\n    Phaser.Math.RND.sow([this.currentSeed.toString()]);\n\n    // 显示当前 seed\n    this.seedText = this.add.text(10, 10, `Seed: ${this.currentSeed}`, {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.seedText.setDepth(100);\n\n    // 生成 5 个粉色障碍物\n    this.generateObstacles();\n\n    // 添加说明文本\n    this.add.text(10, 50, 'Press SPACE to regenerate with new seed', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#333333',\n      padding: { x: 8, y: 4 }\n    });\n\n    this.add.text(10, 80, 'Press R to reset to original seed', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#333333',\n      padding: { x: 8, y: 4 }\n    });\n\n    // 添加键盘输入\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n\n    // 显示障碍物信息（用于验证确定性）\n    this.infoText = this.add.text(10, 550, '', {\n      fontSize: '14px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n    this.updateInfo();\n  }\n\n  generateObstacles() {\n    // 清除旧障碍物\n    this.obstacles.forEach(obstacle => obstacle.destroy());\n    this.obstacles = [];\n\n    // 使用确定性随机数生成 5 个障碍物\n    const obstacleCount = 5;\n    const minSize = 40;\n    const maxSize = 100;\n    const margin = 150; // 避免生成在边缘或文字区域\n\n    for (let i = 0; i < obstacleCount; i++) {\n      // 生成随机位置和尺寸（使用 Phaser 的 RND）\n      const x = Phaser.Math.RND.between(margin, 800 - margin);\n      const y = Phaser.Math.RND.between(margin, 600 - margin);\n      const width = Phaser.Math.RND.between(minSize, maxSize);\n      const height = Phaser.Math.RND.between(minSize, maxSize);\n\n      // 创建粉色障碍物\n      const graphics = this.add.graphics();\n      graphics.fillStyle(0xff69b4, 1); // 粉色 (HotPink)\n      graphics.fillRect(x - width / 2, y - height / 2, width, height);\n\n      // 添加边框使其更明显\n      graphics.lineStyle(3, 0xff1493, 1); // 深粉色边框\n      graphics.strokeRect(x - width / 2, y - height / 2, width, height);\n\n      // 添加障碍物编号\n      const label = this.add.text(x, y, `${i + 1}`, {\n        fontSize: '20px',\n        color: '#ffffff',\n        fontStyle: 'bold'\n      });\n      label.setOrigin(0.5);\n\n      // 保存障碍物信息\n      this.obstacles.push({\n        graphics: graphics,\n        label: label,\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }\n\n  updateInfo() {\n    // 显示障碍物位置信息用于验证确定性\n    let info = 'Obstacles: ';\n    this.obstacles.forEach((obs, i) => {\n      info += `[${i + 1}:(${Math.round(obs.x)},${Math.round(obs.y)},${Math.round(obs.width)}x${Math.round(obs.height)})] `;\n    });\n    this.infoText.setText(info);\n  }\n\n  update() {\n    // 按空格键生成新的 seed 并重新生成\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      this.currentSeed = Math.floor(Math.random() * 999999);\n      this.restartWithNewSeed();\n    }\n\n    // 按 R 键重置为原始 seed\n    if (Phaser.Input.Keyboard.JustDown(this.rKey)) {\n      this.currentSeed = 12345;\n      this.restartWithNewSeed();\n    }\n  }\n\n  restartWithNewSeed() {\n    // 更新 seed 显示\n    this.seedText.setText(`Seed: ${this.currentSeed}`);\n\n    // 重新设置随机种子\n    this.game.config.seed = [this.currentSeed.toString()];\n    Phaser.Math.RND.sow([this.currentSeed.toString()]);\n\n    // 重新生成障碍物\n    this.generateObstacles();\n    this.updateInfo();\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  seed: ['12345'], // 初始固定 seed\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001779_v2", "prompt_id": "seed_001779", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按方向键向当前朝向发射子弹，子弹速度 120，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现可旋转玩家，按方向键向当前朝向发射速度为120的子弹\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Group, Phaser.Math.DegToRad, Graphics.generateTexture\nSTEPS:\n1. 创建物理系统配置，初始化玩家精灵和子弹组\n2. 使用Graphics绘制玩家（三角形）和子弹（圆形）纹理\n3. 监听方向键输入，左右键控制玩家旋转，上键发射子弹\n4. 根据玩家当前角度计算子弹发射方向，设置子弹速度为120\n5. 子弹超出边界时自动销毁，维护bulletsFired计数器作为状态信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 状态信号：已发射子弹数\n    this.rotationSpeed = 3; // 旋转速度\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（三角形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(20, 0);\n    playerGraphics.lineTo(-10, -10);\n    playerGraphics.lineTo(-10, 10);\n    playerGraphics.closePath();\n    playerGraphics.fillPath();\n    playerGraphics.generateTexture('player', 30, 20);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（圆形）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xff0000, 1);\n    bulletGraphics.fillCircle(5, 5, 5);\n    bulletGraphics.generateTexture('bullet', 10, 10);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, '左右键旋转，上键/空格发射子弹', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家旋转控制\n    if (this.cursors.left.isDown) {\n      this.player.angle -= this.rotationSpeed;\n    } else if (this.cursors.right.isDown) {\n      this.player.angle += this.rotationSpeed;\n    }\n\n    // 发射子弹（上键或空格键）\n    if (Phaser.Input.Keyboard.JustDown(this.cursors.up) || \n        Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      this.fireBullet();\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -50 || bullet.x > 850 || \n            bullet.y < -50 || bullet.y > 650) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText(\n      `子弹发射数: ${this.bulletsFired}\\n` +\n      `当前角度: ${Math.round(this.player.angle)}°\\n` +\n      `活跃子弹: ${this.bullets.countActive(true)}`\n    );\n  }\n\n  fireBullet() {\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹角度与玩家一致\n      bullet.rotation = this.player.rotation;\n      \n      // 计算子弹速度方向（根据玩家角度）\n      const angleInRadians = Phaser.Math.DegToRad(this.player.angle);\n      const velocityX = Math.cos(angleInRadians) * 120;\n      const velocityY = Math.sin(angleInRadians) * 120;\n      \n      // 设置子弹速度\n      bullet.body.setVelocity(velocityX, velocityY);\n      \n      // 增加发射计数\n      this.bulletsFired++;\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001016_v3", "prompt_id": "seed_001016", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现角色受伤效果：碰撞时绿色角色闪烁 1 秒，同时播放击退效果（击退距离与速度 300 相关）。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现角色碰撞时的受伤效果，包括1秒闪烁动画和基于速度300的击退效果\nAPI: Phaser.Physics.Arcade, Phaser.Tweens, Phaser.Time, Graphics.generateTexture, Body.setVelocity\nSTEPS:\n1. 创建两个角色精灵（绿色玩家和红色敌人），使用Graphics生成纹理\n2. 设置物理系统碰撞检测，监听玩家与敌人的碰撞事件\n3. 碰撞时计算击退方向和速度（基于碰撞角度，击退速度300）\n4. 使用Tween创建1秒闪烁效果（alpha在0.2-1之间循环）\n5. 添加无敌时间防止连续受伤，记录受伤次数作为验证状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.hitCount = 0; // 受伤次数统计\n    this.isInvincible = false; // 无敌状态\n  }\n\n  preload() {\n    // 创建绿色玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建红色敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家（绿色）\n    this.player = this.physics.add.sprite(200, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0.2);\n    this.player.setDamping(true);\n    this.player.setDrag(0.95);\n\n    // 创建敌人（红色）\n    this.enemy = this.physics.add.sprite(600, 300, 'enemy');\n    this.enemy.setCollideWorldBounds(true);\n    this.enemy.setBounce(1);\n    \n    // 给敌人一个初始速度，让它移动\n    this.enemy.setVelocity(150, 100);\n\n    // 设置碰撞检测\n    this.physics.add.collider(\n      this.player,\n      this.enemy,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示受伤次数\n    this.hitText = this.add.text(16, 16, 'Hit Count: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 显示无敌状态\n    this.statusText = this.add.text(16, 50, 'Status: Normal', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n\n    // 提示信息\n    this.add.text(16, 550, 'Use Arrow Keys to Move', {\n      fontSize: '18px',\n      fill: '#ffff00'\n    });\n  }\n\n  handleCollision(player, enemy) {\n    // 如果处于无敌状态，不触发受伤效果\n    if (this.isInvincible) {\n      return;\n    }\n\n    // 增加受伤计数\n    this.hitCount++;\n    this.hitText.setText('Hit Count: ' + this.hitCount);\n\n    // 设置无敌状态\n    this.isInvincible = true;\n    this.statusText.setText('Status: Invincible');\n\n    // 计算击退方向（从敌人到玩家的方向）\n    const angle = Phaser.Math.Angle.Between(\n      enemy.x,\n      enemy.y,\n      player.x,\n      player.y\n    );\n\n    // 击退速度为300\n    const knockbackSpeed = 300;\n    const knockbackVelocityX = Math.cos(angle) * knockbackSpeed;\n    const knockbackVelocityY = Math.sin(angle) * knockbackSpeed;\n\n    // 应用击退效果\n    player.setVelocity(knockbackVelocityX, knockbackVelocityY);\n\n    // 停止当前所有闪烁动画（防止重复）\n    this.tweens.killTweensOf(player);\n\n    // 创建1秒闪烁效果\n    this.tweens.add({\n      targets: player,\n      alpha: 0.2,\n      duration: 100,\n      yoyo: true,\n      repeat: 4, // 重复4次，加上初始的一次，总共5个循环，约1秒\n      onComplete: () => {\n        // 闪烁结束后恢复正常\n        player.alpha = 1;\n        this.isInvincible = false;\n        this.statusText.setText('Status: Normal');\n      }\n    });\n\n    // 可选：敌人也受到反作用力\n    const enemyKnockbackX = Math.cos(angle + Math.PI) * 200;\n    const enemyKnockbackY = Math.sin(angle + Math.PI) * 200;\n    enemy.setVelocity(enemyKnockbackX, enemyKnockbackY);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 显示当前速度（用于调试）\n    const velocity = this.player.body.velocity;\n    const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n    \n    // 更新状态文本，显示更多信息\n    if (!this.isInvincible) {\n      this.statusText.setText(\n        `Status: Normal | Speed: ${Math.round(currentSpeed)}`\n      );\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false // 设置为true可以看到碰撞框\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001844_v2", "prompt_id": "seed_001844", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "Animations"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个32像素的红色三角形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置生成32像素红色三角形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Graphics.fillTriangle\nSTEPS:\n1. 配置 Phaser.Game 和 Scene，设置画布尺寸\n2. 在 create 中监听 pointerdown 事件\n3. 在点击回调中使用 Graphics 绘制红色三角形（边长32像素）\n4. 三角形中心位于点击位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 监听画布点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 创建 Graphics 对象用于绘制三角形\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 计算三角形的三个顶点坐标\n    // 等边三角形，边长32像素，中心在点击位置\n    const size = 32;\n    const height = (Math.sqrt(3) / 2) * size; // 等边三角形高度\n    \n    // 三角形顶点相对于中心的偏移\n    const x = pointer.x;\n    const y = pointer.y;\n    \n    // 顶点坐标（顶点朝上的等边三角形）\n    const x1 = x;                    // 顶部顶点\n    const y1 = y - (2 * height / 3);\n    \n    const x2 = x - size / 2;         // 左下顶点\n    const y2 = y + (height / 3);\n    \n    const x3 = x + size / 2;         // 右下顶点\n    const y3 = y + (height / 3);\n    \n    // 绘制填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 可选：添加边框使三角形更清晰\n    graphics.lineStyle(2, 0xffffff, 1);\n    graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Click anywhere to create red triangles', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000131_v1", "prompt_id": "seed_000131", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 2.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让星形在 2.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个使用该纹理的精灵对象，初始 alpha 设为 0\n3. 使用 tweens.add 创建透明度补间动画，从 0 到 1，持续 2.5 秒\n4. 设置 repeat: -1 使动画无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色星形\n  \n  // 绘制五角星\n  const centerX = 64;\n  const centerY = 64;\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const points = 5;\n  \n  const path = [];\n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    path.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  graphics.fillPoints(path, true);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 128, 128);\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 设置初始透明度为 0（完全透明）\n  star.setAlpha(0);\n  \n  // 创建透明度渐变补间动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    alpha: 1,                // 目标透明度：完全不透明\n    duration: 2500,          // 持续时间：2.5 秒（2500 毫秒）\n    ease: 'Linear',          // 线性缓动\n    repeat: -1,              // 无限循环\n    yoyo: true               // 往返播放（透明→不透明→透明）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000426_v3", "prompt_id": "seed_000426", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形移动，速度 120 像素/秒\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制矩形作为玩家\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新矩形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象\nlet player;\n// 按键对象\nlet keyW, keyA, keyS, keyD;\n// 移动速度（像素/秒）\nconst SPEED = 120;\n\nfunction preload() {\n  // 本游戏不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形（50x50 的红色矩形）\n  player = this.add.graphics();\n  player.fillStyle(0xff0000, 1);\n  player.fillRect(0, 0, 50, 50);\n  \n  // 设置初始位置（屏幕中心）\n  player.x = 400 - 25; // 减去矩形宽度的一半使其居中\n  player.y = 300 - 25; // 减去矩形高度的一半使其居中\n  \n  // 绑定 WASD 按键\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the red square', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧的移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    player.y -= moveDistance; // 向上移动\n  }\n  if (keyS.isDown) {\n    player.y += moveDistance; // 向下移动\n  }\n  if (keyA.isDown) {\n    player.x -= moveDistance; // 向左移动\n  }\n  if (keyD.isDown) {\n    player.x += moveDistance; // 向右移动\n  }\n  \n  // 限制在画布范围内（可选）\n  player.x = Phaser.Math.Clamp(player.x, 0, 750); // 800 - 50\n  player.y = Phaser.Math.Clamp(player.y, 0, 550); // 600 - 50\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000685_v2", "prompt_id": "seed_000685", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 记录玩家 3 秒内的操作序列，按鼠标右键开始回放，回放速度可调。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 记录玩家 3 秒内的操作序列，按鼠标右键开始回放，回放速度可调\nAPI: Scene, Input.Keyboard, Input.Mouse, GameObjects.Graphics, GameObjects.Text, Time.Clock\nSTEPS:\n1. 创建可控制的玩家精灵（使用 Graphics 绘制）\n2. 记录玩家的键盘输入和位置信息，时间戳记录操作序列\n3. 限制记录时长为 3 秒，超过后自动停止记录\n4. 监听鼠标右键事件触发回放模式\n5. 回放时根据时间戳重现玩家操作，支持速度调节（1x, 2x, 0.5x）\n6. 显示当前状态（录制/回放/空闲）和回放速度\n[/PLAN]\n\n```javascript\nclass RecordReplayScene extends Phaser.Scene {\n  constructor() {\n    super('RecordReplayScene');\n    \n    // 状态变量\n    this.isRecording = false;\n    this.isReplaying = false;\n    this.recordStartTime = 0;\n    this.recordDuration = 3000; // 3秒\n    this.replaySpeed = 1.0; // 回放速度倍率\n    this.replayStartTime = 0;\n    \n    // 操作记录\n    this.actionLog = [];\n    this.currentReplayIndex = 0;\n    \n    // 玩家状态\n    this.playerX = 400;\n    this.playerY = 300;\n    this.playerSpeed = 200;\n    \n    // 记录的初始位置\n    this.recordedStartX = 400;\n    this.recordedStartY = 300;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建玩家（实时控制的蓝色方块）\n    this.player = this.add.graphics();\n    this.player.fillStyle(0x0000ff, 1);\n    this.player.fillRect(-16, -16, 32, 32);\n    this.player.x = this.playerX;\n    this.player.y = this.playerY;\n    \n    // 创建回放玩家（红色方块，回放时显示）\n    this.replayPlayer = this.add.graphics();\n    this.replayPlayer.fillStyle(0xff0000, 0.7);\n    this.replayPlayer.fillRect(-16, -16, 32, 32);\n    this.replayPlayer.visible = false;\n    \n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.aKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.sKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.dKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    // 监听空格键开始录制\n    this.spaceKey.on('down', () => {\n      if (!this.isRecording && !this.isReplaying) {\n        this.startRecording();\n      }\n    });\n    \n    // 监听鼠标右键开始回放\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown() && !this.isReplaying && this.actionLog.length > 0) {\n        this.startReplay();\n      }\n    });\n    \n    // 监听数字键调整回放速度\n    this.input.keyboard.on('keydown-ONE', () => { this.replaySpeed = 0.5; });\n    this.input.keyboard.on('keydown-TWO', () => { this.replaySpeed = 1.0; });\n    this.input.keyboard.on('keydown-THREE', () => { this.replaySpeed = 2.0; });\n    \n    // UI 文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.instructionText = this.add.text(10, 50, \n      '按 SPACE 开始录制（3秒）\\n' +\n      '鼠标右键开始回放\\n' +\n      '按 1/2/3 调整回放速度（0.5x/1x/2x）\\n' +\n      'WASD 或方向键移动', {\n      fontSize: '14px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.recordInfoText = this.add.text(10, 550, '', {\n      fontSize: '14px',\n      color: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 录制模式\n    if (this.isRecording) {\n      const elapsed = time - this.recordStartTime;\n      \n      // 检查是否超过 3 秒\n      if (elapsed >= this.recordDuration) {\n        this.stopRecording();\n      } else {\n        // 记录玩家操作\n        this.recordPlayerInput(time, delta);\n        this.updateStatusText();\n      }\n    }\n    \n    // 回放模式\n    if (this.isReplaying) {\n      this.updateReplay(time);\n    }\n    \n    // 正常控制模式（非回放时）\n    if (!this.isReplaying) {\n      this.handlePlayerMovement(delta);\n    }\n    \n    this.updateStatusText();\n  }\n\n  startRecording() {\n    this.isRecording = true;\n    this.recordStartTime = this.time.now;\n    this.actionLog = [];\n    this.recordedStartX = this.player.x;\n    this.recordedStartY = this.player.y;\n    \n    // 记录初始位置\n    this.actionLog.push({\n      time: 0,\n      x: this.player.x,\n      y: this.player.y,\n      type: 'position'\n    });\n  }\n\n  stopRecording() {\n    this.isRecording = false;\n    this.recordInfoText.setText(`录制完成！共记录 ${this.actionLog.length} 个动作`);\n  }\n\n  recordPlayerInput(time, delta) {\n    const relativeTime = time - this.recordStartTime;\n    \n    // 记录当前位置\n    this.actionLog.push({\n      time: relativeTime,\n      x: this.player.x,\n      y: this.player.y,\n      type: 'position'\n    });\n  }\n\n  handlePlayerMovement(delta) {\n    const speed = this.playerSpeed * (delta / 1000);\n    let moved = false;\n    \n    if (this.cursors.left.isDown || this.aKey.isDown) {\n      this.player.x -= speed;\n      moved = true;\n    }\n    if (this.cursors.right.isDown || this.dKey.isDown) {\n      this.player.x += speed;\n      moved = true;\n    }\n    if (this.cursors.up.isDown || this.wKey.isDown) {\n      this.player.y -= speed;\n      moved = true;\n    }\n    if (this.cursors.down.isDown || this.sKey.isDown) {\n      this.player.y += speed;\n      moved = true;\n    }\n    \n    // 边界限制\n    this.player.x = Phaser.Math.Clamp(this.player.x, 16, 784);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 16, 584);\n  }\n\n  startReplay() {\n    if (this.actionLog.length === 0) return;\n    \n    this.isReplaying = true;\n    this.replayStartTime = this.time.now;\n    this.currentReplayIndex = 0;\n    \n    // 显示回放玩家\n    this.replayPlayer.visible = true;\n    this.replayPlayer.x = this.recordedStartX;\n    this.replayPlayer.y = this.recordedStartY;\n    \n    this.recordInfoText.setText('');\n  }\n\n  updateReplay(time) {\n    const elapsed = (time - this.replayStartTime) * this.replaySpeed;\n    \n    // 查找当前应该执行的动作\n    while (this.currentReplayIndex < this.actionLog.length) {\n      const action = this.actionLog[this.currentReplayIndex];\n      \n      if (action.time <= elapsed) {\n        // 执行动作\n        if (action.type === 'position') {\n          this.replayPlayer.x = action.x;\n          this.replayPlayer.y = action.y;\n        }\n        this.currentReplayIndex++;\n      } else {\n        break;\n      }\n    }\n    \n    // 回放结束\n    if (this.currentReplayIndex >= this.actionLog.length) {\n      this.stopReplay();\n    }\n  }\n\n  stopReplay() {\n    this.isReplaying = false;\n    this.replayPlayer.visible = false;\n    this.currentReplayIndex = 0;\n    this.recordInfoText.setText('回放完成！');\n  }\n\n  updateStatusText() {\n    let status = '';\n    \n    if (this.isRecording) {\n      const elapsed = this.time.now - this.recordStartTime;\n      const remaining = Math.max(0, (this.recordDuration - elapsed) / 1000).toFixed(1);\n      status = `🔴 录制中... 剩余时间: ${remaining}s`;\n    } else if (this.isReplaying) {\n      status = `▶️ 回放中... 速度: ${this.replaySpeed}x`;\n    } else {\n      status = `⏸️ 空闲 | 录制数据: ${this.actionLog.length} 个动作`;\n    }\n    \n    this.statusText.setText(status);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: RecordReplayScene,\n  parent: 'game-container'\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001879_v2", "prompt_id": "seed_001879", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.38666666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制一个六边形移动，速度为 300 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Phaser.GameObjects.Sprite\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建精灵对象并设置六边形纹理\n4. 监听 WASD 键盘输入\n5. 在 update 中根据按键状态移动六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 300;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制六边形（中心点在 40, 40）\n  const hexRadius = 30;\n  const centerX = 40;\n  const centerY = 40;\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 80, 80);\n  graphics.destroy();\n  \n  // 创建六边形精灵\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置键盘输入\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键并设置速度方向\n  if (keys.W.isDown) {\n    velocityY = -1;\n  }\n  if (keys.S.isDown) {\n    velocityY = 1;\n  }\n  if (keys.A.isDown) {\n    velocityX = -1;\n  }\n  if (keys.D.isDown) {\n    velocityX = 1;\n  }\n  \n  // 归一化对角线移动（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n  \n  // 更新六边形位置\n  hexagon.x += velocityX * distance;\n  hexagon.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000748_v2", "prompt_id": "seed_000748", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色方块以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 创建物理引擎配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制蓝色方块并生成纹理\n3. 创建物理精灵，设置初始速度为200\n4. 设置世界边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 不需要重力\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1);  // 蓝色\n  graphics.fillRect(0, 0, 50, 50);  // 50x50 的方块\n  \n  // 生成纹理\n  graphics.generateTexture('blueSquare', 50, 50);\n  graphics.destroy();  // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵，位置在画布中心\n  const square = this.physics.add.sprite(400, 300, 'blueSquare');\n  \n  // 设置初始速度（斜向移动，速度大小约为200）\n  // 使用勾股定理：sqrt(141^2 + 141^2) ≈ 200\n  square.setVelocity(141, 141);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000663_v2", "prompt_id": "seed_000663", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个蓝色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 20 个蓝色可复用对象，离屏自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, this.physics.add.group\nSTEPS:\n1. 创建蓝色方块纹理（使用 Graphics 生成）\n2. 使用 Physics.Arcade.Group 创建对象池，maxSize 设为 20\n3. 在 create 中批量创建 20 个物理精灵并加入对象池\n4. 设置随机速度让对象移动\n5. 在 update 中检测对象是否离开屏幕边界\n6. 离屏对象调用 setActive(false).setVisible(false) 回收到池中\n7. 定时从池中获取非活动对象并重新激活使用\n8. 添加 activeCount 状态信号用于验证对象池工作状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet activeCount = 0;\nlet recycledCount = 0;\nlet respawnCount = 0;\n\n// 对象池\nlet objectPool;\n\n// 显示文本\nlet statusText;\n\nfunction preload() {\n  // 使用 Graphics 创建蓝色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('blueBox', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建对象池（使用 Physics Group）\n  objectPool = this.physics.add.group({\n    defaultKey: 'blueBox',\n    maxSize: 20,\n    createCallback: function(sprite) {\n      // 设置物理属性\n      sprite.setCollideWorldBounds(false);\n      sprite.body.onWorldBounds = false;\n    }\n  });\n\n  // 初始化 20 个对象\n  for (let i = 0; i < 20; i++) {\n    const obj = objectPool.create(\n      Phaser.Math.Between(50, 750),\n      Phaser.Math.Between(50, 550),\n      'blueBox'\n    );\n    \n    // 设置随机速度\n    const velocityX = Phaser.Math.Between(-150, 150);\n    const velocityY = Phaser.Math.Between(-150, 150);\n    obj.setVelocity(velocityX, velocityY);\n    \n    // 添加自定义数据\n    obj.setData('id', i);\n  }\n\n  // 创建状态显示文本\n  statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 定时重新激活对象（每 2 秒）\n  this.time.addEvent({\n    delay: 2000,\n    callback: respawnObject,\n    callbackScope: this,\n    loop: true\n  });\n\n  updateStatusText();\n}\n\nfunction update(time, delta) {\n  activeCount = 0;\n\n  // 遍历对象池中的所有对象\n  objectPool.children.iterate(function(obj) {\n    if (obj.active) {\n      activeCount++;\n\n      // 检测是否离开屏幕\n      if (obj.x < -50 || obj.x > 850 || obj.y < -50 || obj.y > 650) {\n        // 回收对象\n        recycleObject(obj);\n      }\n    }\n  });\n\n  updateStatusText();\n}\n\n// 回收对象到池中\nfunction recycleObject(obj) {\n  obj.setActive(false);\n  obj.setVisible(false);\n  obj.body.stop();\n  recycledCount++;\n}\n\n// 从池中重新激活对象\nfunction respawnObject() {\n  // 获取第一个非活动对象\n  const obj = objectPool.getFirstDead(false);\n  \n  if (obj) {\n    // 重新激活对象\n    obj.setActive(true);\n    obj.setVisible(true);\n    \n    // 重置位置到屏幕中心附近\n    obj.setPosition(\n      Phaser.Math.Between(200, 600),\n      Phaser.Math.Between(150, 450)\n    );\n    \n    // 设置新的随机速度\n    const velocityX = Phaser.Math.Between(-150, 150);\n    const velocityY = Phaser.Math.Between(-150, 150);\n    obj.setVelocity(velocityX, velocityY);\n    \n    respawnCount++;\n  }\n}\n\n// 更新状态文本\nfunction updateStatusText() {\n  const totalObjects = objectPool.getLength();\n  const deadObjects = objectPool.countDead(false);\n  \n  statusText.setText([\n    `对象池状态:`,\n    `总对象数: ${totalObjects}`,\n    `活动对象: ${activeCount}`,\n    `池中对象: ${deadObjects}`,\n    `已回收次数: ${recycledCount}`,\n    `已重生次数: ${respawnCount}`,\n    '',\n    '提示: 蓝色方块离屏后自动回收',\n    '每 2 秒从池中重新激活一个对象'\n  ]);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000960_v2", "prompt_id": "seed_000960", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按空格键向当前朝向发射子弹，子弹速度 120，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现多方向射击系统，玩家可旋转朝向并按空格键发射子弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建玩家精灵，使用 Graphics 生成三角形纹理表示朝向\n2. 实现键盘输入监听（方向键旋转玩家，空格键发射子弹）\n3. 创建子弹物理组，使用 Graphics 生成圆形子弹纹理\n4. 在 update 中处理玩家旋转和子弹发射逻辑\n5. 添加状态信号变量记录射击次数和活跃子弹数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet shotsFired = 0;\nlet activeBullets = 0;\nlet player;\nlet bullets;\nlet cursors;\nlet spaceKey;\nlet lastFireTime = 0;\nconst fireRate = 250; // 发射间隔（毫秒）\n\nfunction preload() {\n  // 使用 Graphics 生成玩家纹理（三角形表示朝向）\n  const graphics = this.add.graphics();\n  \n  // 玩家纹理 - 三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(20, 0);\n  graphics.lineTo(0, 15);\n  graphics.lineTo(0, -15);\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.generateTexture('player', 20, 30);\n  graphics.clear();\n  \n  // 子弹纹理 - 小圆形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(4, 4, 4);\n  graphics.generateTexture('bullet', 8, 8);\n  graphics.clear();\n  \n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setDamping(true);\n  player.setDrag(0.95);\n  \n  // 创建子弹组\n  bullets = this.physics.add.group({\n    defaultKey: 'bullet',\n    maxSize: 50,\n    runChildUpdate: true\n  });\n  \n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n  \n  // 显示提示文本\n  this.add.text(10, 10, '方向键: 旋转玩家\\n空格键: 发射子弹', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n  \n  // 显示状态信息\n  this.statusText = this.add.text(10, 560, '', {\n    fontSize: '16px',\n    fill: '#00ff00'\n  });\n  \n  updateStatusText.call(this);\n}\n\nfunction update(time, delta) {\n  // 玩家旋转控制\n  const rotationSpeed = 3; // 旋转速度（度/帧）\n  \n  if (cursors.left.isDown) {\n    player.angle -= rotationSpeed;\n  }\n  \n  if (cursors.right.isDown) {\n    player.angle += rotationSpeed;\n  }\n  \n  // 发射子弹\n  if (Phaser.Input.Keyboard.JustDown(spaceKey) && time > lastFireTime + fireRate) {\n    fireBullet.call(this);\n    lastFireTime = time;\n  }\n  \n  // 清理超出边界的子弹\n  bullets.children.entries.forEach(bullet => {\n    if (bullet.active) {\n      if (bullet.x < -10 || bullet.x > 810 || bullet.y < -10 || bullet.y > 610) {\n        bullet.setActive(false);\n        bullet.setVisible(false);\n        activeBullets--;\n        updateStatusText.call(this);\n      }\n    }\n  });\n}\n\nfunction fireBullet() {\n  // 获取或创建子弹\n  let bullet = bullets.get(player.x, player.y);\n  \n  if (bullet) {\n    bullet.setActive(true);\n    bullet.setVisible(true);\n    \n    // 根据玩家朝向计算子弹速度\n    const angleInRadians = Phaser.Math.DegToRad(player.angle);\n    const velocityX = Math.cos(angleInRadians) * 300;\n    const velocityY = Math.sin(angleInRadians) * 300;\n    \n    bullet.setVelocity(velocityX, velocityY);\n    bullet.setRotation(angleInRadians);\n    \n    // 更新状态\n    shotsFired++;\n    activeBullets++;\n    updateStatusText.call(this);\n  }\n}\n\nfunction updateStatusText() {\n  if (this.statusText) {\n    this.statusText.setText(\n      `发射次数: ${shotsFired} | 活跃子弹: ${activeBullets}`\n    );\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001347_v2", "prompt_id": "seed_001347", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色方块以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成粉色方块纹理\n3. 创建物理精灵并设置初始速度为200\n4. 设置边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建粉色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('pinkSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  const square = this.physics.add.sprite(400, 300, 'pinkSquare');\n  \n  // 设置初始速度 (200速度，随机方向)\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 200;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 200;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000721_v3", "prompt_id": "seed_000721", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的绿色三角形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的绿色三角形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillTriangle, Graphics#fillStyle, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环20次，每次生成随机坐标位置\n4. 使用 fillTriangle 绘制等边三角形，计算三个顶点坐标\n5. 设置绿色填充样式，每个三角形大小为32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 三角形的大小（边长）\n  const triangleSize = 32;\n  \n  // 计算等边三角形的高度\n  const height = (Math.sqrt(3) / 2) * triangleSize;\n  \n  // 绘制20个随机位置的三角形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置，确保三角形完全在画布内\n    const x = Phaser.Math.Between(triangleSize, config.width - triangleSize);\n    const y = Phaser.Math.Between(triangleSize, config.height - triangleSize);\n    \n    // 计算等边三角形的三个顶点坐标（顶点朝上）\n    const x1 = x;                           // 顶点\n    const y1 = y - height / 2;\n    \n    const x2 = x - triangleSize / 2;        // 左下角\n    const y2 = y + height / 2;\n    \n    const x3 = x + triangleSize / 2;        // 右下角\n    const y3 = y + height / 2;\n    \n    // 绘制填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000303_v3", "prompt_id": "seed_000303", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每 1 秒从顶部随机位置生成一个白色下落障碍物，速度为 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 每秒从顶部随机位置生成白色下落障碍物，速度160\nAPI: Phaser.Time.Clock#addEvent, Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为0（手动控制速度）\n2. 在 create 中创建物理组用于管理障碍物\n3. 使用 Graphics 生成白色方块纹理作为障碍物外观\n4. 使用 addEvent 创建定时器，每1000ms触发一次生成逻辑\n5. 生成逻辑：随机 x 坐标，从顶部 y=-50 创建障碍物，设置 velocityY=160\n6. 添加 obstacleCount 变量作为可验证状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\n// 可验证的状态信号\nlet obstacleCount = 0;\nlet obstaclesGroup;\nlet spawnTimer;\n\nfunction preload() {\n  // 使用 Graphics 创建白色方块纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('obstacle', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理组用于管理障碍物\n  obstaclesGroup = this.physics.add.group({\n    defaultKey: 'obstacle',\n    maxSize: 50 // 限制最大数量，避免内存溢出\n  });\n\n  // 创建定时器，每 1000ms 生成一个障碍物\n  spawnTimer = this.time.addEvent({\n    delay: 1000,\n    callback: spawnObstacle,\n    callbackScope: this,\n    loop: true\n  });\n\n  // 显示状态信息（用于验证）\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 300, '白色障碍物每秒从顶部生成\\n速度: 160 px/s', {\n    fontSize: '24px',\n    fill: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nfunction spawnObstacle() {\n  // 随机 x 坐标（留出边距，避免障碍物被裁切）\n  const randomX = Phaser.Math.Between(20, 780);\n  \n  // 从物理组获取或创建障碍物\n  const obstacle = obstaclesGroup.get(randomX, -50);\n  \n  if (obstacle) {\n    // 激活并设置物理属性\n    obstacle.setActive(true);\n    obstacle.setVisible(true);\n    obstacle.setVelocityY(160); // 设置下落速度\n    \n    // 增加计数器\n    obstacleCount++;\n  }\n}\n\nfunction update() {\n  // 更新状态文本\n  if (this.statusText) {\n    this.statusText.setText(\n      `生成障碍物数量: ${obstacleCount}\\n` +\n      `活跃障碍物: ${obstaclesGroup.countActive(true)}`\n    );\n  }\n\n  // 清理超出屏幕的障碍物\n  obstaclesGroup.children.entries.forEach((obstacle) => {\n    if (obstacle.active && obstacle.y > 650) {\n      // 回收到对象池\n      obstacle.setActive(false);\n      obstacle.setVisible(false);\n      obstacle.setVelocity(0, 0);\n    }\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000822_v2", "prompt_id": "seed_000822", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 10 种不同颜色的粒子效果，可按WASD键切换当前粒子类型。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.GameObjects.Particles.ParticleEmitter", "output": "[PLAN]\nREQ: 实现10种不同颜色的粒子效果，支持WASD键切换粒子类型\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Particles.ParticleEmitter, Phaser.Input.Keyboard, Phaser.Scene\nSTEPS:\n1. 创建10种不同颜色的粒子纹理（使用Graphics生成）\n2. 初始化粒子发射器，设置初始粒子类型\n3. 监听WASD键盘输入，切换当前粒子类型索引\n4. 更新粒子发射器的纹理和颜色配置\n5. 显示当前粒子类型信息和状态变量\n[/PLAN]\n\n```javascript\nclass ParticleScene extends Phaser.Scene {\n  constructor() {\n    super('ParticleScene');\n    this.currentParticleIndex = 0;\n    this.switchCount = 0; // 可验证的状态信号：切换次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 定义10种粒子配置\n    this.particleConfigs = [\n      { name: 'Red Fire', color: 0xff0000, tint: [0xff0000, 0xff6600, 0xffaa00] },\n      { name: 'Blue Ice', color: 0x0088ff, tint: [0x0088ff, 0x00ccff, 0xaaffff] },\n      { name: 'Green Nature', color: 0x00ff00, tint: [0x00ff00, 0x88ff00, 0xaaff88] },\n      { name: 'Purple Magic', color: 0x8800ff, tint: [0x8800ff, 0xaa00ff, 0xff00ff] },\n      { name: 'Yellow Lightning', color: 0xffff00, tint: [0xffff00, 0xffdd00, 0xffaa00] },\n      { name: 'Cyan Water', color: 0x00ffff, tint: [0x00ffff, 0x00ddff, 0x88ffff] },\n      { name: 'Orange Flame', color: 0xff8800, tint: [0xff8800, 0xff6600, 0xff4400] },\n      { name: 'Pink Love', color: 0xff00ff, tint: [0xff00ff, 0xff88ff, 0xffaaff] },\n      { name: 'White Holy', color: 0xffffff, tint: [0xffffff, 0xdddddd, 0xaaaaaa] },\n      { name: 'Dark Shadow', color: 0x444444, tint: [0x444444, 0x666666, 0x888888] }\n    ];\n\n    // 创建粒子纹理\n    this.createParticleTextures();\n\n    // 创建粒子发射器\n    this.emitter = this.add.particles(400, 300, 'particle0', {\n      speed: { min: 100, max: 200 },\n      angle: { min: 0, max: 360 },\n      scale: { start: 1, end: 0 },\n      alpha: { start: 1, end: 0 },\n      lifespan: 2000,\n      blendMode: 'ADD',\n      frequency: 50,\n      maxParticles: 100,\n      tint: this.particleConfigs[0].tint\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 防止连续触发\n    this.lastSwitchTime = 0;\n    this.switchCooldown = 200; // 毫秒\n\n    // 创建UI文本\n    this.infoText = this.add.text(20, 20, '', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 10 }\n    });\n\n    this.instructionText = this.add.text(20, 80, \n      'Press W/A/S/D to switch particle types', {\n      fontSize: '16px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 状态信号文本\n    this.statusText = this.add.text(20, 120, '', {\n      fontSize: '16px',\n      color: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 更新显示\n    this.updateDisplay();\n  }\n\n  createParticleTextures() {\n    // 为每种颜色创建一个圆形粒子纹理\n    this.particleConfigs.forEach((config, index) => {\n      const graphics = this.add.graphics();\n      graphics.fillStyle(config.color, 1);\n      graphics.fillCircle(8, 8, 8);\n      graphics.generateTexture(`particle${index}`, 16, 16);\n      graphics.destroy();\n    });\n  }\n\n  update(time, delta) {\n    // 检查键盘输入\n    if (time - this.lastSwitchTime > this.switchCooldown) {\n      let switched = false;\n\n      if (Phaser.Input.Keyboard.JustDown(this.cursors.W)) {\n        this.currentParticleIndex = (this.currentParticleIndex + 1) % 10;\n        switched = true;\n      } else if (Phaser.Input.Keyboard.JustDown(this.cursors.A)) {\n        this.currentParticleIndex = (this.currentParticleIndex - 1 + 10) % 10;\n        switched = true;\n      } else if (Phaser.Input.Keyboard.JustDown(this.cursors.S)) {\n        this.currentParticleIndex = (this.currentParticleIndex + 2) % 10;\n        switched = true;\n      } else if (Phaser.Input.Keyboard.JustDown(this.cursors.D)) {\n        this.currentParticleIndex = (this.currentParticleIndex - 2 + 10) % 10;\n        switched = true;\n      }\n\n      if (switched) {\n        this.switchParticleType();\n        this.lastSwitchTime = time;\n        this.switchCount++; // 增加切换计数\n      }\n    }\n\n    // 更新状态显示\n    this.statusText.setText(\n      `Status: Switches=${this.switchCount} | Active=${this.emitter.getAliveParticleCount()} | Total=${this.emitter.getParticleCount()}`\n    );\n  }\n\n  switchParticleType() {\n    const config = this.particleConfigs[this.currentParticleIndex];\n    \n    // 更新粒子发射器的纹理和颜色\n    this.emitter.setTexture(`particle${this.currentParticleIndex}`);\n    this.emitter.setTint(config.tint);\n    \n    // 短暂爆发效果以展示新粒子\n    this.emitter.explode(20);\n    \n    // 更新显示信息\n    this.updateDisplay();\n  }\n\n  updateDisplay() {\n    const config = this.particleConfigs[this.currentParticleIndex];\n    this.infoText.setText(\n      `Current: ${config.name} (${this.currentParticleIndex + 1}/10)`\n    );\n    \n    // 更新信息文本颜色以匹配当前粒子\n    this.infoText.setColor('#' + config.color.toString(16).padStart(6, '0'));\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: ParticleScene,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }\n    }\n  }\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001820_v2", "prompt_id": "seed_001820", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Particles"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个灰色圆形移动，移动速度为 80，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制灰色圆形移动，速度80，限制在画布边界内\nAPI: Graphics.fillCircle, Input.Keyboard.createCursorKeys, GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制灰色圆形并生成纹理\n2. 创建 Sprite 对象作为可移动的圆形\n3. 获取方向键输入对象\n4. 在 update 中检测方向键状态并更新位置\n5. 使用 Phaser.Math.Clamp 限制位置在画布边界内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet circle;\nlet cursors;\nconst SPEED = 80;\nconst RADIUS = 25;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillCircle(RADIUS, RADIUS, RADIUS);\n  graphics.generateTexture('circleTexture', RADIUS * 2, RADIUS * 2);\n  graphics.destroy();\n\n  // 创建圆形精灵，初始位置在画布中心\n  circle = this.add.sprite(400, 300, 'circleTexture');\n\n  // 获取方向键输入\n  cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间差 / 1000 转换为秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据方向键输入更新位置\n  if (cursors.left.isDown) {\n    circle.x -= distance;\n  }\n  if (cursors.right.isDown) {\n    circle.x += distance;\n  }\n  if (cursors.up.isDown) {\n    circle.y -= distance;\n  }\n  if (cursors.down.isDown) {\n    circle.y += distance;\n  }\n\n  // 限制圆形位置在画布边界内\n  circle.x = Phaser.Math.Clamp(circle.x, RADIUS, config.width - RADIUS);\n  circle.y = Phaser.Math.Clamp(circle.y, RADIUS, config.height - RADIUS);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000366_v3", "prompt_id": "seed_000366", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现白色移动平台：平台以 200 速度水平往返移动，玩家可站在上面并跟随移动，重力 500。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现白色移动平台，玩家可站在上面跟随移动，平台以200速度水平往返\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Body, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard\nSTEPS:\n1. 创建白色平台精灵，设置为物理对象，immovable=true，velocity.x=200\n2. 创建玩家精灵，设置重力500，添加碰撞检测\n3. 在update中检测平台边界，到达边界时反转速度\n4. 使用collider处理玩家与平台碰撞，玩家站在平台上时跟随移动\n5. 添加键盘控制让玩家可以左右移动和跳跃\n6. 添加状态变量记录平台移动次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.platformBounceCount = 0; // 状态信号：平台反弹次数\n    this.playerOnPlatform = false; // 玩家是否在平台上\n  }\n\n  preload() {\n    // 创建白色平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0xffffff, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platformTex', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建蓝色玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 50);\n    playerGraphics.generateTexture('playerTex', 40, 50);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x666666, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('groundTex', 800, 40);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 添加信息文本\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建地面\n    this.ground = this.physics.add.sprite(400, 580, 'groundTex');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(400, 400, 'platformTex');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.setVelocityX(200); // 初始向右移动\n    \n    // 设置平台移动范围\n    this.platformMinX = 100;\n    this.platformMaxX = 700;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 200, 'playerTex');\n    this.player.setGravityY(500); // 设置重力\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.platform, this.onPlayerPlatformCollide, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 添加说明文本\n    this.add.text(10, 560, '方向键移动，空格跳跃', {\n      fontSize: '14px',\n      fill: '#ffffff'\n    });\n  }\n\n  onPlayerPlatformCollide(player, platform) {\n    // 检测玩家是否在平台上方（而不是侧面或下方碰撞）\n    if (player.body.touching.down && platform.body.touching.up) {\n      this.playerOnPlatform = true;\n    }\n  }\n\n  update(time, delta) {\n    // 更新平台移动\n    if (this.platform.x <= this.platformMinX) {\n      this.platform.x = this.platformMinX;\n      this.platform.setVelocityX(200); // 向右移动\n      this.platformBounceCount++;\n    } else if (this.platform.x >= this.platformMaxX) {\n      this.platform.x = this.platformMaxX;\n      this.platform.setVelocityX(-200); // 向左移动\n      this.platformBounceCount++;\n    }\n\n    // 检测玩家是否仍在平台上\n    const wasOnPlatform = this.playerOnPlatform;\n    this.playerOnPlatform = false;\n\n    // 如果玩家在平台上，让玩家跟随平台移动\n    if (this.physics.overlap(this.player, this.platform)) {\n      if (this.player.body.touching.down && this.platform.body.touching.up) {\n        this.playerOnPlatform = true;\n        // 玩家跟随平台水平移动\n        this.player.x += this.platform.body.velocity.x * (delta / 1000);\n      }\n    }\n\n    // 玩家左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      // 如果在平台上，保持平台速度；否则停止\n      if (!this.playerOnPlatform) {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      if (this.player.body.touching.down) {\n        this.player.setVelocityY(-400);\n      }\n    }\n\n    // 更新信息显示\n    this.infoText.setText([\n      `Platform Bounces: ${this.platformBounceCount}`,\n      `Player On Platform: ${this.playerOnPlatform}`,\n      `Platform X: ${Math.round(this.platform.x)}`,\n      `Platform Velocity: ${this.platform.body.velocity.x}`,\n      `Player Y: ${Math.round(this.player.y)}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 全局重力设为0，单独给玩家设置\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001899_v2", "prompt_id": "seed_001899", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 10 个金币，重力 300，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集10个金币，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，设置重力为300\n2. 使用Graphics绘制玩家（矩形）、平台（矩形）、金币（圆形）纹理\n3. 创建玩家精灵，添加物理属性和碰撞体\n4. 创建静态平台组，包含地面和几个跳跃平台\n5. 创建金币组（10个），随机分布在空中\n6. 添加键盘输入（方向键），实现左右移动和跳跃\n7. 设置玩家与平台、金币的碰撞检测\n8. 实现金币收集逻辑，更新分数显示\n9. 添加分数文本显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet platforms;\nlet coins;\nlet cursors;\nlet score = 0;\nlet scoreText;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x0088ff, 1);\n  playerGraphics.fillRect(0, 0, 32, 48);\n  playerGraphics.generateTexture('player', 32, 48);\n  playerGraphics.destroy();\n\n  // 创建平台纹理（绿色矩形）\n  const platformGraphics = this.add.graphics();\n  platformGraphics.fillStyle(0x00ff00, 1);\n  platformGraphics.fillRect(0, 0, 200, 20);\n  platformGraphics.generateTexture('platform', 200, 20);\n  platformGraphics.destroy();\n\n  // 创建地面纹理（深绿色）\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x008800, 1);\n  groundGraphics.fillRect(0, 0, 800, 32);\n  groundGraphics.generateTexture('ground', 800, 32);\n  groundGraphics.destroy();\n\n  // 创建金币纹理（黄色圆形）\n  const coinGraphics = this.add.graphics();\n  coinGraphics.fillStyle(0xffff00, 1);\n  coinGraphics.fillCircle(16, 16, 16);\n  coinGraphics.generateTexture('coin', 32, 32);\n  coinGraphics.destroy();\n}\n\nfunction create() {\n  // 创建平台组\n  platforms = this.physics.add.staticGroup();\n\n  // 添加地面\n  platforms.create(400, 584, 'ground');\n\n  // 添加跳跃平台\n  platforms.create(100, 450, 'platform');\n  platforms.create(300, 350, 'platform');\n  platforms.create(500, 280, 'platform');\n  platforms.create(700, 400, 'platform');\n  platforms.create(600, 200, 'platform');\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 500, 'player');\n  player.setBounce(0.1);\n  player.setCollideWorldBounds(true);\n\n  // 玩家与平台碰撞\n  this.physics.add.collider(player, platforms);\n\n  // 创建金币组\n  coins = this.physics.add.group();\n\n  // 在平台上方创建10个金币\n  const coinPositions = [\n    { x: 100, y: 400 },\n    { x: 300, y: 300 },\n    { x: 500, y: 230 },\n    { x: 700, y: 350 },\n    { x: 600, y: 150 },\n    { x: 200, y: 250 },\n    { x: 400, y: 180 },\n    { x: 650, y: 450 },\n    { x: 150, y: 350 },\n    { x: 550, y: 320 }\n  ];\n\n  coinPositions.forEach(pos => {\n    const coin = coins.create(pos.x, pos.y, 'coin');\n    coin.setBounce(0.2);\n    coin.setCollideWorldBounds(true);\n  });\n\n  // 金币与平台碰撞\n  this.physics.add.collider(coins, platforms);\n\n  // 玩家收集金币\n  this.physics.add.overlap(player, coins, collectCoin, null, this);\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#fff',\n    fontFamily: 'Arial',\n    stroke: '#000',\n    strokeThickness: 4\n  });\n  scoreText.setDepth(100);\n\n  // 添加游戏说明\n  this.add.text(16, 56, 'Arrow Keys: Move & Jump', {\n    fontSize: '16px',\n    fill: '#fff',\n    fontFamily: 'Arial',\n    stroke: '#000',\n    strokeThickness: 2\n  });\n}\n\nfunction update() {\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃（只能在地面或平台上跳跃）\n  if (cursors.up.isDown && player.body.touching.down) {\n    player.setVelocityY(-400);\n  }\n\n  // 检查是否收集完所有金币\n  if (score === 10 && coins.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - YOU WIN!');\n  }\n}\n\nfunction collectCoin(player, coin) {\n  // 移除金币\n  coin.disableBody(true, true);\n\n  // 增加分数\n  score += 1;\n  scoreText.setText('Score: ' + score);\n\n  // 播放简单的视觉反馈\n  const flash = this.add.graphics();\n  flash.fillStyle(0xffff00, 0.5);\n  flash.fillCircle(coin.x, coin.y, 32);\n  this.tweens.add({\n    targets: flash,\n    alpha: 0,\n    duration: 300,\n    onComplete: () => flash.destroy()\n  });\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001375_v2", "prompt_id": "seed_001375", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.42000000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让粉色星形在 1.5 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色星形并使用 Tween 实现 1.5 秒循环缩放动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 tweens.add 创建缩放动画，设置 duration 为 1500ms，yoyo 和 repeat -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  function drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillStyle(color, 1);\n    graphics.fillPath();\n  }\n\n  // 绘制粉色星形\n  graphics.clear();\n  drawStar(graphics, 60, 60, 5, 50, 25, 0xff69b4);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkStar', 120, 120);\n  graphics.destroy();\n\n  // 创建星形精灵并居中\n  const star = this.add.sprite(400, 300, 'pinkStar');\n\n  // 创建缩放动画\n  // 从原始大小缩放到 1.5 倍，然后返回，持续 1.5 秒，无限循环\n  this.tweens.add({\n    targets: star,\n    scaleX: 1.5,\n    scaleY: 1.5,\n    duration: 1500,\n    yoyo: true,        // 动画结束后反向播放\n    repeat: -1,        // 无限循环 (-1 表示永远重复)\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000282_v2", "prompt_id": "seed_000282", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 15 个青色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成15个青色可收集物体，玩家碰撞后消失并加分\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建带物理系统的游戏配置\n2. 使用 Graphics 生成玩家和可收集物体的纹理\n3. 创建物理精灵组存放15个青色收集物\n4. 添加键盘控制让玩家移动\n5. 使用 overlap 检测碰撞，触发收集逻辑\n6. 更新分数显示文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（红色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0xff0000, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（青色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0x00ffff, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('collectible', 24, 24);\n    itemGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集物品组\n    this.collectibles = this.physics.add.group();\n\n    // 生成15个收集物，随机分布在场景中\n    for (let i = 0; i < 15; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 400);\n      const item = this.collectibles.create(x, y, 'collectible');\n      item.setCircle(12); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加提示文本\n    this.add.text(400, 550, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update() {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n\n  collectItem(player, item) {\n    // 收集物品消失\n    item.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0) {\n      this.add.text(400, 300, 'ALL COLLECTED!', {\n        fontSize: '48px',\n        fill: '#00ff00',\n        fontFamily: 'Arial'\n      }).setOrigin(0.5);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001076_v2", "prompt_id": "seed_001076", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setAlpha\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建使用该纹理的精灵对象\n3. 使用 Tween 动画控制精灵的 alpha 属性从 0 到 1\n4. 设置 Tween 为循环播放模式\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100; // 绘制中心点\n  const centerY = 100;\n  \n  // 绘制填充的六边形\n  graphics.fillStyle(0x00ff00, 1); // 绿色填充\n  graphics.lineStyle(4, 0xffffff, 1); // 白色边框\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算六边形的六个顶点并绘制\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexSprite.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: hexSprite,\n    alpha: 1, // 目标透明度：完全不透明\n    duration: 1000, // 持续时间：1 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（透明->不透明->透明）\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '六边形透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000073_v3", "prompt_id": "seed_000073", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让红色矩形在 2 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色矩形的缩放循环动画，2秒完成一次缩放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建缩放动画，设置 yoyo 和 repeat 实现循环效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建红色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('redRect', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象，放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'redRect');\n  \n  // 创建缩放动画\n  // 从原始大小缩放到 1.5 倍，然后返回，持续 2 秒，无限循环\n  this.tweens.add({\n    targets: rect,\n    scaleX: 1.5,\n    scaleY: 1.5,\n    duration: 1000, // 1秒放大\n    yoyo: true,     // 动画结束后反向播放（缩回原大小）\n    repeat: -1,     // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000355_v2", "prompt_id": "seed_000355", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形和一个标记线（用于观察旋转）\n2. 将 Graphics 添加到 Container 中以便控制旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（200度/秒）\n4. 应用旋转到 Container 上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circleContainer;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制圆形主体\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的线，用于观察旋转\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, 0);\n  graphics.lineTo(80, 0);\n  graphics.strokePath();\n  \n  // 在圆边缘添加一个小圆点作为旋转标记\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(80, 0, 10);\n  \n  // 创建容器并将 Graphics 添加到容器中\n  // 使用容器可以更方便地控制整体旋转\n  circleContainer = this.add.container(400, 300);\n  circleContainer.add(graphics);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形以每秒 200° 旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的帧间隔时间\n  // 将 delta 转换为秒：delta / 1000\n  // 每秒旋转 200 度，转换为弧度：Phaser.Math.DegToRad(200)\n  const rotationSpeed = Phaser.Math.DegToRad(200); // 每秒旋转的弧度\n  const deltaInSeconds = delta / 1000;\n  \n  // 累加旋转角度\n  circleContainer.rotation += rotationSpeed * deltaInSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000301_v2", "prompt_id": "seed_000301", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的青色椭圆，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个可拖拽的青色椭圆，拖拽时改变颜色，松手后回到初始位置\nAPI: Graphics.fillEllipse, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆并生成纹理\n2. 创建 Sprite 并设置为可交互和可拖拽\n3. 监听 dragstart 事件改变颜色为黄色\n4. 监听 drag 事件更新椭圆位置\n5. 监听 dragend 事件恢复青色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n  \n  // 创建青色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillEllipse(50, 40, 100, 80); // 在纹理中心绘制椭圆\n  graphics.generateTexture('cyanEllipse', 100, 80);\n  graphics.destroy();\n  \n  // 创建黄色椭圆纹理（拖拽时使用）\n  const graphicsYellow = this.add.graphics();\n  graphicsYellow.fillStyle(0xffff00, 1); // 黄色\n  graphicsYellow.fillEllipse(50, 40, 100, 80);\n  graphicsYellow.generateTexture('yellowEllipse', 100, 80);\n  graphicsYellow.destroy();\n  \n  // 创建椭圆精灵\n  const ellipse = this.add.sprite(initialX, initialY, 'cyanEllipse');\n  \n  // 设置为可交互和可拖拽\n  ellipse.setInteractive({ draggable: true });\n  \n  // 监听拖拽开始事件\n  ellipse.on('dragstart', function(pointer) {\n    // 改变为黄色\n    this.setTexture('yellowEllipse');\n  });\n  \n  // 监听拖拽中事件\n  ellipse.on('drag', function(pointer, dragX, dragY) {\n    // 更新椭圆位置\n    this.x = dragX;\n    this.y = dragY;\n  });\n  \n  // 监听拖拽结束事件\n  ellipse.on('dragend', function(pointer) {\n    // 恢复青色\n    this.setTexture('cyanEllipse');\n    \n    // 回到初始位置\n    this.x = initialX;\n    this.y = initialY;\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 50, '拖拽青色椭圆试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000295_v2", "prompt_id": "seed_000295", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制三角形\n2. 在 create 中设置三角形的位置和初始旋转\n3. 在 update 中根据 delta 时间增量更新旋转角度（160度/秒 = 160 * (Math.PI/180) 弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心在原点）\n  const size = 80;\n  const height = size * Math.sqrt(3) / 2;\n  graphics.fillTriangle(\n    0, -height * 2/3,           // 顶点\n    -size/2, height * 1/3,      // 左下\n    size/2, height * 1/3        // 右下\n  );\n  \n  // 设置三角形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 存储到 scene 数据中，便于在 update 中访问\n  this.triangle = graphics;\n  \n  // 添加文字提示\n  this.add.text(10, 10, '三角形以每秒 160° 旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 每秒旋转 160 度，转换为弧度\n  const rotationSpeed = 160 * (Math.PI / 180); // 弧度/秒\n  \n  // 更新旋转角度\n  this.triangle.rotation += rotationSpeed * deltaSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000424_v3", "prompt_id": "seed_000424", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 3 种不同颜色的粒子效果，可按鼠标左键切换当前粒子类型。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.GameObjects.Particles.ParticleEmitter", "output": "[PLAN]\nREQ: 实现3种不同颜色的粒子效果，鼠标左键切换粒子类型\nAPI: ParticleEmitter, Graphics.generateTexture, input.on, ParticleEmitter.setConfig\nSTEPS:\n1. 创建3种颜色的粒子纹理（红、绿、蓝）\n2. 初始化粒子发射器，默认使用第一种颜色\n3. 监听鼠标左键点击事件，切换粒子类型\n4. 更新粒子发射器配置（颜色、速度、生命周期等）\n5. 添加状态变量记录当前粒子类型索引\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态变量\nlet currentParticleType = 0; // 当前粒子类型索引 (0=红色, 1=绿色, 2=蓝色)\nlet particleEmitter = null;\nlet particleTextures = [];\nlet statusText = null;\n\n// 粒子配置数组\nconst particleConfigs = [\n  {\n    name: 'Red Particles',\n    color: 0xff0000,\n    speed: { min: 100, max: 200 },\n    scale: { start: 1, end: 0 },\n    lifespan: 2000,\n    frequency: 50,\n    quantity: 2\n  },\n  {\n    name: 'Green Particles',\n    color: 0x00ff00,\n    speed: { min: 150, max: 300 },\n    scale: { start: 0.5, end: 1.5 },\n    lifespan: 1500,\n    frequency: 30,\n    quantity: 3\n  },\n  {\n    name: 'Blue Particles',\n    color: 0x0099ff,\n    speed: { min: 50, max: 150 },\n    scale: { start: 1.5, end: 0.2 },\n    lifespan: 3000,\n    frequency: 80,\n    quantity: 1\n  }\n];\n\nfunction preload() {\n  // 预加载阶段（本例使用 Graphics 生成纹理，无需预加载外部资源）\n}\n\nfunction create() {\n  // 创建3种颜色的粒子纹理\n  particleTextures = createParticleTextures(this);\n  \n  // 创建粒子发射器（初始使用第一种类型）\n  particleEmitter = this.add.particles(400, 300, particleTextures[0], {\n    speed: particleConfigs[0].speed,\n    scale: particleConfigs[0].scale,\n    lifespan: particleConfigs[0].lifespan,\n    frequency: particleConfigs[0].frequency,\n    quantity: particleConfigs[0].quantity,\n    blendMode: 'ADD',\n    angle: { min: 0, max: 360 }\n  });\n  \n  // 创建状态显示文本\n  statusText = this.add.text(10, 10, '', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#00000088',\n    padding: { x: 10, y: 5 }\n  });\n  updateStatusText();\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Click Left Mouse Button to Switch Particle Type', {\n    fontSize: '18px',\n    color: '#ffff00'\n  }).setOrigin(0.5);\n  \n  // 监听鼠标左键点击事件\n  this.input.on('pointerdown', (pointer) => {\n    if (pointer.leftButtonDown()) {\n      switchParticleType(this);\n    }\n  });\n  \n  // 让粒子发射器跟随鼠标\n  this.input.on('pointermove', (pointer) => {\n    particleEmitter.setPosition(pointer.x, pointer.y);\n  });\n}\n\nfunction update(time, delta) {\n  // 每帧更新逻辑（本例中粒子系统自动更新）\n}\n\n/**\n * 创建3种颜色的粒子纹理\n */\nfunction createParticleTextures(scene) {\n  const textures = [];\n  const colors = [0xff0000, 0x00ff00, 0x0099ff]; // 红、绿、蓝\n  \n  colors.forEach((color, index) => {\n    const graphics = scene.add.graphics();\n    \n    // 绘制圆形粒子\n    graphics.fillStyle(color, 1);\n    graphics.fillCircle(8, 8, 8);\n    \n    // 添加外发光效果\n    graphics.fillStyle(color, 0.5);\n    graphics.fillCircle(8, 8, 12);\n    \n    // 生成纹理\n    const textureName = `particle_${index}`;\n    graphics.generateTexture(textureName, 16, 16);\n    graphics.destroy();\n    \n    textures.push(textureName);\n  });\n  \n  return textures;\n}\n\n/**\n * 切换粒子类型\n */\nfunction switchParticleType(scene) {\n  // 切换到下一个粒子类型\n  currentParticleType = (currentParticleType + 1) % particleConfigs.length;\n  \n  const config = particleConfigs[currentParticleType];\n  \n  // 更新粒子发射器配置\n  particleEmitter.setTexture(particleTextures[currentParticleType]);\n  particleEmitter.setSpeed(config.speed);\n  particleEmitter.setScale(config.scale);\n  particleEmitter.setLifespan(config.lifespan);\n  particleEmitter.setFrequency(config.frequency);\n  particleEmitter.setQuantity(config.quantity);\n  \n  // 更新状态文本\n  updateStatusText();\n  \n  // 添加视觉反馈（屏幕闪烁效果）\n  scene.cameras.main.flash(200, \n    config.color >> 16 & 0xff, \n    config.color >> 8 & 0xff, \n    config.color & 0xff\n  );\n}\n\n/**\n * 更新状态显示文本\n */\nfunction updateStatusText() {\n  const config = particleConfigs[currentParticleType];\n  const colorName = ['Red', 'Green', 'Blue'][currentParticleType];\n  \n  statusText.setText([\n    `Current Particle Type: ${currentParticleType}`,\n    `Name: ${config.name}`,\n    `Color: ${colorName}`,\n    `Lifespan: ${config.lifespan}ms`,\n    `Frequency: ${config.frequency}ms`,\n    `Quantity: ${config.quantity}`\n  ]);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001871_v2", "prompt_id": "seed_001871", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Particles"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现点击画面生成三角形的功能：每次点击生成一个随机颜色的三角形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画面生成随机颜色的三角形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Phaser.GameObjects.Triangle\nSTEPS:\n1. 创建 Scene 并配置输入系统\n2. 监听 POINTER_DOWN 事件获取点击坐标\n3. 使用 Graphics 或 Triangle 对象在点击位置绘制随机颜色的三角形\n4. 每次点击生成新的三角形并添加到场景中\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 添加提示文本\n  const text = this.add.text(400, 30, '点击画面生成三角形', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n\n  // 监听点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 生成随机颜色\n    const randomColor = Phaser.Display.Color.RandomRGB();\n    const colorValue = Phaser.Display.Color.GetColor(randomColor.r, randomColor.g, randomColor.b);\n\n    // 创建 Graphics 对象绘制三角形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(colorValue, 1);\n\n    // 定义三角形的三个顶点（相对于点击位置）\n    const size = Phaser.Math.Between(30, 60); // 随机大小\n    const rotation = Phaser.Math.Between(0, 360) * Math.PI / 180; // 随机旋转角度\n\n    // 计算三个顶点坐标（等边三角形）\n    const point1 = {\n      x: pointer.x + Math.cos(rotation) * size,\n      y: pointer.y + Math.sin(rotation) * size\n    };\n    const point2 = {\n      x: pointer.x + Math.cos(rotation + (2 * Math.PI / 3)) * size,\n      y: pointer.y + Math.sin(rotation + (2 * Math.PI / 3)) * size\n    };\n    const point3 = {\n      x: pointer.x + Math.cos(rotation + (4 * Math.PI / 3)) * size,\n      y: pointer.y + Math.sin(rotation + (4 * Math.PI / 3)) * size\n    };\n\n    // 绘制填充三角形\n    graphics.fillTriangle(\n      point1.x, point1.y,\n      point2.x, point2.y,\n      point3.x, point3.y\n    );\n\n    // 添加描边效果\n    graphics.lineStyle(2, 0xffffff, 0.5);\n    graphics.strokeTriangle(\n      point1.x, point1.y,\n      point2.x, point2.y,\n      point3.x, point3.y\n    );\n\n    // 添加淡入效果\n    graphics.setAlpha(0);\n    this.tweens.add({\n      targets: graphics,\n      alpha: 1,\n      duration: 200,\n      ease: 'Power2'\n    });\n\n    // 可选：添加点击反馈音效（使用简单的视觉反馈代替）\n    const clickFeedback = this.add.circle(pointer.x, pointer.y, 5, 0xffffff, 0.8);\n    this.tweens.add({\n      targets: clickFeedback,\n      scale: 3,\n      alpha: 0,\n      duration: 300,\n      ease: 'Power2',\n      onComplete: () => {\n        clickFeedback.destroy();\n      }\n    });\n  });\n\n  // 添加清空按钮\n  const clearButton = this.add.text(400, 570, '[ 点击此处清空所有三角形 ]', {\n    fontSize: '16px',\n    color: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  clearButton.setOrigin(0.5);\n  clearButton.setInteractive({ useHandCursor: true });\n\n  clearButton.on('pointerdown', () => {\n    // 清除所有 Graphics 对象\n    const allGraphics = this.children.list.filter(child => child instanceof Phaser.GameObjects.Graphics);\n    allGraphics.forEach(graphic => graphic.destroy());\n  });\n\n  clearButton.on('pointerover', () => {\n    clearButton.setStyle({ color: '#ffffff' });\n  });\n\n  clearButton.on('pointerout', () => {\n    clearButton.setStyle({ color: '#ffff00' });\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000302_v3", "prompt_id": "seed_000302", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 300，移动速度 160，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现带重力的平台跳跃游戏，角色可左右移动和跳跃，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 300\n2. 使用 Graphics 创建玩家和地面的纹理\n3. 创建玩家精灵并设置物理属性（碰撞边界、反弹等）\n4. 创建地面平台组并设置为静态物理体\n5. 添加键盘输入监听（左右方向键和空格跳跃）\n6. 在 update 中处理移动逻辑和跳跃逻辑\n7. 添加状态变量记录跳跃次数作为验证信号\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 平台跳跃游戏\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false; // 是否在地面上\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00aa00, 1);\n    groundGraphics.fillRect(0, 0, 200, 32);\n    groundGraphics.generateTexture('ground', 200, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0); // 不反弹\n    this.player.setCollideWorldBounds(true); // 与世界边界碰撞\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加多个平台\n    this.platforms.create(400, 568, 'ground').setScale(4, 1).refreshBody(); // 底部地面\n    this.platforms.create(600, 450, 'ground'); // 右侧平台\n    this.platforms.create(200, 450, 'ground'); // 左侧平台\n    this.platforms.create(400, 350, 'ground').setScale(0.8, 1).refreshBody(); // 中间平台\n\n    // 设置玩家与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      // 碰撞回调，检测是否在地面上\n      if (this.player.body.touching.down) {\n        this.isGrounded = true;\n      }\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(16, 50, '← → 移动  空格/↑ 跳跃', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新状态文本\n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount}\\n` +\n      `速度: ${Math.abs(this.player.body.velocity.x).toFixed(0)}\\n` +\n      `高度: ${(600 - this.player.y).toFixed(0)}`\n    );\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      // 没有按键时停止水平移动\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（空格键或上方向键）\n    const jumpPressed = Phaser.Input.Keyboard.JustDown(this.cursors.up) || \n                       Phaser.Input.Keyboard.JustDown(this.spaceKey);\n    \n    if (jumpPressed && this.player.body.touching.down) {\n      this.player.setVelocityY(-400); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n      this.isGrounded = false;\n    }\n\n    // 检测是否离开地面\n    if (!this.player.body.touching.down) {\n      this.isGrounded = false;\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB', // 天空蓝背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 }, // 重力设置为 300\n      debug: false // 设置为 true 可查看物理边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001085_v3", "prompt_id": "seed_001085", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 160 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建游戏配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 绘制椭圆并生成纹理\n3. 创建椭圆精灵对象并设置到画布中心\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态更新椭圆位置，应用速度 160 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 使用 Graphics 程序化生成椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40,30)，宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建椭圆精灵，放置在画布中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  \n  // 添加 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算实际移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新椭圆位置\n  if (keys.w.isDown) {\n    ellipse.y -= distance;\n  }\n  if (keys.s.isDown) {\n    ellipse.y += distance;\n  }\n  if (keys.a.isDown) {\n    ellipse.x -= distance;\n  }\n  if (keys.d.isDown) {\n    ellipse.x += distance;\n  }\n  \n  // 边界限制（可选，防止椭圆移出画布）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 40, 760);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 30, 570);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000599_v3", "prompt_id": "seed_000599", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让紫色菱形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色菱形，使用 Tween 动画实现 1.5 秒闪烁循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制紫色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 值在 0-1 之间变化，持续 1.5 秒\n4. 设置 yoyo 和 repeat: -1 实现循环闪烁效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建紫色菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（使用四个点连接）\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵并放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建闪烁动画\n  // 使用 Tween 控制 alpha 值实现闪烁效果\n  this.tweens.add({\n    targets: diamond,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 750,      // 单程持续 750ms\n    yoyo: true,         // 往返动画（0->1->0）\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '紫色菱形闪烁动画 (1.5秒/次)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000106_v2", "prompt_id": "seed_000106", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 200，移动速度 300，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色可左右移动和跳跃，具有重力和地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 200\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建物理精灵作为角色，设置碰撞体积\n4. 创建静态物理组作为地面平台\n5. 设置角色与地面的碰撞检测\n6. 监听键盘输入（方向键），实现左右移动（速度 300）和跳跃\n7. 添加状态变量记录跳跃次数和是否在地面\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号：跳跃次数\n    this.isGrounded = false; // 可验证的状态信号：是否在地面\n    this.moveDistance = 0; // 可验证的状态信号：移动距离\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0099ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 200, 40);\n    groundGraphics.generateTexture('ground', 200, 40);\n    groundGraphics.destroy();\n\n    // 创建角色精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true); // 角色不超出世界边界\n    this.player.body.setGravityY(200); // 设置重力为 200\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加多个平台\n    this.platforms.create(400, 568, 'ground').setScale(4, 1).refreshBody(); // 主地面\n    this.platforms.create(200, 450, 'ground').setScale(1.5, 1).refreshBody(); // 左侧平台\n    this.platforms.create(600, 400, 'ground').setScale(1.5, 1).refreshBody(); // 右侧平台\n    this.platforms.create(400, 250, 'ground').setScale(1, 1).refreshBody(); // 顶部平台\n\n    // 设置角色与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(16, 60, '← → 移动 | ↑ 或 空格 跳跃', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新状态信息\n    this.statusText.setText([\n      `跳跃次数: ${this.jumpCount}`,\n      `移动距离: ${Math.floor(this.moveDistance)}`,\n      `在地面: ${this.isGrounded ? '是' : '否'}`,\n      `速度Y: ${Math.floor(this.player.body.velocity.y)}`\n    ]);\n\n    // 检测是否在地面（通过垂直速度判断）\n    if (this.player.body.touching.down) {\n      this.isGrounded = true;\n    } else {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300); // 向左移动，速度 300\n      this.moveDistance += Math.abs(delta * 0.3); // 累计移动距离\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300); // 向右移动，速度 300\n      this.moveDistance += Math.abs(delta * 0.3);\n    } else {\n      this.player.setVelocityX(0); // 停止移动\n    }\n\n    // 跳跃控制（上方向键或空格键）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.isGrounded) {\n      this.player.setVelocityY(-400); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n      this.isGrounded = false; // 离开地面\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB', // 天蓝色背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 全局重力设为 0，由角色自身重力控制\n      debug: false // 设为 true 可查看碰撞边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000885_v2", "prompt_id": "seed_000885", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 1.5 秒在随机位置生成一个蓝色矩形，最多生成 15 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔1.5秒在随机位置生成蓝色矩形，最多15个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Math.Between\nSTEPS:\n1. 创建 Scene 配置，初始化计数器变量\n2. 在 create 中使用 Graphics 创建蓝色矩形纹理\n3. 使用 time.addEvent 创建定时器，每1.5秒触发一次\n4. 在定时器回调中生成随机位置的矩形，并检查数量限制\n5. 当矩形数量达到15个时停止定时器\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet rectangleCount = 0;\nconst MAX_RECTANGLES = 15;\nlet timerEvent = null;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建蓝色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1);\n  graphics.fillRect(0, 0, 40, 30);\n  graphics.generateTexture('blueRect', 40, 30);\n  graphics.destroy();\n\n  // 添加文本提示\n  this.add.text(10, 10, '蓝色矩形将每1.5秒生成一个，最多15个', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n\n  const countText = this.add.text(10, 35, `已生成: 0 / ${MAX_RECTANGLES}`, {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n\n  // 创建定时器事件，每1.5秒触发一次\n  timerEvent = this.time.addEvent({\n    delay: 1500, // 1.5秒 = 1500毫秒\n    callback: () => {\n      // 检查是否达到最大数量\n      if (rectangleCount < MAX_RECTANGLES) {\n        // 生成随机位置\n        const randomX = Phaser.Math.Between(0, config.width - 40);\n        const randomY = Phaser.Math.Between(60, config.height - 30);\n\n        // 创建蓝色矩形\n        const rect = this.add.image(randomX, randomY, 'blueRect');\n        rect.setOrigin(0, 0);\n\n        // 增加计数\n        rectangleCount++;\n        countText.setText(`已生成: ${rectangleCount} / ${MAX_RECTANGLES}`);\n\n        // 如果达到最大数量，停止定时器\n        if (rectangleCount >= MAX_RECTANGLES) {\n          timerEvent.remove();\n          this.add.text(10, 60, '已达到最大数量！', {\n            fontSize: '16px',\n            color: '#ffff00'\n          });\n        }\n      }\n    },\n    callbackScope: this,\n    loop: true // 循环执行\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000669_v3", "prompt_id": "seed_000669", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色敌人死亡时触发粒子爆炸效果：发射 10 个粒子向四周扩散后消失，持续 4 秒。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.GameObjects.Particles.ParticleEmitter\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 灰色敌人死亡时触发粒子爆炸效果，发射10个粒子向四周扩散后消失，持续4秒\nAPI: ParticleEmitter, Graphics, Physics.Arcade, Sprite, Keyboard\nSTEPS:\n1. 创建灰色敌人精灵（使用 Graphics 生成纹理）\n2. 创建粒子发射器，配置为爆炸模式（一次性发射10个粒子）\n3. 设置粒子属性：速度、生命周期4秒、向四周扩散\n4. 监听键盘输入（空格键）触发敌人死亡\n5. 敌人死亡时在其位置触发粒子爆炸效果\n6. 添加状态变量记录敌人死亡次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemyDeathCount = 0; // 验证状态信号\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，不依赖外部资源\n  }\n\n  create() {\n    // 创建灰色敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x808080, 1); // 灰色\n    enemyGraphics.fillRect(0, 0, 40, 40);\n    enemyGraphics.generateTexture('enemyTexture', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建粒子纹理（红色小方块）\n    const particleGraphics = this.add.graphics();\n    particleGraphics.fillStyle(0xff4444, 1);\n    particleGraphics.fillCircle(4, 4, 4);\n    particleGraphics.generateTexture('particleTexture', 8, 8);\n    particleGraphics.destroy();\n\n    // 创建敌人精灵\n    this.enemy = this.add.sprite(400, 300, 'enemyTexture');\n    this.enemy.setInteractive();\n\n    // 创建粒子发射器\n    this.particleEmitter = this.add.particles(0, 0, 'particleTexture', {\n      speed: { min: 100, max: 200 },\n      angle: { min: 0, max: 360 },\n      scale: { start: 1, end: 0 },\n      alpha: { start: 1, end: 0 },\n      lifespan: 4000, // 持续4秒\n      gravityY: 0,\n      quantity: 10, // 每次发射10个粒子\n      frequency: -1, // 手动触发，不自动发射\n      blendMode: 'ADD'\n    });\n\n    // 停止自动发射\n    this.particleEmitter.stop();\n\n    // 添加键盘输入监听\n    this.input.keyboard.on('keydown-SPACE', () => {\n      this.killEnemy();\n    });\n\n    // 添加鼠标点击监听\n    this.enemy.on('pointerdown', () => {\n      this.killEnemy();\n    });\n\n    // 添加提示文本\n    this.add.text(10, 10, 'Press SPACE or Click Enemy to Trigger Explosion', {\n      fontSize: '18px',\n      color: '#ffffff'\n    });\n\n    // 显示死亡计数\n    this.deathCountText = this.add.text(10, 40, `Deaths: ${this.enemyDeathCount}`, {\n      fontSize: '18px',\n      color: '#ffff00'\n    });\n\n    // 添加说明文本\n    this.add.text(10, 70, 'Particles: 10 | Duration: 4 seconds', {\n      fontSize: '14px',\n      color: '#aaaaaa'\n    });\n  }\n\n  killEnemy() {\n    if (!this.enemy.visible) {\n      return; // 已经死亡，避免重复触发\n    }\n\n    // 记录敌人位置\n    const enemyX = this.enemy.x;\n    const enemyY = this.enemy.y;\n\n    // 隐藏敌人\n    this.enemy.setVisible(false);\n\n    // 在敌人位置触发粒子爆炸\n    this.particleEmitter.setPosition(enemyX, enemyY);\n    this.particleEmitter.explode(10); // 一次性发射10个粒子\n\n    // 更新死亡计数\n    this.enemyDeathCount++;\n    this.deathCountText.setText(`Deaths: ${this.enemyDeathCount}`);\n\n    // 4秒后重新生成敌人（演示可重复触发）\n    this.time.delayedCall(4000, () => {\n      this.respawnEnemy();\n    });\n  }\n\n  respawnEnemy() {\n    // 在随机位置重新生成敌人\n    const randomX = Phaser.Math.Between(100, 700);\n    const randomY = Phaser.Math.Between(100, 500);\n    \n    this.enemy.setPosition(randomX, randomY);\n    this.enemy.setVisible(true);\n\n    // 添加闪烁效果表示重生\n    this.tweens.add({\n      targets: this.enemy,\n      alpha: { from: 0, to: 1 },\n      duration: 500,\n      ease: 'Power2'\n    });\n  }\n\n  update(time, delta) {\n    // 可以在这里添加其他更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  }\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001897_v1", "prompt_id": "seed_001897", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Particles", "Physics"], "quality_score": 0.42000000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色椭圆平滑跟随鼠标指针移动，跟随速度为 200。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Pointer\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色椭圆平滑跟随鼠标指针移动，跟随速度为200\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin, Phaser.Math.Distance.Between, Phaser.Math.Angle.Between\nSTEPS:\n1. 创建 Graphics 对象绘制白色椭圆\n2. 在 create 中获取鼠标指针对象\n3. 在 update 中计算椭圆与指针的距离和角度\n4. 根据速度和 delta 时间平滑移动椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nlet pointer;\nconst FOLLOW_SPEED = 200; // 每秒移动的像素数\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建白色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillEllipse(0, 0, 60, 40); // 中心点为(0,0)，宽60，高40\n  \n  // 生成纹理并创建精灵\n  graphics.generateTexture('ellipseTex', 60, 40);\n  graphics.destroy();\n  \n  // 创建椭圆精灵，初始位置在屏幕中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  \n  // 获取活动指针（鼠标）\n  pointer = this.input.activePointer;\n}\n\nfunction update(time, delta) {\n  // 计算椭圆中心到指针的距离\n  const distance = Phaser.Math.Distance.Between(\n    ellipse.x,\n    ellipse.y,\n    pointer.x,\n    pointer.y\n  );\n  \n  // 如果距离大于1像素，则移动椭圆（避免抖动）\n  if (distance > 1) {\n    // 计算移动角度\n    const angle = Phaser.Math.Angle.Between(\n      ellipse.x,\n      ellipse.y,\n      pointer.x,\n      pointer.y\n    );\n    \n    // 计算本帧应该移动的距离（速度 * 时间）\n    const moveDistance = FOLLOW_SPEED * (delta / 1000);\n    \n    // 如果本帧移动距离大于剩余距离，则直接到达目标点\n    if (moveDistance >= distance) {\n      ellipse.x = pointer.x;\n      ellipse.y = pointer.y;\n    } else {\n      // 根据角度和移动距离计算新位置\n      ellipse.x += Math.cos(angle) * moveDistance;\n      ellipse.y += Math.sin(angle) * moveDistance;\n    }\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000601_v1", "prompt_id": "seed_000601", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：橙色敌人从上方以 300 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，橙色敌人从上方以300速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制玩家（蓝色方块）和敌人（橙色圆形）纹理\n3. 创建玩家精灵，设置键盘控制（左右方向键）\n4. 创建敌人组，定时从顶部随机位置生成敌人，设置向下速度300\n5. 添加碰撞检测，碰撞时设置游戏结束状态\n6. 在 update 中处理玩家移动和游戏结束逻辑\n7. 添加分数系统，记录存活时间\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.playerSpeed = 300;\n    this.enemySpeed = 300;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（橙色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff8800, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 定时生成敌人（每1秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 分数计时器\n    this.scoreTimer = this.time.addEvent({\n      delay: 100,\n      callback: () => {\n        if (!this.gameOver) {\n          this.score += 10;\n          this.scoreText.setText('Score: ' + this.score);\n        }\n      },\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 玩家左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 在顶部随机位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  hitEnemy(player, enemy) {\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.player.setTint(0xff0000);\n    this.gameOverText.setVisible(true);\n    this.enemyTimer.remove();\n    this.scoreTimer.remove();\n\n    // 添加重启提示\n    const restartText = this.add.text(400, 380, 'Click to Restart', {\n      fontSize: '32px',\n      fill: '#fff'\n    });\n    restartText.setOrigin(0.5);\n\n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001015_v3", "prompt_id": "seed_001015", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每关难度递增：第 1 关 12 个橙色敌人，每关增加 2 个，共 5 关，显示当前关卡和敌人数。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现5关递增难度的射击游戏，每关敌人数+2，显示关卡和敌人数信息\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Scene, Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard\nSTEPS:\n1. 创建游戏场景，初始化物理系统和关卡变量（currentLevel, enemiesPerLevel, totalLevels）\n2. 使用Graphics创建玩家（蓝色三角形）和敌人（橙色圆形）的纹理\n3. 实现敌人生成逻辑：根据关卡计算敌人数量（12 + (level-1)*2），使用Physics.Arcade.Group管理\n4. 添加键盘控制（方向键移动，空格射击）和碰撞检测（子弹击中敌人）\n5. 实现关卡切换：所有敌人消灭后进入下一关，5关后显示胜利信息\n6. 显示UI文本：当前关卡、剩余敌人数、游戏状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentLevel = 1;\n    this.totalLevels = 5;\n    this.baseEnemies = 12;\n    this.enemiesPerLevel = 2;\n    this.remainingEnemies = 0;\n    this.gameOver = false;\n    this.gameWon = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色三角形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(0, -20);\n    playerGraphics.lineTo(-15, 20);\n    playerGraphics.lineTo(15, 20);\n    playerGraphics.closePath();\n    playerGraphics.fillPath();\n    playerGraphics.generateTexture('player', 30, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（橙色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff8800, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建子弹纹理（黄色小矩形）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillRect(0, 0, 4, 10);\n    bulletGraphics.generateTexture('bullet', 4, 10);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 20\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.lastFired = 0;\n    this.fireRate = 200; // 毫秒\n\n    // 碰撞检测\n    this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);\n\n    // UI文本\n    this.levelText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    this.enemyCountText = this.add.text(16, 46, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    this.statusText = this.add.text(400, 300, '', {\n      fontSize: '32px',\n      fill: '#00ff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 开始第一关\n    this.startLevel();\n  }\n\n  startLevel() {\n    if (this.currentLevel > this.totalLevels) {\n      this.gameWon = true;\n      this.statusText.setText('YOU WIN!\\nAll 5 Levels Completed!');\n      this.statusText.setVisible(true);\n      return;\n    }\n\n    // 计算当前关卡敌人数量：12, 14, 16, 18, 20\n    const enemyCount = this.baseEnemies + (this.currentLevel - 1) * this.enemiesPerLevel;\n    this.remainingEnemies = enemyCount;\n\n    // 清除旧敌人\n    this.enemies.clear(true, true);\n\n    // 生成敌人（使用固定模式以保证确定性）\n    const rows = Math.ceil(enemyCount / 6);\n    const cols = Math.min(6, enemyCount);\n    let enemyIndex = 0;\n\n    for (let row = 0; row < rows && enemyIndex < enemyCount; row++) {\n      for (let col = 0; col < cols && enemyIndex < enemyCount; col++) {\n        const x = 100 + col * 100;\n        const y = 80 + row * 60;\n        const enemy = this.enemies.create(x, y, 'enemy');\n        enemy.setVelocity(50 + this.currentLevel * 10, 0);\n        enemy.setBounce(1);\n        enemy.setCollideWorldBounds(true);\n        enemyIndex++;\n      }\n    }\n\n    this.updateUI();\n  }\n\n  hitEnemy(bullet, enemy) {\n    bullet.destroy();\n    enemy.destroy();\n    this.remainingEnemies--;\n    this.updateUI();\n\n    // 检查是否完成当前关卡\n    if (this.remainingEnemies <= 0) {\n      this.currentLevel++;\n      this.time.delayedCall(1000, () => {\n        this.startLevel();\n      });\n    }\n  }\n\n  shootBullet() {\n    const bullet = this.bullets.get(this.player.x, this.player.y - 20);\n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocityY(-400);\n    }\n  }\n\n  updateUI() {\n    this.levelText.setText(`Level: ${this.currentLevel}/${this.totalLevels}`);\n    this.enemyCountText.setText(`Enemies: ${this.remainingEnemies}`);\n    \n    if (this.currentLevel > this.totalLevels && !this.gameWon) {\n      this.statusText.setVisible(false);\n    }\n  }\n\n  update(time, delta) {\n    if (this.gameOver || this.gameWon) {\n      return;\n    }\n\n    // 玩家移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-300);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(300);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 射击\n    if (this.spaceKey.isDown && time > this.lastFired + this.fireRate) {\n      this.shootBullet();\n      this.lastFired = time;\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active && bullet.y < 0) {\n        bullet.destroy();\n      }\n    });\n\n    // 检查敌人是否到达底部（游戏失败条件）\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active && enemy.y > 580) {\n        this.gameOver = true;\n        this.statusText.setText('GAME OVER\\nEnemies Reached Bottom!');\n        this.statusText.setFill('#ff0000');\n        this.statusText.setVisible(true);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001752_v2", "prompt_id": "seed_001752", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色椭圆平滑跟随鼠标指针移动，跟随速度为 80。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Pointer\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色椭圆平滑跟随鼠标指针移动，跟随速度为80\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Pointer, Phaser.Math.Distance.Between, Phaser.Math.Angle.Between\nSTEPS:\n1. 使用 Graphics 绘制蓝色椭圆并生成纹理\n2. 创建椭圆精灵对象并设置初始位置\n3. 在 update 中获取鼠标指针位置\n4. 计算椭圆到鼠标的距离和角度\n5. 根据速度和时间差计算移动距离，平滑移动椭圆\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet pointer;\nconst FOLLOW_SPEED = 80; // 每秒移动80像素\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1); // 蓝色\n  graphics.fillEllipse(30, 20, 60, 40); // 椭圆：中心(30,20)，宽60，高40\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTex', 60, 40);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建椭圆精灵\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  \n  // 获取鼠标指针\n  pointer = this.input.activePointer;\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 获取鼠标位置\n  const targetX = pointer.x;\n  const targetY = pointer.y;\n  \n  // 计算椭圆到鼠标的距离\n  const distance = Phaser.Math.Distance.Between(\n    ellipse.x,\n    ellipse.y,\n    targetX,\n    targetY\n  );\n  \n  // 如果距离很小，直接设置位置，避免抖动\n  if (distance < 1) {\n    ellipse.x = targetX;\n    ellipse.y = targetY;\n    return;\n  }\n  \n  // 计算这一帧应该移动的距离\n  const moveDistance = FOLLOW_SPEED * deltaSeconds;\n  \n  // 如果移动距离大于实际距离，直接到达目标位置\n  if (moveDistance >= distance) {\n    ellipse.x = targetX;\n    ellipse.y = targetY;\n  } else {\n    // 计算移动角度\n    const angle = Phaser.Math.Angle.Between(\n      ellipse.x,\n      ellipse.y,\n      targetX,\n      targetY\n    );\n    \n    // 根据角度和移动距离计算新位置\n    ellipse.x += Math.cos(angle) * moveDistance;\n    ellipse.y += Math.sin(angle) * moveDistance;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000251_v2", "prompt_id": "seed_000251", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个倒计时 20 秒的计时器，在屏幕中央显示剩余时间，归零时显示 \"时间到\"。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建20秒倒计时器，屏幕中央显示剩余时间，归零时显示\"时间到\"\nAPI: Phaser.GameObjects.Text, Phaser.Time.Clock#addEvent, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建 Scene 并在 create 中初始化文本对象显示倒计时\n2. 使用 this.time.addEvent 创建每秒触发的定时器事件\n3. 在定时器回调中更新剩余时间并刷新文本显示\n4. 当倒计时归零时显示\"时间到\"并停止定时器\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nlet timeText;\nlet remainingTime = 20;\nlet timerEvent;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建文本对象显示倒计时，居中显示\n  timeText = this.add.text(\n    400, \n    300, \n    remainingTime.toString(), \n    {\n      fontSize: '64px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }\n  );\n  \n  // 设置文本原点为中心，便于居中对齐\n  timeText.setOrigin(0.5, 0.5);\n  \n  // 创建定时器事件，每秒触发一次\n  timerEvent = this.time.addEvent({\n    delay: 1000,                // 每1000毫秒（1秒）触发一次\n    callback: updateTimer,      // 回调函数\n    callbackScope: this,        // 回调函数的作用域\n    loop: true                  // 循环执行\n  });\n}\n\nfunction updateTimer() {\n  // 减少剩余时间\n  remainingTime--;\n  \n  // 检查是否倒计时结束\n  if (remainingTime <= 0) {\n    // 显示\"时间到\"\n    timeText.setText('时间到');\n    \n    // 停止定时器\n    timerEvent.remove();\n  } else {\n    // 更新显示的时间\n    timeText.setText(remainingTime.toString());\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000565_v3", "prompt_id": "seed_000565", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的红色矩形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的红色矩形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布大小\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环8次，每次生成随机坐标（x, y）\n4. 使用 fillStyle 设置红色，fillRect 绘制 32x32 的矩形\n5. 确保矩形在画布范围内（考虑矩形大小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 矩形大小\n  const rectSize = 32;\n  \n  // 绘制8个随机位置的红色矩形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机坐标，确保矩形完全在画布内\n    // x 范围: 0 到 (width - rectSize)\n    // y 范围: 0 到 (height - rectSize)\n    const x = Math.random() * (config.width - rectSize);\n    const y = Math.random() * (config.height - rectSize);\n    \n    // 绘制矩形\n    graphics.fillRect(x, y, rectSize, rectSize);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000175_v2", "prompt_id": "seed_000175", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 同时控制 5 个灰色对象：按方向键时所有对象同步移动，速度 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 同时控制5个灰色对象，按方向键同步移动，速度160\nAPI: this.add.graphics(), this.input.keyboard.createCursorKeys(), sprite.setVelocity(), this.physics.add.sprite()\nSTEPS:\n1. 创建物理系统配置，关闭重力\n2. 使用Graphics生成灰色方块纹理\n3. 创建5个物理精灵对象，分散在不同位置\n4. 创建键盘方向键输入\n5. 在update中检测方向键，同步设置所有对象的速度为160\n6. 添加状态变量记录移动帧数作为验证信号\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量\nlet objects = [];\nlet cursors;\nlet moveFrameCount = 0; // 记录移动帧数作为验证信号\nlet statusText;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 生成灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('grayBox', 40, 40);\n  graphics.destroy();\n\n  // 创建5个灰色对象，分散在不同位置\n  const positions = [\n    { x: 200, y: 300 },\n    { x: 400, y: 200 },\n    { x: 600, y: 300 },\n    { x: 300, y: 400 },\n    { x: 500, y: 400 }\n  ];\n\n  positions.forEach(pos => {\n    const obj = this.physics.add.sprite(pos.x, pos.y, 'grayBox');\n    obj.setCollideWorldBounds(true); // 限制在世界边界内\n    objects.push(obj);\n  });\n\n  // 创建方向键输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 添加状态文本显示\n  statusText = this.add.text(10, 10, 'Move Frames: 0', {\n    fontSize: '20px',\n    fill: '#ffffff'\n  });\n\n  // 添加提示文本\n  this.add.text(10, 40, 'Use Arrow Keys to Move All Objects', {\n    fontSize: '16px',\n    fill: '#00ff00'\n  });\n}\n\nfunction update(time, delta) {\n  let velocityX = 0;\n  let velocityY = 0;\n  let isMoving = false;\n\n  // 检测方向键输入\n  if (cursors.left.isDown) {\n    velocityX = -160;\n    isMoving = true;\n  } else if (cursors.right.isDown) {\n    velocityX = 160;\n    isMoving = true;\n  }\n\n  if (cursors.up.isDown) {\n    velocityY = -160;\n    isMoving = true;\n  } else if (cursors.down.isDown) {\n    velocityY = 160;\n    isMoving = true;\n  }\n\n  // 同步设置所有对象的速度\n  objects.forEach(obj => {\n    obj.setVelocity(velocityX, velocityY);\n  });\n\n  // 更新移动帧计数\n  if (isMoving) {\n    moveFrameCount++;\n    statusText.setText(`Move Frames: ${moveFrameCount}`);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001507_v1", "prompt_id": "seed_001507", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个蓝色物体以 240 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个蓝色物体以240速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity, setCollideWorldBounds\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成蓝色圆形纹理\n3. 创建物理组，添加 15 个蓝色物体\n4. 为每个物体设置随机速度（总速度为 240）和反弹属性\n5. 设置物体间的碰撞检测和世界边界碰撞\n6. 添加状态信号变量追踪碰撞次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet collisionCount = 0;\nlet activeObjects = 0;\nlet totalBounces = 0;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('blueCircle', 32, 32);\n  graphics.destroy();\n\n  // 创建物理组\n  const blueObjects = this.physics.add.group({\n    key: 'blueCircle',\n    repeat: 14, // 总共 15 个（1 + 14）\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n\n  // 初始化活动对象计数\n  activeObjects = 15;\n\n  // 为每个物体设置随机位置和随机方向的速度（总速度为 240）\n  blueObjects.children.iterate((object, index) => {\n    // 随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    object.setPosition(x, y);\n\n    // 随机角度，速度大小固定为 240\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const velocityX = Math.cos(angle) * 240;\n    const velocityY = Math.sin(angle) * 240;\n    object.setVelocity(velocityX, velocityY);\n\n    // 设置反弹系数\n    object.setBounce(1, 1);\n  });\n\n  // 设置物体之间的碰撞\n  this.physics.add.collider(blueObjects, blueObjects, onCollision, null, this);\n\n  // 添加文本显示状态信息\n  this.statusText = this.add.text(16, 16, '', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 监听世界边界碰撞\n  blueObjects.children.iterate((object) => {\n    object.body.onWorldBounds = true;\n  });\n\n  this.physics.world.on('worldbounds', () => {\n    totalBounces++;\n  });\n\n  // 保存引用以便在 update 中使用\n  this.blueObjects = blueObjects;\n}\n\nfunction onCollision(obj1, obj2) {\n  // 碰撞计数\n  collisionCount++;\n}\n\nfunction update(time, delta) {\n  // 更新状态显示\n  this.statusText.setText([\n    `Active Objects: ${activeObjects}`,\n    `Object Collisions: ${collisionCount}`,\n    `Wall Bounces: ${totalBounces}`,\n    `Average Speed: 240 px/s`\n  ]);\n\n  // 验证速度保持在 240 左右（考虑浮点误差）\n  this.blueObjects.children.iterate((object) => {\n    const velocity = object.body.velocity;\n    const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n    \n    // 如果速度偏离 240 太多，重新归一化（防止数值误差累积）\n    if (Math.abs(speed - 240) > 1) {\n      const angle = Math.atan2(velocity.y, velocity.x);\n      object.setVelocity(Math.cos(angle) * 240, Math.sin(angle) * 240);\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001283_v3", "prompt_id": "seed_001283", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个80像素的粉色星形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置，在点击处生成一个80像素的粉色星形\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Events.POINTER_DOWN, Graphics.fillStyle, Graphics.fillStar\nSTEPS:\n1. 创建 Scene 并配置输入系统\n2. 在 create 中监听 POINTER_DOWN 事件\n3. 在点击事件回调中使用 Graphics 绘制粉色星形\n4. 星形中心位置为点击坐标，半径为40像素（直径80像素）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 添加提示文本\n  this.add.text(400, 30, '点击画布任意位置生成粉色星形', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  // 监听点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式\n    graphics.fillStyle(0xff69b4, 1); // 粉色 (Hot Pink)\n    \n    // 绘制星形\n    // fillStar(x, y, points, innerRadius, outerRadius, angle)\n    // 80像素指的是外径，所以外半径为40\n    graphics.fillStar(\n      pointer.x,        // x 坐标\n      pointer.y,        // y 坐标\n      5,                // 5个顶点\n      20,               // 内半径\n      40,               // 外半径（80像素直径）\n      0                 // 旋转角度\n    );\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000715_v2", "prompt_id": "seed_000715", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环3次，每次创建一个 Graphics 对象\n3. 使用三角函数计算六边形的6个顶点坐标（半径32像素）\n4. 使用 Phaser.Math.Between 生成随机位置（考虑边界避免超出画布）\n5. 使用 Graphics API 绘制填充的紫色六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制3个随机位置的紫色六边形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充\n    graphics.fillStyle(0x9932cc, 1);\n    \n    // 六边形参数\n    const radius = 32; // 半径32像素，直径64像素\n    const sides = 6;\n    \n    // 生成随机位置（考虑边界，留出半径空间）\n    const x = Phaser.Math.Between(radius + 10, 800 - radius - 10);\n    const y = Phaser.Math.Between(radius + 10, 600 - radius - 10);\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的顶点并绘制\n    for (let j = 0; j < sides; j++) {\n      // 计算每个顶点的角度（从顶部开始，所以减去90度）\n      const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(vx, vy);\n      } else {\n        graphics.lineTo(vx, vy);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000647_v3", "prompt_id": "seed_000647", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.4025}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 0.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 0.5 秒内缩放到 80% 然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建缩放动画，从 1 缩放到 0.8 再回到 1\n4. 设置 Tween 的 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个等边三角形（中心在原点）\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, -60);      // 顶点\n  graphics.lineTo(-52, 30);     // 左下角\n  graphics.lineTo(52, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 104, 90);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵并居中\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 500,        // 0.5 秒\n    yoyo: true,           // 动画结束后反向播放（恢复到原始大小）\n    repeat: -1,           // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '三角形缩放循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000352_v3", "prompt_id": "seed_000352", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按鼠标右键发射橙色子弹的例子，子弹速度 120，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现鼠标右键发射橙色子弹，速度120，离开边界自动回收到对象池\nAPI: Phaser.Physics.Arcade.Group, this.input.on('pointerdown'), Phaser.GameObjects.Graphics, this.physics.moveTo\nSTEPS:\n1. 创建带物理系统的场景配置\n2. 使用 Graphics 生成橙色圆形子弹纹理\n3. 创建物理组作为子弹对象池，设置回收条件\n4. 监听鼠标右键点击事件（pointer.rightButtonDown()）\n5. 发射子弹时从对象池获取，设置位置和速度方向\n6. 在 update 中检测子弹边界，超出边界则回收\n[/PLAN]\n\n```javascript\nclass BulletScene extends Phaser.Scene {\n  constructor() {\n    super('BulletScene');\n    this.bulletsFired = 0; // 可验证的状态信号\n    this.activeBullets = 0; // 当前活跃子弹数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建橙色子弹纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff8800, 1); // 橙色\n    graphics.fillCircle(8, 8, 8); // 圆形子弹，半径8\n    graphics.generateTexture('bullet', 16, 16);\n    graphics.destroy();\n\n    // 创建子弹对象池（使用物理组）\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50, // 对象池最大容量\n      runChildUpdate: false\n    });\n\n    // 创建发射器位置指示（屏幕中心）\n    const shooter = this.add.graphics();\n    shooter.fillStyle(0x00ff00, 1);\n    shooter.fillCircle(400, 300, 10);\n    this.shooterX = 400;\n    this.shooterY = 300;\n\n    // 监听鼠标右键点击事件\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown()) {\n        this.fireBullet(pointer.x, pointer.y);\n      }\n    });\n\n    // 添加提示文本\n    this.add.text(10, 10, '右键点击发射橙色子弹', {\n      fontSize: '18px',\n      color: '#ffffff'\n    });\n\n    // 显示状态信息\n    this.statsText = this.add.text(10, 40, '', {\n      fontSize: '16px',\n      color: '#ffff00'\n    });\n\n    this.updateStatsText();\n  }\n\n  fireBullet(targetX, targetY) {\n    // 从对象池获取子弹\n    const bullet = this.bullets.get(this.shooterX, this.shooterY);\n\n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n\n      // 计算从发射器到目标点的方向，设置速度\n      const angle = Phaser.Math.Angle.Between(\n        this.shooterX,\n        this.shooterY,\n        targetX,\n        targetY\n      );\n\n      // 设置子弹速度（速度为120）\n      this.physics.velocityFromRotation(angle, 120, bullet.body.velocity);\n\n      // 更新统计信息\n      this.bulletsFired++;\n      this.activeBullets++;\n      this.updateStatsText();\n    }\n  }\n\n  update(time, delta) {\n    // 检查所有活跃的子弹\n    this.bullets.children.entries.forEach((bullet) => {\n      if (bullet.active) {\n        // 检查子弹是否离开边界\n        if (\n          bullet.x < -20 ||\n          bullet.x > 820 ||\n          bullet.y < -20 ||\n          bullet.y > 620\n        ) {\n          // 回收到对象池\n          this.bullets.killAndHide(bullet);\n          bullet.body.reset(0, 0);\n          this.activeBullets--;\n          this.updateStatsText();\n        }\n      }\n    });\n  }\n\n  updateStatsText() {\n    this.statsText.setText([\n      `已发射子弹: ${this.bulletsFired}`,\n      `活跃子弹: ${this.activeBullets}`,\n      `对象池大小: ${this.bullets.getLength()}`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BulletScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001362_v2", "prompt_id": "seed_001362", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 120 像素/秒速度移动\nAPI: Graphics.fillEllipse, input.keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆形状\n2. 使用 input.keyboard.addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间更新椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet ellipse;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建椭圆图形\n  ellipse = this.add.graphics();\n  ellipse.fillStyle(0x00ff00, 1);\n  ellipse.fillEllipse(0, 0, 60, 40); // 中心点在 (0,0)，宽60，高40\n  \n  // 设置初始位置\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 添加 WASD 键盘监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  const movement = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    ellipse.y -= movement;\n  }\n  if (keyS.isDown) {\n    ellipse.y += movement;\n  }\n  if (keyA.isDown) {\n    ellipse.x -= movement;\n  }\n  if (keyD.isDown) {\n    ellipse.x += movement;\n  }\n  \n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 30, 770);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000183_v2", "prompt_id": "seed_000183", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个黄色六边形移动，移动速度为 240，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制黄色六边形移动，速度240，限制在画布边界内\nAPI: this.add.graphics(), this.input.keyboard.createCursorKeys(), graphics.fillStyle(), graphics.fillCircle(), graphics.generateTexture()\nSTEPS:\n1. 创建 Scene 并在 create 中使用 Graphics 绘制黄色六边形纹理\n2. 使用该纹理创建 Sprite 对象作为玩家角色\n3. 通过 createCursorKeys() 获取方向键输入\n4. 在 update 中检测方向键状态，更新玩家位置\n5. 使用 Phaser.Math.Clamp 限制玩家在画布边界内移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nconst SPEED = 240;\n\nfunction preload() {\n  // 使用 Graphics 创建黄色六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制黄色六边形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 六边形的顶点坐标（半径30，中心在32,32）\n  const hexRadius = 30;\n  const centerX = 32;\n  const centerY = 32;\n  const points = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push(x, y);\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵（黄色六边形）\n  player = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建方向键控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use Arrow Keys to Move', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间差）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测方向键输入\n  if (cursors.left.isDown) {\n    velocityX = -distance;\n  } else if (cursors.right.isDown) {\n    velocityX = distance;\n  }\n  \n  if (cursors.up.isDown) {\n    velocityY = -distance;\n  } else if (cursors.down.isDown) {\n    velocityY = distance;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX;\n  player.y += velocityY;\n  \n  // 限制在画布边界内\n  const halfWidth = player.width / 2;\n  const halfHeight = player.height / 2;\n  \n  player.x = Phaser.Math.Clamp(player.x, halfWidth, config.width - halfWidth);\n  player.y = Phaser.Math.Clamp(player.y, halfHeight, config.height - halfHeight);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000786_v2", "prompt_id": "seed_000786", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个蓝色圆形移动，移动速度为 120，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制蓝色圆形在画布边界内移动\nAPI: this.add.graphics(), this.input.keyboard.createCursorKeys(), graphics.fillCircle(), graphics.generateTexture()\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建精灵对象并应用纹理\n3. 获取键盘方向键输入\n4. 在 update 中根据按键更新精灵位置\n5. 限制精灵在画布边界内移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet cursors;\nconst SPEED = 120;\nconst RADIUS = 20;\n\nfunction preload() {\n  // 使用 Graphics 生成蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1);\n  graphics.fillCircle(RADIUS, RADIUS, RADIUS);\n  graphics.generateTexture('blueCircle', RADIUS * 2, RADIUS * 2);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵，初始位置在画布中心\n  player = this.add.sprite(400, 300, 'blueCircle');\n  \n  // 创建方向键控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use Arrow Keys to Move', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测方向键输入\n  if (cursors.left.isDown) {\n    velocityX = -SPEED;\n  } else if (cursors.right.isDown) {\n    velocityX = SPEED;\n  }\n  \n  if (cursors.up.isDown) {\n    velocityY = -SPEED;\n  } else if (cursors.down.isDown) {\n    velocityY = SPEED;\n  }\n  \n  // 计算新位置（基于 delta 时间实现平滑移动）\n  const deltaSeconds = delta / 1000;\n  player.x += velocityX * deltaSeconds;\n  player.y += velocityY * deltaSeconds;\n  \n  // 限制在画布边界内\n  player.x = Phaser.Math.Clamp(player.x, RADIUS, config.width - RADIUS);\n  player.y = Phaser.Math.Clamp(player.y, RADIUS, config.height - RADIUS);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000513_v1", "prompt_id": "seed_000513", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现黄色物体拖拽排序：10 个物体可拖拽，松手后按 Y 坐标自动排列。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现10个黄色方块可拖拽，松手后按Y坐标自动排列\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin#setDraggable, Phaser.Input.Events.DRAG, Phaser.Input.Events.DRAG_END, Phaser.Tweens.TweenManager\nSTEPS:\n1. 创建10个黄色方块并生成纹理\n2. 为每个方块启用拖拽交互\n3. 监听拖拽事件实时更新方块位置\n4. 监听拖拽结束事件，按Y坐标排序所有方块\n5. 使用缓动动画将方块移动到排序后的位置\n6. 添加状态信号记录拖拽次数和当前排序状态\n[/PLAN]\n\n```javascript\nclass DragSortScene extends Phaser.Scene {\n  constructor() {\n    super('DragSortScene');\n    this.dragCount = 0; // 状态信号：拖拽次数\n    this.isSorted = false; // 状态信号：是否已排序\n    this.boxes = []; // 存储所有方块\n  }\n\n  preload() {\n    // 使用 Graphics 创建黄色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFFD700, 1); // 金黄色\n    graphics.fillRect(0, 0, 60, 60);\n    graphics.lineStyle(3, 0xFFA500, 1); // 橙色边框\n    graphics.strokeRect(0, 0, 60, 60);\n    graphics.generateTexture('yellowBox', 60, 60);\n    graphics.destroy();\n  }\n\n  create() {\n    // 添加标题文字\n    this.add.text(400, 30, '拖拽黄色方块，松手后自动按Y坐标排序', {\n      fontSize: '20px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 添加状态显示文字\n    this.statusText = this.add.text(400, 60, '拖拽次数: 0 | 状态: 未排序', {\n      fontSize: '16px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 创建10个黄色方块，随机分布\n    const startX = 150;\n    const startY = 150;\n    \n    for (let i = 0; i < 10; i++) {\n      // 随机位置分布\n      const x = startX + (i % 5) * 120 + Phaser.Math.Between(-20, 20);\n      const y = startY + Math.floor(i / 5) * 200 + Phaser.Math.Between(-50, 50);\n      \n      const box = this.add.image(x, y, 'yellowBox');\n      box.setInteractive({ draggable: true });\n      \n      // 添加序号文字\n      const text = this.add.text(x, y, (i + 1).toString(), {\n        fontSize: '24px',\n        color: '#000000',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n      \n      // 将文字绑定到方块上\n      box.textLabel = text;\n      box.index = i + 1;\n      \n      this.boxes.push(box);\n    }\n\n    // 设置拖拽事件\n    this.input.on('drag', (pointer, gameObject, dragX, dragY) => {\n      gameObject.x = dragX;\n      gameObject.y = dragY;\n      // 同步更新文字位置\n      if (gameObject.textLabel) {\n        gameObject.textLabel.x = dragX;\n        gameObject.textLabel.y = dragY;\n      }\n    });\n\n    this.input.on('dragstart', (pointer, gameObject) => {\n      // 拖拽时放大并提升深度\n      this.tweens.add({\n        targets: gameObject,\n        scaleX: 1.1,\n        scaleY: 1.1,\n        duration: 100\n      });\n      gameObject.setDepth(100);\n      if (gameObject.textLabel) {\n        gameObject.textLabel.setDepth(101);\n      }\n    });\n\n    this.input.on('dragend', (pointer, gameObject) => {\n      // 恢复大小\n      this.tweens.add({\n        targets: gameObject,\n        scaleX: 1,\n        scaleY: 1,\n        duration: 100\n      });\n      gameObject.setDepth(0);\n      if (gameObject.textLabel) {\n        gameObject.textLabel.setDepth(1);\n      }\n\n      // 更新拖拽次数\n      this.dragCount++;\n      \n      // 松手后按Y坐标排序\n      this.sortBoxesByY();\n    });\n\n    // 添加重置按钮\n    const resetButton = this.add.text(400, 550, '重置位置', {\n      fontSize: '18px',\n      color: '#ffffff',\n      backgroundColor: '#4444ff',\n      padding: { x: 20, y: 10 }\n    }).setOrigin(0.5).setInteractive();\n\n    resetButton.on('pointerdown', () => {\n      this.resetBoxes();\n    });\n\n    resetButton.on('pointerover', () => {\n      resetButton.setScale(1.1);\n    });\n\n    resetButton.on('pointerout', () => {\n      resetButton.setScale(1);\n    });\n  }\n\n  sortBoxesByY() {\n    // 按当前Y坐标排序\n    const sortedBoxes = [...this.boxes].sort((a, b) => a.y - b.y);\n    \n    // 计算新的排列位置（垂直居中排列）\n    const startX = 400;\n    const startY = 150;\n    const spacing = 40;\n\n    sortedBoxes.forEach((box, index) => {\n      const targetY = startY + index * spacing;\n      \n      // 使用缓动动画移动到新位置\n      this.tweens.add({\n        targets: box,\n        x: startX,\n        y: targetY,\n        duration: 500,\n        ease: 'Power2'\n      });\n\n      // 同步移动文字\n      if (box.textLabel) {\n        this.tweens.add({\n          targets: box.textLabel,\n          x: startX,\n          y: targetY,\n          duration: 500,\n          ease: 'Power2'\n        });\n      }\n    });\n\n    // 更新排序状态\n    this.isSorted = true;\n    this.updateStatus();\n  }\n\n  resetBoxes() {\n    // 重置到随机位置\n    const startX = 150;\n    const startY = 150;\n    \n    this.boxes.forEach((box, i) => {\n      const x = startX + (i % 5) * 120 + Phaser.Math.Between(-20, 20);\n      const y = startY + Math.floor(i / 5) * 200 + Phaser.Math.Between(-50, 50);\n      \n      this.tweens.add({\n        targets: box,\n        x: x,\n        y: y,\n        duration: 300,\n        ease: 'Back.easeOut'\n      });\n\n      if (box.textLabel) {\n        this.tweens.add({\n          targets: box.textLabel,\n          x: x,\n          y: y,\n          duration: 300,\n          ease: 'Back.easeOut'\n        });\n      }\n    });\n\n    this.isSorted = false;\n    this.dragCount = 0;\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const sortedText = this.isSorted ? '已排序' : '未排序';\n    this.statusText.setText(`拖拽次数: ${this.dragCount} | 状态: ${sortedText}`);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: DragSortScene,\n  parent: 'game-container'\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000967_v3", "prompt_id": "seed_000967", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.4}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绿色玩家移出边界时从对侧出现（循环地图效果），移动速度 360。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 绿色玩家以速度360移动，移出边界时从对侧循环出现\nAPI: Graphics.fillRect, Physics.add.sprite, Input.keyboard.createCursorKeys, Physics.Arcade.Body.setVelocity, Scene.events\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 生成绿色方块纹理作为玩家\n3. 创建物理精灵并设置初始位置\n4. 在 create 中绑定键盘输入（方向键）\n5. 在 update 中根据输入设置速度（最大360）\n6. 检测玩家位置，当超出边界时从对侧重新出现\n7. 添加状态变量记录循环次数作为可验证信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态变量\nlet player;\nlet cursors;\nlet loopCount = 0; // 可验证的状态信号：记录循环次数\nlet loopText;\n\nfunction preload() {\n  // 使用 Graphics 创建绿色玩家纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('playerTex', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'playerTex');\n  player.setCollideWorldBounds(false); // 不阻止移出边界\n  \n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 显示循环计数器\n  loopText = this.add.text(16, 16, 'Loop Count: 0', {\n    fontSize: '24px',\n    fill: '#ffffff'\n  });\n  \n  // 添加说明文字\n  this.add.text(16, 50, 'Use Arrow Keys to Move (Speed: 360)', {\n    fontSize: '18px',\n    fill: '#aaaaaa'\n  });\n  \n  // 显示边界提示\n  const borderGraphics = this.add.graphics();\n  borderGraphics.lineStyle(2, 0xffffff, 0.3);\n  borderGraphics.strokeRect(0, 0, 800, 600);\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0, 0);\n  \n  // 处理键盘输入\n  const speed = 360;\n  let isMoving = false;\n  \n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n    isMoving = true;\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n    isMoving = true;\n  }\n  \n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n    isMoving = true;\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n    isMoving = true;\n  }\n  \n  // 如果同时按下两个方向，归一化速度向量\n  if (cursors.left.isDown && cursors.up.isDown ||\n      cursors.left.isDown && cursors.down.isDown ||\n      cursors.right.isDown && cursors.up.isDown ||\n      cursors.right.isDown && cursors.down.isDown) {\n    const velocity = player.body.velocity;\n    velocity.normalize().scale(speed);\n  }\n  \n  // 循环地图效果 - 检测边界并从对侧出现\n  const playerWidth = player.width;\n  const playerHeight = player.height;\n  \n  // 左右边界循环\n  if (player.x < -playerWidth / 2) {\n    player.x = config.width + playerWidth / 2;\n    loopCount++;\n    updateLoopText();\n  } else if (player.x > config.width + playerWidth / 2) {\n    player.x = -playerWidth / 2;\n    loopCount++;\n    updateLoopText();\n  }\n  \n  // 上下边界循环\n  if (player.y < -playerHeight / 2) {\n    player.y = config.height + playerHeight / 2;\n    loopCount++;\n    updateLoopText();\n  } else if (player.y > config.height + playerHeight / 2) {\n    player.y = -playerHeight / 2;\n    loopCount++;\n    updateLoopText();\n  }\n}\n\nfunction updateLoopText() {\n  loopText.setText('Loop Count: ' + loopCount);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001314_v3", "prompt_id": "seed_001314", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按方向键触发相机旋转效果，持续 1.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按方向键触发相机旋转效果，持续1.5秒\nAPI: Phaser.Input.Keyboard.createCursorKeys, Phaser.Cameras.Scene2D.Camera.rotateTo, Phaser.Add.Graphics\nSTEPS:\n1. 创建场景并绘制参考图形（网格和中心标记）\n2. 设置键盘输入监听（方向键）\n3. 根据方向键触发相机旋转效果（左键逆时针、右键顺时针、上键复位、下键180度）\n4. 添加状态变量记录旋转次数和当前角度\n5. 显示文本提示当前状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 状态变量\nlet rotationCount = 0;  // 旋转次数\nlet currentRotation = 0;  // 当前旋转角度（度）\nlet statusText;\nlet cursors;\nlet lastKeyPressed = null;\nlet isRotating = false;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制参考网格\n  const graphics = this.add.graphics();\n  \n  // 绘制网格线\n  graphics.lineStyle(1, 0x444444, 0.5);\n  for (let x = 0; x <= 800; x += 50) {\n    graphics.lineBetween(x, 0, x, 600);\n  }\n  for (let y = 0; y <= 600; y += 50) {\n    graphics.lineBetween(0, y, 800, y);\n  }\n  \n  // 绘制中心十字标记\n  graphics.lineStyle(3, 0xff0000, 1);\n  graphics.lineBetween(400, 280, 400, 320);\n  graphics.lineBetween(380, 300, 420, 300);\n  \n  // 绘制一些彩色方块作为旋转参考\n  const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3];\n  for (let i = 0; i < 4; i++) {\n    const angle = (Math.PI / 2) * i;\n    const x = 400 + Math.cos(angle) * 200;\n    const y = 300 + Math.sin(angle) * 150;\n    \n    graphics.fillStyle(colors[i], 1);\n    graphics.fillRect(x - 30, y - 30, 60, 60);\n    \n    // 添加文字标记\n    this.add.text(x, y, `Box ${i + 1}`, {\n      fontSize: '16px',\n      color: '#ffffff',\n      align: 'center'\n    }).setOrigin(0.5);\n  }\n  \n  // 添加标题文字\n  this.add.text(400, 50, 'Camera Rotation Effect', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n  \n  // 添加说明文字\n  this.add.text(400, 100, 'Press Arrow Keys to Rotate Camera', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 130, 'LEFT: -90° | RIGHT: +90° | UP: Reset | DOWN: 180°', {\n    fontSize: '14px',\n    color: '#888888'\n  }).setOrigin(0.5);\n  \n  // 状态显示文字\n  statusText = this.add.text(400, 550, '', {\n    fontSize: '20px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setOrigin(0.5);\n  \n  updateStatusText();\n  \n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 获取主相机\n  const camera = this.cameras.main;\n  \n  // 监听方向键\n  this.input.keyboard.on('keydown-LEFT', () => {\n    if (!isRotating) {\n      isRotating = true;\n      lastKeyPressed = 'LEFT';\n      currentRotation -= 90;\n      rotationCount++;\n      \n      // 旋转到目标角度（逆时针90度）\n      camera.rotateTo(Phaser.Math.DegToRad(currentRotation), false, 1500, 'Sine.easeInOut', false, (cam, progress) => {\n        if (progress === 1) {\n          isRotating = false;\n        }\n      });\n      \n      updateStatusText();\n    }\n  });\n  \n  this.input.keyboard.on('keydown-RIGHT', () => {\n    if (!isRotating) {\n      isRotating = true;\n      lastKeyPressed = 'RIGHT';\n      currentRotation += 90;\n      rotationCount++;\n      \n      // 旋转到目标角度（顺时针90度）\n      camera.rotateTo(Phaser.Math.DegToRad(currentRotation), false, 1500, 'Sine.easeInOut', false, (cam, progress) => {\n        if (progress === 1) {\n          isRotating = false;\n        }\n      });\n      \n      updateStatusText();\n    }\n  });\n  \n  this.input.keyboard.on('keydown-UP', () => {\n    if (!isRotating) {\n      isRotating = true;\n      lastKeyPressed = 'UP';\n      currentRotation = 0;\n      rotationCount++;\n      \n      // 重置旋转\n      camera.rotateTo(0, false, 1500, 'Sine.easeInOut', false, (cam, progress) => {\n        if (progress === 1) {\n          isRotating = false;\n        }\n      });\n      \n      updateStatusText();\n    }\n  });\n  \n  this.input.keyboard.on('keydown-DOWN', () => {\n    if (!isRotating) {\n      isRotating = true;\n      lastKeyPressed = 'DOWN';\n      currentRotation += 180;\n      rotationCount++;\n      \n      // 旋转180度\n      camera.rotateTo(Phaser.Math.DegToRad(currentRotation), false, 1500, 'Sine.easeInOut', false, (cam, progress) => {\n        if (progress === 1) {\n          isRotating = false;\n        }\n      });\n      \n      updateStatusText();\n    }\n  });\n}\n\nfunction update() {\n  // 可以在这里添加实时更新逻辑\n}\n\nfunction updateStatusText() {\n  const normalizedRotation = ((currentRotation % 360) + 360) % 360;\n  statusText.setText(\n    `Rotation Count: ${rotationCount} | ` +\n    `Current Angle: ${normalizedRotation}° | ` +\n    `Last Key: ${lastKeyPressed || 'None'} | ` +\n    `Status: ${isRotating ? 'ROTATING...' : 'IDLE'}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001050_v1", "prompt_id": "seed_001050", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Input"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 1.5 秒在随机位置生成一个红色圆形，最多生成 8 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔1.5秒在随机位置生成红色圆形，最多8个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillCircle\nSTEPS:\n1. 创建 Scene 并初始化计数器\n2. 在 create 中使用 time.addEvent 创建定时器，设置 1.5 秒间隔和最多重复 7 次（共 8 个）\n3. 在定时器回调中生成随机坐标，使用 Graphics 绘制红色圆形\n4. 将生成的圆形存储在数组中便于管理\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n// 存储生成的圆形\nlet circles = [];\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 初始化圆形数组\n  circles = [];\n  \n  // 添加标题文本\n  this.add.text(400, 30, '每1.5秒生成一个红色圆形（最多8个）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 显示计数器\n  const counterText = this.add.text(400, 60, '已生成: 0/8', {\n    fontSize: '18px',\n    color: '#ffff00'\n  }).setOrigin(0.5);\n  \n  // 创建定时器事件，每1.5秒触发一次，最多重复7次（加上首次共8次）\n  this.time.addEvent({\n    delay: 1500,                    // 1.5秒 = 1500毫秒\n    callback: spawnCircle,          // 回调函数\n    callbackScope: this,            // 回调函数的作用域\n    args: [counterText],            // 传递参数\n    repeat: 7,                      // 重复7次，加上首次执行共8次\n    loop: false                     // 不循环\n  });\n}\n\nfunction spawnCircle(counterText) {\n  // 生成随机位置（避免圆形超出边界）\n  const radius = 30;\n  const x = Phaser.Math.Between(radius + 50, 800 - radius - 50);\n  const y = Phaser.Math.Between(radius + 100, 600 - radius - 50);\n  \n  // 创建 Graphics 对象绘制红色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);  // 红色，不透明\n  graphics.fillCircle(x, y, radius);\n  \n  // 添加白色边框使圆形更明显\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeCircle(x, y, radius);\n  \n  // 存储圆形\n  circles.push(graphics);\n  \n  // 更新计数器文本\n  counterText.setText(`已生成: ${circles.length}/8`);\n  \n  // 添加缩放动画效果\n  graphics.setScale(0);\n  this.tweens.add({\n    targets: graphics,\n    scale: 1,\n    duration: 300,\n    ease: 'Back.easeOut'\n  });\n  \n  // 在圆形中心显示序号\n  this.add.text(x, y, circles.length.toString(), {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n  \n  // 如果达到8个，显示完成提示\n  if (circles.length === 8) {\n    this.time.delayedCall(500, () => {\n      this.add.text(400, 550, '已生成全部8个圆形！', {\n        fontSize: '24px',\n        color: '#00ff00',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n    });\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000075_v3", "prompt_id": "seed_000075", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色移动平台：平台以 300 速度水平往返移动，玩家可站在上面并跟随移动，重力 300。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现粉色移动平台，玩家可站立并跟随移动，重力300，平台速度300\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.GameObjects.Sprite, Phaser.Input.Keyboard\nSTEPS:\n1. 创建物理系统配置，设置重力为300\n2. 使用Graphics生成粉色平台纹理和玩家纹理\n3. 创建移动平台精灵，设置水平往返移动逻辑\n4. 创建玩家精灵，添加键盘控制\n5. 设置玩家与平台的碰撞检测，实现站立跟随效果\n6. 添加状态信号变量用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    // 状态信号变量\n    this.platformPosition = 0;\n    this.playerOnPlatform = false;\n    this.platformDirection = 1; // 1: 向右, -1: 向左\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建粉色平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0xFF69B4, 1); // 粉色\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platformTex', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000FF, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('playerTex', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面（用于参考）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x808080, 1);\n    groundGraphics.fillRect(0, 550, 800, 50);\n    groundGraphics.generateTexture('groundTex', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建地面物理对象\n    this.ground = this.physics.add.sprite(400, 575, 'groundTex');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(200, 400, 'platformTex');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.body.setVelocityX(300); // 初始速度向右\n    \n    // 设置平台移动范围\n    this.platformMinX = 100;\n    this.platformMaxX = 700;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'playerTex');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.platform, () => {\n      // 检测玩家是否在平台上方\n      if (this.player.body.touching.down && this.platform.body.touching.up) {\n        this.playerOnPlatform = true;\n      }\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加调试文本\n    this.debugText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 重置平台状态\n    this.playerOnPlatform = false;\n\n    // 平台往返移动逻辑\n    if (this.platform.x >= this.platformMaxX) {\n      this.platform.body.setVelocityX(-300);\n      this.platformDirection = -1;\n    } else if (this.platform.x <= this.platformMinX) {\n      this.platform.body.setVelocityX(300);\n      this.platformDirection = 1;\n    }\n\n    // 记录平台位置\n    this.platformPosition = Math.round(this.platform.x);\n\n    // 玩家控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      // 如果玩家在平台上，跟随平台移动\n      if (this.player.body.touching.down && this.platform.body.touching.up) {\n        this.playerOnPlatform = true;\n        this.player.setVelocityX(this.platform.body.velocity.x);\n      } else {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 更新调试信息\n    this.debugText.setText([\n      `Platform Position: ${this.platformPosition}`,\n      `Platform Direction: ${this.platformDirection === 1 ? 'Right' : 'Left'}`,\n      `Player On Platform: ${this.playerOnPlatform}`,\n      `Player Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `Platform Velocity: ${Math.round(this.platform.body.velocity.x)}`,\n      '',\n      'Controls: Arrow Keys to Move, Up to Jump'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001939_v3", "prompt_id": "seed_001939", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 AI 对战：青色AI 角色以 360 速度追踪玩家，玩家收集 5 个物品获胜，被 AI 碰到失败。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现 AI 追踪对战游戏，玩家收集 5 个物品获胜，被 AI 碰到失败\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.moveToObject, Phaser.Input.Keyboard.createCursorKeys, Phaser.Physics.Arcade.overlap\nSTEPS:\n1. 创建玩家角色（绿色方块）和 AI 角色（青色方块），启用物理系统\n2. 生成 5 个可收集物品（黄色圆圈），随机分布在场景中\n3. 实现玩家键盘控制（方向键），设置移动速度\n4. 在 update 中让 AI 以 360 速度追踪玩家位置\n5. 检测玩家与物品的碰撞（收集计数），检测玩家与 AI 碰撞（游戏失败）\n6. 当收集数达到 5 时显示胜利，被 AI 碰到显示失败\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.gameWon = false;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建 AI 纹理（青色方块）\n    const aiGraphics = this.add.graphics();\n    aiGraphics.fillStyle(0x00ffff, 1);\n    aiGraphics.fillRect(0, 0, 32, 32);\n    aiGraphics.generateTexture('ai', 32, 32);\n    aiGraphics.destroy();\n\n    // 创建物品纹理（黄色圆圈）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('item', 24, 24);\n    itemGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建 AI\n    this.ai = this.physics.add.sprite(100, 100, 'ai');\n    this.ai.setCollideWorldBounds(true);\n\n    // 创建物品组\n    this.items = this.physics.add.group();\n    \n    // 使用固定种子生成物品位置（确保确定性）\n    const seed = 12345;\n    let random = this.seededRandom(seed);\n    \n    for (let i = 0; i < 5; i++) {\n      const x = 100 + random() * 600;\n      const y = 100 + random() * 400;\n      const item = this.items.create(x, y, 'item');\n      item.setCircle(12);\n    }\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(this.player, this.items, this.collectItem, null, this);\n    this.physics.add.overlap(this.player, this.ai, this.hitAI, null, this);\n\n    // UI 文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0 / 5', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    this.statusText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ffffff',\n      align: 'center'\n    });\n    this.statusText.setOrigin(0.5);\n    this.statusText.setVisible(false);\n\n    // 初始化随机数生成器状态\n    this.randomState = seed;\n  }\n\n  update(time, delta) {\n    if (this.gameOver || this.gameWon) {\n      return;\n    }\n\n    // 玩家控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    }\n\n    // AI 追踪玩家，速度 360\n    this.physics.moveToObject(this.ai, this.player, 360);\n  }\n\n  collectItem(player, item) {\n    item.destroy();\n    this.score++;\n    this.scoreText.setText('Score: ' + this.score + ' / 5');\n\n    if (this.score >= 5) {\n      this.winGame();\n    }\n  }\n\n  hitAI(player, ai) {\n    this.loseGame();\n  }\n\n  winGame() {\n    this.gameWon = true;\n    this.player.setVelocity(0);\n    this.ai.setVelocity(0);\n    this.statusText.setText('YOU WIN!');\n    this.statusText.setFill('#00ff00');\n    this.statusText.setVisible(true);\n  }\n\n  loseGame() {\n    this.gameOver = true;\n    this.player.setVelocity(0);\n    this.ai.setVelocity(0);\n    this.statusText.setText('GAME OVER');\n    this.statusText.setFill('#ff0000');\n    this.statusText.setVisible(true);\n  }\n\n  // 简单的伪随机数生成器（确保确定性）\n  seededRandom(seed) {\n    let state = seed;\n    return function() {\n      state = (state * 9301 + 49297) % 233280;\n      return state / 233280;\n    };\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001851_v2", "prompt_id": "seed_001851", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.39}}
