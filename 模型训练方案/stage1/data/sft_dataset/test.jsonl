{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画让 alpha 属性从 0 变化到 1，持续 1 秒\n4. 设置 Tween 的 yoyo 和 repeat 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建 Sprite 并设置到屏幕中心\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 1000,            // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 反向播放（从 1 回到 0）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '方块透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000386_v2", "prompt_id": "seed_000386", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现血条+回血：显示 8 格生命值，按方向键扣血，每 4 秒自动回复 1 点。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现8格血条显示，方向键扣血，每4秒自动回复1点生命值\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Time.Clock#addEvent, Phaser.GameObjects.Text\nSTEPS:\n1. 创建8格血条UI，使用Graphics绘制红色方块表示生命值\n2. 监听方向键输入，按下任意方向键扣除1点生命值\n3. 使用TimerEvent每4秒自动回复1点生命值（不超过最大值8）\n4. 实时更新血条显示，根据当前生命值重绘Graphics\n5. 添加文本显示当前生命值数值，方便验证状态\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.maxHealth = 8;\n    this.currentHealth = 8;\n    this.healthBarGraphics = null;\n    this.healthText = null;\n    this.cursors = null;\n    this.canTakeDamage = true;\n    this.damageDelay = 200; // 防止连续扣血的延迟（毫秒）\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建标题文字\n    this.add.text(400, 100, '生命值系统演示', {\n      fontSize: '32px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 创建说明文字\n    this.add.text(400, 150, '按方向键扣血 | 每4秒自动回复1点', {\n      fontSize: '18px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.healthBarGraphics = this.add.graphics();\n    \n    // 创建生命值文本显示\n    this.healthText = this.add.text(400, 250, '', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 初始化绘制血条\n    this.updateHealthBar();\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加额外的WASD键支持\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 设置自动回血计时器（每4秒触发一次）\n    this.time.addEvent({\n      delay: 4000,\n      callback: this.regenerateHealth,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 添加调试信息\n    this.add.text(20, 20, '状态验证:', {\n      fontSize: '16px',\n      color: '#00ff00'\n    });\n\n    this.debugText = this.add.text(20, 45, '', {\n      fontSize: '14px',\n      color: '#00ff00'\n    });\n\n    this.updateDebugInfo();\n  }\n\n  update(time, delta) {\n    // 检测方向键按下（包括WASD）\n    if (this.canTakeDamage) {\n      if (this.cursors.up.isDown || this.keyW.isDown ||\n          this.cursors.down.isDown || this.keyS.isDown ||\n          this.cursors.left.isDown || this.keyA.isDown ||\n          this.cursors.right.isDown || this.keyD.isDown) {\n        this.takeDamage(1);\n      }\n    }\n  }\n\n  /**\n   * 扣除生命值\n   */\n  takeDamage(amount) {\n    if (this.currentHealth > 0) {\n      this.currentHealth = Math.max(0, this.currentHealth - amount);\n      this.updateHealthBar();\n      this.updateDebugInfo();\n\n      // 设置扣血冷却，防止连续扣血\n      this.canTakeDamage = false;\n      this.time.delayedCall(this.damageDelay, () => {\n        this.canTakeDamage = true;\n      });\n\n      // 死亡检测\n      if (this.currentHealth === 0) {\n        this.showGameOver();\n      }\n    }\n  }\n\n  /**\n   * 自动回复生命值\n   */\n  regenerateHealth() {\n    if (this.currentHealth < this.maxHealth && this.currentHealth > 0) {\n      this.currentHealth = Math.min(this.maxHealth, this.currentHealth + 1);\n      this.updateHealthBar();\n      this.updateDebugInfo();\n      \n      // 显示回血提示\n      const regenText = this.add.text(400, 350, '+1 HP', {\n        fontSize: '20px',\n        color: '#00ff00'\n      }).setOrigin(0.5);\n\n      // 回血文字淡出效果\n      this.tweens.add({\n        targets: regenText,\n        alpha: 0,\n        y: 320,\n        duration: 1000,\n        ease: 'Power2',\n        onComplete: () => {\n          regenText.destroy();\n        }\n      });\n    }\n  }\n\n  /**\n   * 更新血条显示\n   */\n  updateHealthBar() {\n    this.healthBarGraphics.clear();\n\n    const barWidth = 40;  // 每格血条宽度\n    const barHeight = 40; // 每格血条高度\n    const spacing = 8;    // 格子间距\n    const startX = 400 - (this.maxHealth * (barWidth + spacing) - spacing) / 2; // 居中起始位置\n    const startY = 300;\n\n    // 绘制所有血条格子\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + spacing);\n      \n      // 绘制边框\n      this.healthBarGraphics.lineStyle(3, 0x666666, 1);\n      this.healthBarGraphics.strokeRect(x, startY, barWidth, barHeight);\n\n      // 如果当前格子有生命值，填充红色\n      if (i < this.currentHealth) {\n        this.healthBarGraphics.fillStyle(0xff0000, 1);\n        this.healthBarGraphics.fillRect(x + 3, startY + 3, barWidth - 6, barHeight - 6);\n      } else {\n        // 空血格子填充深灰色\n        this.healthBarGraphics.fillStyle(0x333333, 1);\n        this.healthBarGraphics.fillRect(x + 3, startY + 3, barWidth - 6, barHeight - 6);\n      }\n    }\n\n    // 更新生命值文本\n    this.healthText.setText(`生命值: ${this.currentHealth} / ${this.maxHealth}`);\n  }\n\n  /**\n   * 更新调试信息\n   */\n  updateDebugInfo() {\n    this.debugText.setText(\n      `currentHealth: ${this.currentHealth}\\n` +\n      `maxHealth: ${this.maxHealth}\\n` +\n      `healthPercentage: ${((this.currentHealth / this.maxHealth) * 100).toFixed(1)}%`\n    );\n  }\n\n  /**\n   * 显示游戏结束\n   */\n  showGameOver() {\n    const gameOverText = this.add.text(400, 450, '生命值耗尽！', {\n      fontSize: '28px',\n      color: '#ff0000'\n    }).setOrigin(0.5);\n\n    // 闪烁效果\n    this.tweens.add({\n      targets: gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 3秒后重置\n    this.time.delayedCall(3000, () => {\n      this.currentHealth = this.maxHealth;\n      this.updateHealthBar();\n      this.updateDebugInfo();\n      gameOverText.destroy();\n      this.canTakeDamage = true;\n    });\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: HealthBarScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001108_v1", "prompt_id": "seed_001108", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让粉色菱形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色菱形在1.5秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制粉色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建 y 轴弹跳动画，设置缓动函数模拟弹跳效果\n4. 设置动画循环播放，总时长1.5秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建粉色菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（旋转45度的正方形）\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，初始位置在屏幕中上方\n  const diamond = this.add.sprite(400, 200, 'diamond');\n  \n  // 设置原点为中心\n  diamond.setOrigin(0.5, 0.5);\n  \n  // 创建弹跳动画\n  // 使用 Bounce.easeOut 模拟真实的弹跳效果\n  this.tweens.add({\n    targets: diamond,\n    y: 400, // 弹跳到的目标位置\n    duration: 750, // 下落时间 0.75秒\n    ease: 'Bounce.easeOut', // 弹跳缓动\n    yoyo: true, // 来回运动\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加轻微的缩放效果增强弹跳感\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 1.1,\n    scaleY: 0.9,\n    duration: 750,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 550, '粉色菱形弹跳动画 (1.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000333_v2", "prompt_id": "seed_000333", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色圆形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的粉色圆形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环5次创建 Graphics 对象\n3. 每个 Graphics 对象使用 fillStyle 设置粉色，用 fillCircle 绘制半径为24的圆形\n4. 使用 setRandomPosition 将每个圆形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建5个随机位置的粉色圆形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充 (0xff69b4 是粉色的十六进制值)\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 绘制圆形，圆心在 (0, 0)，半径为 24 (直径48)\n    graphics.fillCircle(0, 0, 24);\n    \n    // 设置随机位置\n    // 考虑圆形半径，确保圆形完全在画布内\n    const randomX = Phaser.Math.Between(24, 800 - 24);\n    const randomY = Phaser.Math.Between(24, 600 - 24);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000089_v2", "prompt_id": "seed_000089", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色椭圆在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让白色椭圆在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Ellipse, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽度为 800，高度为 600\n2. 在 create 方法中使用 Graphics 或 Ellipse 绘制白色椭圆\n3. 使用 this.tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 设置 duration 为 2000ms，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建白色椭圆\n  // 椭圆初始位置在左侧（x=100），垂直居中（y=300）\n  const ellipse = this.add.ellipse(100, 300, 80, 50, 0xffffff);\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 2000,             // 持续时间 2 秒\n    yoyo: true,                 // 往返效果（到达终点后反向回到起点）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Linear'              // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000777_v3", "prompt_id": "seed_000777", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 AI 对战：蓝色AI 角色以 360 速度追踪玩家，玩家收集 5 个物品获胜，被 AI 碰到失败。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现 AI 追踪对战游戏，玩家收集 5 个物品获胜，被 AI 碰到失败\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.moveToObject, Phaser.Physics.Arcade.overlap, Phaser.GameObjects.Graphics, Phaser.Scene.add.text\nSTEPS:\n1. 创建玩家角色（绿色方块）和 AI 角色（蓝色方块），使用物理系统\n2. 生成 5 个可收集物品（黄色圆形），随机分布在场景中\n3. 实现玩家键盘控制（方向键移动）\n4. 实现 AI 追踪逻辑，使用 moveToObject 以 360 速度追踪玩家\n5. 检测玩家与物品的碰撞（收集），检测玩家与 AI 的碰撞（失败）\n6. 显示收集进度和游戏状态，达成胜利/失败条件时停止游戏\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet aiEnemy;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet statusText;\nlet score = 0;\nlet gameOver = false;\nlet gameWon = false;\nconst TOTAL_COLLECTIBLES = 5;\nconst AI_SPEED = 360;\nconst PLAYER_SPEED = 250;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建 AI 纹理（蓝色方块）\n  const aiGraphics = this.add.graphics();\n  aiGraphics.fillStyle(0x0088ff, 1);\n  aiGraphics.fillRect(0, 0, 32, 32);\n  aiGraphics.generateTexture('ai', 32, 32);\n  aiGraphics.destroy();\n\n  // 创建收集物纹理（黄色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0xffff00, 1);\n  collectibleGraphics.fillCircle(12, 12, 12);\n  collectibleGraphics.generateTexture('collectible', 24, 24);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 100, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建 AI 敌人\n  aiEnemy = this.physics.add.sprite(700, 500, 'ai');\n  aiEnemy.setCollideWorldBounds(true);\n\n  // 创建收集物品组\n  collectibles = this.physics.add.group();\n  \n  // 使用固定种子生成收集物位置（保证确定性）\n  const positions = [\n    { x: 400, y: 300 },\n    { x: 200, y: 500 },\n    { x: 600, y: 150 },\n    { x: 150, y: 300 },\n    { x: 650, y: 450 }\n  ];\n\n  positions.forEach(pos => {\n    const collectible = collectibles.create(pos.x, pos.y, 'collectible');\n    collectible.setCircle(12);\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n  this.physics.add.overlap(player, aiEnemy, hitAI, null, this);\n\n  // 创建 UI 文本\n  scoreText = this.add.text(16, 16, `收集进度: ${score}/${TOTAL_COLLECTIBLES}`, {\n    fontSize: '24px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  statusText = this.add.text(400, 300, '', {\n    fontSize: '48px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  statusText.setOrigin(0.5);\n  statusText.setVisible(false);\n\n  // 添加边界线（可选，帮助视觉识别）\n  const graphics = this.add.graphics();\n  graphics.lineStyle(2, 0x00ff00, 0.3);\n  graphics.strokeRect(0, 0, 800, 600);\n}\n\nfunction update(time, delta) {\n  if (gameOver || gameWon) {\n    player.setVelocity(0, 0);\n    aiEnemy.setVelocity(0, 0);\n    return;\n  }\n\n  // 玩家移动控制\n  player.setVelocity(0, 0);\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-PLAYER_SPEED);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(PLAYER_SPEED);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-PLAYER_SPEED);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(PLAYER_SPEED);\n  }\n\n  // 对角线移动时归一化速度\n  if (player.body.velocity.x !== 0 && player.body.velocity.y !== 0) {\n    player.body.velocity.normalize().scale(PLAYER_SPEED);\n  }\n\n  // AI 追踪玩家\n  this.physics.moveToObject(aiEnemy, player, AI_SPEED);\n}\n\n// 收集物品回调\nfunction collectItem(player, collectible) {\n  collectible.disableBody(true, true);\n  score++;\n  scoreText.setText(`收集进度: ${score}/${TOTAL_COLLECTIBLES}`);\n\n  // 检查胜利条件\n  if (score >= TOTAL_COLLECTIBLES) {\n    gameWon = true;\n    statusText.setText('胜利！\\n收集完成！');\n    statusText.setFill('#00ff00');\n    statusText.setVisible(true);\n    this.physics.pause();\n  }\n}\n\n// 碰到 AI 回调\nfunction hitAI(player, aiEnemy) {\n  if (!gameOver && !gameWon) {\n    gameOver = true;\n    statusText.setText('失败！\\n被 AI 抓住了！');\n    statusText.setFill('#ff0000');\n    statusText.setVisible(true);\n    this.physics.pause();\n    \n    // 玩家变红表示失败\n    player.setTint(0xff0000);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001834_v1", "prompt_id": "seed_001834", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个16像素的紫色菱形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置生成16像素紫色菱形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中监听 pointerdown 事件\n3. 在点击回调中使用 Graphics 绘制菱形路径（4个顶点形成菱形）\n4. 将菱形中心定位到点击位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 监听画布点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充\n    graphics.fillStyle(0x9932cc, 1); // 紫色\n    \n    // 绘制菱形路径\n    // 菱形是由4个顶点构成的多边形\n    // 以点击位置为中心，边长16像素\n    const centerX = pointer.x;\n    const centerY = pointer.y;\n    const halfSize = 8; // 16像素菱形的半径\n    \n    // 创建菱形路径（上、右、下、左四个顶点）\n    const diamond = new Phaser.Geom.Polygon([\n      centerX, centerY - halfSize,           // 上顶点\n      centerX + halfSize, centerY,           // 右顶点\n      centerX, centerY + halfSize,           // 下顶点\n      centerX - halfSize, centerY            // 左顶点\n    ]);\n    \n    // 填充菱形\n    graphics.fillPoints(diamond.points, true);\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Click anywhere to create purple diamonds', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000105_v1", "prompt_id": "seed_000105", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央创建一个持续发射粒子的发射器，粒子数量上限 8 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Particles.ParticleEmitter", "output": "[PLAN]\nREQ: 在画布中央创建粒子发射器，粒子数量上限8个\nAPI: this.add.particles, Graphics.fillStyle, Graphics.fillCircle, Graphics.generateTexture, ParticleEmitter.setConfig\nSTEPS:\n1. 使用 Graphics 创建一个圆形纹理作为粒子贴图\n2. 在画布中央 (400, 300) 创建粒子发射器\n3. 配置发射器参数：maxParticles 设为 8，设置速度、生命周期等属性\n4. 启动粒子发射器持续发射\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建粒子纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(8, 8, 8);\n  graphics.generateTexture('particle', 16, 16);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 在画布中央创建粒子发射器\n  const particles = this.add.particles(400, 300, 'particle', {\n    // 粒子数量上限设为 8\n    maxParticles: 8,\n    // 发射速度\n    speed: { min: 100, max: 200 },\n    // 发射角度范围（全方向）\n    angle: { min: 0, max: 360 },\n    // 粒子缩放\n    scale: { start: 1, end: 0 },\n    // 粒子透明度\n    alpha: { start: 1, end: 0 },\n    // 粒子生命周期（毫秒）\n    lifespan: 2000,\n    // 粒子颜色渐变\n    tint: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00],\n    // 发射频率（每秒发射的粒子数）\n    frequency: 200,\n    // 混合模式\n    blendMode: 'ADD'\n  });\n\n  // 添加提示文字\n  this.add.text(400, 50, 'Particle Emitter (Max: 8 particles)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  // 显示实时粒子数量\n  const countText = this.add.text(400, 550, '', {\n    fontSize: '18px',\n    color: '#00ff00'\n  }).setOrigin(0.5);\n\n  // 更新粒子数量显示\n  this.time.addEvent({\n    delay: 100,\n    callback: () => {\n      const aliveCount = particles.getAliveParticleCount();\n      countText.setText(`Active Particles: ${aliveCount} / 8`);\n    },\n    loop: true\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000317_v1", "prompt_id": "seed_000317", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Particles"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 1.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Graphics 对象绘制矩形\n2. 设置矩形初始透明度为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1\n4. 设置 Tween 循环播放（loop: -1）和持续时间 1500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 在屏幕中央绘制一个 200x150 的矩形\n  const rectWidth = 200;\n  const rectHeight = 150;\n  const rectX = (this.cameras.main.width - rectWidth) / 2;\n  const rectY = (this.cameras.main.height - rectHeight) / 2;\n  \n  graphics.fillRect(rectX, rectY, rectWidth, rectHeight);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    alpha: 1,                    // 目标透明度值（完全不透明）\n    duration: 1500,              // 持续时间 1.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: false,                 // 不反向播放\n    repeat: -1,                  // 无限循环（-1 表示永久重复）\n    repeatDelay: 0               // 重复之间无延迟\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '矩形渐变动画（循环播放）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000503_v3", "prompt_id": "seed_000503", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：5 个圆形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 玩家控制角色收集5个随机分布的圆形物品，全部收集后显示通关文本\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text, this.input.keyboard.createCursorKeys\nSTEPS:\n1. 创建物理引擎场景，初始化玩家精灵（使用Graphics绘制方形）\n2. 使用Graphics随机生成5个圆形收集物，添加物理属性\n3. 设置键盘控制（方向键）实现玩家移动\n4. 添加碰撞检测，收集物品时销毁并增加计数\n5. 当收集数达到5时显示\"恭喜通关\"文本\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet collectedCount = 0;\nlet totalCollectibles = 5;\nlet winText;\nlet scoreText;\n\nfunction preload() {\n  // 使用Graphics创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00aaff, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（黄色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0xffff00, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setScale(1);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成5个收集物\n  for (let i = 0; i < totalCollectibles; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    \n    // 添加轻微的随机移动效果\n    collectible.setVelocity(\n      Phaser.Math.Between(-50, 50),\n      Phaser.Math.Between(-50, 50)\n    );\n    collectible.setBounce(1, 1);\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, '已收集: 0 / 5', {\n    fontSize: '24px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 创建通关文本（初始隐藏）\n  winText = this.add.text(400, 300, '恭喜通关！', {\n    fontSize: '64px',\n    fill: '#00ff00',\n    fontFamily: 'Arial',\n    fontStyle: 'bold'\n  });\n  winText.setOrigin(0.5);\n  winText.setVisible(false);\n\n  // 添加游戏说明\n  this.add.text(16, 50, '使用方向键移动，收集所有黄色圆圈', {\n    fontSize: '16px',\n    fill: '#cccccc',\n    fontFamily: 'Arial'\n  });\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n  \n  // 增加收集计数\n  collectedCount++;\n  \n  // 更新分数文本\n  scoreText.setText('已收集: ' + collectedCount + ' / ' + totalCollectibles);\n  \n  // 检查是否收集完成\n  if (collectedCount >= totalCollectibles) {\n    // 显示通关文本\n    winText.setVisible(true);\n    \n    // 停止玩家移动\n    player.setVelocity(0, 0);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: winText,\n      alpha: { from: 1, to: 0.3 },\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n    \n    // 可选：3秒后重启游戏\n    this.time.delayedCall(3000, () => {\n      this.scene.restart();\n      collectedCount = 0;\n    });\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001439_v3", "prompt_id": "seed_001439", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色星形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色星形以160速度移动并在画布边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制蓝色星形并生成纹理\n3. 创建物理精灵，应用星形纹理\n4. 设置精灵速度为 160（x和y方向各取随机值保证总速度约160）\n5. 设置精灵与世界边界碰撞并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  \n  // 绘制星形（中心点在64,64，半径50）\n  graphics.fillStar(64, 64, 5, 20, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 128, 128);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置初始速度（使用勾股定理确保总速度约为160）\n  // 160 = sqrt(vx^2 + vy^2)，这里使用 45度角\n  const speed = 160;\n  const angle = Phaser.Math.DegToRad(45); // 45度角\n  const vx = Math.cos(angle) * speed;\n  const vy = Math.sin(angle) * speed;\n  \n  star.setVelocity(vx, vy);\n  \n  // 设置与世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  star.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, 'Blue star bouncing at 160 speed', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000788_v1", "prompt_id": "seed_000788", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 4 秒在随机位置生成一个灰色方块，最多生成 12 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔4秒在随机位置生成灰色方块，最多12个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Container\nSTEPS:\n1. 创建 Scene 并初始化计数器变量\n2. 使用 Graphics 创建灰色方块纹理\n3. 使用 time.addEvent 创建定时器，每4秒触发一次\n4. 在定时器回调中检查方块数量，未达到12个则在随机位置生成方块\n5. 达到12个后停止定时器\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n// 方块计数器\nlet blockCount = 0;\nconst MAX_BLOCKS = 12;\nlet timerEvent = null;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 重置计数器\n  blockCount = 0;\n  \n  // 使用 Graphics 创建灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 40, 40); // 40x40 的方块\n  graphics.generateTexture('grayBlock', 40, 40);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n  \n  // 创建定时器事件，每4秒执行一次\n  timerEvent = this.time.addEvent({\n    delay: 4000, // 4秒 = 4000毫秒\n    callback: spawnBlock,\n    callbackScope: this,\n    loop: true // 循环执行\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, '灰色方块生成器', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n  \n  this.blockCountText = this.add.text(10, 40, `方块数量: 0 / ${MAX_BLOCKS}`, {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction spawnBlock() {\n  // 检查是否已达到最大数量\n  if (blockCount >= MAX_BLOCKS) {\n    // 停止定时器\n    if (timerEvent) {\n      timerEvent.remove();\n      timerEvent = null;\n    }\n    \n    // 更新提示文本\n    this.blockCountText.setText(`方块数量: ${blockCount} / ${MAX_BLOCKS} (已完成)`);\n    return;\n  }\n  \n  // 生成随机位置\n  // 确保方块完全在画布内（考虑方块大小40x40）\n  const x = Phaser.Math.Between(20, 780);\n  const y = Phaser.Math.Between(80, 580);\n  \n  // 创建方块\n  const block = this.add.image(x, y, 'grayBlock');\n  \n  // 添加简单的缩放动画效果\n  block.setScale(0);\n  this.tweens.add({\n    targets: block,\n    scale: 1,\n    duration: 300,\n    ease: 'Back.easeOut'\n  });\n  \n  // 增加计数\n  blockCount++;\n  \n  // 更新计数文本\n  this.blockCountText.setText(`方块数量: ${blockCount} / ${MAX_BLOCKS}`);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000219_v1", "prompt_id": "seed_000219", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按空格键向当前朝向发射子弹，子弹速度 160，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现多方向射击系统，玩家可旋转改变朝向并按空格键发射子弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建玩家精灵，使用 Graphics 绘制三角形表示朝向\n2. 设置键盘输入（方向键旋转玩家，空格键发射子弹）\n3. 创建子弹组（Physics Group），管理所有发射的子弹\n4. 在空格键按下时，根据玩家当前角度计算子弹速度向量并发射\n5. 子弹超出屏幕边界时自动回收到对象池\n6. 添加状态变量（bulletsFired）用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 状态信号：已发射子弹数\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（三角形表示朝向）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(20, 0);  // 尖端朝右\n    playerGraphics.lineTo(-10, -10);\n    playerGraphics.lineTo(-10, 10);\n    playerGraphics.closePath();\n    playerGraphics.fillPath();\n    playerGraphics.generateTexture('player', 30, 20);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（小圆点）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: true\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, 'Arrow Keys: Rotate | Space: Shoot', {\n      fontSize: '14px',\n      fill: '#ffffff'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家旋转控制\n    if (this.cursors.left.isDown) {\n      this.player.angle -= 3;\n    } else if (this.cursors.right.isDown) {\n      this.player.angle += 3;\n    }\n\n    // 发射子弹（防止连续发射，添加冷却）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      this.shootBullet();\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -10 || bullet.x > 810 || bullet.y < -10 || bullet.y > 610) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText(\n      `Bullets Fired: ${this.bulletsFired}\\n` +\n      `Active Bullets: ${this.bullets.countActive(true)}\\n` +\n      `Player Angle: ${Math.round(this.player.angle)}°`\n    );\n  }\n\n  shootBullet() {\n    // 从对象池获取子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹角度与玩家一致\n      bullet.setAngle(this.player.angle);\n      \n      // 根据玩家角度计算速度向量\n      // Phaser 中角度 0 度对应右侧，需要转换为弧度\n      const angleInRadians = Phaser.Math.DegToRad(this.player.angle);\n      \n      // 计算速度分量（速度 160）\n      const velocityX = Math.cos(angleInRadians) * 160;\n      const velocityY = Math.sin(angleInRadians) * 160;\n      \n      bullet.setVelocity(velocityX, velocityY);\n      \n      // 增加发射计数\n      this.bulletsFired++;\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001163_v1", "prompt_id": "seed_001163", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个80像素的粉色星形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置生成80像素粉色星形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Graphics.fillStar, Graphics.generateTexture, Scene.add.image\nSTEPS:\n1. 在 create 中使用 Graphics 绘制粉色星形并生成纹理\n2. 监听 POINTER_DOWN 事件获取点击坐标\n3. 在点击位置创建星形图像对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色星形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xffc0cb, 1);\n  \n  // 绘制星形（中心点在 40, 40，外半径 40，内半径 16，5个角）\n  graphics.fillStar(40, 40, 5, 16, 40, 0);\n  \n  // 生成纹理（80x80 像素）\n  graphics.generateTexture('pinkStar', 80, 80);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 监听点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 在点击位置创建星形图像\n    const star = this.add.image(pointer.x, pointer.y, 'pinkStar');\n    \n    // 可选：添加简单的缩放动画效果\n    star.setScale(0);\n    this.tweens.add({\n      targets: star,\n      scale: 1,\n      duration: 200,\n      ease: 'Back.easeOut'\n    });\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 30, 'Click anywhere to create pink stars!', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000715_v3", "prompt_id": "seed_000715", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 记录玩家 0.5 秒内的操作序列，按方向键开始回放，回放速度可调。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 记录玩家0.5秒内的操作序列，按方向键开始回放，回放速度可调\nAPI: Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Time.TimerEvent, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家角色（使用Graphics绘制方块）和显示文本\n2. 监听WASD键盘输入，记录0.5秒内的操作序列（时间戳+按键）\n3. 按方向键（上下）开始回放，上键加速，下键减速\n4. 回放时按时间戳重现玩家操作，显示回放状态和速度\n5. 回放结束后可重新录制\n[/PLAN]\n\n```javascript\nclass RecordReplayScene extends Phaser.Scene {\n  constructor() {\n    super('RecordReplayScene');\n    this.recordDuration = 500; // 0.5秒 = 500毫秒\n    this.recordedActions = []; // 记录操作序列 [{time, key, action}]\n    this.isRecording = false;\n    this.isReplaying = false;\n    this.recordStartTime = 0;\n    this.replayStartTime = 0;\n    this.replaySpeed = 1.0; // 回放速度倍率\n    this.replayIndex = 0;\n    \n    // 玩家状态\n    this.playerX = 400;\n    this.playerY = 300;\n    this.moveSpeed = 200;\n    \n    // 可验证状态\n    this.totalMoves = 0;\n    this.replayCount = 0;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建玩家（绿色方块）\n    this.player = this.add.graphics();\n    this.player.fillStyle(0x00ff00, 1);\n    this.player.fillRect(-15, -15, 30, 30);\n    this.player.x = this.playerX;\n    this.player.y = this.playerY;\n\n    // 创建录制指示器（红色圆点）\n    this.recordIndicator = this.add.graphics();\n    this.recordIndicator.fillStyle(0xff0000, 1);\n    this.recordIndicator.fillCircle(0, 0, 8);\n    this.recordIndicator.x = 50;\n    this.recordIndicator.y = 50;\n    this.recordIndicator.setVisible(false);\n\n    // 创建回放指示器（蓝色方块）\n    this.replayIndicator = this.add.graphics();\n    this.replayIndicator.fillStyle(0x0000ff, 1);\n    this.replayIndicator.fillRect(-10, -10, 20, 20);\n    this.replayIndicator.x = 50;\n    this.replayIndicator.y = 50;\n    this.replayIndicator.setVisible(false);\n\n    // 状态文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.infoText = this.add.text(10, 100, \n      'Controls:\\n' +\n      'WASD - Move & Record (0.5s)\\n' +\n      'UP Arrow - Start Replay (faster)\\n' +\n      'DOWN Arrow - Start Replay (slower)\\n' +\n      'LEFT/RIGHT - Adjust replay speed', {\n      fontSize: '14px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 5 }\n    });\n\n    // 统计文本\n    this.statsText = this.add.text(10, 550, '', {\n      fontSize: '16px',\n      fill: '#00ffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 键盘输入\n    this.keys = {\n      W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n      A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n      S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n      D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),\n      UP: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP),\n      DOWN: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN),\n      LEFT: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT),\n      RIGHT: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT)\n    };\n\n    // 监听按键按下事件\n    this.input.keyboard.on('keydown', (event) => {\n      this.handleKeyDown(event.keyCode);\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    if (this.isReplaying) {\n      this.updateReplay(time);\n    } else if (!this.isRecording) {\n      // 空闲状态，可以开始录制\n      if (this.keys.W.isDown || this.keys.A.isDown || \n          this.keys.S.isDown || this.keys.D.isDown) {\n        this.startRecording(time);\n      }\n    } else {\n      // 正在录制\n      const elapsed = time - this.recordStartTime;\n      if (elapsed >= this.recordDuration) {\n        this.stopRecording();\n      }\n    }\n\n    // 录制期间移动玩家\n    if (this.isRecording && !this.isReplaying) {\n      this.movePlayer(delta);\n    }\n\n    this.updateStatusText();\n  }\n\n  handleKeyDown(keyCode) {\n    const time = this.time.now;\n\n    // 录制期间记录按键\n    if (this.isRecording && !this.isReplaying) {\n      const relativeTime = time - this.recordStartTime;\n      let key = null;\n\n      if (keyCode === Phaser.Input.Keyboard.KeyCodes.W) key = 'W';\n      else if (keyCode === Phaser.Input.Keyboard.KeyCodes.A) key = 'A';\n      else if (keyCode === Phaser.Input.Keyboard.KeyCodes.S) key = 'S';\n      else if (keyCode === Phaser.Input.Keyboard.KeyCodes.D) key = 'D';\n\n      if (key) {\n        this.recordedActions.push({\n          time: relativeTime,\n          key: key,\n          action: 'down'\n        });\n      }\n    }\n\n    // 方向键控制回放\n    if (!this.isRecording && !this.isReplaying) {\n      if (keyCode === Phaser.Input.Keyboard.KeyCodes.UP) {\n        this.replaySpeed = 1.5;\n        this.startReplay(time);\n      } else if (keyCode === Phaser.Input.Keyboard.KeyCodes.DOWN) {\n        this.replaySpeed = 0.5;\n        this.startReplay(time);\n      }\n    }\n\n    // 调整回放速度\n    if (this.isReplaying) {\n      if (keyCode === Phaser.Input.Keyboard.KeyCodes.LEFT) {\n        this.replaySpeed = Math.max(0.25, this.replaySpeed - 0.25);\n      } else if (keyCode === Phaser.Input.Keyboard.KeyCodes.RIGHT) {\n        this.replaySpeed = Math.min(3.0, this.replaySpeed + 0.25);\n      }\n    }\n  }\n\n  startRecording(time) {\n    this.isRecording = true;\n    this.recordStartTime = time;\n    this.recordedActions = [];\n    this.recordIndicator.setVisible(true);\n    \n    // 记录初始位置\n    this.recordStartX = this.player.x;\n    this.recordStartY = this.player.y;\n  }\n\n  stopRecording() {\n    this.isRecording = false;\n    this.recordIndicator.setVisible(false);\n  }\n\n  startReplay(time) {\n    if (this.recordedActions.length === 0) {\n      return; // 没有录制内容\n    }\n\n    this.isReplaying = true;\n    this.replayStartTime = time;\n    this.replayIndex = 0;\n    this.replayCount++;\n    \n    // 重置玩家到录制起始位置\n    this.player.x = this.recordStartX;\n    this.player.y = this.recordStartY;\n    \n    this.replayIndicator.setVisible(true);\n\n    // 模拟按键状态\n    this.simulatedKeys = {\n      W: false,\n      A: false,\n      S: false,\n      D: false\n    };\n  }\n\n  updateReplay(time) {\n    const elapsed = (time - this.replayStartTime) * this.replaySpeed;\n\n    // 处理所有应该触发的动作\n    while (this.replayIndex < this.recordedActions.length) {\n      const action = this.recordedActions[this.replayIndex];\n      if (action.time <= elapsed) {\n        // 触发动作\n        if (action.action === 'down') {\n          this.simulatedKeys[action.key] = true;\n        }\n        this.replayIndex++;\n      } else {\n        break;\n      }\n    }\n\n    // 移动玩家（基于模拟按键）\n    this.movePlayerSimulated(this.time.now - this.lastTime || 16);\n    this.lastTime = this.time.now;\n\n    // 检查回放是否结束\n    if (elapsed >= this.recordDuration) {\n      this.stopReplay();\n    }\n  }\n\n  stopReplay() {\n    this.isReplaying = false;\n    this.replayIndicator.setVisible(false);\n    this.simulatedKeys = null;\n  }\n\n  movePlayer(delta) {\n    const distance = (this.moveSpeed * delta) / 1000;\n\n    if (this.keys.W.isDown) {\n      this.player.y -= distance;\n      this.totalMoves++;\n    }\n    if (this.keys.S.isDown) {\n      this.player.y += distance;\n      this.totalMoves++;\n    }\n    if (this.keys.A.isDown) {\n      this.player.x -= distance;\n      this.totalMoves++;\n    }\n    if (this.keys.D.isDown) {\n      this.player.x += distance;\n      this.totalMoves++;\n    }\n\n    // 边界限制\n    this.player.x = Phaser.Math.Clamp(this.player.x, 15, 785);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 15, 585);\n  }\n\n  movePlayerSimulated(delta) {\n    if (!this.simulatedKeys) return;\n\n    const distance = (this.moveSpeed * delta) / 1000;\n\n    if (this.simulatedKeys.W) {\n      this.player.y -= distance;\n    }\n    if (this.simulatedKeys.S) {\n      this.player.y += distance;\n    }\n    if (this.simulatedKeys.A) {\n      this.player.x -= distance;\n    }\n    if (this.simulatedKeys.D) {\n      this.player.x += distance;\n    }\n\n    // 边界限制\n    this.player.x = Phaser.Math.Clamp(this.player.x, 15, 785);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 15, 585);\n  }\n\n  updateStatusText() {\n    let status = '';\n    \n    if (this.isReplaying) {\n      const elapsed = (this.time.now - this.replayStartTime) * this.replaySpeed;\n      const progress = Math.min(100, (elapsed / this.recordDuration) * 100);\n      status = `REPLAYING (${this.replaySpeed.toFixed(2)}x speed) - ${progress.toFixed(0)}%`;\n    } else if (this.isRecording) {\n      const elapsed = this.time.now - this.recordStartTime;\n      const remaining = Math.max(0, this.recordDuration - elapsed);\n      status = `RECORDING - ${(remaining / 1000).toFixed(2)}s remaining`;\n    } else {\n      status = `IDLE - Press WASD to record | Actions: ${this.recordedActions.length}`;\n    }\n\n    this.statusText.setText(status);\n\n    this.statsText.setText(\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})\\n` +\n      `Total Moves: ${this.totalMoves}\\n` +\n      `Replay Count: ${this.replayCount}\\n` +\n      `Recorded Actions: ${this.recordedActions.length}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: RecordReplayScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001822_v3", "prompt_id": "seed_001822", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个24像素的灰色矩形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置，在点击处生成一个24像素的灰色矩形\nAPI: Phaser.Input.Events.POINTER_DOWN, Phaser.GameObjects.Graphics, Graphics.fillRect, Graphics.generateTexture\nSTEPS:\n1. 创建 Phaser 游戏配置，设置场景和画布尺寸\n2. 在 preload 中使用 Graphics 生成灰色矩形纹理\n3. 在 create 中监听 POINTER_DOWN 事件\n4. 在点击事件处理函数中，获取点击坐标并创建使用灰色纹理的精灵对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#ffffff',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成灰色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 24, 24); // 24x24 像素矩形\n  graphics.generateTexture('grayRect', 24, 24);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n}\n\nfunction create() {\n  // 监听画布点击事件\n  this.input.on('pointerdown', (pointer) => {\n    // 在点击位置创建灰色矩形\n    // 设置原点为中心，使矩形中心对齐点击位置\n    const rect = this.add.image(pointer.x, pointer.y, 'grayRect');\n    rect.setOrigin(0.5, 0.5);\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Click anywhere to create gray rectangles', {\n    fontSize: '16px',\n    color: '#000000'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000673_v3", "prompt_id": "seed_000673", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 8 个蓝色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成8个蓝色可收集物体，玩家碰到后消失并加分显示score\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家和收集物的纹理（玩家用绿色方块，收集物用蓝色圆形）\n3. 创建玩家物理精灵，添加键盘控制\n4. 创建物理组，随机生成8个蓝色收集物\n5. 添加 overlap 碰撞检测，碰到后销毁收集物并增加分数\n6. 创建文本对象显示当前分数\n7. 在 update 中处理玩家移动逻辑\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 收集物品游戏代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 不需要加载外部资源，使用程序化生成\n}\n\nfunction create() {\n  // 生成玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 生成收集物纹理（蓝色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x0088ff, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setVelocityDrag(800);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成8个收集物\n  for (let i = 0; i < 8; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCircle(15); // 设置圆形碰撞体\n  }\n\n  // 添加碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 添加提示文本\n  this.add.text(16, 560, 'Use Arrow Keys to Move', {\n    fontSize: '20px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  });\n}\n\nfunction update() {\n  // 重置速度\n  player.setVelocity(0);\n\n  // 键盘控制\n  const speed = 300;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n\n  // 检查是否收集完所有物品\n  if (collectibles.countActive(true) === 0 && score > 0) {\n    scoreText.setText('Score: ' + score + ' - All Collected!');\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 添加收集音效的视觉反馈（闪烁效果）\n  this.tweens.add({\n    targets: scoreText,\n    scaleX: 1.2,\n    scaleY: 1.2,\n    duration: 100,\n    yoyo: true,\n    ease: 'Power2'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001031_v3", "prompt_id": "seed_001031", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 同时控制 3 个红色对象：按方向键时所有对象同步移动，速度 120。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 同时控制3个红色对象，按方向键同步移动，速度120\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Container\nSTEPS:\n1. 创建3个红色矩形对象，使用Graphics绘制并生成纹理\n2. 将3个对象存储在数组中，设置初始位置（横向排列）\n3. 在create中创建键盘方向键监听\n4. 在update中检测方向键状态，同步更新所有对象的位置\n5. 添加边界检测，防止对象移出屏幕\n6. 添加状态变量记录移动总距离作为可验证信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 状态变量\nlet objects = [];\nlet cursors;\nlet totalDistance = 0; // 可验证的状态信号：记录总移动距离\nlet statusText;\n\nfunction preload() {\n  // 创建红色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('redBox', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建3个红色对象，横向排列\n  const startX = 200;\n  const startY = 300;\n  const spacing = 150;\n  \n  for (let i = 0; i < 3; i++) {\n    const obj = this.add.image(startX + i * spacing, startY, 'redBox');\n    obj.setOrigin(0.5);\n    objects.push(obj);\n  }\n  \n  // 创建方向键\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 显示状态信息\n  statusText = this.add.text(10, 10, '', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  updateStatusText();\n  \n  // 添加提示文本\n  this.add.text(400, 550, '使用方向键控制所有红色方块移动', {\n    fontSize: '16px',\n    fill: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  const speed = 120;\n  const deltaSeconds = delta / 1000; // 转换为秒\n  let moved = false;\n  let dx = 0;\n  let dy = 0;\n  \n  // 检测方向键状态\n  if (cursors.left.isDown) {\n    dx = -speed * deltaSeconds;\n    moved = true;\n  } else if (cursors.right.isDown) {\n    dx = speed * deltaSeconds;\n    moved = true;\n  }\n  \n  if (cursors.up.isDown) {\n    dy = -speed * deltaSeconds;\n    moved = true;\n  } else if (cursors.down.isDown) {\n    dy = speed * deltaSeconds;\n    moved = true;\n  }\n  \n  // 同步移动所有对象\n  if (moved) {\n    objects.forEach(obj => {\n      let newX = obj.x + dx;\n      let newY = obj.y + dy;\n      \n      // 边界检测（考虑对象的宽高）\n      const halfWidth = obj.width / 2;\n      const halfHeight = obj.height / 2;\n      \n      newX = Phaser.Math.Clamp(newX, halfWidth, 800 - halfWidth);\n      newY = Phaser.Math.Clamp(newY, halfHeight, 600 - halfHeight);\n      \n      obj.setPosition(newX, newY);\n    });\n    \n    // 计算移动距离\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    totalDistance += distance;\n    \n    updateStatusText();\n  }\n}\n\nfunction updateStatusText() {\n  statusText.setText([\n    `对象数量: ${objects.length}`,\n    `移动速度: 120`,\n    `总移动距离: ${Math.floor(totalDistance)}`,\n    `位置: [${objects.map(obj => `(${Math.floor(obj.x)},${Math.floor(obj.y)})`).join(', ')}]`\n  ]);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001135_v1", "prompt_id": "seed_001135", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的红色六边形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的红色六边形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，根据中心点和半径计算6个顶点坐标\n4. 使用循环绘制20个六边形，每个位置随机，大小为24像素（半径12）\n5. 设置红色填充样式 0xff0000\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置红色填充\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制20个随机位置的六边形\n  for (let i = 0; i < 20; i++) {\n    // 随机位置，留出边距避免六边形被裁切\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const radius = 12; // 大小24像素，半径为12\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, radius);\n  }\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} radius - 六边形半径\n */\nfunction drawHexagon(graphics, x, y, radius) {\n  graphics.beginPath();\n  \n  // 六边形有6个顶点，从顶部开始顺时针绘制\n  for (let i = 0; i < 6; i++) {\n    // 计算角度（从-90度开始，使六边形顶点朝上）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const px = x + radius * Math.cos(angle);\n    const py = y + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(px, py);\n    } else {\n      graphics.lineTo(px, py);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000108_v3", "prompt_id": "seed_000108", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色矩形在0.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Game\nSTEPS:\n1. 创建 Scene 并配置 Game 实例\n2. 在 create 中使用 Graphics 绘制白色矩形\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 500 毫秒（0.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 60, 40);\n  \n  // 将 Graphics 转换为纹理以便于补间动画控制\n  graphics.generateTexture('whiteRect', 60, 40);\n  graphics.destroy();\n  \n  // 创建使用该纹理的精灵对象\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（从初始 100 移动到 700）\n    duration: 500,           // 持续时间 0.5 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向回到起点）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动函数，保持匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000658_v3", "prompt_id": "seed_000658", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让黄色矩形在 1 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色矩形的淡入淡出循环动画\nAPI: Graphics, Tween, TweenManager\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 参数实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建黄色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('yellowRect', 200, 150);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建黄色矩形精灵\n  const rect = this.add.sprite(400, 300, 'yellowRect');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入后自动淡出\n  // repeat: -1 实现无限循环\n  this.tweens.add({\n    targets: rect,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 1000,     // 动画时长 1 秒\n    yoyo: true,         // 动画结束后反向播放（淡出后淡入）\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000088_v2", "prompt_id": "seed_000088", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.49}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Phaser.Scene.cameras\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个星形纹理\n2. 创建一个使用该纹理的精灵对象\n3. 在 create 中设置相机跟随该精灵对象\n4. 在 update 中让星形自动向右下移动\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 移动速度（像素/秒）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 1. 创建背景网格以便观察相机移动\n    this.createBackgroundGrid();\n\n    // 2. 使用 Graphics 创建星形纹理\n    this.createStarTexture();\n\n    // 3. 创建星形精灵并放置在起始位置\n    this.star = this.add.sprite(400, 300, 'starTexture');\n    this.star.setScale(2); // 放大星形以便观察\n\n    // 4. 设置相机跟随星形对象，保持居中\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机边界，让星形可以在更大的世界中移动\n    this.cameras.main.setBounds(0, 0, 2000, 2000);\n    \n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 2000, 2000);\n\n    // 添加提示文本（固定在相机上）\n    const infoText = this.add.text(10, 10, '星形自动向右下移动\\n相机跟随并保持居中', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    infoText.setScrollFactor(0); // 固定在相机上，不随世界移动\n  }\n\n  update(time, delta) {\n    // 让星形自动向右下移动\n    // delta 是毫秒，转换为秒\n    const deltaSeconds = delta / 1000;\n    \n    // 向右下方向移动（45度角）\n    const moveX = this.speed * deltaSeconds;\n    const moveY = this.speed * deltaSeconds;\n    \n    this.star.x += moveX;\n    this.star.y += moveY;\n\n    // 可选：当星形超出世界边界时重置位置\n    if (this.star.x > 1900 || this.star.y > 1900) {\n      this.star.x = 100;\n      this.star.y = 100;\n    }\n  }\n\n  // 创建星形纹理\n  createStarTexture() {\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    \n    // 绘制黄色星形\n    graphics.fillStyle(0xffff00, 1);\n    graphics.lineStyle(2, 0xffa500, 1);\n    \n    // 绘制五角星\n    const centerX = 32;\n    const centerY = 32;\n    const outerRadius = 30;\n    const innerRadius = 12;\n    const points = 5;\n    \n    graphics.beginPath();\n    for (let i = 0; i < points * 2; i++) {\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const angle = (i * Math.PI) / points - Math.PI / 2;\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n      \n      if (i === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 生成纹理\n    graphics.generateTexture('starTexture', 64, 64);\n    graphics.destroy();\n  }\n\n  // 创建背景网格以便观察相机移动\n  createBackgroundGrid() {\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n    \n    // 绘制网格\n    const gridSize = 100;\n    const worldWidth = 2000;\n    const worldHeight = 2000;\n    \n    // 垂直线\n    for (let x = 0; x <= worldWidth; x += gridSize) {\n      graphics.lineBetween(x, 0, x, worldHeight);\n    }\n    \n    // 水平线\n    for (let y = 0; y <= worldHeight; y += gridSize) {\n      graphics.lineBetween(0, y, worldWidth, y);\n    }\n    \n    // 添加坐标标记\n    for (let x = 0; x <= worldWidth; x += 200) {\n      for (let y = 0; y <= worldHeight; y += 200) {\n        const text = this.add.text(x + 5, y + 5, `${x},${y}`, {\n          fontSize: '12px',\n          fill: '#666666'\n        });\n      }\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000659_v3", "prompt_id": "seed_000659", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 点击画布任意位置，在点击处生成一个80像素的橙色星形。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 点击画布任意位置生成80像素橙色星形\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Events.POINTER_DOWN, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath\nSTEPS:\n1. 创建 Scene 并监听 pointerdown 事件\n2. 在事件回调中获取点击坐标\n3. 使用 Graphics 绘制五角星路径（计算五角星的顶点坐标）\n4. 填充橙色并渲染星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 监听画布点击事件\n  this.input.on('pointerdown', (pointer) => {\n    createStar(this, pointer.x, pointer.y);\n  });\n}\n\n/**\n * 在指定位置创建橙色星形\n * @param {Phaser.Scene} scene - 当前场景\n * @param {number} x - X坐标\n * @param {number} y - Y坐标\n */\nfunction createStar(scene, x, y) {\n  const graphics = scene.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 星形参数\n  const outerRadius = 40; // 外半径（总大小80像素）\n  const innerRadius = 16; // 内半径\n  const points = 5; // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算星形的顶点坐标\n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const px = x + Math.cos(angle) * radius;\n    const py = y + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(px, py);\n    } else {\n      graphics.lineTo(px, py);\n    }\n  }\n  \n  // 闭合路径并填充\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000378_v1", "prompt_id": "seed_000378", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现追踪镜头与震屏：玩家与敌人碰撞时触发 camera shake 1 秒，并扣减生命值显示。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现玩家与敌人碰撞时触发相机震动1秒并扣减生命值显示\nAPI: Phaser.Cameras.Scene2D.Camera#shake, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建玩家和敌人精灵，使用Graphics生成纹理\n2. 设置Arcade物理系统，添加碰撞检测\n3. 碰撞时触发camera.shake效果持续1秒\n4. 扣减玩家生命值并更新UI显示\n5. 相机跟随玩家实现追踪镜头\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerHealth = 100;\n    this.collisionCooldown = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 32, 32);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建多个敌人\n    this.enemies = this.physics.add.group();\n    for (let i = 0; i < 5; i++) {\n      const x = Phaser.Math.Between(100, 700);\n      const y = Phaser.Math.Between(100, 500);\n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setVelocity(\n        Phaser.Math.Between(-100, 100),\n        Phaser.Math.Between(-100, 100)\n      );\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(1);\n    }\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.enemies, this.handleCollision, null, this);\n\n    // 设置相机跟随玩家\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n    this.cameras.main.setZoom(1);\n    this.cameras.main.setBounds(0, 0, 800, 600);\n\n    // 创建生命值显示文本（固定在相机上）\n    this.healthText = this.add.text(16, 16, `Health: ${this.playerHealth}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.healthText.setScrollFactor(0); // 固定在相机上\n\n    // 创建提示文本\n    this.infoText = this.add.text(16, 50, 'Use Arrow Keys to Move', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n    this.infoText.setScrollFactor(0);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加背景网格以便观察相机移动\n    this.createBackground();\n  }\n\n  createBackground() {\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n    \n    // 绘制网格\n    for (let x = 0; x <= 800; x += 50) {\n      graphics.lineBetween(x, 0, x, 600);\n    }\n    for (let y = 0; y <= 600; y += 50) {\n      graphics.lineBetween(0, y, 800, y);\n    }\n    \n    graphics.setDepth(-1);\n  }\n\n  handleCollision(player, enemy) {\n    // 使用冷却时间防止连续碰撞造成多次扣血\n    if (this.collisionCooldown) {\n      return;\n    }\n\n    this.collisionCooldown = true;\n\n    // 扣减生命值\n    this.playerHealth -= 10;\n    if (this.playerHealth < 0) {\n      this.playerHealth = 0;\n    }\n\n    // 更新生命值显示\n    this.healthText.setText(`Health: ${this.playerHealth}`);\n\n    // 触发相机震动效果，持续1000毫秒\n    this.cameras.main.shake(1000, 0.01);\n\n    // 玩家闪烁效果\n    this.tweens.add({\n      targets: player,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 5\n    });\n\n    // 检查游戏结束\n    if (this.playerHealth <= 0) {\n      this.gameOver();\n    }\n\n    // 设置冷却时间\n    this.time.delayedCall(1000, () => {\n      this.collisionCooldown = false;\n    });\n  }\n\n  gameOver() {\n    // 显示游戏结束文本\n    const gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 }\n    });\n    gameOverText.setOrigin(0.5);\n    gameOverText.setScrollFactor(0);\n\n    // 停止玩家移动\n    this.player.setVelocity(0, 0);\n    this.physics.pause();\n\n    // 重启提示\n    this.time.delayedCall(2000, () => {\n      const restartText = this.add.text(400, 360, 'Click to Restart', {\n        fontSize: '24px',\n        fill: '#ffffff',\n        backgroundColor: '#000000',\n        padding: { x: 10, y: 5 }\n      });\n      restartText.setOrigin(0.5);\n      restartText.setScrollFactor(0);\n\n      this.input.once('pointerdown', () => {\n        this.scene.restart();\n      });\n    });\n  }\n\n  update(time, delta) {\n    if (this.playerHealth <= 0) {\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000839_v1", "prompt_id": "seed_000839", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Physics"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按空格键触发相机缩放效果，持续 1 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按空格键触发相机缩放效果，持续1秒\nAPI: Phaser.Input.Keyboard.KeyCodes.SPACE, Phaser.Cameras.Scene2D.Camera#zoomTo, Phaser.Input.Keyboard.KeyboardPlugin#addKey\nSTEPS:\n1. 创建场景并绘制一些可视化元素（使用Graphics绘制网格和中心标记）\n2. 在create中监听空格键输入事件\n3. 按下空格键时调用camera.zoomTo方法触发缩放效果\n4. 添加状态变量记录缩放次数作为可验证信号\n5. 显示文本提示和缩放次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.zoomCount = 0; // 可验证的状态信号\n    this.isZooming = false;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 绘制背景网格\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n    \n    // 绘制垂直线\n    for (let x = 0; x <= 800; x += 50) {\n      graphics.lineBetween(x, 0, x, 600);\n    }\n    \n    // 绘制水平线\n    for (let y = 0; y <= 600; y += 50) {\n      graphics.lineBetween(0, y, 800, y);\n    }\n\n    // 绘制中心标记\n    graphics.fillStyle(0xff0000, 1);\n    graphics.fillCircle(400, 300, 20);\n    \n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillRect(350, 250, 100, 100);\n\n    // 绘制四个角的标记\n    graphics.fillStyle(0x0000ff, 1);\n    graphics.fillCircle(100, 100, 15);\n    graphics.fillCircle(700, 100, 15);\n    graphics.fillCircle(100, 500, 15);\n    graphics.fillCircle(700, 500, 15);\n\n    // 添加提示文本\n    this.instructionText = this.add.text(400, 50, 'Press SPACE to Zoom', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.instructionText.setOrigin(0.5);\n    this.instructionText.setScrollFactor(0); // 固定在屏幕上\n\n    // 添加缩放次数显示\n    this.zoomCountText = this.add.text(400, 100, `Zoom Count: ${this.zoomCount}`, {\n      fontSize: '20px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.zoomCountText.setOrigin(0.5);\n    this.zoomCountText.setScrollFactor(0);\n\n    // 添加状态显示\n    this.statusText = this.add.text(400, 550, 'Status: Ready', {\n      fontSize: '18px',\n      color: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setOrigin(0.5);\n    this.statusText.setScrollFactor(0);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    this.spaceKey.on('down', () => {\n      if (!this.isZooming) {\n        this.triggerZoom();\n      }\n    });\n\n    // 获取主相机\n    this.mainCamera = this.cameras.main;\n  }\n\n  triggerZoom() {\n    this.isZooming = true;\n    this.zoomCount++;\n    \n    // 更新状态文本\n    this.zoomCountText.setText(`Zoom Count: ${this.zoomCount}`);\n    this.statusText.setText('Status: Zooming In...');\n    this.statusText.setColor('#ff0000');\n\n    // 缩放到2倍，持续1000毫秒\n    this.mainCamera.zoomTo(2, 1000, 'Sine.easeInOut', false, (camera, progress) => {\n      // 缩放进行中的回调\n      if (progress === 1) {\n        // 缩放完成后，缩小回原始大小\n        this.statusText.setText('Status: Zooming Out...');\n        this.statusText.setColor('#ffaa00');\n        \n        this.mainCamera.zoomTo(1, 1000, 'Sine.easeInOut', false, (camera, progress) => {\n          if (progress === 1) {\n            // 完全恢复后\n            this.isZooming = false;\n            this.statusText.setText('Status: Ready');\n            this.statusText.setColor('#00ff00');\n          }\n        });\n      }\n    });\n  }\n\n  update(time, delta) {\n    // 可以在这里添加其他更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene,\n  parent: 'game-container'\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000867_v3", "prompt_id": "seed_000867", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Input"], "quality_score": 0.44666666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现红色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 红色角色按键切换 idle/run 状态，使用帧动画或 tween 体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Animations.AnimationManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 生成红色角色的两种状态纹理（idle 和 run 的不同帧）\n2. 创建 idle 和 run 的帧动画\n3. 监听键盘输入（I 键切换 idle，R 键切换 run）\n4. 根据状态播放对应动画，并更新状态变量\n5. 在屏幕上显示当前状态文本作为验证信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态变量\nlet currentState = 'idle';\nlet player;\nlet stateText;\nlet keyI, keyR;\n\nfunction preload() {\n  // 创建 idle 状态的纹理帧（2帧：稍微变化的红色方块）\n  const graphics = this.add.graphics();\n  \n  // Idle Frame 1 - 较小的红色方块\n  graphics.clear();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 48, 64);\n  graphics.fillStyle(0xaa0000, 1);\n  graphics.fillRect(12, 16, 24, 8); // 眼睛\n  graphics.generateTexture('idle1', 48, 64);\n  \n  // Idle Frame 2 - 稍微变大（呼吸效果）\n  graphics.clear();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 52, 66);\n  graphics.fillStyle(0xaa0000, 1);\n  graphics.fillRect(14, 18, 24, 8);\n  graphics.generateTexture('idle2', 52, 66);\n  \n  // Run Frame 1 - 倾斜的红色方块\n  graphics.clear();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 8, 48, 56);\n  graphics.fillStyle(0xaa0000, 1);\n  graphics.fillRect(12, 20, 24, 8);\n  graphics.fillStyle(0xff6666, 1); // 腿部动作\n  graphics.fillRect(8, 48, 12, 16);\n  graphics.fillRect(28, 52, 12, 12);\n  graphics.generateTexture('run1', 48, 64);\n  \n  // Run Frame 2 - 另一个倾斜角度\n  graphics.clear();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 4, 48, 60);\n  graphics.fillStyle(0xaa0000, 1);\n  graphics.fillRect(12, 16, 24, 8);\n  graphics.fillStyle(0xff6666, 1); // 腿部动作（交替）\n  graphics.fillRect(28, 48, 12, 16);\n  graphics.fillRect(8, 52, 12, 12);\n  graphics.generateTexture('run2', 48, 64);\n  \n  // Run Frame 3 - 中间姿势\n  graphics.clear();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 48, 64);\n  graphics.fillStyle(0xaa0000, 1);\n  graphics.fillRect(12, 16, 24, 8);\n  graphics.fillStyle(0xff6666, 1);\n  graphics.fillRect(18, 52, 12, 12);\n  graphics.generateTexture('run3', 48, 64);\n  \n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建角色精灵\n  player = this.add.sprite(400, 300, 'idle1');\n  player.setScale(2);\n  \n  // 创建 idle 动画（慢速呼吸效果）\n  this.anims.create({\n    key: 'idle_anim',\n    frames: [\n      { key: 'idle1' },\n      { key: 'idle2' },\n      { key: 'idle1' }\n    ],\n    frameRate: 2,\n    repeat: -1\n  });\n  \n  // 创建 run 动画（快速跑步效果）\n  this.anims.create({\n    key: 'run_anim',\n    frames: [\n      { key: 'run1' },\n      { key: 'run2' },\n      { key: 'run3' },\n      { key: 'run2' }\n    ],\n    frameRate: 10,\n    repeat: -1\n  });\n  \n  // 默认播放 idle 动画\n  player.play('idle_anim');\n  \n  // 创建状态显示文本\n  stateText = this.add.text(400, 100, 'State: IDLE', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 20, y: 10 }\n  });\n  stateText.setOrigin(0.5);\n  \n  // 创建提示文本\n  this.add.text(400, 550, 'Press [I] for IDLE  |  Press [R] for RUN', {\n    fontSize: '20px',\n    fontFamily: 'Arial',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n  \n  // 设置键盘输入\n  keyI = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);\n  keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n  \n  // 监听按键按下事件\n  keyI.on('down', () => {\n    switchState(this, 'idle');\n  });\n  \n  keyR.on('down', () => {\n    switchState(this, 'run');\n  });\n  \n  // 添加状态指示器（颜色条）\n  this.stateIndicator = this.add.graphics();\n  updateStateIndicator(this);\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 例如：根据状态改变角色位置等\n  if (currentState === 'run') {\n    // 跑步状态下轻微晃动\n    player.y = 300 + Math.sin(time / 100) * 5;\n  } else {\n    // idle 状态下保持稳定\n    player.y = 300;\n  }\n}\n\nfunction switchState(scene, newState) {\n  if (currentState === newState) {\n    return; // 已经是该状态，无需切换\n  }\n  \n  currentState = newState;\n  \n  if (newState === 'idle') {\n    player.play('idle_anim');\n    stateText.setText('State: IDLE');\n    stateText.setStyle({ color: '#ffffff' });\n    \n    // Tween 效果：缩小回正常大小\n    scene.tweens.add({\n      targets: player,\n      scaleX: 2,\n      scaleY: 2,\n      duration: 300,\n      ease: 'Back.out'\n    });\n  } else if (newState === 'run') {\n    player.play('run_anim');\n    stateText.setText('State: RUN');\n    stateText.setStyle({ color: '#ffff00' });\n    \n    // Tween 效果：稍微放大表示活跃\n    scene.tweens.add({\n      targets: player,\n      scaleX: 2.2,\n      scaleY: 2.2,\n      duration: 300,\n      ease: 'Back.out'\n    });\n  }\n  \n  updateStateIndicator(scene);\n}\n\nfunction updateStateIndicator(scene) {\n  scene.stateIndicator.clear();\n  \n  if (currentState === 'idle') {\n    // 蓝色指示器\n    scene.stateIndicator.fillStyle(0x0088ff, 1);\n    scene.stateIndicator.fillRect(350, 120, 100, 20);\n  } else if (currentState === 'run') {\n    // 黄色指示器\n    scene.stateIndicator.fillStyle(0xffff00, 1);\n    scene.stateIndicator.fillRect(350, 120, 100, 20);\n    \n    // 添加闪烁效果\n    scene.tweens.add({\n      targets: scene.stateIndicator,\n      alpha: 0.3,\n      duration: 200,\n      yoyo: true,\n      repeat: 2\n    });\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000868_v1", "prompt_id": "seed_000868", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的青色方块，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个可拖拽的青色方块，拖拽时改变颜色，松手后回到初始位置\nAPI: Graphics.fillRect, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制青色方块并生成纹理\n2. 创建 Sprite 并设置为可交互和可拖拽\n3. 监听 dragstart 事件改变方块颜色为黄色\n4. 监听 drag 事件更新方块位置\n5. 监听 dragend 事件恢复青色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建青色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('cyanBlock', 100, 100);\n  graphics.destroy();\n\n  // 创建黄色方块纹理（拖拽时使用）\n  const graphicsYellow = this.add.graphics();\n  graphicsYellow.fillStyle(0xffff00, 1);\n  graphicsYellow.fillRect(0, 0, 100, 100);\n  graphicsYellow.generateTexture('yellowBlock', 100, 100);\n  graphicsYellow.destroy();\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n\n  // 创建可拖拽的方块\n  const block = this.add.sprite(initialX, initialY, 'cyanBlock');\n  \n  // 设置为可交互和可拖拽\n  block.setInteractive({ draggable: true });\n\n  // 添加提示文本\n  const text = this.add.text(400, 50, '拖拽方块试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n\n  // 监听拖拽开始事件\n  block.on('dragstart', (pointer) => {\n    // 改变为黄色\n    block.setTexture('yellowBlock');\n  });\n\n  // 监听拖拽中事件\n  block.on('drag', (pointer, dragX, dragY) => {\n    // 更新方块位置\n    block.x = dragX;\n    block.y = dragY;\n  });\n\n  // 监听拖拽结束事件\n  block.on('dragend', (pointer) => {\n    // 恢复青色\n    block.setTexture('cyanBlock');\n    \n    // 回到初始位置（添加缓动动画使其更平滑）\n    this.tweens.add({\n      targets: block,\n      x: initialX,\n      y: initialY,\n      duration: 300,\n      ease: 'Power2'\n    });\n  });\n\n  // 添加鼠标悬停效果\n  block.on('pointerover', () => {\n    block.setScale(1.05);\n  });\n\n  block.on('pointerout', () => {\n    block.setScale(1);\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000034_v1", "prompt_id": "seed_000034", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色角色冲刺：按鼠标右键进行短距离冲刺，冲刺速度为 300*3，冷却 3 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现粉色角色冲刺功能，鼠标右键触发，速度300*3，冷却3秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Pointer, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建粉色角色精灵，使用Graphics绘制粉色方块作为纹理\n2. 监听鼠标右键点击事件，触发冲刺逻辑\n3. 冲刺时计算角色朝向鼠标的方向向量，应用900速度（300*3）\n4. 使用TimerEvent实现冲刺持续时间（0.2秒）和冷却时间（3秒）\n5. 添加状态变量isDashing和canDash用于控制冲刺状态和冷却\n6. 显示冷却倒计时文本作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass DashGameScene extends Phaser.Scene {\n  constructor() {\n    super('DashGameScene');\n    this.player = null;\n    this.isDashing = false;\n    this.canDash = true;\n    this.dashCooldown = 3000; // 3秒冷却\n    this.dashSpeed = 300 * 3; // 冲刺速度\n    this.dashDuration = 200; // 冲刺持续时间（毫秒）\n    this.normalSpeed = 200; // 正常移动速度\n    this.cooldownRemaining = 0; // 剩余冷却时间（用于验证）\n  }\n\n  preload() {\n    // 使用Graphics创建粉色角色纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff69b4, 1); // 粉色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理角色\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.cooldownText = this.add.text(10, 40, '', {\n      fontSize: '16px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 监听鼠标右键点击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown()) {\n        this.performDash(pointer);\n      }\n    });\n\n    // 键盘移动控制（WASD）\n    this.cursors = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 添加提示文本\n    this.add.text(400, 550, '使用WASD移动，鼠标右键冲刺', {\n      fontSize: '16px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n  }\n\n  performDash(pointer) {\n    // 检查是否可以冲刺\n    if (!this.canDash || this.isDashing) {\n      return;\n    }\n\n    // 计算冲刺方向（从角色指向鼠标位置）\n    const angle = Phaser.Math.Angle.Between(\n      this.player.x,\n      this.player.y,\n      pointer.worldX,\n      pointer.worldY\n    );\n\n    // 设置冲刺状态\n    this.isDashing = true;\n    this.canDash = false;\n\n    // 应用冲刺速度\n    this.player.setVelocity(\n      Math.cos(angle) * this.dashSpeed,\n      Math.sin(angle) * this.dashSpeed\n    );\n\n    // 改变角色颜色表示冲刺状态\n    this.player.setTint(0xffffff);\n\n    // 冲刺持续时间结束\n    this.time.addEvent({\n      delay: this.dashDuration,\n      callback: () => {\n        this.isDashing = false;\n        this.player.setVelocity(0, 0);\n        this.player.clearTint();\n      }\n    });\n\n    // 冷却时间\n    this.cooldownRemaining = this.dashCooldown;\n    const cooldownTimer = this.time.addEvent({\n      delay: this.dashCooldown,\n      callback: () => {\n        this.canDash = true;\n        this.cooldownRemaining = 0;\n      }\n    });\n\n    // 更新冷却倒计时\n    this.time.addEvent({\n      delay: 100,\n      repeat: Math.ceil(this.dashCooldown / 100),\n      callback: () => {\n        this.cooldownRemaining = Math.max(0, cooldownTimer.getRemaining());\n      }\n    });\n  }\n\n  update(time, delta) {\n    // 非冲刺状态下的正常移动\n    if (!this.isDashing) {\n      let velocityX = 0;\n      let velocityY = 0;\n\n      if (this.cursors.left.isDown) {\n        velocityX = -this.normalSpeed;\n      } else if (this.cursors.right.isDown) {\n        velocityX = this.normalSpeed;\n      }\n\n      if (this.cursors.up.isDown) {\n        velocityY = -this.normalSpeed;\n      } else if (this.cursors.down.isDown) {\n        velocityY = this.normalSpeed;\n      }\n\n      // 归一化对角线移动速度\n      if (velocityX !== 0 && velocityY !== 0) {\n        velocityX *= 0.707;\n        velocityY *= 0.707;\n      }\n\n      this.player.setVelocity(velocityX, velocityY);\n    }\n\n    // 更新状态显示\n    const status = this.isDashing ? '冲刺中!' : (this.canDash ? '就绪' : '冷却中');\n    this.statusText.setText(`状态: ${status}`);\n\n    if (!this.canDash && this.cooldownRemaining > 0) {\n      this.cooldownText.setText(`冷却: ${(this.cooldownRemaining / 1000).toFixed(1)}秒`);\n      this.cooldownText.setVisible(true);\n    } else {\n      this.cooldownText.setVisible(false);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DashGameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001593_v2", "prompt_id": "seed_001593", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 程序化关卡生成：用 seed 生成 15x15 的迷宫，显示 seed 以便复现。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Math.RND\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 seed 生成 15x15 迷宫并显示 seed 以便复现\nAPI: Phaser.Math.RND, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 初始化随机数生成器并显示 seed\n2. 使用深度优先搜索算法生成 15x15 迷宫\n3. 使用 Graphics 绘制迷宫墙壁和路径\n4. 添加玩家角色和物理系统\n5. 实现键盘控制和碰撞检测\n6. 添加终点和胜利检测\n[/PLAN]\n\n```javascript\nclass MazeScene extends Phaser.Scene {\n  constructor() {\n    super('MazeScene');\n    this.mazeSize = 15;\n    this.cellSize = 40;\n    this.wallThickness = 4;\n    this.seed = Date.now() % 1000000; // 可配置的种子\n    this.level = 1;\n    this.score = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 设置随机种子\n    this.rnd = new Phaser.Math.RandomDataGenerator([this.seed]);\n    \n    // 显示 seed 信息\n    this.add.text(10, 10, `Seed: ${this.seed}`, {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }).setDepth(100);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 45, `Level: ${this.level} | Score: ${this.score}`, {\n      fontSize: '18px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }).setDepth(100);\n\n    // 生成迷宫\n    this.maze = this.generateMaze(this.mazeSize, this.mazeSize);\n    \n    // 绘制迷宫\n    this.drawMaze();\n    \n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 14);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建终点纹理\n    const goalGraphics = this.add.graphics();\n    goalGraphics.fillStyle(0xffff00, 1);\n    goalGraphics.fillRect(4, 4, 24, 24);\n    goalGraphics.generateTexture('goal', 32, 32);\n    goalGraphics.destroy();\n\n    // 添加物理系统\n    this.physics.world.setBounds(\n      0, \n      0, \n      this.mazeSize * this.cellSize, \n      this.mazeSize * this.cellSize\n    );\n\n    // 创建玩家\n    const startX = this.cellSize / 2;\n    const startY = this.cellSize / 2;\n    this.player = this.physics.add.sprite(startX, startY, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setScale(0.8);\n\n    // 创建终点\n    const goalX = (this.mazeSize - 0.5) * this.cellSize;\n    const goalY = (this.mazeSize - 0.5) * this.cellSize;\n    this.goal = this.physics.add.sprite(goalX, goalY, 'goal');\n    this.goal.setScale(0.8);\n\n    // 创建墙壁碰撞组\n    this.walls = this.physics.add.staticGroup();\n    this.createWallColliders();\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.walls);\n    this.physics.add.overlap(this.player, this.goal, this.reachGoal, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keys = this.input.keyboard.addKeys('W,A,S,D');\n\n    // 添加重置键\n    this.input.keyboard.on('keydown-R', () => {\n      this.scene.restart();\n    });\n\n    // 添加新种子键\n    this.input.keyboard.on('keydown-N', () => {\n      this.seed = Date.now() % 1000000;\n      this.scene.restart();\n    });\n\n    // 提示文本\n    this.add.text(10, this.mazeSize * this.cellSize + 10, \n      'Arrow Keys/WASD: Move | R: Restart | N: New Maze', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 摄像机跟随玩家\n    this.cameras.main.setBounds(0, 0, this.mazeSize * this.cellSize, this.mazeSize * this.cellSize);\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  }\n\n  generateMaze(width, height) {\n    // 初始化迷宫，所有墙壁都存在\n    const maze = [];\n    for (let y = 0; y < height; y++) {\n      maze[y] = [];\n      for (let x = 0; x < width; x++) {\n        maze[y][x] = {\n          visited: false,\n          walls: { top: true, right: true, bottom: true, left: true }\n        };\n      }\n    }\n\n    // 深度优先搜索生成迷宫\n    const stack = [];\n    let current = { x: 0, y: 0 };\n    maze[0][0].visited = true;\n\n    while (true) {\n      const neighbors = this.getUnvisitedNeighbors(current, maze, width, height);\n      \n      if (neighbors.length > 0) {\n        // 随机选择一个邻居\n        const next = neighbors[this.rnd.between(0, neighbors.length - 1)];\n        \n        // 移除当前单元格和邻居之间的墙\n        this.removeWall(current, next, maze);\n        \n        stack.push(current);\n        maze[next.y][next.x].visited = true;\n        current = next;\n      } else if (stack.length > 0) {\n        current = stack.pop();\n      } else {\n        break;\n      }\n    }\n\n    return maze;\n  }\n\n  getUnvisitedNeighbors(cell, maze, width, height) {\n    const neighbors = [];\n    const { x, y } = cell;\n\n    // 上\n    if (y > 0 && !maze[y - 1][x].visited) {\n      neighbors.push({ x, y: y - 1, dir: 'top' });\n    }\n    // 右\n    if (x < width - 1 && !maze[y][x + 1].visited) {\n      neighbors.push({ x: x + 1, y, dir: 'right' });\n    }\n    // 下\n    if (y < height - 1 && !maze[y + 1][x].visited) {\n      neighbors.push({ x, y: y + 1, dir: 'bottom' });\n    }\n    // 左\n    if (x > 0 && !maze[y][x - 1].visited) {\n      neighbors.push({ x: x - 1, y, dir: 'left' });\n    }\n\n    return neighbors;\n  }\n\n  removeWall(current, next, maze) {\n    const dx = next.x - current.x;\n    const dy = next.y - current.y;\n\n    if (dx === 1) {\n      maze[current.y][current.x].walls.right = false;\n      maze[next.y][next.x].walls.left = false;\n    } else if (dx === -1) {\n      maze[current.y][current.x].walls.left = false;\n      maze[next.y][next.x].walls.right = false;\n    } else if (dy === 1) {\n      maze[current.y][current.x].walls.bottom = false;\n      maze[next.y][next.x].walls.top = false;\n    } else if (dy === -1) {\n      maze[current.y][current.x].walls.top = false;\n      maze[next.y][next.x].walls.bottom = false;\n    }\n  }\n\n  drawMaze() {\n    const graphics = this.add.graphics();\n    graphics.lineStyle(this.wallThickness, 0x3333ff, 1);\n\n    for (let y = 0; y < this.mazeSize; y++) {\n      for (let x = 0; x < this.mazeSize; x++) {\n        const cell = this.maze[y][x];\n        const px = x * this.cellSize;\n        const py = y * this.cellSize;\n\n        if (cell.walls.top) {\n          graphics.lineBetween(px, py, px + this.cellSize, py);\n        }\n        if (cell.walls.right) {\n          graphics.lineBetween(px + this.cellSize, py, px + this.cellSize, py + this.cellSize);\n        }\n        if (cell.walls.bottom) {\n          graphics.lineBetween(px, py + this.cellSize, px + this.cellSize, py + this.cellSize);\n        }\n        if (cell.walls.left) {\n          graphics.lineBetween(px, py, px, py + this.cellSize);\n        }\n      }\n    }\n  }\n\n  createWallColliders() {\n    const halfThickness = this.wallThickness / 2;\n\n    for (let y = 0; y < this.mazeSize; y++) {\n      for (let x = 0; x < this.mazeSize; x++) {\n        const cell = this.maze[y][x];\n        const px = x * this.cellSize;\n        const py = y * this.cellSize;\n\n        if (cell.walls.top) {\n          const wall = this.add.rectangle(\n            px + this.cellSize / 2, \n            py, \n            this.cellSize, \n            this.wallThickness, \n            0x3333ff, \n            0\n          );\n          this.walls.add(wall);\n        }\n        if (cell.walls.right) {\n          const wall = this.add.rectangle(\n            px + this.cellSize, \n            py + this.cellSize / 2, \n            this.wallThickness, \n            this.cellSize, \n            0x3333ff, \n            0\n          );\n          this.walls.add(wall);\n        }\n        if (cell.walls.bottom) {\n          const wall = this.add.rectangle(\n            px + this.cellSize / 2, \n            py + this.cellSize, \n            this.cellSize, \n            this.wallThickness, \n            0x3333ff, \n            0\n          );\n          this.walls.add(wall);\n        }\n        if (cell.walls.left) {\n          const wall = this.add.rectangle(\n            px, \n            py + this.cellSize / 2, \n            this.wallThickness, \n            this.cellSize, \n            0x3333ff, \n            0\n          );\n          this.walls.add(wall);\n        }\n      }\n    }\n  }\n\n  reachGoal() {\n    this.score += 100;\n    this.level += 1;\n    this.seed = Date.now() % 1000000;\n    this.scene.restart();\n  }\n\n  update() {\n    const speed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 标准化对角线速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.setVelocity(\n        this.player.body.velocity.x * 0.707,\n        this.player.body.velocity.y * 0.707\n      );\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 700,\n  backgroundColor: '#111111',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: MazeScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001701_v3", "prompt_id": "seed_001701", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 同时控制 10 个粉色对象：按方向键时所有对象同步移动，速度 80。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 同时控制10个粉色对象，按方向键同步移动，速度80\nAPI: this.add.graphics(), this.input.keyboard.createCursorKeys(), Graphics.fillStyle(), Graphics.fillCircle(), Graphics.generateTexture()\nSTEPS:\n1. 创建 Graphics 对象生成粉色圆形纹理\n2. 在场景中创建10个使用该纹理的精灵对象，随机分布\n3. 使用 createCursorKeys() 监听方向键输入\n4. 在 update 中根据方向键状态同步移动所有对象\n5. 添加状态变量记录总移动距离作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.objects = [];\n    this.totalDistance = 0; // 可验证的状态信号\n    this.moveSpeed = 80;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建粉色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff69b4, 1); // 粉色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆形\n    graphics.generateTexture('pinkCircle', 32, 32);\n    graphics.destroy();\n\n    // 创建10个粉色对象，随机分布\n    for (let i = 0; i < 10; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const obj = this.add.sprite(x, y, 'pinkCircle');\n      this.objects.push(obj);\n    }\n\n    // 创建方向键控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 560, '使用方向键同时控制所有粉色对象', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatus();\n  }\n\n  update(time, delta) {\n    let velocityX = 0;\n    let velocityY = 0;\n\n    // 检测方向键输入\n    if (this.cursors.left.isDown) {\n      velocityX = -this.moveSpeed;\n    } else if (this.cursors.right.isDown) {\n      velocityX = this.moveSpeed;\n    }\n\n    if (this.cursors.up.isDown) {\n      velocityY = -this.moveSpeed;\n    } else if (this.cursors.down.isDown) {\n      velocityY = this.moveSpeed;\n    }\n\n    // 同步移动所有对象\n    if (velocityX !== 0 || velocityY !== 0) {\n      const deltaSeconds = delta / 1000;\n      const moveX = velocityX * deltaSeconds;\n      const moveY = velocityY * deltaSeconds;\n      \n      // 计算移动距离\n      const distance = Math.sqrt(moveX * moveX + moveY * moveY);\n      this.totalDistance += distance;\n\n      // 移动所有对象\n      this.objects.forEach(obj => {\n        obj.x += moveX;\n        obj.y += moveY;\n\n        // 边界检测（可选：让对象在边界内循环）\n        if (obj.x < 0) obj.x = 800;\n        if (obj.x > 800) obj.x = 0;\n        if (obj.y < 0) obj.y = 600;\n        if (obj.y > 600) obj.y = 0;\n      });\n\n      this.updateStatus();\n    }\n  }\n\n  updateStatus() {\n    this.statusText.setText(\n      `对象数量: ${this.objects.length}\\n` +\n      `移动速度: ${this.moveSpeed}\\n` +\n      `总移动距离: ${Math.floor(this.totalDistance)}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001431_v1", "prompt_id": "seed_001431", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：5 个星形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 收集5个随机分布的星形，收集完成后显示\"恭喜通关\"\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Factory#overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 使用 Graphics 绘制星形纹理和玩家方块纹理\n2. 创建带物理属性的玩家精灵，支持键盘控制移动\n3. 随机生成5个星形物理对象分布在场景中\n4. 使用 overlap 检测玩家与星形碰撞，碰撞后销毁星形并增加收集计数\n5. 当收集数达到5时，显示\"恭喜通关\"文本并停止游戏\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet stars;\nlet cursors;\nlet collectedCount = 0;\nlet totalStars = 5;\nlet winText;\nlet gameOver = false;\nlet scoreText;\n\nfunction preload() {\n  // 创建星形纹理\n  createStarTexture(this);\n  // 创建玩家纹理\n  createPlayerTexture(this);\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setScale(1);\n\n  // 创建星形组\n  stars = this.physics.add.group();\n  \n  // 随机生成5个星形\n  for (let i = 0; i < totalStars; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const star = stars.create(x, y, 'star');\n    star.setScale(0.8);\n    // 添加轻微的旋转动画\n    this.tweens.add({\n      targets: star,\n      angle: 360,\n      duration: 3000,\n      repeat: -1,\n      ease: 'Linear'\n    });\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, stars, collectStar, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 显示收集进度\n  scoreText = this.add.text(16, 16, `已收集: ${collectedCount}/${totalStars}`, {\n    fontSize: '24px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 创建胜利文本（初始隐藏）\n  winText = this.add.text(400, 300, '恭喜通关!', {\n    fontSize: '64px',\n    fill: '#00ff00',\n    fontFamily: 'Arial',\n    stroke: '#000000',\n    strokeThickness: 6\n  });\n  winText.setOrigin(0.5);\n  winText.setVisible(false);\n}\n\nfunction update() {\n  if (gameOver) {\n    return;\n  }\n\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectStar(player, star) {\n  // 销毁星形\n  star.destroy();\n  \n  // 增加收集计数\n  collectedCount++;\n  \n  // 更新分数显示\n  scoreText.setText(`已收集: ${collectedCount}/${totalStars}`);\n  \n  // 检查是否收集完所有星形\n  if (collectedCount >= totalStars) {\n    gameOver = true;\n    winText.setVisible(true);\n    player.setVelocity(0, 0);\n    \n    // 添加胜利文本缩放动画\n    this.tweens.add({\n      targets: winText,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n}\n\n// 创建星形纹理\nfunction createStarTexture(scene) {\n  const graphics = scene.add.graphics();\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 25;\n  const innerRadius = 10;\n  \n  for (let i = 0; i < 5; i++) {\n    const angle = (i * 72 - 90) * Math.PI / 180;\n    points.push({\n      x: 25 + Math.cos(angle) * outerRadius,\n      y: 25 + Math.sin(angle) * outerRadius\n    });\n    \n    const innerAngle = (i * 72 - 90 + 36) * Math.PI / 180;\n    points.push({\n      x: 25 + Math.cos(innerAngle) * innerRadius,\n      y: 25 + Math.sin(innerAngle) * innerRadius\n    });\n  }\n  \n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  \n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  graphics.generateTexture('star', 50, 50);\n  graphics.destroy();\n}\n\n// 创建玩家纹理\nfunction createPlayerTexture(scene) {\n  const graphics = scene.add.graphics();\n  \n  // 绘制圆形玩家\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.lineStyle(3, 0x0066cc, 1);\n  graphics.fillCircle(20, 20, 18);\n  graphics.strokeCircle(20, 20, 18);\n  \n  // 添加眼睛\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(14, 16, 4);\n  graphics.fillCircle(26, 16, 4);\n  \n  graphics.fillStyle(0x000000, 1);\n  graphics.fillCircle(14, 16, 2);\n  graphics.fillCircle(26, 16, 2);\n  \n  graphics.generateTexture('player', 40, 40);\n  graphics.destroy();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001054_v3", "prompt_id": "seed_001054", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 3 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 3 秒内缩放到 48% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 Tween 创建缩放动画，从 1 缩放到 0.48，yoyo 模式自动恢复\n4. 设置 loop: -1 实现无限循环，duration: 3000 控制单程 3 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (50, 50)，半径约 40\n  graphics.beginPath();\n  graphics.moveTo(50, 10);  // 顶点\n  graphics.lineTo(15, 75);  // 左下角\n  graphics.lineTo(85, 75);  // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建三角形 Sprite，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置三角形的原点为中心\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.48,  // 缩放到 48%\n    scaleY: 0.48,  // 缩放到 48%\n    duration: 3000,  // 3 秒完成缩放\n    yoyo: true,  // 自动返回原始大小\n    loop: -1,  // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '三角形缩放动画\\n3秒缩放到48%后恢复', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000257_v2", "prompt_id": "seed_000257", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 四向重力切换：按不同方向键切换重力方向，重力大小 500，玩家和 10 个物体都受影响。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 四向重力切换游戏，按方向键改变重力方向，影响玩家和10个物体\nAPI: Phaser.Physics.Arcade.World, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，初始重力向下(y:500)\n2. 使用Graphics生成玩家和物体的纹理（不同颜色区分）\n3. 创建玩家精灵和10个随机位置的物体精灵，启用物理\n4. 监听方向键输入，切换世界重力方向\n5. 添加边界碰撞和状态显示文本\n6. 记录重力切换次数作为可验证状态\n[/PLAN]\n\n```javascript\nclass GravityGame extends Phaser.Scene {\n  constructor() {\n    super('GravityGame');\n    this.gravitySwitchCount = 0;\n    this.currentGravityDirection = 'down';\n    this.seed = 12345; // 固定随机种子\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建物体纹理\n    const objectGraphics = this.add.graphics();\n    objectGraphics.fillStyle(0xff6600, 1);\n    objectGraphics.fillRect(0, 0, 24, 24);\n    objectGraphics.generateTexture('object', 24, 24);\n    objectGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0.3);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建10个物体（使用固定种子生成位置）\n    this.objects = this.physics.add.group();\n    const rng = this.createSeededRandom(this.seed);\n    \n    for (let i = 0; i < 10; i++) {\n      const x = rng() * 700 + 50; // 50-750\n      const y = rng() * 500 + 50; // 50-550\n      const obj = this.objects.create(x, y, 'object');\n      obj.setBounce(0.4);\n      obj.setCollideWorldBounds(true);\n    }\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.objects);\n    this.physics.add.collider(this.objects, this.objects);\n\n    // 创建方向键\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加WASD键作为备用\n    this.keys = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.UP,\n      down: Phaser.Input.Keyboard.KeyCodes.DOWN,\n      left: Phaser.Input.Keyboard.KeyCodes.LEFT,\n      right: Phaser.Input.Keyboard.KeyCodes.RIGHT,\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 状态文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 说明文本\n    this.instructionText = this.add.text(10, 550, \n      'Use Arrow Keys to switch gravity direction', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n\n    // 初始化重力方向指示器\n    this.gravityIndicator = this.add.graphics();\n    \n    this.updateStatus();\n  }\n\n  update() {\n    // 检测方向键按下（使用 justDown 避免重复触发）\n    if (Phaser.Input.Keyboard.JustDown(this.cursors.up) || \n        Phaser.Input.Keyboard.JustDown(this.keys.w)) {\n      this.setGravity('up');\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.down) || \n               Phaser.Input.Keyboard.JustDown(this.keys.s)) {\n      this.setGravity('down');\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.left) || \n               Phaser.Input.Keyboard.JustDown(this.keys.a)) {\n      this.setGravity('left');\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.right) || \n               Phaser.Input.Keyboard.JustDown(this.keys.d)) {\n      this.setGravity('right');\n    }\n\n    this.updateGravityIndicator();\n  }\n\n  setGravity(direction) {\n    const gravityStrength = 500;\n    \n    // 如果方向相同，不重复设置\n    if (this.currentGravityDirection === direction) {\n      return;\n    }\n\n    switch(direction) {\n      case 'up':\n        this.physics.world.gravity.x = 0;\n        this.physics.world.gravity.y = -gravityStrength;\n        break;\n      case 'down':\n        this.physics.world.gravity.x = 0;\n        this.physics.world.gravity.y = gravityStrength;\n        break;\n      case 'left':\n        this.physics.world.gravity.x = -gravityStrength;\n        this.physics.world.gravity.y = 0;\n        break;\n      case 'right':\n        this.physics.world.gravity.x = gravityStrength;\n        this.physics.world.gravity.y = 0;\n        break;\n    }\n\n    this.currentGravityDirection = direction;\n    this.gravitySwitchCount++;\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    this.statusText.setText([\n      `Gravity: ${this.currentGravityDirection.toUpperCase()}`,\n      `Switches: ${this.gravitySwitchCount}`,\n      `Objects: ${this.objects.getChildren().length}`,\n      `Player: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`\n    ]);\n  }\n\n  updateGravityIndicator() {\n    this.gravityIndicator.clear();\n    this.gravityIndicator.lineStyle(3, 0xffff00, 1);\n    this.gravityIndicator.fillStyle(0xffff00, 1);\n\n    const centerX = 750;\n    const centerY = 30;\n    const length = 20;\n\n    // 绘制重力方向箭头\n    switch(this.currentGravityDirection) {\n      case 'up':\n        this.gravityIndicator.beginPath();\n        this.gravityIndicator.moveTo(centerX, centerY);\n        this.gravityIndicator.lineTo(centerX, centerY - length);\n        this.gravityIndicator.lineTo(centerX - 5, centerY - length + 8);\n        this.gravityIndicator.moveTo(centerX, centerY - length);\n        this.gravityIndicator.lineTo(centerX + 5, centerY - length + 8);\n        this.gravityIndicator.strokePath();\n        break;\n      case 'down':\n        this.gravityIndicator.beginPath();\n        this.gravityIndicator.moveTo(centerX, centerY);\n        this.gravityIndicator.lineTo(centerX, centerY + length);\n        this.gravityIndicator.lineTo(centerX - 5, centerY + length - 8);\n        this.gravityIndicator.moveTo(centerX, centerY + length);\n        this.gravityIndicator.lineTo(centerX + 5, centerY + length - 8);\n        this.gravityIndicator.strokePath();\n        break;\n      case 'left':\n        this.gravityIndicator.beginPath();\n        this.gravityIndicator.moveTo(centerX, centerY);\n        this.gravityIndicator.lineTo(centerX - length, centerY);\n        this.gravityIndicator.lineTo(centerX - length + 8, centerY - 5);\n        this.gravityIndicator.moveTo(centerX - length, centerY);\n        this.gravityIndicator.lineTo(centerX - length + 8, centerY + 5);\n        this.gravityIndicator.strokePath();\n        break;\n      case 'right':\n        this.gravityIndicator.beginPath();\n        this.gravityIndicator.moveTo(centerX, centerY);\n        this.gravityIndicator.lineTo(centerX + length, centerY);\n        this.gravityIndicator.lineTo(centerX + length - 8, centerY - 5);\n        this.gravityIndicator.moveTo(centerX + length, centerY);\n        this.gravityIndicator.lineTo(centerX + length - 8, centerY + 5);\n        this.gravityIndicator.strokePath();\n        break;\n    }\n  }\n\n  // 创建固定种子的随机数生成器\n  createSeededRandom(seed) {\n    let currentSeed = seed;\n    return function() {\n      currentSeed = (currentSeed * 9301 + 49297) % 233280;\n      return currentSeed / 233280;\n    };\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: GravityGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001788_v3", "prompt_id": "seed_001788", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个蓝色圆形移动，移动速度为 120，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制蓝色圆形移动，速度120，限制在画布边界内\nAPI: this.add.graphics(), this.input.keyboard.createCursorKeys(), graphics.fillCircle(), graphics.generateTexture()\nSTEPS:\n1. 创建 Graphics 对象绘制蓝色圆形并生成纹理\n2. 使用生成的纹理创建 Sprite 对象作为玩家\n3. 在 create 中获取方向键输入对象\n4. 在 update 中检测方向键状态并更新玩家位置\n5. 使用 Phaser.Math.Clamp 限制玩家在画布边界内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nconst SPEED = 120;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  graphics.generateTexture('playerCircle', 50, 50); // 生成 50x50 的纹理\n  graphics.destroy(); // 销毁 graphics 对象，因为纹理已生成\n\n  // 创建玩家精灵，放置在画布中心\n  player = this.add.sprite(400, 300, 'playerCircle');\n\n  // 创建方向键输入\n  cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间增量，转换为秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 检测方向键输入\n  if (cursors.left.isDown) {\n    velocityX = -distance;\n  } else if (cursors.right.isDown) {\n    velocityX = distance;\n  }\n\n  if (cursors.up.isDown) {\n    velocityY = -distance;\n  } else if (cursors.down.isDown) {\n    velocityY = distance;\n  }\n\n  // 更新玩家位置\n  player.x += velocityX;\n  player.y += velocityY;\n\n  // 限制玩家在画布边界内（考虑圆形半径）\n  const radius = 25;\n  player.x = Phaser.Math.Clamp(player.x, radius, config.width - radius);\n  player.y = Phaser.Math.Clamp(player.y, radius, config.height - radius);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000513_v3", "prompt_id": "seed_000513", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现简单 Boss 战：绿色Boss 有 5 点血量，被子弹（速度 240）命中扣血，血量归零时显示胜利。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现简单Boss战，绿色Boss有5点血量，被子弹命中扣血，血量归零显示胜利\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard\nSTEPS:\n1. 创建玩家飞船（蓝色矩形）和Boss（绿色圆形），添加物理属性\n2. 实现键盘控制玩家移动和空格键发射子弹\n3. 设置子弹与Boss的碰撞检测，命中时扣血并销毁子弹\n4. 显示Boss血量条，血量归零时显示胜利文本\n5. 添加状态变量用于验证游戏进度\n[/PLAN]\n\n```javascript\nclass BossBattleScene extends Phaser.Scene {\n  constructor() {\n    super('BossBattleScene');\n    this.bossHealth = 5;\n    this.maxBossHealth = 5;\n    this.gameWon = false;\n    this.bulletSpeed = 240;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色矩形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 30);\n    playerGraphics.generateTexture('player', 40, 30);\n    playerGraphics.destroy();\n\n    // 创建Boss纹理（绿色圆形）\n    const bossGraphics = this.add.graphics();\n    bossGraphics.fillStyle(0x00ff00, 1);\n    bossGraphics.fillCircle(50, 50, 50);\n    bossGraphics.generateTexture('boss', 100, 100);\n    bossGraphics.destroy();\n\n    // 创建子弹纹理（黄色小圆）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(5, 5, 5);\n    bulletGraphics.generateTexture('bullet', 10, 10);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建Boss\n    this.boss = this.physics.add.sprite(400, 150, 'boss');\n    this.boss.setCollideWorldBounds(true);\n    this.boss.setVelocityX(100);\n\n    // Boss左右移动逻辑\n    this.physics.world.on('worldbounds', (body) => {\n      if (body.gameObject === this.boss) {\n        this.boss.setVelocityX(-this.boss.body.velocity.x);\n      }\n    });\n    this.boss.body.onWorldBounds = true;\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 20\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    // 发射冷却\n    this.canShoot = true;\n    this.shootCooldown = 300;\n\n    // 碰撞检测：子弹击中Boss\n    this.physics.add.overlap(this.bullets, this.boss, this.hitBoss, null, this);\n\n    // UI文本\n    this.healthText = this.add.text(16, 16, `Boss HP: ${this.bossHealth}/${this.maxBossHealth}`, {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n\n    // 血量条背景\n    this.healthBarBg = this.add.graphics();\n    this.healthBarBg.fillStyle(0x666666, 1);\n    this.healthBarBg.fillRect(350, 50, 200, 20);\n\n    // 血量条前景\n    this.healthBar = this.add.graphics();\n    this.updateHealthBar();\n\n    // 胜利文本（初始隐藏）\n    this.victoryText = this.add.text(400, 300, 'VICTORY!', {\n      fontSize: '64px',\n      fill: '#ffff00',\n      stroke: '#000',\n      strokeThickness: 6\n    });\n    this.victoryText.setOrigin(0.5);\n    this.victoryText.setVisible(false);\n\n    // 调试信息\n    this.debugText = this.add.text(16, 550, '', {\n      fontSize: '16px',\n      fill: '#fff'\n    });\n  }\n\n  update(time, delta) {\n    if (this.gameWon) {\n      return; // 游戏胜利后停止更新\n    }\n\n    // 玩家移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 发射子弹\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.canShoot) {\n      this.shootBullet();\n    }\n\n    // 清理超出屏幕的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active && bullet.y < -10) {\n        bullet.setActive(false);\n        bullet.setVisible(false);\n      }\n    });\n\n    // 更新调试信息\n    this.debugText.setText([\n      `Boss Health: ${this.bossHealth}`,\n      `Active Bullets: ${this.bullets.countActive(true)}`,\n      `Game Won: ${this.gameWon}`\n    ]);\n  }\n\n  shootBullet() {\n    const bullet = this.bullets.get(this.player.x, this.player.y - 20);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocityY(-this.bulletSpeed);\n      \n      this.canShoot = false;\n      this.time.delayedCall(this.shootCooldown, () => {\n        this.canShoot = true;\n      });\n    }\n  }\n\n  hitBoss(bullet, boss) {\n    // 销毁子弹\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.setVelocity(0, 0);\n\n    // Boss扣血\n    this.bossHealth--;\n    this.healthText.setText(`Boss HP: ${this.bossHealth}/${this.maxBossHealth}`);\n    this.updateHealthBar();\n\n    // Boss闪烁效果\n    this.tweens.add({\n      targets: boss,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 1\n    });\n\n    // 检查胜利条件\n    if (this.bossHealth <= 0) {\n      this.winGame();\n    }\n  }\n\n  updateHealthBar() {\n    this.healthBar.clear();\n    const healthPercent = this.bossHealth / this.maxBossHealth;\n    const barWidth = 200 * healthPercent;\n    \n    // 根据血量变色\n    let color = 0x00ff00; // 绿色\n    if (healthPercent < 0.3) {\n      color = 0xff0000; // 红色\n    } else if (healthPercent < 0.6) {\n      color = 0xffaa00; // 橙色\n    }\n    \n    this.healthBar.fillStyle(color, 1);\n    this.healthBar.fillRect(350, 50, barWidth, 20);\n  }\n\n  winGame() {\n    this.gameWon = true;\n    \n    // 停止Boss移动\n    this.boss.setVelocity(0, 0);\n    \n    // Boss消失动画\n    this.tweens.add({\n      targets: this.boss,\n      alpha: 0,\n      scale: 0,\n      duration: 500,\n      onComplete: () => {\n        this.boss.destroy();\n      }\n    });\n\n    // 显示胜利文本\n    this.victoryText.setVisible(true);\n    this.tweens.add({\n      targets: this.victoryText,\n      scale: { from: 0, to: 1.2 },\n      duration: 500,\n      ease: 'Bounce.easeOut'\n    });\n\n    // 停止玩家移动\n    this.player.setVelocity(0, 0);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000033',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: BossBattleScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001819_v1", "prompt_id": "seed_001819", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 创建 Graphics 对象并绘制三角形\n2. 设置三角形初始透明度为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 4 秒\n4. 设置 Tween 循环播放（repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制三角形（使用 beginPath 和 fillPath）\n  graphics.beginPath();\n  graphics.moveTo(400, 200); // 顶点\n  graphics.lineTo(300, 400); // 左下角\n  graphics.lineTo(500, 400); // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1, // 目标透明度：完全不透明\n    duration: 4000, // 持续时间 4 秒\n    ease: 'Linear', // 线性渐变\n    repeat: -1, // 无限循环\n    yoyo: false // 不反向播放，只是从 0 到 1 循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Triangle fading in (4s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000473_v1", "prompt_id": "seed_000473", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个黄色物体以 120 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 20个黄色物体以120速度随机移动，碰撞边界和彼此时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.World.setBoundsCollision, Phaser.Physics.Arcade.Collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 创建黄色圆形纹理\n3. 创建物理组，添加 20 个物体并设置随机速度\n4. 设置物体边界碰撞和反弹属性\n5. 添加物体间的碰撞检测\n6. 添加状态信号（活跃物体数量）用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeObjectsCount = 0; // 状态信号：活跃物体数量\n    this.collisionCount = 0; // 状态信号：碰撞次数\n  }\n\n  preload() {\n    // 使用 Graphics 创建黄色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFFFF00, 1); // 黄色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆形\n    graphics.generateTexture('yellowBall', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理组\n    this.ballGroup = this.physics.add.group({\n      key: 'yellowBall',\n      repeat: 19, // 创建20个物体（1个默认 + 19个重复）\n      setXY: {\n        x: Phaser.Math.Between(50, 750),\n        y: Phaser.Math.Between(50, 550),\n        stepX: 0,\n        stepY: 0\n      }\n    });\n\n    // 为每个物体设置属性\n    this.ballGroup.children.iterate((ball) => {\n      // 设置随机速度方向，速度大小为120\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 120;\n      const velocityY = Math.sin(angle) * 120;\n      \n      ball.setVelocity(velocityX, velocityY);\n      \n      // 设置反弹系数为1（完全弹性碰撞）\n      ball.setBounce(1, 1);\n      \n      // 设置与世界边界碰撞\n      ball.setCollideWorldBounds(true);\n      \n      // 设置圆形碰撞体，更准确的碰撞检测\n      ball.body.setCircle(16);\n    });\n\n    // 设置物体间的碰撞\n    this.physics.add.collider(this.ballGroup, this.ballGroup, this.onCollision, null, this);\n\n    // 更新活跃物体数量\n    this.activeObjectsCount = this.ballGroup.getLength();\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  onCollision(ball1, ball2) {\n    // 碰撞回调，增加碰撞计数\n    this.collisionCount++;\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Active Objects: ${this.activeObjectsCount}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 120 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 每帧更新状态显示\n    this.updateStatusText();\n\n    // 验证速度保持在120左右（考虑浮点误差）\n    this.ballGroup.children.iterate((ball) => {\n      const speed = Math.sqrt(\n        ball.body.velocity.x ** 2 + \n        ball.body.velocity.y ** 2\n      );\n      \n      // 如果速度偏差过大，重新归一化到120\n      if (Math.abs(speed - 120) > 1) {\n        const scale = 120 / speed;\n        ball.setVelocity(\n          ball.body.velocity.x * scale,\n          ball.body.velocity.y * scale\n        );\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001417_v3", "prompt_id": "seed_001417", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按WASD键向当前朝向发射子弹，子弹速度 160，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现WASD控制玩家旋转朝向，按空格键向当前朝向发射速度160的子弹\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Group, this.physics.velocityFromAngle\nSTEPS:\n1. 创建玩家精灵，使用Graphics绘制三角形表示朝向\n2. 监听WASD键控制玩家旋转（W上/S下/A左/D右对应不同角度）\n3. 创建子弹物理组，监听空格键发射子弹\n4. 使用velocityFromAngle根据玩家角度计算子弹速度\n5. 子弹超出边界自动销毁，维护bulletsFired计数器作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 验证状态信号\n    this.playerRotationSpeed = 3; // 旋转速度\n  }\n\n  preload() {\n    // 创建玩家纹理（三角形指示方向）\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.beginPath();\n    graphics.moveTo(20, 0);\n    graphics.lineTo(-10, -10);\n    graphics.lineTo(-10, 10);\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.generateTexture('player', 30, 20);\n    graphics.destroy();\n\n    // 创建子弹纹理（圆形）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.angle = 0; // 初始朝向右侧\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D,\n      space: Phaser.Input.Keyboard.KeyCodes.SPACE\n    });\n\n    // 空格键发射子弹（添加延迟防止连发）\n    this.lastFireTime = 0;\n    this.fireDelay = 200; // 200ms 发射间隔\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, 'WASD: 旋转方向 | SPACE: 发射子弹', {\n      fontSize: '14px',\n      fill: '#aaaaaa'\n    });\n  }\n\n  update(time, delta) {\n    // WASD 控制玩家旋转方向\n    if (this.cursors.w.isDown) {\n      // W键 - 向上（-90度）\n      this.player.angle = -90;\n    } else if (this.cursors.s.isDown) {\n      // S键 - 向下（90度）\n      this.player.angle = 90;\n    } else if (this.cursors.a.isDown) {\n      // A键 - 向左（180度）\n      this.player.angle = 180;\n    } else if (this.cursors.d.isDown) {\n      // D键 - 向右（0度）\n      this.player.angle = 0;\n    }\n\n    // 空格键发射子弹\n    if (this.cursors.space.isDown && time > this.lastFireTime + this.fireDelay) {\n      this.fireBullet();\n      this.lastFireTime = time;\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -20 || bullet.x > 820 || \n            bullet.y < -20 || bullet.y > 620) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText([\n      `子弹发射数: ${this.bulletsFired}`,\n      `玩家角度: ${Math.round(this.player.angle)}°`,\n      `活跃子弹: ${this.bullets.countActive(true)}`\n    ]);\n  }\n\n  fireBullet() {\n    // 获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 根据玩家角度计算子弹速度\n      // Phaser角度是顺时针，0度向右\n      const velocity = this.physics.velocityFromAngle(\n        this.player.angle, \n        160 // 子弹速度\n      );\n      \n      bullet.setVelocity(velocity.x, velocity.y);\n      bullet.setRotation(Phaser.Math.DegToRad(this.player.angle));\n      \n      // 增加发射计数\n      this.bulletsFired++;\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001141_v1", "prompt_id": "seed_001141", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，根据中心点和半径计算6个顶点坐标\n4. 使用循环15次，每次生成随机 x、y 坐标（考虑边界）\n5. 在每个随机位置绘制紫色填充的六边形（大小64像素）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9966ff, 1);\n  \n  // 六边形半径（从中心到顶点的距离）\n  const hexRadius = 32; // 64像素大小的六边形半径为32\n  \n  // 绘制六边形的辅助函数\n  function drawHexagon(gfx, x, y, radius) {\n    gfx.beginPath();\n    \n    // 计算六边形的6个顶点（从顶部开始，顺时针）\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度起始，使顶点朝上\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        gfx.moveTo(vx, vy);\n      } else {\n        gfx.lineTo(vx, vy);\n      }\n    }\n    \n    gfx.closePath();\n    gfx.fillPath();\n  }\n  \n  // 绘制15个随机位置的六边形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const x = hexRadius + Math.random() * (800 - hexRadius * 2);\n    const y = hexRadius + Math.random() * (600 - hexRadius * 2);\n    \n    drawHexagon(graphics, x, y, hexRadius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000644_v2", "prompt_id": "seed_000644", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 8 个青色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 8 个青色可复用对象，离开屏幕后自动回收并重新使用\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, Group.get, Group.killAndHide\nSTEPS:\n1. 创建青色圆形纹理用于对象显示\n2. 使用 Physics.Arcade.Group 创建对象池，设置最大数量为 8\n3. 在 create 中初始化发射器，定时从对象池获取对象并发射\n4. 在 update 中检测对象是否离开屏幕，离开则回收到对象池\n5. 添加状态变量跟踪活跃对象数量和总回收次数\n[/PLAN]\n\n```javascript\nclass PoolScene extends Phaser.Scene {\n  constructor() {\n    super('PoolScene');\n    this.activeCount = 0;      // 当前活跃对象数量\n    this.recycledCount = 0;    // 总回收次数\n    this.launchedCount = 0;    // 总发射次数\n  }\n\n  preload() {\n    // 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('cyanBall', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池，最大 8 个对象\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'cyanBall',\n      maxSize: 8,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 创建状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 每 800ms 发射一个对象\n    this.time.addEvent({\n      delay: 800,\n      callback: this.launchObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 初始发射几个对象\n    for (let i = 0; i < 3; i++) {\n      this.time.delayedCall(i * 300, () => {\n        this.launchObject();\n      });\n    }\n\n    this.updateStatusText();\n  }\n\n  launchObject() {\n    // 从对象池获取一个对象\n    const obj = this.objectPool.get(\n      Phaser.Math.Between(50, 750),  // 随机 x 位置\n      -50                             // 屏幕上方\n    );\n\n    if (obj) {\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 设置随机速度\n      obj.setVelocity(\n        Phaser.Math.Between(-100, 100),  // x 方向速度\n        Phaser.Math.Between(150, 300)    // y 方向速度（向下）\n      );\n\n      // 添加旋转效果\n      obj.setAngularVelocity(Phaser.Math.Between(-200, 200));\n\n      this.launchedCount++;\n      this.activeCount = this.objectPool.countActive(true);\n    }\n  }\n\n  update() {\n    // 检查所有活跃对象\n    this.objectPool.children.entries.forEach((obj) => {\n      if (obj.active) {\n        // 检查是否离开屏幕边界\n        if (obj.y > 650 || obj.x < -50 || obj.x > 850 || obj.y < -50) {\n          // 回收对象\n          this.recycleObject(obj);\n        }\n      }\n    });\n\n    this.updateStatusText();\n  }\n\n  recycleObject(obj) {\n    // 停止物理运动\n    obj.setVelocity(0, 0);\n    obj.setAngularVelocity(0);\n    \n    // 回收到对象池\n    this.objectPool.killAndHide(obj);\n    obj.setActive(false);\n\n    this.recycledCount++;\n    this.activeCount = this.objectPool.countActive(true);\n  }\n\n  updateStatusText() {\n    const poolSize = this.objectPool.getLength();\n    const activeObjs = this.objectPool.countActive(true);\n    const inactiveObjs = this.objectPool.countActive(false);\n\n    this.statusText.setText([\n      `Pool Size: ${poolSize} / 8`,\n      `Active: ${activeObjs}`,\n      `Inactive: ${inactiveObjs}`,\n      `Launched: ${this.launchedCount}`,\n      `Recycled: ${this.recycledCount}`,\n      '',\n      'Objects auto-recycle when',\n      'they leave the screen'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: PoolScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001300_v3", "prompt_id": "seed_001300", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 创建 Game 配置，设置场景的 preload、create 和 update 方法\n2. 在 create 中使用 Graphics 绘制一个矩形\n3. 在 update 中根据 delta 时间增量计算旋转角度（240度/秒 = 240 * Math.PI / 180 弧度/秒）\n4. 每帧更新矩形的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet rectangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  rectangle = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  rectangle.fillStyle(0x4a90e2, 1);\n  \n  // 绘制一个矩形（中心点在原点，便于旋转）\n  // 矩形大小：宽 150，高 100\n  rectangle.fillRect(-75, -50, 150, 100);\n  \n  // 设置矩形位置到画布中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n  \n  // 初始旋转角度为 0\n  rectangle.rotation = 0;\n}\n\nfunction update(time, delta) {\n  // 计算每帧旋转的角度\n  // 240 度/秒 = 240 * (Math.PI / 180) 弧度/秒\n  // delta 是以毫秒为单位，需要转换为秒：delta / 1000\n  const rotationSpeed = 240 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 当前帧旋转的弧度\n  \n  // 更新矩形的旋转角度\n  rectangle.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000335_v3", "prompt_id": "seed_000335", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色星形以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Physics.Arcade, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 在 create 中使用 Graphics 绘制红色星形并生成纹理\n3. 创建物理精灵并应用星形纹理，设置初始速度为360\n4. 设置精灵与世界边界碰撞并反弹\n5. 可选：在 update 中保持恒定速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet star;\nconst SPEED = 360;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制星形（5个尖角）\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: 40 + Math.cos(angle) * radius,\n      y: 40 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 80, 80);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置随机初始速度方向，但保持速度大小为360\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  star.setVelocity(\n    Math.cos(angle) * SPEED,\n    Math.sin(angle) * SPEED\n  );\n  \n  // 设置与世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  star.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（修正由于浮点数误差导致的速度变化）\n  const currentSpeed = Math.sqrt(\n    star.body.velocity.x ** 2 + star.body.velocity.y ** 2\n  );\n  \n  if (Math.abs(currentSpeed - SPEED) > 1) {\n    const scale = SPEED / currentSpeed;\n    star.setVelocity(\n      star.body.velocity.x * scale,\n      star.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000182_v3", "prompt_id": "seed_000182", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 0.5 秒在随机位置生成一个橙色菱形，最多生成 12 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔 0.5 秒在随机位置生成橙色菱形，最多 12 个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Geom.Point\nSTEPS:\n1. 创建 Scene 并初始化计数器变量\n2. 使用 Graphics 绘制菱形形状并生成纹理\n3. 在 create 中使用 time.addEvent 创建定时器，每 0.5 秒触发一次\n4. 在定时器回调中生成随机坐标，创建菱形精灵\n5. 当生成数量达到 12 个时停止定时器\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nlet diamondCount = 0;\nconst MAX_DIAMONDS = 12;\nlet timerEvent;\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制橙色菱形\n  graphics.fillStyle(0xff8800, 1);\n  graphics.beginPath();\n  graphics.moveTo(20, 0);    // 上顶点\n  graphics.lineTo(40, 20);   // 右顶点\n  graphics.lineTo(20, 40);   // 下顶点\n  graphics.lineTo(0, 20);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 重置计数器\n  diamondCount = 0;\n  \n  // 添加标题文字\n  this.add.text(400, 30, 'Orange Diamonds Generator', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 添加计数显示\n  const countText = this.add.text(400, 70, `Diamonds: ${diamondCount}/${MAX_DIAMONDS}`, {\n    fontSize: '18px',\n    color: '#ff8800'\n  }).setOrigin(0.5);\n  \n  // 创建定时器事件，每 0.5 秒执行一次\n  timerEvent = this.time.addEvent({\n    delay: 500,                    // 0.5 秒 = 500 毫秒\n    callback: spawnDiamond,\n    callbackScope: this,\n    loop: true\n  });\n  \n  function spawnDiamond() {\n    // 检查是否已达到最大数量\n    if (diamondCount >= MAX_DIAMONDS) {\n      timerEvent.remove();  // 停止定时器\n      \n      // 显示完成信息\n      this.add.text(400, 550, 'All diamonds generated!', {\n        fontSize: '20px',\n        color: '#00ff00'\n      }).setOrigin(0.5);\n      \n      return;\n    }\n    \n    // 生成随机位置（留出边距）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(120, 550);\n    \n    // 创建菱形精灵\n    const diamond = this.add.image(x, y, 'diamond');\n    \n    // 添加简单的缩放动画效果\n    diamond.setScale(0);\n    this.tweens.add({\n      targets: diamond,\n      scale: 1,\n      duration: 200,\n      ease: 'Back.easeOut'\n    });\n    \n    // 增加计数\n    diamondCount++;\n    \n    // 更新计数显示\n    countText.setText(`Diamonds: ${diamondCount}/${MAX_DIAMONDS}`);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000558_v3", "prompt_id": "seed_000558", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按鼠标左键向当前朝向发射子弹，子弹速度 160，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现多方向射击系统，玩家可旋转朝向并向当前方向发射子弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建玩家精灵，使用 Graphics 绘制三角形表示朝向\n2. 监听键盘输入（A/D 或左右箭头）实现玩家旋转\n3. 创建子弹物理组，监听鼠标左键点击事件\n4. 点击时从玩家位置按当前角度发射子弹，使用 velocityFromAngle 设置速度\n5. 子弹超出边界时自动回收，维护发射计数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 验证信号：发射的子弹总数\n    this.activeBullets = 0; // 验证信号：当前活跃的子弹数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建玩家纹理（三角形指示朝向）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(20, 0);      // 顶点（前方）\n    playerGraphics.lineTo(-10, -10);   // 左下\n    playerGraphics.lineTo(-10, 10);    // 右下\n    playerGraphics.closePath();\n    playerGraphics.fillPath();\n    playerGraphics.generateTexture('player', 30, 20);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（小圆点）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: true\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 鼠标左键射击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        this.shootBullet();\n      }\n    });\n\n    // 显示状态信息\n    this.statsText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(10, height - 60, 'Controls:\\nA/D or Arrow Keys: Rotate\\nLeft Click: Shoot', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStats();\n  }\n\n  update(time, delta) {\n    // 玩家旋转控制\n    const rotationSpeed = 3; // 度/帧\n    \n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.angle -= rotationSpeed;\n    }\n    if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.angle += rotationSpeed;\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        const bounds = this.cameras.main;\n        if (bullet.x < -50 || bullet.x > bounds.width + 50 ||\n            bullet.y < -50 || bullet.y > bounds.height + 50) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n          this.activeBullets--;\n          this.updateStats();\n        }\n      }\n    });\n  }\n\n  shootBullet() {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n\n      // 根据玩家角度计算速度\n      const bulletSpeed = 400;\n      const velocity = this.physics.velocityFromAngle(\n        this.player.angle,\n        bulletSpeed\n      );\n\n      bullet.setVelocity(velocity.x, velocity.y);\n      bullet.setRotation(Phaser.Math.DegToRad(this.player.angle));\n\n      // 更新统计\n      this.bulletsFired++;\n      this.activeBullets++;\n      this.updateStats();\n    }\n  }\n\n  updateStats() {\n    this.statsText.setText([\n      `Bullets Fired: ${this.bulletsFired}`,\n      `Active Bullets: ${this.activeBullets}`,\n      `Player Angle: ${Math.round(this.player.angle)}°`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001057_v1", "prompt_id": "seed_001057", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按鼠标右键触发相机淡入淡出效果，持续 0.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按鼠标右键触发相机淡入淡出效果，持续 0.5 秒\nAPI: Phaser.Input.InputPlugin#on, Phaser.Cameras.Scene2D.Camera#fadeIn, Phaser.Cameras.Scene2D.Camera#fadeOut, Phaser.Cameras.Scene2D.Camera#once\nSTEPS:\n1. 创建基础场景，使用 Graphics 绘制可视元素作为背景\n2. 监听鼠标右键点击事件（pointerdown 事件，判断 rightButtonDown）\n3. 右键按下时先触发 fadeOut 效果（淡出到黑色，持续 250ms）\n4. fadeOut 完成后触发 fadeIn 效果（淡入回来，持续 250ms）\n5. 添加状态变量记录淡入淡出触发次数，便于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.fadeCount = 0; // 状态信号：记录淡入淡出触发次数\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建背景和可视元素\n    const graphics = this.add.graphics();\n    \n    // 绘制彩色背景网格\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 6; j++) {\n        const color = ((i + j) % 2 === 0) ? 0x3498db : 0x2ecc71;\n        graphics.fillStyle(color, 1);\n        graphics.fillRect(i * 100, j * 100, 100, 100);\n      }\n    }\n\n    // 绘制中心圆形\n    graphics.fillStyle(0xe74c3c, 1);\n    graphics.fillCircle(400, 300, 80);\n\n    // 添加文本提示\n    const text = this.add.text(400, 50, '右键点击触发淡入淡出效果', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setOrigin(0.5);\n\n    // 显示触发次数的文本\n    this.countText = this.add.text(400, 550, `触发次数: ${this.fadeCount}`, {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.countText.setOrigin(0.5);\n\n    // 获取主相机\n    this.mainCamera = this.cameras.main;\n\n    // 监听鼠标右键点击事件\n    this.input.on('pointerdown', (pointer) => {\n      // 判断是否为右键\n      if (pointer.rightButtonDown()) {\n        this.triggerFadeEffect();\n      }\n    });\n\n    // 提示：需要在浏览器中禁用右键菜单才能正常工作\n    this.input.mouse.disableContextMenu();\n  }\n\n  triggerFadeEffect() {\n    // 增加触发计数\n    this.fadeCount++;\n    this.countText.setText(`触发次数: ${this.fadeCount}`);\n\n    // 先淡出（持续 250ms）\n    this.mainCamera.fadeOut(250, 0, 0, 0);\n\n    // 淡出完成后触发淡入\n    this.mainCamera.once('camerafadeoutcomplete', () => {\n      // 淡入（持续 250ms）\n      this.mainCamera.fadeIn(250, 0, 0, 0);\n    });\n  }\n\n  update(time, delta) {\n    // 可选：添加一些动态效果\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: GameScene,\n  parent: 'game-container'\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000875_v1", "prompt_id": "seed_000875", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Input"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现灰色移动平台：平台以 360 速度水平往返移动，玩家可站在上面并跟随移动，重力 200。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现灰色移动平台，平台水平往返移动速度360，玩家可站在上面跟随移动，重力200\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Body, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard\nSTEPS:\n1. 创建物理系统配置，设置重力为200\n2. 使用Graphics生成灰色平台和玩家纹理\n3. 创建移动平台，设置初始速度360，碰撞检测\n4. 创建玩家精灵，添加键盘控制\n5. 实现平台边界检测和速度反转逻辑\n6. 添加玩家与平台的碰撞处理，确保玩家能站在平台上并跟随移动\n7. 添加状态信号变量记录平台移动次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.platformBounces = 0; // 状态信号：平台反弹次数\n    this.platformDirection = 1; // 平台移动方向\n  }\n\n  preload() {\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x808080, 1); // 灰色\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1); // 绿色玩家\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x654321, 1); // 棕色地面\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#87CEEB');\n\n    // 创建地面\n    this.ground = this.physics.add.sprite(400, 575, 'ground');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(400, 400, 'platform');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.setVelocityX(360 * this.platformDirection);\n\n    // 设置平台移动范围（左右边界）\n    this.platformMinX = 150;\n    this.platformMaxX = 650;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 200, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.platform, this.handlePlatformCollision, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    });\n    this.updateStatusText();\n\n    // 添加说明文字\n    this.add.text(400, 50, '使用方向键移动玩家\\n站在灰色平台上体验移动', {\n      fontSize: '16px',\n      fill: '#000',\n      align: 'center'\n    }).setOrigin(0.5);\n  }\n\n  handlePlatformCollision(player, platform) {\n    // 当玩家在平台上方时，让玩家跟随平台移动\n    if (player.body.touching.down && platform.body.touching.up) {\n      // 玩家继承平台的水平速度\n      const platformVelocity = platform.body.velocity.x;\n      \n      // 如果玩家没有按左右键，则完全跟随平台\n      if (!this.cursors.left.isDown && !this.cursors.right.isDown) {\n        player.setVelocityX(platformVelocity);\n      } else {\n        // 如果玩家按了方向键，则在平台速度基础上叠加\n        const playerControl = this.cursors.left.isDown ? -160 : (this.cursors.right.isDown ? 160 : 0);\n        player.setVelocityX(platformVelocity + playerControl);\n      }\n    }\n  }\n\n  update(time, delta) {\n    // 平台边界检测和速度反转\n    if (this.platform.x <= this.platformMinX) {\n      this.platform.x = this.platformMinX;\n      this.platformDirection = 1;\n      this.platform.setVelocityX(360 * this.platformDirection);\n      this.platformBounces++;\n      this.updateStatusText();\n    } else if (this.platform.x >= this.platformMaxX) {\n      this.platform.x = this.platformMaxX;\n      this.platformDirection = -1;\n      this.platform.setVelocityX(360 * this.platformDirection);\n      this.platformBounces++;\n      this.updateStatusText();\n    }\n\n    // 玩家控制（仅在不在平台上时或主动控制时）\n    if (this.cursors.left.isDown) {\n      if (!this.player.body.touching.down || !this.platform.body.touching.up) {\n        this.player.setVelocityX(-160);\n      }\n    } else if (this.cursors.right.isDown) {\n      if (!this.player.body.touching.down || !this.platform.body.touching.up) {\n        this.player.setVelocityX(160);\n      }\n    } else {\n      // 如果玩家不在平台上且没有按键，则停止水平移动\n      if (!this.physics.overlap(this.player, this.platform)) {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-330);\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `平台反弹次数: ${this.platformBounces}\\n` +\n      `平台速度: ${Math.abs(this.platform.body.velocity.x).toFixed(0)} px/s\\n` +\n      `平台方向: ${this.platformDirection > 0 ? '右' : '左'}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 200 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001705_v3", "prompt_id": "seed_001705", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现血条+回血：显示 15 格生命值，按鼠标右键扣血，每 1.5 秒自动回复 1 点。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现15格血条显示，鼠标右键扣血，每1.5秒自动回复1点生命值\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Mouse, Phaser.Time.Clock#addEvent, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建 15 格血条的可视化显示（使用 Graphics 绘制矩形）\n2. 监听鼠标右键点击事件，每次扣除 1 点生命值\n3. 使用 TimerEvent 创建定时器，每 1.5 秒自动回复 1 点生命值（不超过最大值）\n4. 每次生命值变化时更新血条显示\n5. 添加文本显示当前生命值数字\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.maxHealth = 15;\n    this.currentHealth = 15;\n    this.healthBlocks = [];\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 添加标题\n    this.add.text(400, 50, '血条系统演示', {\n      fontSize: '32px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 添加说明文字\n    this.add.text(400, 100, '右键点击扣血 | 每1.5秒自动回复1点', {\n      fontSize: '18px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 创建生命值文本显示\n    this.healthText = this.add.text(400, 450, `生命值: ${this.currentHealth}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 监听鼠标右键点击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown()) {\n        this.takeDamage(1);\n      }\n    });\n\n    // 创建自动回血定时器（每1.5秒）\n    this.time.addEvent({\n      delay: 1500,\n      callback: this.regenerateHealth,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 添加状态指示器（用于验证）\n    this.statusText = this.add.text(10, 10, 'Status: Running', {\n      fontSize: '16px',\n      color: '#00ff00'\n    });\n  }\n\n  createHealthBar() {\n    const startX = 150;\n    const startY = 250;\n    const blockWidth = 30;\n    const blockHeight = 40;\n    const blockSpacing = 5;\n\n    // 创建15个血条格子\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (blockWidth + blockSpacing);\n      const y = startY;\n\n      // 创建背景（空血槽）\n      const background = this.add.graphics();\n      background.fillStyle(0x333333, 1);\n      background.fillRect(x, y, blockWidth, blockHeight);\n      background.lineStyle(2, 0x666666, 1);\n      background.strokeRect(x, y, blockWidth, blockHeight);\n\n      // 创建前景（实际血量）\n      const foreground = this.add.graphics();\n      this.drawHealthBlock(foreground, x, y, blockWidth, blockHeight, true);\n\n      this.healthBlocks.push({\n        background,\n        foreground,\n        x,\n        y,\n        width: blockWidth,\n        height: blockHeight\n      });\n    }\n  }\n\n  drawHealthBlock(graphics, x, y, width, height, isFilled) {\n    graphics.clear();\n    if (isFilled) {\n      // 根据血量使用不同颜色\n      let color;\n      if (this.currentHealth > 10) {\n        color = 0x00ff00; // 绿色（健康）\n      } else if (this.currentHealth > 5) {\n        color = 0xffff00; // 黄色（警告）\n      } else {\n        color = 0xff0000; // 红色（危险）\n      }\n      graphics.fillStyle(color, 1);\n      graphics.fillRect(x + 2, y + 2, width - 4, height - 4);\n    }\n  }\n\n  updateHealthBar() {\n    // 更新每个血条格子的显示\n    for (let i = 0; i < this.maxHealth; i++) {\n      const block = this.healthBlocks[i];\n      const isFilled = i < this.currentHealth;\n      this.drawHealthBlock(block.foreground, block.x, block.y, block.width, block.height, isFilled);\n    }\n\n    // 更新文本显示\n    this.healthText.setText(`生命值: ${this.currentHealth}/${this.maxHealth}`);\n\n    // 更新文本颜色\n    if (this.currentHealth > 10) {\n      this.healthText.setColor('#00ff00');\n    } else if (this.currentHealth > 5) {\n      this.healthText.setColor('#ffff00');\n    } else {\n      this.healthText.setColor('#ff0000');\n    }\n  }\n\n  takeDamage(amount) {\n    if (this.currentHealth > 0) {\n      this.currentHealth = Math.max(0, this.currentHealth - amount);\n      this.updateHealthBar();\n\n      // 创建伤害提示\n      const damageText = this.add.text(400, 350, `-${amount}`, {\n        fontSize: '32px',\n        color: '#ff0000',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n\n      // 伤害数字上浮动画\n      this.tweens.add({\n        targets: damageText,\n        y: 300,\n        alpha: 0,\n        duration: 800,\n        ease: 'Power2',\n        onComplete: () => {\n          damageText.destroy();\n        }\n      });\n\n      if (this.currentHealth === 0) {\n        this.statusText.setText('Status: Dead').setColor('#ff0000');\n      }\n    }\n  }\n\n  regenerateHealth() {\n    if (this.currentHealth < this.maxHealth && this.currentHealth > 0) {\n      this.currentHealth = Math.min(this.maxHealth, this.currentHealth + 1);\n      this.updateHealthBar();\n\n      // 创建回复提示\n      const healText = this.add.text(400, 350, '+1', {\n        fontSize: '24px',\n        color: '#00ff00',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n\n      // 回复数字上浮动画\n      this.tweens.add({\n        targets: healText,\n        y: 300,\n        alpha: 0,\n        duration: 800,\n        ease: 'Power2',\n        onComplete: () => {\n          healText.destroy();\n        }\n      });\n    }\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: HealthBarScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001596_v2", "prompt_id": "seed_001596", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现蓝色角色冲刺：按鼠标左键进行短距离冲刺，冲刺速度为 200*3，冷却 2.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现蓝色角色按鼠标左键冲刺，速度200*3，冷却2.5秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Pointer, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建蓝色角色精灵并启用物理系统\n2. 监听鼠标左键点击事件\n3. 点击时检查冷却状态，如果可用则触发冲刺\n4. 冲刺时设置速度为600（200*3），持续短时间后恢复正常\n5. 使用TimerEvent实现2.5秒冷却机制\n6. 显示冷却状态和冲刺次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.dashCount = 0; // 可验证状态：冲刺次数\n    this.canDash = true; // 冷却状态\n    this.isDashing = false; // 是否正在冲刺\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建蓝色角色纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0000ff, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('bluePlayer', 32, 32);\n    graphics.destroy();\n\n    // 创建玩家精灵（屏幕中央）\n    this.player = this.physics.add.sprite(400, 300, 'bluePlayer');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDamping(true);\n    this.player.setDrag(0.9);\n\n    // 创建状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.updateStatusText();\n\n    // 创建冷却指示器（圆形）\n    this.cooldownIndicator = this.add.graphics();\n    this.cooldownIndicator.setDepth(1);\n\n    // 监听鼠标左键点击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        this.attemptDash(pointer);\n      }\n    });\n\n    // 键盘控制（可选，用于移动角色）\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 冷却计时器（初始为null）\n    this.cooldownTimer = null;\n  }\n\n  attemptDash(pointer) {\n    // 检查是否可以冲刺\n    if (!this.canDash || this.isDashing) {\n      return;\n    }\n\n    // 计算冲刺方向（从角色指向鼠标）\n    const angle = Phaser.Math.Angle.Between(\n      this.player.x,\n      this.player.y,\n      pointer.worldX,\n      pointer.worldY\n    );\n\n    // 执行冲刺\n    this.performDash(angle);\n  }\n\n  performDash(angle) {\n    // 设置冲刺状态\n    this.isDashing = true;\n    this.canDash = false;\n    this.dashCount++;\n\n    // 冲刺速度：200 * 3 = 600\n    const dashSpeed = 600;\n    const velocityX = Math.cos(angle) * dashSpeed;\n    const velocityY = Math.sin(angle) * dashSpeed;\n\n    // 设置冲刺速度\n    this.player.setVelocity(velocityX, velocityY);\n\n    // 冲刺持续时间：0.2秒\n    this.time.delayedCall(200, () => {\n      this.isDashing = false;\n      // 冲刺结束后减速\n      this.player.setVelocity(\n        this.player.body.velocity.x * 0.3,\n        this.player.body.velocity.y * 0.3\n      );\n    });\n\n    // 开始冷却：2.5秒\n    this.startCooldown();\n    this.updateStatusText();\n  }\n\n  startCooldown() {\n    const cooldownDuration = 2500; // 2.5秒\n\n    // 创建冷却计时器\n    this.cooldownTimer = this.time.addEvent({\n      delay: cooldownDuration,\n      callback: () => {\n        this.canDash = true;\n        this.cooldownTimer = null;\n        this.updateStatusText();\n      },\n      callbackScope: this\n    });\n  }\n\n  update(time, delta) {\n    // 键盘移动控制（非冲刺时）\n    if (!this.isDashing) {\n      const speed = 200;\n      \n      if (this.cursors.left.isDown) {\n        this.player.setVelocityX(-speed);\n      } else if (this.cursors.right.isDown) {\n        this.player.setVelocityX(speed);\n      }\n\n      if (this.cursors.up.isDown) {\n        this.player.setVelocityY(-speed);\n      } else if (this.cursors.down.isDown) {\n        this.player.setVelocityY(speed);\n      }\n    }\n\n    // 更新冷却指示器\n    this.updateCooldownIndicator();\n  }\n\n  updateStatusText() {\n    const cooldownStatus = this.canDash ? '✓ Ready' : '✗ Cooling';\n    this.statusText.setText([\n      `Dash Count: ${this.dashCount}`,\n      `Cooldown: ${cooldownStatus}`,\n      `Click to Dash!`\n    ]);\n  }\n\n  updateCooldownIndicator() {\n    this.cooldownIndicator.clear();\n\n    if (this.cooldownTimer) {\n      // 计算冷却进度\n      const progress = this.cooldownTimer.getProgress();\n      const angle = Phaser.Math.PI2 * progress;\n\n      // 在角色周围绘制冷却进度圆环\n      this.cooldownIndicator.lineStyle(4, 0xff0000, 0.8);\n      this.cooldownIndicator.beginPath();\n      this.cooldownIndicator.arc(\n        this.player.x,\n        this.player.y,\n        25,\n        -Math.PI / 2,\n        -Math.PI / 2 + angle,\n        false\n      );\n      this.cooldownIndicator.strokePath();\n    } else if (this.canDash) {\n      // 可以冲刺时显示绿色圆环\n      this.cooldownIndicator.lineStyle(3, 0x00ff00, 0.6);\n      this.cooldownIndicator.strokeCircle(this.player.x, this.player.y, 25);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001550_v1", "prompt_id": "seed_001550", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：粉色敌人从上方以 120 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，粉色敌人从上方以120速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制玩家（蓝色方块）和敌人（粉色圆形）纹理\n3. 创建玩家精灵，添加键盘控制（左右方向键）\n4. 使用定时器定期生成敌人，设置速度为 120\n5. 添加碰撞检测，碰撞时游戏结束，显示 GAME OVER 文本\n6. 添加分数系统，记录存活时间作为可验证状态\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.score = 0;\n    this.gameOver = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（粉色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff69b4, 1);\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 定时生成敌人（每1秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 分数显示\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 分数计时器（每100ms增加1分）\n    this.scoreTimer = this.time.addEvent({\n      delay: 100,\n      callback: () => {\n        if (!this.gameOver) {\n          this.score += 1;\n          this.scoreText.setText('Score: ' + this.score);\n        }\n      },\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  update() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 随机X位置生成敌人\n    const x = Phaser.Math.Between(20, 780);\n    const enemy = this.enemies.create(x, -20, 'enemy');\n    \n    // 设置敌人速度为120（向下）\n    enemy.setVelocityY(120);\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.player.setTint(0xff0000);\n    this.gameOverText.setVisible(true);\n\n    // 停止生成敌人\n    this.enemyTimer.remove();\n    this.scoreTimer.remove();\n\n    // 显示最终分数\n    this.add.text(400, 370, 'Final Score: ' + this.score, {\n      fontSize: '32px',\n      fill: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 重启提示\n    this.add.text(400, 420, 'Click to Restart', {\n      fontSize: '24px',\n      fill: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000850_v2", "prompt_id": "seed_000850", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 AI 对战：灰色AI 角色以 120 速度追踪玩家，玩家收集 10 个物品获胜，被 AI 碰到失败。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现 AI 追踪对战游戏，玩家收集 10 个物品获胜，被 AI 碰到失败\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.moveToObject, Phaser.Graphics, Phaser.Input.Keyboard, Phaser.Physics.Arcade.overlap\nSTEPS:\n1. 创建玩家角色（蓝色方块）和 AI 角色（灰色方块），启用物理系统\n2. 生成 10 个可收集物品（黄色圆形），随机分布在场景中\n3. 实现玩家键盘控制（方向键移动）\n4. 在 update 中让 AI 以 120 速度追踪玩家位置\n5. 检测玩家与物品的碰撞（收集物品增加分数）\n6. 检测玩家与 AI 的碰撞（游戏失败）\n7. 当分数达到 10 时游戏胜利，显示结果文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.gameWon = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建 AI 纹理（灰色方块）\n    const aiGraphics = this.add.graphics();\n    aiGraphics.fillStyle(0x808080, 1);\n    aiGraphics.fillRect(0, 0, 32, 32);\n    aiGraphics.generateTexture('ai', 32, 32);\n    aiGraphics.destroy();\n\n    // 创建物品纹理（黄色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('item', 24, 24);\n    itemGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建 AI\n    this.ai = this.physics.add.sprite(100, 100, 'ai');\n    this.ai.setCollideWorldBounds(true);\n\n    // 创建物品组\n    this.items = this.physics.add.group();\n    \n    // 使用固定种子生成物品位置（确保可重现）\n    const seed = 12345;\n    let random = this.seededRandom(seed);\n    \n    for (let i = 0; i < 10; i++) {\n      const x = 50 + random() * 700;\n      const y = 50 + random() * 500;\n      const item = this.items.create(x, y, 'item');\n      item.setCircle(12); // 设置圆形碰撞体\n    }\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.items,\n      this.collectItem,\n      null,\n      this\n    );\n\n    this.physics.add.overlap(\n      this.player,\n      this.ai,\n      this.hitAI,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0 / 10', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 创建结果文本（初始隐藏）\n    this.resultText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ffffff',\n      align: 'center'\n    });\n    this.resultText.setOrigin(0.5);\n    this.resultText.setVisible(false);\n  }\n\n  update(time, delta) {\n    if (this.gameOver || this.gameWon) {\n      // 游戏结束，停止所有移动\n      this.player.setVelocity(0);\n      this.ai.setVelocity(0);\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // AI 追踪玩家\n    this.physics.moveToObject(this.ai, this.player, 120);\n  }\n\n  collectItem(player, item) {\n    // 移除物品\n    item.destroy();\n\n    // 增加分数\n    this.score++;\n    this.scoreText.setText('Score: ' + this.score + ' / 10');\n\n    // 检查胜利条件\n    if (this.score >= 10) {\n      this.gameWon = true;\n      this.resultText.setText('YOU WIN!');\n      this.resultText.setFill('#00ff00');\n      this.resultText.setVisible(true);\n    }\n  }\n\n  hitAI(player, ai) {\n    if (!this.gameOver) {\n      this.gameOver = true;\n      this.resultText.setText('GAME OVER!\\nAI Caught You!');\n      this.resultText.setFill('#ff0000');\n      this.resultText.setVisible(true);\n    }\n  }\n\n  // 简单的伪随机数生成器（基于种子）\n  seededRandom(seed) {\n    let value = seed;\n    return function() {\n      value = (value * 9301 + 49297) % 233280;\n      return value / 233280;\n    };\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001929_v3", "prompt_id": "seed_001929", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.4}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 程序化关卡生成：用 seed 生成 3x3 的迷宫，显示 seed 以便复现。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Math.RND\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 seed 生成 3x3 程序化迷宫，显示种子值便于复现\nAPI: Phaser.Math.RND, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 使用深度优先搜索（DFS）算法生成 3x3 迷宫结构\n2. 基于 seed 初始化随机数生成器确保可复现\n3. 使用 Graphics 绘制迷宫墙壁和通道\n4. 在屏幕上显示当前 seed 值\n5. 添加玩家角色和目标点，支持键盘控制移动\n6. 实现碰撞检测和胜利条件\n[/PLAN]\n\n```javascript\nclass MazeScene extends Phaser.Scene {\n  constructor() {\n    super('MazeScene');\n    this.seed = Date.now(); // 默认使用时间戳作为种子\n    this.gridSize = 3; // 3x3 迷宫\n    this.cellSize = 150; // 每个单元格大小\n    this.wallThickness = 10;\n    this.maze = [];\n    this.playerX = 0;\n    this.playerY = 0;\n    this.goalX = 2;\n    this.goalY = 2;\n    this.hasWon = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 设置随机种子\n    this.seed = this.game.config.seed || Date.now();\n    Phaser.Math.RND.seed([this.seed]);\n\n    // 生成迷宫\n    this.generateMaze();\n\n    // 绘制迷宫\n    this.drawMaze();\n\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(30, 30, 25);\n    playerGraphics.generateTexture('player', 60, 60);\n    playerGraphics.destroy();\n\n    // 创建目标纹理\n    const goalGraphics = this.add.graphics();\n    goalGraphics.fillStyle(0xffff00, 1);\n    goalGraphics.fillStar(30, 30, 5, 10, 25);\n    goalGraphics.generateTexture('goal', 60, 60);\n    goalGraphics.destroy();\n\n    // 添加玩家\n    const startPos = this.getCellCenter(this.playerX, this.playerY);\n    this.player = this.add.sprite(startPos.x, startPos.y, 'player');\n\n    // 添加目标\n    const goalPos = this.getCellCenter(this.goalX, this.goalY);\n    this.goal = this.add.sprite(goalPos.x, goalPos.y, 'goal');\n\n    // 显示种子值\n    this.seedText = this.add.text(10, 10, `Seed: ${this.seed}`, {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示控制说明\n    this.add.text(10, 50, 'Use Arrow Keys to Move', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 状态文本\n    this.statusText = this.add.text(10, 90, 'Position: (0, 0)', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.moveDelay = 200;\n    this.lastMoveTime = 0;\n  }\n\n  update(time, delta) {\n    if (this.hasWon) return;\n\n    // 控制移动频率\n    if (time - this.lastMoveTime < this.moveDelay) return;\n\n    let moved = false;\n    let newX = this.playerX;\n    let newY = this.playerY;\n\n    if (this.cursors.left.isDown) {\n      newX--;\n      moved = true;\n    } else if (this.cursors.right.isDown) {\n      newX++;\n      moved = true;\n    } else if (this.cursors.up.isDown) {\n      newY--;\n      moved = true;\n    } else if (this.cursors.down.isDown) {\n      newY++;\n      moved = true;\n    }\n\n    if (moved && this.canMove(this.playerX, this.playerY, newX, newY)) {\n      this.playerX = newX;\n      this.playerY = newY;\n      this.lastMoveTime = time;\n\n      // 移动玩家精灵\n      const newPos = this.getCellCenter(this.playerX, this.playerY);\n      this.tweens.add({\n        targets: this.player,\n        x: newPos.x,\n        y: newPos.y,\n        duration: 150,\n        ease: 'Power2'\n      });\n\n      // 更新状态\n      this.statusText.setText(`Position: (${this.playerX}, ${this.playerY})`);\n\n      // 检查是否到达目标\n      if (this.playerX === this.goalX && this.playerY === this.goalY) {\n        this.win();\n      }\n    }\n  }\n\n  generateMaze() {\n    // 初始化迷宫网格，每个单元格有四面墙\n    this.maze = [];\n    for (let y = 0; y < this.gridSize; y++) {\n      this.maze[y] = [];\n      for (let x = 0; x < this.gridSize; x++) {\n        this.maze[y][x] = {\n          visited: false,\n          walls: { top: true, right: true, bottom: true, left: true }\n        };\n      }\n    }\n\n    // 使用深度优先搜索生成迷宫\n    const stack = [];\n    let currentX = 0;\n    let currentY = 0;\n    this.maze[currentY][currentX].visited = true;\n\n    while (true) {\n      const neighbors = this.getUnvisitedNeighbors(currentX, currentY);\n\n      if (neighbors.length > 0) {\n        // 随机选择一个未访问的邻居\n        const next = Phaser.Math.RND.pick(neighbors);\n        stack.push({ x: currentX, y: currentY });\n\n        // 移除当前单元格和邻居之间的墙\n        this.removeWall(currentX, currentY, next.x, next.y);\n\n        // 移动到邻居\n        currentX = next.x;\n        currentY = next.y;\n        this.maze[currentY][currentX].visited = true;\n      } else if (stack.length > 0) {\n        // 回溯\n        const prev = stack.pop();\n        currentX = prev.x;\n        currentY = prev.y;\n      } else {\n        break;\n      }\n    }\n  }\n\n  getUnvisitedNeighbors(x, y) {\n    const neighbors = [];\n    const directions = [\n      { dx: 0, dy: -1 }, // 上\n      { dx: 1, dy: 0 },  // 右\n      { dx: 0, dy: 1 },  // 下\n      { dx: -1, dy: 0 }  // 左\n    ];\n\n    for (const dir of directions) {\n      const nx = x + dir.dx;\n      const ny = y + dir.dy;\n      if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {\n        if (!this.maze[ny][nx].visited) {\n          neighbors.push({ x: nx, y: ny });\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  removeWall(x1, y1, x2, y2) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    if (dx === 1) {\n      this.maze[y1][x1].walls.right = false;\n      this.maze[y2][x2].walls.left = false;\n    } else if (dx === -1) {\n      this.maze[y1][x1].walls.left = false;\n      this.maze[y2][x2].walls.right = false;\n    } else if (dy === 1) {\n      this.maze[y1][x1].walls.bottom = false;\n      this.maze[y2][x2].walls.top = false;\n    } else if (dy === -1) {\n      this.maze[y1][x1].walls.top = false;\n      this.maze[y2][x2].walls.bottom = false;\n    }\n  }\n\n  drawMaze() {\n    const graphics = this.add.graphics();\n    graphics.lineStyle(this.wallThickness, 0x0000ff, 1);\n\n    const offsetX = 100;\n    const offsetY = 150;\n\n    for (let y = 0; y < this.gridSize; y++) {\n      for (let x = 0; x < this.gridSize; x++) {\n        const cell = this.maze[y][x];\n        const px = offsetX + x * this.cellSize;\n        const py = offsetY + y * this.cellSize;\n\n        // 绘制墙壁\n        if (cell.walls.top) {\n          graphics.lineBetween(px, py, px + this.cellSize, py);\n        }\n        if (cell.walls.right) {\n          graphics.lineBetween(px + this.cellSize, py, px + this.cellSize, py + this.cellSize);\n        }\n        if (cell.walls.bottom) {\n          graphics.lineBetween(px, py + this.cellSize, px + this.cellSize, py + this.cellSize);\n        }\n        if (cell.walls.left) {\n          graphics.lineBetween(px, py, px, py + this.cellSize);\n        }\n      }\n    }\n\n    graphics.strokePath();\n  }\n\n  getCellCenter(x, y) {\n    const offsetX = 100;\n    const offsetY = 150;\n    return {\n      x: offsetX + x * this.cellSize + this.cellSize / 2,\n      y: offsetY + y * this.cellSize + this.cellSize / 2\n    };\n  }\n\n  canMove(fromX, fromY, toX, toY) {\n    // 检查边界\n    if (toX < 0 || toX >= this.gridSize || toY < 0 || toY >= this.gridSize) {\n      return false;\n    }\n\n    // 检查墙壁\n    const dx = toX - fromX;\n    const dy = toY - fromY;\n    const cell = this.maze[fromY][fromX];\n\n    if (dx === 1 && cell.walls.right) return false;\n    if (dx === -1 && cell.walls.left) return false;\n    if (dy === 1 && cell.walls.bottom) return false;\n    if (dy === -1 && cell.walls.top) return false;\n\n    return true;\n  }\n\n  win() {\n    this.hasWon = true;\n    this.statusText.setText('YOU WIN! Refresh to play again.');\n    this.statusText.setStyle({ color: '#00ff00', fontSize: '24px' });\n\n    // 添加胜利动画\n    this.tweens.add({\n      targets: this.player,\n      scale: 1.5,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 700,\n  backgroundColor: '#222222',\n  seed: 12345, // 可以修改这个值来生成不同的迷宫\n  scene: MazeScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001636_v1", "prompt_id": "seed_001636", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个圆形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制圆形以 160 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制圆形作为玩家\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位置增量并更新圆形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet player;\nlet keys;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建圆形玩家\n  player = this.add.graphics();\n  player.fillStyle(0x00ff00, 1);\n  player.fillCircle(0, 0, 20); // 半径 20 的圆形\n  \n  // 设置初始位置为屏幕中心\n  player.x = 400;\n  player.y = 300;\n  \n  // 设置 WASD 键\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间增量(秒)\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n  \n  // 限制在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000676_v1", "prompt_id": "seed_000676", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现进度条 UI：从 0 到 12 的橙色进度条，每秒增加 1，满后显示完成。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现从0到12的橙色进度条，每秒增加1，满后显示完成文字\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建进度条背景（灰色矩形）和前景（橙色矩形）使用 Graphics\n2. 创建文本显示当前进度值\n3. 使用 TimerEvent 每秒触发一次，更新进度值\n4. 在 update 中根据进度值重绘橙色进度条\n5. 当进度达到12时停止计时器并显示\"完成\"文字\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量（可验证）\nlet progressValue = 0;\nlet maxProgress = 12;\nlet isCompleted = false;\n\n// UI 元素引用\nlet progressBarBg;\nlet progressBarFill;\nlet progressText;\nlet completeText;\nlet timerEvent;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 进度条尺寸\n  const barWidth = 600;\n  const barHeight = 40;\n  const barX = centerX - barWidth / 2;\n  const barY = centerY - barHeight / 2;\n  \n  // 创建进度条背景（灰色）\n  progressBarBg = this.add.graphics();\n  progressBarBg.fillStyle(0x555555, 1);\n  progressBarBg.fillRect(barX, barY, barWidth, barHeight);\n  \n  // 创建进度条边框\n  progressBarBg.lineStyle(3, 0x333333, 1);\n  progressBarBg.strokeRect(barX, barY, barWidth, barHeight);\n  \n  // 创建进度条填充（橙色）\n  progressBarFill = this.add.graphics();\n  \n  // 创建进度文本\n  progressText = this.add.text(centerX, centerY - 80, '进度: 0 / 12', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  });\n  progressText.setOrigin(0.5);\n  \n  // 创建完成文本（初始隐藏）\n  completeText = this.add.text(centerX, centerY + 80, '✓ 完成！', {\n    fontSize: '48px',\n    fontFamily: 'Arial',\n    color: '#00ff00',\n    fontStyle: 'bold'\n  });\n  completeText.setOrigin(0.5);\n  completeText.setVisible(false);\n  \n  // 创建定时器事件：每秒增加1\n  timerEvent = this.time.addEvent({\n    delay: 1000,                // 1000ms = 1秒\n    callback: onTimerTick,\n    callbackScope: this,\n    loop: true                  // 循环执行\n  });\n  \n  // 初始化进度值\n  progressValue = 0;\n  isCompleted = false;\n  \n  // 绘制初始进度条\n  updateProgressBar(barX, barY, barWidth, barHeight);\n}\n\nfunction onTimerTick() {\n  if (progressValue < maxProgress) {\n    progressValue++;\n    \n    // 检查是否完成\n    if (progressValue >= maxProgress) {\n      isCompleted = true;\n      completeText.setVisible(true);\n      \n      // 停止计时器\n      if (timerEvent) {\n        timerEvent.remove();\n      }\n      \n      // 添加完成动画效果\n      this.tweens.add({\n        targets: completeText,\n        scale: { from: 0.5, to: 1.2 },\n        duration: 500,\n        ease: 'Back.easeOut',\n        yoyo: true,\n        repeat: 0\n      });\n    }\n  }\n}\n\nfunction updateProgressBar(barX, barY, barWidth, barHeight) {\n  // 清除之前的填充\n  progressBarFill.clear();\n  \n  // 计算当前进度百分比\n  const progress = progressValue / maxProgress;\n  const fillWidth = barWidth * progress;\n  \n  // 绘制橙色进度条\n  if (fillWidth > 0) {\n    progressBarFill.fillStyle(0xff8800, 1);\n    progressBarFill.fillRect(barX, barY, fillWidth, barHeight);\n  }\n  \n  // 更新文本\n  progressText.setText(`进度: ${progressValue} / ${maxProgress}`);\n  \n  // 如果完成，改变进度条颜色为绿色\n  if (isCompleted) {\n    progressBarFill.clear();\n    progressBarFill.fillStyle(0x00ff00, 1);\n    progressBarFill.fillRect(barX, barY, barWidth, barHeight);\n  }\n}\n\nfunction update(time, delta) {\n  // 每帧更新进度条显示\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  const barWidth = 600;\n  const barHeight = 40;\n  const barX = centerX - barWidth / 2;\n  const barY = centerY - barHeight / 2;\n  \n  updateProgressBar(barX, barY, barWidth, barHeight);\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001146_v1", "prompt_id": "seed_001146", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现蓝色角色冲刺：按空格键进行短距离冲刺，冲刺速度为 160*3，冷却 1.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现蓝色角色冲刺功能，按空格键触发短距离冲刺，冲刺速度为480，冷却1.5秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建蓝色角色精灵并启用物理引擎\n2. 监听空格键输入事件\n3. 实现冲刺逻辑：检测冷却状态，设置冲刺速度和持续时间\n4. 使用计时器实现冷却机制和冲刺持续时间控制\n5. 添加状态显示（冷却状态、冲刺次数等）\n[/PLAN]\n\n```javascript\nclass DashScene extends Phaser.Scene {\n  constructor() {\n    super('DashScene');\n    this.dashCount = 0; // 冲刺次数统计\n    this.isDashing = false; // 是否正在冲刺\n    this.canDash = true; // 是否可以冲刺（冷却状态）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建蓝色角色纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0000ff, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('playerTex', 32, 32);\n    graphics.destroy();\n\n    // 创建玩家角色\n    this.player = this.physics.add.sprite(400, 300, 'playerTex');\n    this.player.setCollideWorldBounds(true);\n\n    // 基础移动速度\n    this.normalSpeed = 160;\n    this.dashSpeed = this.normalSpeed * 3; // 480\n    this.dashDuration = 200; // 冲刺持续时间（毫秒）\n    this.dashCooldown = 1500; // 冷却时间（毫秒）\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 监听空格键按下事件\n    this.spaceKey.on('down', () => {\n      this.performDash();\n    });\n\n    // 创建状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建冷却指示器\n    this.cooldownIndicator = this.add.graphics();\n    \n    // 创建地面参考线\n    const ground = this.add.graphics();\n    ground.lineStyle(2, 0x00ff00, 1);\n    ground.lineBetween(0, 500, 800, 500);\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  performDash() {\n    // 检查是否可以冲刺\n    if (!this.canDash || this.isDashing) {\n      return;\n    }\n\n    // 获取当前移动方向\n    let dashVelocityX = 0;\n    let dashVelocityY = 0;\n\n    if (this.cursors.left.isDown) {\n      dashVelocityX = -this.dashSpeed;\n    } else if (this.cursors.right.isDown) {\n      dashVelocityX = this.dashSpeed;\n    }\n\n    if (this.cursors.up.isDown) {\n      dashVelocityY = -this.dashSpeed;\n    } else if (this.cursors.down.isDown) {\n      dashVelocityY = this.dashSpeed;\n    }\n\n    // 如果没有按方向键，默认向右冲刺\n    if (dashVelocityX === 0 && dashVelocityY === 0) {\n      dashVelocityX = this.dashSpeed;\n    }\n\n    // 归一化对角线速度\n    if (dashVelocityX !== 0 && dashVelocityY !== 0) {\n      const length = Math.sqrt(dashVelocityX * dashVelocityX + dashVelocityY * dashVelocityY);\n      dashVelocityX = (dashVelocityX / length) * this.dashSpeed;\n      dashVelocityY = (dashVelocityY / length) * this.dashSpeed;\n    }\n\n    // 执行冲刺\n    this.isDashing = true;\n    this.canDash = false;\n    this.dashCount++;\n    \n    // 设置冲刺速度\n    this.player.setVelocity(dashVelocityX, dashVelocityY);\n    \n    // 改变角色颜色表示冲刺状态\n    this.player.setTint(0xffff00);\n\n    // 冲刺持续时间结束\n    this.time.addEvent({\n      delay: this.dashDuration,\n      callback: () => {\n        this.isDashing = false;\n        this.player.clearTint();\n        // 恢复正常移动控制\n      }\n    });\n\n    // 冷却时间结束\n    this.cooldownTimer = this.time.addEvent({\n      delay: this.dashCooldown,\n      callback: () => {\n        this.canDash = true;\n        this.updateStatus();\n      }\n    });\n\n    this.updateStatus();\n  }\n\n  update(time, delta) {\n    // 如果不在冲刺状态，使用正常移动控制\n    if (!this.isDashing) {\n      let velocityX = 0;\n      let velocityY = 0;\n\n      if (this.cursors.left.isDown) {\n        velocityX = -this.normalSpeed;\n      } else if (this.cursors.right.isDown) {\n        velocityX = this.normalSpeed;\n      }\n\n      if (this.cursors.up.isDown) {\n        velocityY = -this.normalSpeed;\n      } else if (this.cursors.down.isDown) {\n        velocityY = this.normalSpeed;\n      }\n\n      this.player.setVelocity(velocityX, velocityY);\n    }\n\n    // 更新状态显示\n    this.updateStatus();\n    \n    // 绘制冷却指示器\n    this.drawCooldownIndicator();\n  }\n\n  updateStatus() {\n    const dashStatus = this.isDashing ? 'DASHING!' : (this.canDash ? 'Ready' : 'Cooling down...');\n    const cooldownProgress = this.canDash ? 100 : \n      Math.floor((1 - this.cooldownTimer.getRemaining() / this.dashCooldown) * 100);\n    \n    this.statusText.setText([\n      `Dash Count: ${this.dashCount}`,\n      `Status: ${dashStatus}`,\n      `Cooldown: ${this.canDash ? 'Ready' : cooldownProgress + '%'}`,\n      `Speed: ${this.isDashing ? this.dashSpeed : this.normalSpeed}`,\n      '',\n      'Controls:',\n      'Arrow Keys - Move',\n      'Space - Dash'\n    ]);\n  }\n\n  drawCooldownIndicator() {\n    this.cooldownIndicator.clear();\n    \n    // 绘制冷却条背景\n    this.cooldownIndicator.fillStyle(0x333333, 1);\n    this.cooldownIndicator.fillRect(10, 150, 200, 20);\n    \n    // 绘制冷却进度\n    if (!this.canDash && this.cooldownTimer) {\n      const progress = 1 - (this.cooldownTimer.getRemaining() / this.dashCooldown);\n      const color = this.isDashing ? 0xffff00 : 0x00ff00;\n      this.cooldownIndicator.fillStyle(color, 1);\n      this.cooldownIndicator.fillRect(10, 150, 200 * progress, 20);\n    } else if (this.canDash) {\n      this.cooldownIndicator.fillStyle(0x00ff00, 1);\n      this.cooldownIndicator.fillRect(10, 150, 200, 20);\n    }\n    \n    // 绘制边框\n    this.cooldownIndicator.lineStyle(2, 0xffffff, 1);\n    this.cooldownIndicator.strokeRect(10, 150, 200, 20);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DashScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001271_v3", "prompt_id": "seed_001271", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个基于 12x12 数组的简单 Tilemap：0 为空，1 为墙可碰撞，玩家用方向键移动且不能穿墙。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tilemaps.Tilemap\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现12x12 Tilemap，玩家用方向键移动且不能穿墙\nAPI: Phaser.Tilemaps.Tilemap, Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建12x12二维数组地图数据（0空地，1墙壁）\n2. 使用Graphics生成墙壁和地板纹理\n3. 通过createBlank创建Tilemap并填充瓦片\n4. 启用Arcade物理系统，设置玩家精灵和瓦片碰撞\n5. 监听方向键输入控制玩家移动\n6. 添加位置状态信号用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerX = 0;\n    this.playerY = 0;\n    this.moveCount = 0; // 状态信号：移动次数\n  }\n\n  preload() {\n    // 创建墙壁纹理\n    const wallGraphics = this.add.graphics();\n    wallGraphics.fillStyle(0x555555, 1);\n    wallGraphics.fillRect(0, 0, 32, 32);\n    wallGraphics.lineStyle(2, 0x333333, 1);\n    wallGraphics.strokeRect(0, 0, 32, 32);\n    wallGraphics.generateTexture('wall', 32, 32);\n    wallGraphics.destroy();\n\n    // 创建地板纹理\n    const floorGraphics = this.add.graphics();\n    floorGraphics.fillStyle(0xcccccc, 1);\n    floorGraphics.fillRect(0, 0, 32, 32);\n    floorGraphics.lineStyle(1, 0xaaaaaa, 0.5);\n    floorGraphics.strokeRect(0, 0, 32, 32);\n    floorGraphics.generateTexture('floor', 32, 32);\n    floorGraphics.destroy();\n\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 12);\n    playerGraphics.lineStyle(2, 0x00aa00, 1);\n    playerGraphics.strokeCircle(16, 16, 12);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n  }\n\n  create() {\n    // 12x12 地图数据（0=空地，1=墙壁）\n    const mapData = [\n      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n      [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],\n      [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n      [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1],\n      [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n      [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1],\n      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n      [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],\n      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    ];\n\n    // 创建空白 Tilemap\n    const map = this.make.tilemap({\n      tileWidth: 32,\n      tileHeight: 32,\n      width: 12,\n      height: 12\n    });\n\n    // 添加 Tileset\n    const tiles = map.addTilesetImage('tiles', null, 32, 32, 0, 0);\n    \n    // 创建图层\n    const layer = map.createBlankLayer('ground', tiles);\n\n    // 填充地图数据\n    for (let y = 0; y < 12; y++) {\n      for (let x = 0; x < 12; x++) {\n        if (mapData[y][x] === 1) {\n          // 墙壁\n          const tile = layer.putTileAt(1, x, y);\n          tile.setCollision(true);\n        } else {\n          // 地板\n          layer.putTileAt(0, x, y);\n        }\n      }\n    }\n\n    // 手动设置瓦片纹理（因为我们使用自定义纹理）\n    layer.forEachTile(tile => {\n      if (tile.index === 1) {\n        // 创建墙壁精灵\n        const wall = this.add.image(tile.pixelX + 16, tile.pixelY + 16, 'wall');\n        wall.setOrigin(0.5);\n      } else if (tile.index === 0) {\n        // 创建地板精灵\n        const floor = this.add.image(tile.pixelX + 16, tile.pixelY + 16, 'floor');\n        floor.setOrigin(0.5);\n      }\n    });\n\n    // 设置碰撞\n    layer.setCollisionByProperty({ collides: true });\n    layer.setCollisionBetween(1, 1);\n\n    // 创建玩家（起始位置在 1,1）\n    this.player = this.physics.add.sprite(1 * 32 + 16, 1 * 32 + 16, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(24, 24);\n    \n    // 更新玩家位置状态\n    this.playerX = 1;\n    this.playerY = 1;\n\n    // 设置物理碰撞\n    this.physics.add.collider(this.player, layer);\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 移动速度\n    this.moveSpeed = 150;\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setScrollFactor(0);\n    this.statusText.setDepth(100);\n\n    this.updateStatusText();\n\n    // 存储地图引用用于碰撞检测\n    this.mapData = mapData;\n    this.tileLayer = layer;\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n\n    let moved = false;\n    let targetX = this.playerX;\n    let targetY = this.playerY;\n\n    // 处理输入\n    if (this.cursors.left.isDown) {\n      targetX = this.playerX - 1;\n      this.player.setVelocityX(-this.moveSpeed);\n      moved = true;\n    } else if (this.cursors.right.isDown) {\n      targetX = this.playerX + 1;\n      this.player.setVelocityX(this.moveSpeed);\n      moved = true;\n    }\n\n    if (this.cursors.up.isDown) {\n      targetY = this.playerY - 1;\n      this.player.setVelocityY(-this.moveSpeed);\n      moved = true;\n    } else if (this.cursors.down.isDown) {\n      targetY = this.playerY + 1;\n      this.player.setVelocityY(this.moveSpeed);\n      moved = true;\n    }\n\n    // 检查目标位置是否可以移动\n    if (moved) {\n      // 确保在地图范围内\n      if (targetX >= 0 && targetX < 12 && targetY >= 0 && targetY < 12) {\n        // 检查是否是墙壁\n        if (this.mapData[targetY][targetX] === 1) {\n          // 是墙壁，停止移动\n          this.player.setVelocity(0);\n        } else {\n          // 检查玩家是否移动到了新的格子\n          const currentGridX = Math.floor(this.player.x / 32);\n          const currentGridY = Math.floor(this.player.y / 32);\n          \n          if (currentGridX !== this.playerX || currentGridY !== this.playerY) {\n            this.playerX = currentGridX;\n            this.playerY = currentGridY;\n            this.moveCount++;\n            this.updateStatusText();\n          }\n        }\n      } else {\n        // 超出边界，停止移动\n        this.player.setVelocity(0);\n      }\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Position: (${this.playerX}, ${this.playerY})\\n` +\n      `Moves: ${this.moveCount}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 384,  // 12 * 32\n  height: 384, // 12 * 32\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000847_v1", "prompt_id": "seed_000847", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Tilemap", "Input", "Physics"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色菱形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色菱形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返，loop 为 -1 实现无限循环，duration 为 4000 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0066ff, 1);\n  \n  // 绘制菱形（四个顶点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 上顶点\n  graphics.lineTo(30, 0);     // 右顶点\n  graphics.lineTo(0, 30);     // 下顶点\n  graphics.lineTo(-30, 0);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 60, 60);\n  graphics.destroy();\n  \n  // 创建菱形精灵，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 4000,            // 持续时间 4 秒\n    yoyo: true,                // 往返模式\n    loop: -1,                  // 无限循环\n    ease: 'Linear'             // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000429_v1", "prompt_id": "seed_000429", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色三角形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色三角形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置绿色填充样式\n4. 计算画布中心点坐标 (400, 300)\n5. 使用 fillTriangle 绘制等边三角形，三个顶点相对中心点分布，边长约 48 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形大小参数（边长约 48 像素）\n  const size = 48;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size / Math.sqrt(3);\n  \n  // 顶点2：左下\n  const x2 = centerX - size / 2;\n  const y2 = centerY + size / (2 * Math.sqrt(3));\n  \n  // 顶点3：右下\n  const x3 = centerX + size / 2;\n  const y3 = centerY + size / (2 * Math.sqrt(3));\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加描边使三角形更清晰\n  graphics.lineStyle(2, 0x00aa00, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000471_v1", "prompt_id": "seed_000471", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现波次敌人生成：每波 8 个灰色敌人，敌人速度 160，消灭完后等 2 秒进入下一波，显示当前波次。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现波次敌人生成系统，每波8个灰色敌人速度160，消灭后等2秒进入下一波并显示波次\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Time.TimerEvent, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 创建玩家角色和敌人组，使用 Graphics 绘制灰色敌人纹理\n2. 实现波次管理系统，每波生成8个敌人，敌人速度设为160\n3. 检测敌人与玩家子弹碰撞，消灭敌人后检查是否清空\n4. 当前波次敌人全部消灭后，使用 TimerEvent 延迟2秒进入下一波\n5. 显示当前波次文本，玩家可发射子弹消灭敌人\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量（可验证）\nlet gameState = {\n  currentWave: 1,\n  enemiesInWave: 8,\n  enemiesKilled: 0,\n  totalKilled: 0,\n  isWaveActive: false,\n  isWaitingForNextWave: false\n};\n\nlet player;\nlet enemies;\nlet bullets;\nlet cursors;\nlet fireKey;\nlet waveText;\nlet statsText;\nlet nextWaveTimer;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00aaff, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建敌人纹理（灰色圆形）\n  const enemyGraphics = this.add.graphics();\n  enemyGraphics.fillStyle(0x888888, 1);\n  enemyGraphics.fillCircle(16, 16, 16);\n  enemyGraphics.generateTexture('enemy', 32, 32);\n  enemyGraphics.destroy();\n\n  // 创建子弹纹理（黄色小圆）\n  const bulletGraphics = this.add.graphics();\n  bulletGraphics.fillStyle(0xffff00, 1);\n  bulletGraphics.fillCircle(4, 4, 4);\n  bulletGraphics.generateTexture('bullet', 8, 8);\n  bulletGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 500, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建敌人组\n  enemies = this.physics.add.group();\n\n  // 创建子弹组\n  bullets = this.physics.add.group({\n    defaultKey: 'bullet',\n    maxSize: 20\n  });\n\n  // 输入控制\n  cursors = this.input.keyboard.createCursorKeys();\n  fireKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 碰撞检测\n  this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);\n\n  // UI 文本\n  waveText = this.add.text(400, 50, 'Wave: 1', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n\n  statsText = this.add.text(16, 16, '', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n\n  // 开始第一波\n  startWave.call(this);\n}\n\nfunction update(time, delta) {\n  // 玩家移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-300);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(300);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-300);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(300);\n  } else {\n    player.setVelocityY(0);\n  }\n\n  // 发射子弹\n  if (Phaser.Input.Keyboard.JustDown(fireKey)) {\n    fireBullet.call(this);\n  }\n\n  // 清理超出边界的子弹\n  bullets.children.entries.forEach(bullet => {\n    if (bullet.active && bullet.y < 0) {\n      bullet.setActive(false);\n      bullet.setVisible(false);\n    }\n  });\n\n  // 更新统计信息\n  updateStats();\n}\n\nfunction startWave() {\n  gameState.isWaveActive = true;\n  gameState.isWaitingForNextWave = false;\n  gameState.enemiesKilled = 0;\n\n  // 生成 8 个敌人\n  for (let i = 0; i < gameState.enemiesInWave; i++) {\n    const x = 100 + i * 80;\n    const y = 100;\n    \n    const enemy = enemies.create(x, y, 'enemy');\n    enemy.setVelocity(\n      Phaser.Math.Between(-160, 160),\n      Phaser.Math.Between(50, 160)\n    );\n    enemy.setBounce(1);\n    enemy.setCollideWorldBounds(true);\n    \n    // 确保敌人速度为 160\n    const speed = 160;\n    const angle = Phaser.Math.Between(0, 360);\n    enemy.setVelocity(\n      Math.cos(angle * Math.PI / 180) * speed,\n      Math.sin(angle * Math.PI / 180) * speed\n    );\n  }\n\n  waveText.setText(`Wave: ${gameState.currentWave}`);\n}\n\nfunction fireBullet() {\n  const bullet = bullets.get(player.x, player.y);\n  \n  if (bullet) {\n    bullet.setActive(true);\n    bullet.setVisible(true);\n    bullet.setVelocityY(-400);\n  }\n}\n\nfunction hitEnemy(bullet, enemy) {\n  // 销毁子弹和敌人\n  bullet.setActive(false);\n  bullet.setVisible(false);\n  enemy.destroy();\n\n  // 更新统计\n  gameState.enemiesKilled++;\n  gameState.totalKilled++;\n\n  // 检查是否清空当前波次\n  if (gameState.enemiesKilled >= gameState.enemiesInWave) {\n    onWaveComplete.call(this);\n  }\n}\n\nfunction onWaveComplete() {\n  gameState.isWaveActive = false;\n  gameState.isWaitingForNextWave = true;\n\n  // 显示波次完成信息\n  const completeText = this.add.text(400, 300, 'Wave Complete!\\nNext wave in 2 seconds...', {\n    fontSize: '28px',\n    fill: '#00ff00',\n    align: 'center',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n\n  // 2 秒后开始下一波\n  nextWaveTimer = this.time.addEvent({\n    delay: 2000,\n    callback: () => {\n      completeText.destroy();\n      gameState.currentWave++;\n      startWave.call(this);\n    },\n    callbackScope: this\n  });\n}\n\nfunction updateStats() {\n  const enemiesRemaining = enemies.countActive(true);\n  statsText.setText(\n    `Wave: ${gameState.currentWave}\\n` +\n    `Enemies: ${enemiesRemaining}/${gameState.enemiesInWave}\\n` +\n    `Killed this wave: ${gameState.enemiesKilled}\\n` +\n    `Total killed: ${gameState.totalKilled}\\n` +\n    `Status: ${gameState.isWaitingForNextWave ? 'Waiting...' : 'Active'}`\n  );\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001914_v3", "prompt_id": "seed_001914", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.4}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 4 秒在随机位置生成一个红色菱形，最多生成 12 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔4秒在随机位置生成红色菱形，最多12个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Scene 配置，初始化游戏画布\n2. 在 create 中使用 Graphics 绘制菱形纹理\n3. 使用 time.addEvent 创建定时器，每4秒触发一次\n4. 在回调函数中生成随机坐标，创建菱形精灵\n5. 计数器达到12个时停止生成\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nlet diamondCount = 0;\nconst MAX_DIAMONDS = 12;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建红色菱形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制菱形路径（中心点为原点）\n  const size = 30;\n  const diamond = new Phaser.Geom.Polygon([\n    0, -size,      // 上顶点\n    size, 0,       // 右顶点\n    0, size,       // 下顶点\n    -size, 0       // 左顶点\n  ]);\n  \n  graphics.fillPoints(diamond.points, true);\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建定时器事件，每4秒生成一个菱形\n  this.time.addEvent({\n    delay: 4000,                    // 4秒间隔\n    callback: spawnDiamond,         // 回调函数\n    callbackScope: this,            // 回调作用域\n    loop: true,                     // 循环执行\n    startAt: 0                      // 立即开始第一次\n  });\n  \n  // 显示提示文本\n  this.add.text(10, 10, 'Diamonds: 0 / 12', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setName('counterText');\n}\n\nfunction spawnDiamond() {\n  // 检查是否已达到最大数量\n  if (diamondCount >= MAX_DIAMONDS) {\n    // 停止所有定时器事件\n    this.time.removeAllEvents();\n    \n    // 更新文本显示完成状态\n    const counterText = this.children.getByName('counterText');\n    if (counterText) {\n      counterText.setText('Diamonds: 12 / 12 (Complete!)');\n    }\n    return;\n  }\n  \n  // 生成随机位置（留出边距避免菱形超出边界）\n  const margin = 40;\n  const randomX = Phaser.Math.Between(margin, 800 - margin);\n  const randomY = Phaser.Math.Between(margin, 600 - margin);\n  \n  // 创建菱形精灵\n  const diamond = this.add.image(randomX, randomY, 'diamond');\n  \n  // 添加简单的缩放动画效果\n  diamond.setScale(0);\n  this.tweens.add({\n    targets: diamond,\n    scale: 1,\n    duration: 300,\n    ease: 'Back.easeOut'\n  });\n  \n  // 增加计数器\n  diamondCount++;\n  \n  // 更新文本显示\n  const counterText = this.children.getByName('counterText');\n  if (counterText) {\n    counterText.setText(`Diamonds: ${diamondCount} / ${MAX_DIAMONDS}`);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000702_v2", "prompt_id": "seed_000702", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现自动加分系统：每 1.5 秒 score +3，字体大小 16，在屏幕右上角显示分数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现自动加分系统，每1.5秒加3分，右上角显示分数\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建 Scene 并初始化 score 变量为 0\n2. 在 create 中使用 this.add.text 在右上角创建分数文本显示\n3. 使用 this.time.addEvent 创建定时器，每 1500ms 触发一次回调\n4. 在定时器回调中 score += 3，并更新文本显示\n5. 设置 loop: true 使定时器循环执行\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet score = 0;\nlet scoreText = null;\nlet timerEvent = null;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 初始化分数\n  score = 0;\n  \n  // 在右上角创建分数文本\n  // 使用 align: 'right' 和 x 坐标为 width - 20 实现右对齐\n  scoreText = this.add.text(\n    this.cameras.main.width - 20, \n    20, \n    'Score: 0', \n    {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      align: 'right'\n    }\n  );\n  \n  // 设置文本的原点为右上角，便于右对齐\n  scoreText.setOrigin(1, 0);\n  \n  // 创建定时器事件：每 1.5 秒（1500ms）触发一次\n  timerEvent = this.time.addEvent({\n    delay: 1500,              // 延迟 1500 毫秒\n    callback: addScore,       // 回调函数\n    callbackScope: this,      // 回调函数的作用域\n    loop: true                // 循环执行\n  });\n  \n  // 添加说明文本\n  this.add.text(\n    this.cameras.main.width / 2,\n    this.cameras.main.height / 2,\n    'Auto Score System\\n\\n+3 points every 1.5 seconds',\n    {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#00ff00',\n      align: 'center'\n    }\n  ).setOrigin(0.5);\n}\n\nfunction addScore() {\n  // 每次调用增加 3 分\n  score += 3;\n  \n  // 更新分数文本显示\n  scoreText.setText('Score: ' + score);\n  \n  // 可选：添加视觉反馈效果\n  scoreText.setScale(1.2);\n  this.tweens.add({\n    targets: scoreText,\n    scale: 1,\n    duration: 200,\n    ease: 'Back.out'\n  });\n}\n\nfunction update(time, delta) {\n  // 不需要每帧更新逻辑，定时器会自动触发\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001051_v1", "prompt_id": "seed_001051", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现15个物体的同步抖动动画，持续 2.5 秒后停止。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现15个物体的同步抖动动画，持续2.5秒后停止\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Group#addMultiple\nSTEPS:\n1. 创建15个使用Graphics绘制的圆形物体，排列成网格布局\n2. 使用Tween系统为所有物体添加同步的抖动动画（x和y方向随机偏移）\n3. 设置动画持续时间为2.5秒，使用yoyo和repeat实现抖动效果\n4. 动画完成后更新状态变量并停止抖动\n[/PLAN]\n\n```javascript\nclass ShakeScene extends Phaser.Scene {\n  constructor() {\n    super('ShakeScene');\n    this.animationComplete = false; // 状态信号：动画是否完成\n    this.activeObjects = 15; // 状态信号：活动物体数量\n    this.shakeIntensity = 10; // 状态信号：抖动强度\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建背景文字提示\n    this.add.text(400, 50, '15个物体同步抖动动画', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 创建状态文本显示\n    this.statusText = this.add.text(400, 550, '状态: 抖动中...', {\n      fontSize: '18px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 存储所有物体\n    this.objects = [];\n\n    // 创建15个物体，排列成3行5列的网格\n    const rows = 3;\n    const cols = 5;\n    const startX = 200;\n    const startY = 150;\n    const spacingX = 100;\n    const spacingY = 100;\n\n    for (let i = 0; i < 15; i++) {\n      const row = Math.floor(i / cols);\n      const col = i % cols;\n      const x = startX + col * spacingX;\n      const y = startY + row * spacingY;\n\n      // 使用Graphics绘制圆形\n      const graphics = this.add.graphics();\n      graphics.fillStyle(0x3498db, 1);\n      graphics.fillCircle(0, 0, 25);\n      graphics.setPosition(x, y);\n\n      // 添加物体编号文字\n      const text = this.add.text(0, 0, (i + 1).toString(), {\n        fontSize: '16px',\n        color: '#ffffff',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n      text.setPosition(x, y);\n\n      // 将graphics和text作为一个容器存储\n      this.objects.push({\n        graphics: graphics,\n        text: text,\n        originalX: x,\n        originalY: y\n      });\n    }\n\n    // 为所有物体创建同步的抖动动画\n    this.createShakeAnimation();\n\n    // 添加重启按钮（动画完成后可用）\n    this.restartButton = this.add.text(400, 500, '点击重启动画', {\n      fontSize: '16px',\n      color: '#888888',\n      backgroundColor: '#333333',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5).setInteractive({ useHandCursor: true });\n\n    this.restartButton.setAlpha(0.5);\n    this.restartButton.on('pointerdown', () => {\n      if (this.animationComplete) {\n        this.restartAnimation();\n      }\n    });\n  }\n\n  createShakeAnimation() {\n    this.animationComplete = false;\n    this.statusText.setText('状态: 抖动中...');\n    this.statusText.setColor('#00ff00');\n    this.restartButton.setAlpha(0.5);\n\n    // 为每个物体创建抖动动画\n    this.objects.forEach((obj, index) => {\n      // X方向抖动\n      this.tweens.add({\n        targets: [obj.graphics, obj.text],\n        x: obj.originalX + Phaser.Math.Between(-this.shakeIntensity, this.shakeIntensity),\n        duration: 50,\n        yoyo: true,\n        repeat: -1, // 无限重复\n        ease: 'Linear'\n      });\n\n      // Y方向抖动\n      this.tweens.add({\n        targets: [obj.graphics, obj.text],\n        y: obj.originalY + Phaser.Math.Between(-this.shakeIntensity, this.shakeIntensity),\n        duration: 50,\n        yoyo: true,\n        repeat: -1, // 无限重复\n        ease: 'Linear'\n      });\n    });\n\n    // 2.5秒后停止所有动画\n    this.time.delayedCall(2500, () => {\n      this.stopShakeAnimation();\n    });\n  }\n\n  stopShakeAnimation() {\n    // 停止所有tweens\n    this.tweens.killAll();\n\n    // 将所有物体恢复到原始位置\n    this.objects.forEach(obj => {\n      obj.graphics.setPosition(obj.originalX, obj.originalY);\n      obj.text.setPosition(obj.originalX, obj.originalY);\n    });\n\n    // 更新状态\n    this.animationComplete = true;\n    this.statusText.setText('状态: 动画已完成');\n    this.statusText.setColor('#ffff00');\n    this.restartButton.setAlpha(1);\n\n    // 添加完成提示闪烁效果\n    this.tweens.add({\n      targets: this.statusText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: 3\n    });\n  }\n\n  restartAnimation() {\n    // 重置状态\n    this.animationComplete = false;\n    this.activeObjects = 15;\n\n    // 停止现有动画\n    this.tweens.killAll();\n\n    // 重新开始抖动动画\n    this.createShakeAnimation();\n  }\n\n  update(time, delta) {\n    // 可以在这里添加实时状态更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: ShakeScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000912_v2", "prompt_id": "seed_000912", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "GameObjects"], "quality_score": 0.41333333333333333}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现简单 Boss 战：青色Boss 有 3 点血量，被子弹（速度 120）命中扣血，血量归零时显示胜利。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现青色Boss战，3点血量，被速度120的子弹击中扣血，血量归零显示胜利\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard\nSTEPS:\n1. 创建物理系统配置，初始化场景\n2. 使用Graphics绘制青色Boss和子弹纹理\n3. 创建玩家飞船（可发射子弹）和Boss精灵\n4. 实现键盘控制（方向键移动，空格发射子弹）\n5. 配置子弹组，设置速度为120\n6. 添加碰撞检测，Boss被击中扣1点血\n7. 显示Boss血量UI，血量归零时显示胜利文本\n[/PLAN]\n\n```javascript\n// Boss战游戏 - 击败青色Boss\nclass BossBattleScene extends Phaser.Scene {\n  constructor() {\n    super('BossBattleScene');\n    this.bossHealth = 3; // Boss血量\n    this.maxBossHealth = 3;\n    this.gameWon = false; // 游戏胜利标志\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建青色Boss纹理\n    const bossGraphics = this.add.graphics();\n    bossGraphics.fillStyle(0x00FFFF, 1); // 青色\n    bossGraphics.fillRect(0, 0, 80, 60);\n    bossGraphics.fillStyle(0x00CCCC, 1);\n    bossGraphics.fillTriangle(10, 60, 40, 80, 70, 60); // 底部装饰\n    bossGraphics.generateTexture('boss', 80, 80);\n    bossGraphics.destroy();\n\n    // 创建玩家飞船纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00FF00, 1); // 绿色\n    playerGraphics.fillTriangle(16, 0, 0, 32, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xFFFF00, 1); // 黄色\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(width / 2, height - 80, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建Boss\n    this.boss = this.physics.add.sprite(width / 2, 100, 'boss');\n    this.boss.setCollideWorldBounds(true);\n    this.boss.body.setVelocityX(100); // Boss左右移动\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 20\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.lastFired = 0;\n\n    // 碰撞检测：子弹击中Boss\n    this.physics.add.overlap(this.bullets, this.boss, this.hitBoss, null, this);\n\n    // Boss碰到边界反向移动\n    this.physics.world.on('worldbounds', (body) => {\n      if (body.gameObject === this.boss) {\n        this.boss.setVelocityX(-this.boss.body.velocity.x);\n      }\n    });\n    this.boss.body.onWorldBounds = true;\n\n    // UI文本 - Boss血量\n    this.healthText = this.add.text(16, 16, `Boss血量: ${this.bossHealth}/${this.maxBossHealth}`, {\n      fontSize: '24px',\n      fill: '#fff',\n      fontFamily: 'Arial'\n    });\n\n    // 胜利文本（初始隐藏）\n    this.victoryText = this.add.text(width / 2, height / 2, '胜利！', {\n      fontSize: '64px',\n      fill: '#FFD700',\n      fontFamily: 'Arial',\n      stroke: '#000',\n      strokeThickness: 6\n    });\n    this.victoryText.setOrigin(0.5);\n    this.victoryText.setVisible(false);\n\n    // 操作提示\n    this.add.text(16, height - 40, '方向键移动 | 空格射击', {\n      fontSize: '18px',\n      fill: '#aaa',\n      fontFamily: 'Arial'\n    });\n\n    // 状态信号（用于验证）\n    this.registry.set('bossHealth', this.bossHealth);\n    this.registry.set('gameWon', this.gameWon);\n  }\n\n  update(time, delta) {\n    if (this.gameWon) {\n      return; // 游戏胜利后停止更新\n    }\n\n    // 玩家移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 发射子弹（每300ms最多一发）\n    if (this.spaceKey.isDown && time > this.lastFired + 300) {\n      this.fireBullet();\n      this.lastFired = time;\n    }\n\n    // 清理飞出屏幕的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active && bullet.y < -10) {\n        bullet.setActive(false);\n        bullet.setVisible(false);\n      }\n    });\n  }\n\n  fireBullet() {\n    // 从对象池获取子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y - 20);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.body.setVelocityY(-120); // 子弹速度120（向上）\n    }\n  }\n\n  hitBoss(bullet, boss) {\n    // 子弹击中Boss\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.body.setVelocity(0, 0);\n\n    // Boss扣血\n    this.bossHealth--;\n    this.healthText.setText(`Boss血量: ${this.bossHealth}/${this.maxBossHealth}`);\n\n    // 更新状态信号\n    this.registry.set('bossHealth', this.bossHealth);\n\n    // Boss受击闪烁效果\n    this.tweens.add({\n      targets: boss,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 1\n    });\n\n    // 检查Boss是否被击败\n    if (this.bossHealth <= 0) {\n      this.defeatBoss();\n    }\n  }\n\n  defeatBoss() {\n    this.gameWon = true;\n    this.registry.set('gameWon', this.gameWon);\n\n    // Boss爆炸效果\n    this.tweens.add({\n      targets: this.boss,\n      alpha: 0,\n      scale: 2,\n      angle: 360,\n      duration: 500,\n      onComplete: () => {\n        this.boss.destroy();\n      }\n    });\n\n    // 显示胜利文本\n    this.victoryText.setVisible(true);\n    this.tweens.add({\n      targets: this.victoryText,\n      scale: { from: 0, to: 1.2 },\n      duration: 500,\n      ease: 'Back.easeOut'\n    });\n\n    // 停止玩家移动\n    this.player.setVelocity(0, 0);\n\n    // 清除所有子弹\n    this.bullets.clear(true, true);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: BossBattleScene\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001793_v2", "prompt_id": "seed_001793", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色菱形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色菱形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环12次\n3. 每次循环创建一个 Graphics 对象\n4. 使用 beginPath 和 moveTo/lineTo 绘制菱形路径（4个顶点）\n5. 使用 Phaser.Math.Between 生成随机 x、y 坐标\n6. 填充绿色并完成绘制\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const diamondSize = 80; // 菱形大小\n  const halfSize = diamondSize / 2; // 半径\n  \n  // 绘制12个随机位置的绿色菱形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置，确保菱形完全在画布内\n    const x = Phaser.Math.Between(halfSize, 800 - halfSize);\n    const y = Phaser.Math.Between(halfSize, 600 - halfSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 开始绘制菱形路径\n    graphics.beginPath();\n    \n    // 菱形的四个顶点（上、右、下、左）\n    graphics.moveTo(x, y - halfSize);           // 上顶点\n    graphics.lineTo(x + halfSize, y);           // 右顶点\n    graphics.lineTo(x, y + halfSize);           // 下顶点\n    graphics.lineTo(x - halfSize, y);           // 左顶点\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000052_v2", "prompt_id": "seed_000052", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.4025}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现蓝色技能冷却：按空格键释放技能，冷却 1.5 秒内不可再次使用，显示冷却进度。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现空格键释放技能，1.5秒冷却时间，显示冷却进度条\nAPI: Phaser.Input.Keyboard.Key, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建技能按钮的视觉表示（蓝色圆形）和冷却进度条\n2. 监听空格键输入事件\n3. 释放技能时触发视觉效果，启动冷却计时器\n4. 在冷却期间禁用技能使用，实时更新进度条\n5. 冷却结束后重置状态，允许再次使用\n[/PLAN]\n\n```javascript\nclass SkillCooldownScene extends Phaser.Scene {\n  constructor() {\n    super('SkillCooldownScene');\n    this.skillReady = true;\n    this.cooldownDuration = 1500; // 1.5秒\n    this.cooldownProgress = 0; // 0-1之间，用于验证\n    this.skillUsedCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    const centerX = this.cameras.main.width / 2;\n    const centerY = this.cameras.main.height / 2;\n\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x222222, 1);\n    bg.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);\n\n    // 创建标题文本\n    this.add.text(centerX, 50, 'Skill Cooldown Demo', {\n      fontSize: '32px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(centerX, 100, 'Press SPACE to use skill', {\n      fontSize: '20px',\n      color: '#aaaaaa'\n    }).setOrigin(0.5);\n\n    // 创建技能图标容器\n    const skillIconY = centerY - 50;\n\n    // 技能图标背景（深蓝色圆形）\n    this.skillIconBg = this.add.graphics();\n    this.skillIconBg.fillStyle(0x1a3a5a, 1);\n    this.skillIconBg.fillCircle(centerX, skillIconY, 60);\n\n    // 技能图标（亮蓝色圆形）\n    this.skillIcon = this.add.graphics();\n    this.updateSkillIcon(centerX, skillIconY, true);\n\n    // 冷却遮罩（灰色半透明圆形，初始不可见）\n    this.cooldownMask = this.add.graphics();\n    this.cooldownMask.setVisible(false);\n\n    // 冷却进度条背景\n    const progressBarY = centerY + 80;\n    const progressBarWidth = 300;\n    const progressBarHeight = 30;\n    \n    this.progressBarBg = this.add.graphics();\n    this.progressBarBg.fillStyle(0x333333, 1);\n    this.progressBarBg.fillRoundedRect(\n      centerX - progressBarWidth / 2,\n      progressBarY,\n      progressBarWidth,\n      progressBarHeight,\n      5\n    );\n\n    // 冷却进度条（蓝色填充）\n    this.progressBar = this.add.graphics();\n\n    // 进度条边框\n    const border = this.add.graphics();\n    border.lineStyle(2, 0x666666, 1);\n    border.strokeRoundedRect(\n      centerX - progressBarWidth / 2,\n      progressBarY,\n      progressBarWidth,\n      progressBarHeight,\n      5\n    );\n\n    // 状态文本\n    this.statusText = this.add.text(centerX, progressBarY - 30, 'Ready', {\n      fontSize: '24px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 冷却时间显示文本\n    this.cooldownText = this.add.text(centerX, progressBarY + 15, '', {\n      fontSize: '18px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 使用次数显示\n    this.usageText = this.add.text(centerX, this.cameras.main.height - 50, \n      `Skills Used: ${this.skillUsedCount}`, {\n      fontSize: '20px',\n      color: '#ffff00'\n    }).setOrigin(0.5);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    // 存储进度条位置信息\n    this.progressBarX = centerX - progressBarWidth / 2;\n    this.progressBarY = progressBarY;\n    this.progressBarWidth = progressBarWidth;\n    this.progressBarHeight = progressBarHeight;\n    this.skillIconX = centerX;\n    this.skillIconY = skillIconY;\n  }\n\n  update(time, delta) {\n    // 检测空格键按下\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      this.tryUseSkill();\n    }\n  }\n\n  tryUseSkill() {\n    if (!this.skillReady) {\n      // 技能冷却中，显示反馈\n      this.cameras.main.shake(100, 0.002);\n      return;\n    }\n\n    // 使用技能\n    this.useSkill();\n  }\n\n  useSkill() {\n    this.skillReady = false;\n    this.skillUsedCount++;\n    \n    // 更新使用次数显示\n    this.usageText.setText(`Skills Used: ${this.skillUsedCount}`);\n\n    // 更新技能图标为暗淡状态\n    this.updateSkillIcon(this.skillIconX, this.skillIconY, false);\n\n    // 显示冷却遮罩\n    this.cooldownMask.setVisible(true);\n\n    // 更新状态文本\n    this.statusText.setText('Cooling Down');\n    this.statusText.setColor('#ff0000');\n\n    // 技能释放特效（蓝色波纹扩散）\n    this.createSkillEffect();\n\n    // 启动冷却计时器\n    this.startCooldown();\n  }\n\n  createSkillEffect() {\n    const effect = this.add.graphics();\n    const centerX = this.skillIconX;\n    const centerY = this.skillIconY;\n\n    // 创建扩散动画\n    this.tweens.add({\n      targets: { radius: 0, alpha: 1 },\n      radius: 100,\n      alpha: 0,\n      duration: 500,\n      ease: 'Power2',\n      onUpdate: (tween) => {\n        const value = tween.getValue();\n        effect.clear();\n        effect.lineStyle(4, 0x00aaff, value.alpha);\n        effect.strokeCircle(centerX, centerY, value.radius);\n      },\n      onComplete: () => {\n        effect.destroy();\n      }\n    });\n\n    // 技能图标闪烁效果\n    this.tweens.add({\n      targets: this.skillIcon,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 2\n    });\n  }\n\n  startCooldown() {\n    const startTime = this.time.now;\n    \n    // 创建冷却计时器\n    this.cooldownTimer = this.time.addEvent({\n      delay: this.cooldownDuration,\n      callback: this.onCooldownComplete,\n      callbackScope: this,\n      loop: false\n    });\n\n    // 更新进度的循环\n    this.cooldownUpdateEvent = this.time.addEvent({\n      delay: 16, // 约60fps\n      callback: () => {\n        const elapsed = this.time.now - startTime;\n        const progress = Math.min(elapsed / this.cooldownDuration, 1);\n        this.cooldownProgress = progress;\n        this.updateCooldownDisplay(progress);\n      },\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  updateCooldownDisplay(progress) {\n    // 更新进度条\n    this.progressBar.clear();\n    this.progressBar.fillStyle(0x0088ff, 1);\n    const fillWidth = this.progressBarWidth * progress;\n    this.progressBar.fillRoundedRect(\n      this.progressBarX,\n      this.progressBarY,\n      fillWidth,\n      this.progressBarHeight,\n      5\n    );\n\n    // 更新冷却遮罩（使用扇形表示剩余冷却）\n    const remainingProgress = 1 - progress;\n    this.cooldownMask.clear();\n    this.cooldownMask.fillStyle(0x000000, 0.6);\n    \n    if (remainingProgress > 0) {\n      this.cooldownMask.slice(\n        this.skillIconX,\n        this.skillIconY,\n        60,\n        Phaser.Math.DegToRad(-90),\n        Phaser.Math.DegToRad(-90 + 360 * remainingProgress),\n        false\n      );\n      this.cooldownMask.fillPath();\n    }\n\n    // 更新冷却时间文本\n    const remainingTime = ((1 - progress) * this.cooldownDuration / 1000).toFixed(1);\n    this.cooldownText.setText(`${remainingTime}s`);\n  }\n\n  onCooldownComplete() {\n    this.skillReady = true;\n    this.cooldownProgress = 1;\n\n    // 停止更新循环\n    if (this.cooldownUpdateEvent) {\n      this.cooldownUpdateEvent.remove();\n    }\n\n    // 更新最终进度条（满）\n    this.progressBar.clear();\n    this.progressBar.fillStyle(0x00ff00, 1);\n    this.progressBar.fillRoundedRect(\n      this.progressBarX,\n      this.progressBarY,\n      this.progressBarWidth,\n      this.progressBarHeight,\n      5\n    );\n\n    // 隐藏冷却遮罩\n    this.cooldownMask.setVisible(false);\n    this.cooldownMask.clear();\n\n    // 更新状态文本\n    this.statusText.setText('Ready');\n    this.statusText.setColor('#00ff00');\n    this.cooldownText.setText('');\n\n    // 恢复技能图标亮度\n    this.updateSkillIcon(this.skillIconX, this.skillIconY, true);\n\n    // 技能就绪提示动画\n    this.tweens.add({\n      targets: this.skillIcon,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 200,\n      yoyo: true,\n      ease: 'Back.easeOut'\n    });\n\n    // 清空进度条（延迟500ms）\n    this.time.delayedCall(500, () => {\n      this.progressBar.clear();\n    });\n  }\n\n  updateSkillIcon(x, y, isReady) {\n    this.skillIcon.clear();\n    if (isReady) {\n      this.skillIcon.fillStyle(0x00aaff, 1);\n    } else {\n      this.skillIcon.fillStyle(0x004466, 1);\n    }\n    this.skillIcon.fillCircle(x, y, 50);\n    \n    // 添加内部装饰\n    this.skillIcon.fillStyle(0xffffff, isReady ? 0.8 : 0.3);\n    this.skillIcon.fillCircle(x, y, 20);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: SkillCooldownScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001901_v2", "prompt_id": "seed_001901", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按空格键切换重力方向（向上/向下），重力大小 600，玩家根据重力方向移动，显示当前重力方向。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 按空格键切换重力方向（向上/向下），玩家随重力移动并显示当前方向\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Physics.Arcade.World.gravity\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置，初始重力向下 600\n2. 在 create 中创建玩家精灵（使用 Graphics 生成纹理）和地面/天花板\n3. 监听空格键输入，切换世界重力方向（gravity.y 在 600 和 -600 之间切换）\n4. 添加文本显示当前重力方向状态\n5. 在 update 中检测玩家是否触碰边界，防止飞出屏幕\n[/PLAN]\n\n```javascript\nclass GravityFlipScene extends Phaser.Scene {\n  constructor() {\n    super('GravityFlipScene');\n    this.gravityDirection = 'DOWN'; // 状态信号：当前重力方向\n    this.flipCount = 0; // 状态信号：切换次数\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, width, 40);\n    groundGraphics.generateTexture('ground', width, 40);\n    groundGraphics.destroy();\n\n    // 创建天花板纹理\n    const ceilingGraphics = this.add.graphics();\n    ceilingGraphics.fillStyle(0x4169e1, 1);\n    ceilingGraphics.fillRect(0, 0, width, 40);\n    ceilingGraphics.generateTexture('ceiling', width, 40);\n    ceilingGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player');\n    this.player.setBounce(0.2);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面（底部）\n    this.ground = this.physics.add.staticSprite(width / 2, height - 20, 'ground');\n    this.ground.refreshBody();\n\n    // 创建天花板（顶部）\n    this.ceiling = this.physics.add.staticSprite(width / 2, 20, 'ceiling');\n    this.ceiling.refreshBody();\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground);\n    this.physics.add.collider(this.player, this.ceiling);\n\n    // 设置初始重力（向下）\n    this.physics.world.gravity.y = 600;\n\n    // 创建空格键监听\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示重力方向文本\n    this.gravityText = this.add.text(20, 20, '', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.gravityText.setDepth(100);\n\n    // 显示切换次数文本\n    this.flipCountText = this.add.text(20, 60, '', {\n      fontSize: '18px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.flipCountText.setDepth(100);\n\n    // 显示说明文本\n    this.add.text(width / 2, height - 60, 'Press SPACE to flip gravity', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#333333',\n      padding: { x: 15, y: 8 }\n    }).setOrigin(0.5);\n\n    // 更新显示\n    this.updateGravityDisplay();\n\n    // 空格键按下事件（使用 JustDown 避免连续触发）\n    this.spaceKey.on('down', () => {\n      this.flipGravity();\n    });\n  }\n\n  flipGravity() {\n    // 切换重力方向\n    if (this.gravityDirection === 'DOWN') {\n      this.physics.world.gravity.y = -600;\n      this.gravityDirection = 'UP';\n    } else {\n      this.physics.world.gravity.y = 600;\n      this.gravityDirection = 'DOWN';\n    }\n\n    // 增加切换计数\n    this.flipCount++;\n\n    // 更新显示\n    this.updateGravityDisplay();\n\n    // 视觉反馈：玩家闪烁\n    this.tweens.add({\n      targets: this.player,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 1\n    });\n  }\n\n  updateGravityDisplay() {\n    const arrow = this.gravityDirection === 'DOWN' ? '↓' : '↑';\n    const color = this.gravityDirection === 'DOWN' ? '#ff0000' : '#00ffff';\n    \n    this.gravityText.setText(`Gravity: ${arrow} ${this.gravityDirection}`);\n    this.gravityText.setColor(color);\n    \n    this.flipCountText.setText(`Flips: ${this.flipCount}`);\n  }\n\n  update(time, delta) {\n    // 检测空格键状态（备用方式，已使用事件监听）\n    // 这里可以添加额外的游戏逻辑\n\n    // 限制玩家速度，防止过快\n    const maxVelocity = 800;\n    if (Math.abs(this.player.body.velocity.y) > maxVelocity) {\n      this.player.body.velocity.y = Math.sign(this.player.body.velocity.y) * maxVelocity;\n    }\n\n    // 可选：添加水平移动控制\n    const cursors = this.input.keyboard.createCursorKeys();\n    if (cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GravityFlipScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001875_v2", "prompt_id": "seed_001875", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 设置相机边界：创建一个 1600x1200 的大场景，限制相机只能在场景范围内移动。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera", "output": "[PLAN]\nREQ: 创建1600x1200大场景，设置相机边界限制相机移动范围\nAPI: setBounds, setBackgroundColor, fillRect, createCursorKeys, scrollX, scrollY\nSTEPS:\n1. 创建1600x1200的场景配置，视口设置为800x600\n2. 使用Graphics绘制场景背景网格，标识场景范围\n3. 使用camera.setBounds设置相机边界为场景大小\n4. 添加键盘控制实现相机移动，验证边界限制\n5. 添加相机位置显示文本，实时显示相机坐标\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建大场景背景 (1600x1200)\n  const graphics = this.add.graphics();\n  \n  // 绘制场景背景 - 使用网格表示整个场景\n  graphics.fillStyle(0x1a1a1a, 1);\n  graphics.fillRect(0, 0, 1600, 1200);\n  \n  // 绘制网格线，帮助识别场景范围\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 垂直线\n  for (let x = 0; x <= 1600; x += 100) {\n    graphics.lineBetween(x, 0, x, 1200);\n  }\n  \n  // 水平线\n  for (let y = 0; y <= 1200; y += 100) {\n    graphics.lineBetween(0, y, 1600, y);\n  }\n  \n  // 绘制场景边界标识\n  graphics.lineStyle(4, 0x00ff00, 1);\n  graphics.strokeRect(2, 2, 1596, 1196);\n  \n  // 在四个角添加标记\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(50, 50, 20);\n  graphics.fillCircle(1550, 50, 20);\n  graphics.fillCircle(50, 1150, 20);\n  graphics.fillCircle(1550, 1150, 20);\n  \n  // 添加坐标文本标识\n  const style = { fontSize: '16px', fill: '#00ff00', backgroundColor: '#000000' };\n  this.add.text(60, 40, '(0, 0)', style);\n  this.add.text(1460, 40, '(1600, 0)', style);\n  this.add.text(60, 1140, '(0, 1200)', style);\n  this.add.text(1410, 1140, '(1600, 1200)', style);\n  \n  // 在中心添加标识\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(800, 600, 30);\n  this.add.text(740, 590, 'CENTER\\n(800, 600)', {\n    fontSize: '18px',\n    fill: '#ff0000',\n    backgroundColor: '#000000',\n    align: 'center'\n  });\n  \n  // **关键：设置相机边界**\n  // 限制相机只能在 1600x1200 的场景范围内移动\n  this.cameras.main.setBounds(0, 0, 1600, 1200);\n  \n  // 设置世界边界（与相机边界一致）\n  this.physics.world.setBounds(0, 0, 1600, 1200);\n  \n  // 创建键盘控制\n  this.cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加WASD控制\n  this.keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 创建固定在屏幕上的UI文本（不随相机移动）\n  this.cameraInfo = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.cameraInfo.setScrollFactor(0); // 固定在屏幕上\n  this.cameraInfo.setDepth(1000); // 确保在最上层\n  \n  // 添加操作说明\n  this.instructions = this.add.text(10, 60, \n    'Controls:\\n' +\n    '← → ↑ ↓ or WASD: Move Camera\\n' +\n    'Camera is bounded to 1600x1200 scene',\n    {\n      fontSize: '14px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }\n  );\n  this.instructions.setScrollFactor(0);\n  this.instructions.setDepth(1000);\n  \n  // 相机移动速度\n  this.cameraSpeed = 5;\n}\n\nfunction update(time, delta) {\n  const camera = this.cameras.main;\n  \n  // 使用方向键或WASD控制相机移动\n  if (this.cursors.left.isDown || this.keys.a.isDown) {\n    camera.scrollX -= this.cameraSpeed;\n  }\n  if (this.cursors.right.isDown || this.keys.d.isDown) {\n    camera.scrollX += this.cameraSpeed;\n  }\n  if (this.cursors.up.isDown || this.keys.w.isDown) {\n    camera.scrollY -= this.cameraSpeed;\n  }\n  if (this.cursors.down.isDown || this.keys.s.isDown) {\n    camera.scrollY += this.cameraSpeed;\n  }\n  \n  // 更新相机信息显示\n  const bounds = camera.getBounds();\n  this.cameraInfo.setText(\n    `Camera Position: (${Math.round(camera.scrollX)}, ${Math.round(camera.scrollY)})\\n` +\n    `Camera View: ${Math.round(bounds.x)}, ${Math.round(bounds.y)} to ` +\n    `${Math.round(bounds.right)}, ${Math.round(bounds.bottom)}\\n` +\n    `World Bounds: 0, 0 to 1600, 1200`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000014_v2", "prompt_id": "seed_000014", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色椭圆以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Ellipse, Phaser.Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制黄色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度\n4. 设置世界边界碰撞和反弹系数\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet ellipse;\nlet velocity = { x: 200, y: 200 };\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillEllipse(50, 40, 100, 80); // 绘制椭圆（中心点，宽度，高度）\n  graphics.generateTexture('ellipseTex', 100, 80);\n  graphics.destroy();\n\n  // 创建物理精灵\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置初始速度\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 设置世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // Arcade 物理系统的 setCollideWorldBounds 和 setBounce \n  // 会自动处理边界碰撞和反弹，无需手动编写逻辑\n  \n  // 如果需要确保速度保持恒定（避免浮点误差累积）\n  const currentVelocity = ellipse.body.velocity;\n  const speed = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);\n  \n  // 如果速度有偏差，重新标准化\n  if (Math.abs(speed - 282.84) > 1) { // 200*sqrt(2) ≈ 282.84\n    const angle = Math.atan2(currentVelocity.y, currentVelocity.x);\n    ellipse.setVelocity(\n      Math.cos(angle) * 200 * Math.SQRT2,\n      Math.sin(angle) * 200 * Math.SQRT2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000079_v3", "prompt_id": "seed_000079", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 多技能系统：15 个技能各有不同冷却时间（2.5 秒基准递增），显示所有技能冷却状态。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现15个技能系统，每个技能有递增冷却时间（2.5秒基准），显示所有技能冷却状态和进度\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建15个技能对象，每个技能冷却时间为2.5 * (index + 1)秒\n2. 使用Graphics绘制技能图标（3x5网格布局）和冷却进度条\n3. 监听键盘输入（1-9, Q-F键）触发对应技能\n4. 使用TimerEvent管理每个技能的冷却计时\n5. 在update中更新所有技能的冷却进度显示\n6. 显示全局状态（技能使用次数统计）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量（可验证）\nlet totalSkillsUsed = 0;\nlet skillUsageCount = Array(15).fill(0);\n\n// 技能系统类\nclass Skill {\n  constructor(scene, id, x, y, baseCooldown) {\n    this.scene = scene;\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.size = 45;\n    this.cooldown = baseCooldown * (id + 1); // 递增冷却时间\n    this.remainingTime = 0;\n    this.isOnCooldown = false;\n    this.timer = null;\n    \n    // 创建图形元素\n    this.createGraphics();\n  }\n  \n  createGraphics() {\n    // 技能背景框\n    this.bgGraphics = this.scene.add.graphics();\n    this.bgGraphics.lineStyle(2, 0x00ff00, 1);\n    this.bgGraphics.strokeRect(this.x, this.y, this.size, this.size);\n    \n    // 技能图标（使用不同颜色区分）\n    this.iconGraphics = this.scene.add.graphics();\n    const hue = (this.id * 24) % 360;\n    const color = Phaser.Display.Color.HSVToRGB(hue / 360, 0.8, 0.9);\n    const hexColor = Phaser.Display.Color.GetColor(color.r, color.g, color.b);\n    this.iconGraphics.fillStyle(hexColor, 1);\n    this.iconGraphics.fillCircle(\n      this.x + this.size / 2,\n      this.y + this.size / 2,\n      this.size / 3\n    );\n    \n    // 冷却遮罩\n    this.cooldownGraphics = this.scene.add.graphics();\n    \n    // 技能ID文本\n    this.idText = this.scene.add.text(\n      this.x + this.size / 2,\n      this.y + this.size / 2,\n      (this.id + 1).toString(),\n      {\n        fontSize: '16px',\n        color: '#ffffff',\n        fontStyle: 'bold'\n      }\n    ).setOrigin(0.5);\n    \n    // 冷却时间文本\n    this.cooldownText = this.scene.add.text(\n      this.x + this.size / 2,\n      this.y + this.size + 5,\n      `${this.cooldown.toFixed(1)}s`,\n      {\n        fontSize: '10px',\n        color: '#aaaaaa'\n      }\n    ).setOrigin(0.5, 0);\n    \n    // 剩余时间文本\n    this.remainingText = this.scene.add.text(\n      this.x + this.size / 2,\n      this.y + this.size / 2 + 15,\n      '',\n      {\n        fontSize: '12px',\n        color: '#ff0000',\n        fontStyle: 'bold'\n      }\n    ).setOrigin(0.5);\n  }\n  \n  use() {\n    if (this.isOnCooldown) {\n      return false;\n    }\n    \n    this.isOnCooldown = true;\n    this.remainingTime = this.cooldown;\n    \n    // 增加使用统计\n    totalSkillsUsed++;\n    skillUsageCount[this.id]++;\n    \n    // 启动冷却计时器\n    if (this.timer) {\n      this.timer.destroy();\n    }\n    \n    this.timer = this.scene.time.addEvent({\n      delay: this.cooldown * 1000,\n      callback: () => {\n        this.isOnCooldown = false;\n        this.remainingTime = 0;\n        this.updateDisplay();\n      }\n    });\n    \n    this.updateDisplay();\n    return true;\n  }\n  \n  updateDisplay() {\n    // 清除冷却遮罩\n    this.cooldownGraphics.clear();\n    \n    if (this.isOnCooldown) {\n      // 计算冷却进度\n      const progress = this.remainingTime / this.cooldown;\n      \n      // 绘制半透明黑色遮罩\n      this.cooldownGraphics.fillStyle(0x000000, 0.7);\n      this.cooldownGraphics.fillRect(\n        this.x,\n        this.y,\n        this.size,\n        this.size * progress\n      );\n      \n      // 显示剩余时间\n      this.remainingText.setText(this.remainingTime.toFixed(1));\n      this.remainingText.setVisible(true);\n      \n      // 边框变红\n      this.bgGraphics.clear();\n      this.bgGraphics.lineStyle(2, 0xff0000, 1);\n      this.bgGraphics.strokeRect(this.x, this.y, this.size, this.size);\n    } else {\n      this.remainingText.setVisible(false);\n      \n      // 边框变绿\n      this.bgGraphics.clear();\n      this.bgGraphics.lineStyle(2, 0x00ff00, 1);\n      this.bgGraphics.strokeRect(this.x, this.y, this.size, this.size);\n    }\n  }\n  \n  update(delta) {\n    if (this.isOnCooldown) {\n      this.remainingTime = Math.max(0, this.remainingTime - delta / 1000);\n      this.updateDisplay();\n    }\n  }\n}\n\nlet skills = [];\nlet statusText;\nlet instructionText;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 标题\n  this.add.text(400, 20, 'Multi-Skill System (15 Skills)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n  \n  // 创建15个技能（3x5网格布局）\n  const startX = 150;\n  const startY = 80;\n  const gapX = 80;\n  const gapY = 90;\n  const cols = 5;\n  \n  for (let i = 0; i < 15; i++) {\n    const col = i % cols;\n    const row = Math.floor(i / cols);\n    const x = startX + col * gapX;\n    const y = startY + row * gapY;\n    \n    const skill = new Skill(this, i, x, y, 2.5);\n    skills.push(skill);\n  }\n  \n  // 键位映射说明\n  instructionText = this.add.text(400, 400, \n    'Press Keys:\\n' +\n    '1-5: Skills 1-5\\n' +\n    '6-9,0: Skills 6-10\\n' +\n    'Q-E: Skills 11-13\\n' +\n    'R-T: Skills 14-15',\n    {\n      fontSize: '14px',\n      color: '#cccccc',\n      align: 'center',\n      lineSpacing: 5\n    }\n  ).setOrigin(0.5);\n  \n  // 状态显示\n  statusText = this.add.text(400, 520, '', {\n    fontSize: '16px',\n    color: '#ffff00',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n  \n  // 详细统计\n  this.detailText = this.add.text(400, 550, '', {\n    fontSize: '12px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n  \n  // 键盘输入映射\n  const keyMappings = {\n    'ONE': 0, 'TWO': 1, 'THREE': 2, 'FOUR': 3, 'FIVE': 4,\n    'SIX': 5, 'SEVEN': 6, 'EIGHT': 7, 'NINE': 8, 'ZERO': 9,\n    'Q': 10, 'W': 11, 'E': 12, 'R': 13, 'T': 14\n  };\n  \n  // 绑定所有按键\n  Object.keys(keyMappings).forEach(keyName => {\n    const key = this.input.keyboard.addKey(Phaser.Input.Keyboard.Keys[keyName]);\n    key.on('down', () => {\n      const skillIndex = keyMappings[keyName];\n      if (skills[skillIndex]) {\n        const success = skills[skillIndex].use();\n        if (success) {\n          // 技能使用成功的视觉反馈\n          this.cameras.main.shake(100, 0.002);\n        }\n      }\n    });\n  });\n  \n  // 更新状态显示\n  updateStatus.call(this);\n}\n\nfunction update(time, delta) {\n  // 更新所有技能\n  skills.forEach(skill => {\n    skill.update(delta);\n  });\n  \n  // 更新状态显示\n  updateStatus.call(this);\n}\n\nfunction updateStatus() {\n  // 计算冷却中的技能数量\n  const onCooldown = skills.filter(s => s.isOnCooldown).length;\n  const available = 15 - onCooldown;\n  \n  statusText.setText(\n    `Total Skills Used: ${totalSkillsUsed} | Available: ${available}/15 | On Cooldown: ${onCooldown}`\n  );\n  \n  // 显示使用次数最多的技能\n  const maxUsage = Math.max(...skillUsageCount);\n  if (maxUsage > 0) {\n    const mostUsedSkills = skillUsageCount\n      .map((count, index) => ({ id: index + 1, count }))\n      .filter(s => s.count === maxUsage)\n      .map(s => `#${s.id}`)\n      .join(', ');\n    \n    this.detailText.setText(\n      `Most Used Skill(s): ${mostUsedSkills} (${maxUsage} times)`\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001981_v1", "prompt_id": "seed_001981", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 多技能系统：20 个技能各有不同冷却时间（4 秒基准递增），显示所有技能冷却状态。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现 20 个技能系统，每个技能有递增冷却时间（4秒基准），显示所有技能冷却状态和可用性\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建 20 个技能对象，每个技能冷却时间为 4000 + (index * 2000) ms\n2. 使用 Graphics 绘制技能图标（4x5 网格布局），用颜色和进度条表示冷却状态\n3. 监听键盘输入（1-9, 0, Q-J）触发对应技能\n4. 使用 TimerEvent 管理每个技能的冷却计时\n5. 在 update 中实时更新所有技能的冷却进度显示\n[/PLAN]\n\n```javascript\nclass SkillSystemScene extends Phaser.Scene {\n  constructor() {\n    super('SkillSystemScene');\n    this.skills = [];\n    this.skillGraphics = [];\n    this.cooldownTexts = [];\n    this.totalSkillsUsed = 0; // 可验证状态\n  }\n\n  preload() {\n    // 不需要外部资源\n  }\n\n  create() {\n    // 初始化 20 个技能\n    const skillKeys = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0',\n                       'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'];\n    \n    for (let i = 0; i < 20; i++) {\n      this.skills.push({\n        id: i,\n        name: `Skill ${i + 1}`,\n        key: skillKeys[i],\n        cooldown: 4000 + (i * 2000), // 基准 4 秒，每个技能递增 2 秒\n        remainingTime: 0,\n        isReady: true,\n        lastUsedTime: 0\n      });\n    }\n\n    // 绘制技能网格（4 列 x 5 行）\n    const cols = 4;\n    const rows = 5;\n    const skillSize = 80;\n    const padding = 20;\n    const startX = 100;\n    const startY = 80;\n\n    for (let i = 0; i < 20; i++) {\n      const col = i % cols;\n      const row = Math.floor(i / cols);\n      const x = startX + col * (skillSize + padding);\n      const y = startY + row * (skillSize + padding);\n\n      // 创建技能图标背景\n      const graphics = this.add.graphics();\n      graphics.x = x;\n      graphics.y = y;\n      this.skillGraphics.push(graphics);\n\n      // 绘制技能边框\n      this.drawSkillIcon(graphics, this.skills[i], 0);\n\n      // 技能按键文本\n      this.add.text(x + 5, y + 5, this.skills[i].key, {\n        fontSize: '14px',\n        fontStyle: 'bold',\n        color: '#ffffff'\n      });\n\n      // 技能编号\n      this.add.text(x + skillSize / 2, y + skillSize / 2 - 10, `S${i + 1}`, {\n        fontSize: '12px',\n        color: '#ffffff',\n        align: 'center'\n      }).setOrigin(0.5);\n\n      // 冷却时间文本\n      const cooldownText = this.add.text(x + skillSize / 2, y + skillSize + 5, '', {\n        fontSize: '11px',\n        color: '#ffff00',\n        align: 'center'\n      }).setOrigin(0.5);\n      this.cooldownTexts.push(cooldownText);\n    }\n\n    // 标题和说明\n    this.add.text(400, 20, '多技能冷却系统', {\n      fontSize: '24px',\n      fontStyle: 'bold',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    this.add.text(400, 50, '按键盘 1-0, Q-P 使用技能 | 绿色=就绪 红色=冷却中', {\n      fontSize: '14px',\n      color: '#aaaaaa'\n    }).setOrigin(0.5);\n\n    // 状态显示\n    this.statusText = this.add.text(400, 550, '', {\n      fontSize: '16px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 绑定键盘输入\n    this.input.keyboard.on('keydown', (event) => {\n      this.handleKeyPress(event.key.toUpperCase());\n    });\n\n    this.updateStatus();\n  }\n\n  update(time, delta) {\n    // 更新所有技能的冷却状态\n    for (let i = 0; i < this.skills.length; i++) {\n      const skill = this.skills[i];\n      \n      if (!skill.isReady) {\n        skill.remainingTime = Math.max(0, skill.cooldown - (time - skill.lastUsedTime));\n        \n        if (skill.remainingTime <= 0) {\n          skill.isReady = true;\n          skill.remainingTime = 0;\n        }\n      }\n\n      // 计算冷却进度 (0-1)\n      const progress = skill.isReady ? 0 : (skill.remainingTime / skill.cooldown);\n      \n      // 更新图标显示\n      this.drawSkillIcon(this.skillGraphics[i], skill, progress);\n      \n      // 更新冷却时间文本\n      if (skill.isReady) {\n        this.cooldownTexts[i].setText(`CD: ${(skill.cooldown / 1000).toFixed(1)}s`);\n        this.cooldownTexts[i].setColor('#00ff00');\n      } else {\n        this.cooldownTexts[i].setText(`${(skill.remainingTime / 1000).toFixed(1)}s`);\n        this.cooldownTexts[i].setColor('#ff0000');\n      }\n    }\n  }\n\n  drawSkillIcon(graphics, skill, cooldownProgress) {\n    graphics.clear();\n    \n    const size = 80;\n    \n    // 背景色（就绪=绿色，冷却=红色）\n    if (skill.isReady) {\n      graphics.fillStyle(0x00aa00, 0.3);\n    } else {\n      graphics.fillStyle(0xaa0000, 0.3);\n    }\n    graphics.fillRect(0, 0, size, size);\n\n    // 边框\n    graphics.lineStyle(2, skill.isReady ? 0x00ff00 : 0xff0000, 1);\n    graphics.strokeRect(0, 0, size, size);\n\n    // 冷却遮罩（从下往上）\n    if (cooldownProgress > 0) {\n      graphics.fillStyle(0x000000, 0.7);\n      const maskHeight = size * cooldownProgress;\n      graphics.fillRect(0, size - maskHeight, size, maskHeight);\n    }\n\n    // 进度条\n    if (!skill.isReady) {\n      const barHeight = 4;\n      const barY = size - barHeight - 2;\n      const barProgress = 1 - cooldownProgress;\n      \n      graphics.fillStyle(0x333333, 1);\n      graphics.fillRect(2, barY, size - 4, barHeight);\n      \n      graphics.fillStyle(0x00ff00, 1);\n      graphics.fillRect(2, barY, (size - 4) * barProgress, barHeight);\n    }\n  }\n\n  handleKeyPress(key) {\n    // 查找对应技能\n    const skill = this.skills.find(s => s.key === key);\n    \n    if (!skill) return;\n\n    if (skill.isReady) {\n      // 使用技能\n      this.useSkill(skill);\n    } else {\n      // 技能冷却中\n      this.showMessage(`${skill.name} 冷却中! 剩余 ${(skill.remainingTime / 1000).toFixed(1)}s`);\n    }\n  }\n\n  useSkill(skill) {\n    skill.isReady = false;\n    skill.lastUsedTime = this.time.now;\n    skill.remainingTime = skill.cooldown;\n    this.totalSkillsUsed++;\n\n    this.showMessage(`使用 ${skill.name}! (CD: ${skill.cooldown / 1000}s)`);\n    this.updateStatus();\n\n    // 创建视觉反馈\n    this.createSkillEffect(skill);\n  }\n\n  createSkillEffect(skill) {\n    const cols = 4;\n    const skillSize = 80;\n    const padding = 20;\n    const startX = 100;\n    const startY = 80;\n    \n    const col = skill.id % cols;\n    const row = Math.floor(skill.id / cols);\n    const x = startX + col * (skillSize + padding) + skillSize / 2;\n    const y = startY + row * (skillSize + padding) + skillSize / 2;\n\n    // 创建爆炸效果\n    const circle = this.add.graphics();\n    circle.fillStyle(0xffff00, 0.8);\n    circle.fillCircle(x, y, 10);\n\n    this.tweens.add({\n      targets: circle,\n      scaleX: 3,\n      scaleY: 3,\n      alpha: 0,\n      duration: 500,\n      onComplete: () => circle.destroy()\n    });\n  }\n\n  showMessage(text) {\n    if (this.messageText) {\n      this.messageText.destroy();\n    }\n\n    this.messageText = this.add.text(400, 500, text, {\n      fontSize: '16px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5);\n\n    this.time.delayedCall(2000, () => {\n      if (this.messageText) {\n        this.messageText.destroy();\n        this.messageText = null;\n      }\n    });\n  }\n\n  updateStatus() {\n    const readyCount = this.skills.filter(s => s.isReady).length;\n    this.statusText.setText(\n      `就绪技能: ${readyCount}/20 | 总使用次数: ${this.totalSkillsUsed}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: SkillSystemScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001896_v2", "prompt_id": "seed_001896", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 4 秒在随机位置生成一个黄色星形，最多生成 15 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔4秒在随机位置生成黄色星形，最多15个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.Geom.Point\nSTEPS:\n1. 创建 Scene 并初始化星形计数器\n2. 使用 Graphics 绘制星形纹理（五角星形状）\n3. 使用 TimerEvent 每隔4秒触发生成逻辑\n4. 在随机位置创建星形图像，直到达到15个上限\n5. 达到上限后移除定时器\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nlet starCount = 0;\nconst MAX_STARS = 15;\nlet timerEvent = null;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形纹理\n  createStarTexture(this);\n  \n  // 创建定时器，每4秒生成一个星形\n  timerEvent = this.time.addEvent({\n    delay: 4000,           // 4秒\n    callback: spawnStar,   // 回调函数\n    callbackScope: this,   // 回调作用域\n    loop: true             // 循环执行\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, '每4秒生成一个星形，最多15个', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n  \n  // 显示星形计数\n  this.countText = this.add.text(10, 35, `星形数量: ${starCount}/${MAX_STARS}`, {\n    fontSize: '16px',\n    color: '#ffff00'\n  });\n}\n\n/**\n * 创建星形纹理\n */\nfunction createStarTexture(scene) {\n  const graphics = scene.add.graphics();\n  \n  // 绘制五角星\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  const points = [];\n  const outerRadius = 25;\n  const innerRadius = 10;\n  const numPoints = 5;\n  \n  // 计算五角星的顶点\n  for (let i = 0; i < numPoints * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    points.push({\n      x: 30 + Math.cos(angle) * radius,\n      y: 30 + Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 60, 60);\n  graphics.destroy();\n}\n\n/**\n * 生成星形\n */\nfunction spawnStar() {\n  // 检查是否达到上限\n  if (starCount >= MAX_STARS) {\n    // 移除定时器\n    if (timerEvent) {\n      timerEvent.remove();\n      timerEvent = null;\n    }\n    \n    // 显示完成提示\n    this.add.text(400, 300, '已生成15个星形！', {\n      fontSize: '24px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n    \n    return;\n  }\n  \n  // 生成随机位置（避免星形超出边界）\n  const margin = 40;\n  const x = Phaser.Math.Between(margin, this.scale.width - margin);\n  const y = Phaser.Math.Between(margin + 60, this.scale.height - margin);\n  \n  // 创建星形图像\n  const star = this.add.image(x, y, 'star');\n  \n  // 添加简单的缩放动画\n  this.tweens.add({\n    targets: star,\n    scaleX: 1.2,\n    scaleY: 1.2,\n    duration: 200,\n    yoyo: true,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 增加计数\n  starCount++;\n  \n  // 更新计数文本\n  this.countText.setText(`星形数量: ${starCount}/${MAX_STARS}`);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000124_v2", "prompt_id": "seed_000124", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的紫色六边形，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现可拖拽的紫色六边形，拖拽时变色，松手后回到初始位置\nAPI: Graphics.fillStyle, Graphics.fillPoints, InputPlugin.setDraggable, Events.DRAG, Events.DRAG_START, Events.DRAG_END\nSTEPS:\n1. 使用 Graphics 绘制紫色六边形并生成纹理\n2. 创建 Sprite 并设置为可拖拽\n3. 监听 DRAG_START 事件改变颜色为亮紫色\n4. 监听 DRAG 事件更新位置\n5. 监听 DRAG_END 事件恢复颜色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建紫色六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点\n  const hexRadius = 60;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    hexPoints.push({\n      x: hexRadius + Math.cos(angle) * hexRadius,\n      y: hexRadius + Math.sin(angle) * hexRadius\n    });\n  }\n  \n  // 绘制紫色六边形\n  graphics.fillStyle(0x9b59b6, 1);\n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0].x, hexPoints[0].y);\n  for (let i = 1; i < hexPoints.length; i++) {\n    graphics.lineTo(hexPoints[i].x, hexPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建亮紫色六边形纹理（拖拽时使用）\n  const graphicsDrag = this.add.graphics();\n  graphicsDrag.fillStyle(0xd896ff, 1);\n  graphicsDrag.beginPath();\n  graphicsDrag.moveTo(hexPoints[0].x, hexPoints[0].y);\n  for (let i = 1; i < hexPoints.length; i++) {\n    graphicsDrag.lineTo(hexPoints[i].x, hexPoints[i].y);\n  }\n  graphicsDrag.closePath();\n  graphicsDrag.fillPath();\n  graphicsDrag.generateTexture('hexagonDrag', hexRadius * 2, hexRadius * 2);\n  graphicsDrag.destroy();\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n  \n  // 创建六边形精灵\n  const hexagon = this.add.sprite(initialX, initialY, 'hexagon');\n  \n  // 设置为可交互和可拖拽\n  hexagon.setInteractive();\n  this.input.setDraggable(hexagon);\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '拖动六边形试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n  \n  // 监听拖拽开始事件\n  this.input.on('dragstart', (pointer, gameObject) => {\n    // 改变为亮紫色\n    gameObject.setTexture('hexagonDrag');\n    gameObject.setScale(1.1); // 稍微放大\n  });\n  \n  // 监听拖拽事件\n  this.input.on('drag', (pointer, gameObject, dragX, dragY) => {\n    // 更新位置跟随鼠标\n    gameObject.x = dragX;\n    gameObject.y = dragY;\n  });\n  \n  // 监听拖拽结束事件\n  this.input.on('dragend', (pointer, gameObject) => {\n    // 恢复原始颜色\n    gameObject.setTexture('hexagon');\n    gameObject.setScale(1); // 恢复大小\n    \n    // 使用补间动画回到初始位置\n    this.tweens.add({\n      targets: gameObject,\n      x: initialX,\n      y: initialY,\n      duration: 300,\n      ease: 'Back.easeOut'\n    });\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000713_v3", "prompt_id": "seed_000713", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个灰色敌人巡逻移动，在 240 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 15个灰色敌人在240速度下左右巡逻，玩家接近时追踪玩家\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.Sprite, this.physics.add.overlap, Phaser.Math.Distance.Between\nSTEPS:\n1. 使用Graphics创建玩家和敌人的纹理（玩家蓝色，敌人灰色）\n2. 创建物理精灵玩家，支持键盘控制移动\n3. 创建15个敌人物理组，随机分布在场景中\n4. 为每个敌人设置初始巡逻方向和边界\n5. 在update中检测玩家与敌人距离，近距离时切换为追踪模式\n6. 巡逻模式下敌人左右往返，追踪模式下向玩家移动\n7. 添加状态变量追踪敌人追踪数量\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.trackingEnemiesCount = 0; // 状态信号：正在追踪的敌人数量\n    this.totalEnemies = 15; // 状态信号：敌人总数\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（灰色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x808080, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建15个敌人，随机分布\n    for (let i = 0; i < this.totalEnemies; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const enemy = this.enemies.create(x, y, 'enemy');\n      \n      // 设置敌人属性\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(1, 0);\n      \n      // 自定义属性：巡逻模式\n      enemy.patrolDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1; // 随机初始方向\n      enemy.patrolSpeed = 240;\n      enemy.trackingSpeed = 240;\n      enemy.detectionRange = 150; // 检测范围\n      enemy.isTracking = false; // 是否正在追踪\n      \n      // 设置初始巡逻边界（左右移动范围）\n      enemy.patrolMinX = Math.max(50, x - 150);\n      enemy.patrolMaxX = Math.min(750, x + 150);\n      \n      // 设置初始速度\n      enemy.setVelocityX(enemy.patrolDirection * enemy.patrolSpeed);\n    }\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加UI文本显示状态\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 570, 'Use Arrow Keys to Move | Enemies track you when close', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    }\n\n    // 重置追踪计数\n    this.trackingEnemiesCount = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, \n        this.player.y, \n        enemy.x, \n        enemy.y\n      );\n\n      // 判断是否进入追踪模式\n      if (distance < enemy.detectionRange) {\n        enemy.isTracking = true;\n        this.trackingEnemiesCount++;\n        \n        // 追踪玩家\n        this.physics.moveToObject(enemy, this.player, enemy.trackingSpeed);\n      } else {\n        // 巡逻模式\n        if (enemy.isTracking) {\n          // 从追踪模式切换回巡逻模式\n          enemy.isTracking = false;\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(enemy.patrolDirection * enemy.patrolSpeed);\n        }\n\n        // 检查巡逻边界，到达边界时反向\n        if (enemy.x <= enemy.patrolMinX && enemy.body.velocity.x < 0) {\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(enemy.patrolDirection * enemy.patrolSpeed);\n        } else if (enemy.x >= enemy.patrolMaxX && enemy.body.velocity.x > 0) {\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(enemy.patrolDirection * enemy.patrolSpeed);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText([\n      `Total Enemies: ${this.totalEnemies}`,\n      `Tracking Enemies: ${this.trackingEnemiesCount}`,\n      `Player Position: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001506_v2", "prompt_id": "seed_001506", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 80 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版，敌人速度随时间从80逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建玩家角色（使用Graphics绘制），添加键盘控制\n2. 创建敌人组，使用物理系统，初始速度80，定时生成新敌人\n3. 添加碰撞检测，碰撞后游戏结束\n4. 实现速度递增机制，每秒增加敌人速度\n5. 显示生存时间文本，实时更新\n6. 游戏结束后显示最终生存时间\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.survivalTime = 0;\n    this.baseEnemySpeed = 80;\n    this.currentEnemySpeed = 80;\n    this.speedIncreaseRate = 5; // 每秒增加5像素速度\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy',\n      maxSize: 20\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0.0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 速度显示文本\n    this.speedText = this.add.text(16, 50, 'Speed: 80', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      fontFamily: 'Arial'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 360, '', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 定时生成敌人（每1.5秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1500,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 速度递增定时器（每秒更新）\n    this.speedTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.increaseSpeed,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 记录开始时间\n    this.startTime = this.time.now;\n\n    // 重启按键\n    this.input.keyboard.on('keydown-SPACE', () => {\n      if (this.isGameOver) {\n        this.scene.restart();\n      }\n    });\n  }\n\n  update(time, delta) {\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 更新生存时间\n    this.survivalTime = (time - this.startTime) / 1000;\n    this.timeText.setText(`Time: ${this.survivalTime.toFixed(1)}s`);\n\n    // 玩家移动\n    const speed = 300;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.isGameOver) {\n      return;\n    }\n\n    const x = Phaser.Math.Between(30, 770);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    if (enemy) {\n      enemy.setVelocityY(this.currentEnemySpeed);\n      enemy.body.setAllowGravity(false);\n    }\n  }\n\n  increaseSpeed() {\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 每秒增加速度\n    this.currentEnemySpeed += this.speedIncreaseRate;\n    this.speedText.setText(`Speed: ${Math.round(this.currentEnemySpeed)}`);\n\n    // 更新现有敌人的速度\n    this.enemies.children.entries.forEach(enemy => {\n      enemy.setVelocityY(this.currentEnemySpeed);\n    });\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.isGameOver) {\n      return;\n    }\n\n    this.isGameOver = true;\n\n    // 停止所有定时器\n    this.enemyTimer.remove();\n    this.speedTimer.remove();\n\n    // 停止玩家和所有敌人\n    this.player.setVelocity(0);\n    this.enemies.setVelocityY(0);\n\n    // 显示游戏结束信息\n    this.gameOverText.setText('GAME OVER!');\n    this.gameOverText.setVisible(true);\n\n    this.restartText.setText(\n      `Survived: ${this.survivalTime.toFixed(1)}s\\nPress SPACE to Restart`\n    );\n    this.restartText.setVisible(true);\n\n    // 玩家变暗\n    this.player.setTint(0x888888);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001306_v2", "prompt_id": "seed_001306", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让白色菱形在 1.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色菱形淡入淡出循环动画，周期1.5秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建 Sprite 对象使用生成的菱形纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 属性实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形路径（中心点在 50, 50，大小为 80x80）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 上顶点\n  graphics.lineTo(centerX + size, centerY);      // 右顶点\n  graphics.lineTo(centerX, centerY + size);      // 下顶点\n  graphics.lineTo(centerX - size, centerY);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中显示\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果，repeat -1 实现无限循环\n  this.tweens.add({\n    targets: diamond,\n    alpha: 0,                    // 目标透明度为 0（完全透明）\n    duration: 750,               // 单程时间 0.75 秒\n    yoyo: true,                  // 启用 yoyo 效果（淡出后自动淡入）\n    repeat: -1,                  // 无限循环\n    ease: 'Sine.easeInOut'       // 使用正弦缓动函数使动画更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000250_v2", "prompt_id": "seed_000250", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：10 个绿色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 10个绿色小球在封闭空间内以360速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade.Group, setBounce, setCollideWorldBounds, collider, setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成绿色圆形纹理\n3. 创建物理组，添加 10 个小球精灵\n4. 为每个小球设置随机速度（总速度为 360）和边界碰撞\n5. 设置小球之间的碰撞检测\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass BallBounceScene extends Phaser.Scene {\n  constructor() {\n    super('BallBounceScene');\n    this.collisionCount = 0; // 状态信号：记录碰撞次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 使用 Graphics 创建绿色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: 9, // 创建 10 个小球（0-9）\n      setXY: {\n        x: 100,\n        y: 100,\n        stepX: 70,\n        stepY: 0\n      }\n    });\n\n    // 配置每个小球\n    this.balls.children.iterate((ball) => {\n      // 设置边界碰撞和反弹\n      ball.setCollideWorldBounds(true);\n      ball.setBounce(1, 1); // 完全弹性碰撞\n\n      // 设置随机方向，速度为 360\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const vx = Math.cos(angle) * 360;\n      const vy = Math.sin(angle) * 360;\n      ball.setVelocity(vx, vy);\n\n      // 设置圆形碰撞体\n      ball.body.setCircle(16);\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.handleBallCollision, null, this);\n\n    // 显示碰撞计数\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n\n    // 显示说明\n    this.add.text(10, 40, 'Green balls bouncing at 360 speed', {\n      fontSize: '16px',\n      fill: '#cccccc'\n    });\n  }\n\n  handleBallCollision(ball1, ball2) {\n    // 记录碰撞次数\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    // 更新碰撞计数显示\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n\n    // 验证速度保持在 360 左右（允许微小误差）\n    this.balls.children.iterate((ball) => {\n      const speed = Math.sqrt(ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2);\n      \n      // 如果速度偏差过大，重新归一化到 360\n      if (Math.abs(speed - 360) > 5) {\n        const angle = Math.atan2(ball.body.velocity.y, ball.body.velocity.x);\n        ball.setVelocity(Math.cos(angle) * 360, Math.sin(angle) * 360);\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallBounceScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001000_v1", "prompt_id": "seed_001000", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的红色椭圆，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现可拖拽的红色椭圆，拖拽时变色，松手后回到初始位置\nAPI: Graphics.fillEllipse, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制红色椭圆并生成纹理\n2. 创建椭圆精灵并启用拖拽交互\n3. 监听 dragstart 事件改变颜色为蓝色\n4. 监听 drag 事件更新椭圆位置\n5. 监听 dragend 事件恢复红色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n  \n  // 创建红色椭圆纹理\n  const graphicsRed = this.add.graphics();\n  graphicsRed.fillStyle(0xff0000, 1);\n  graphicsRed.fillEllipse(50, 40, 100, 80); // 中心点在 (50, 40)，宽100，高80\n  graphicsRed.generateTexture('ellipseRed', 100, 80);\n  graphicsRed.destroy();\n  \n  // 创建蓝色椭圆纹理（拖拽时使用）\n  const graphicsBlue = this.add.graphics();\n  graphicsBlue.fillStyle(0x0000ff, 1);\n  graphicsBlue.fillEllipse(50, 40, 100, 80);\n  graphicsBlue.generateTexture('ellipseBlue', 100, 80);\n  graphicsBlue.destroy();\n  \n  // 创建椭圆精灵\n  const ellipse = this.add.sprite(initialX, initialY, 'ellipseRed');\n  \n  // 启用交互和拖拽\n  ellipse.setInteractive({ draggable: true });\n  \n  // 监听拖拽开始事件 - 改变颜色为蓝色\n  ellipse.on('dragstart', (pointer, dragX, dragY) => {\n    ellipse.setTexture('ellipseBlue');\n  });\n  \n  // 监听拖拽事件 - 更新位置\n  ellipse.on('drag', (pointer, dragX, dragY) => {\n    ellipse.x = dragX;\n    ellipse.y = dragY;\n  });\n  \n  // 监听拖拽结束事件 - 恢复颜色并回到初始位置\n  ellipse.on('dragend', (pointer, dragX, dragY) => {\n    ellipse.setTexture('ellipseRed');\n    \n    // 使用补间动画平滑回到初始位置\n    this.tweens.add({\n      targets: ellipse,\n      x: initialX,\n      y: initialY,\n      duration: 300,\n      ease: 'Power2'\n    });\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '拖拽红色椭圆试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000036_v1", "prompt_id": "seed_000036", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色菱形以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色菱形以80速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 使用 Graphics 绘制黄色菱形并生成纹理\n2. 创建 Arcade 物理精灵并应用菱形纹理\n3. 设置初始速度为 80（x和y方向）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);        // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始速度（80速度，沿对角线方向）\n  diamond.setVelocity(80, 80);\n  \n  // 启用世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, '黄色菱形以80速度移动并反弹', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000144_v3", "prompt_id": "seed_000144", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现白色敌人追踪：敌人以 300 速度追踪玩家位置，玩家速度 300*1.2 可躲避。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现白色敌人以300速度追踪玩家，玩家速度360可躲避\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.ArcadePhysics#moveToObject, Phaser.Input.Keyboard.createCursorKeys, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建带物理系统的游戏配置（Arcade物理引擎）\n2. 使用Graphics绘制玩家（绿色圆形）和敌人（白色圆形）纹理\n3. 在create中创建玩家精灵（速度360）和敌人精灵（速度300）\n4. 添加键盘输入控制玩家移动（方向键）\n5. 在update中实现敌人追踪逻辑（moveToObject）和玩家移动逻辑\n6. 添加碰撞检测，记录被追到次数作为状态信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerSpeed = 300 * 1.2; // 360\n    this.enemySpeed = 300;\n    this.caughtCount = 0; // 状态信号：被追到次数\n    this.escapeTime = 0; // 状态信号：逃脱时间（秒）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色圆形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(20, 20, 20);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（白色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xffffff, 1);\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人精灵（从随机位置开始）\n    const startX = Phaser.Math.Between(100, 700);\n    const startY = Phaser.Math.Between(100, 500);\n    this.enemy = this.physics.add.sprite(startX, startY, 'enemy');\n    this.enemy.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.physics.add.overlap(this.player, this.enemy, this.onCaught, null, this);\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加提示文本\n    this.add.text(400, 30, '使用方向键移动逃脱白色敌人', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    }).setOrigin(0.5);\n\n    // 更新状态文本\n    this.updateStatus();\n  }\n\n  update(time, delta) {\n    // 更新逃脱时间\n    this.escapeTime += delta / 1000;\n\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-this.playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(this.playerSpeed);\n    }\n\n    // 对角线移动时归一化速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(this.playerSpeed);\n    }\n\n    // 敌人追踪玩家\n    this.physics.moveToObject(this.enemy, this.player, this.enemySpeed);\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  onCaught(player, enemy) {\n    // 被追到时的处理\n    this.caughtCount++;\n\n    // 重置玩家位置到随机安全位置\n    let safeX, safeY;\n    do {\n      safeX = Phaser.Math.Between(100, 700);\n      safeY = Phaser.Math.Between(100, 500);\n    } while (Phaser.Math.Distance.Between(safeX, safeY, enemy.x, enemy.y) < 150);\n\n    player.setPosition(safeX, safeY);\n\n    // 短暂闪烁效果\n    this.tweens.add({\n      targets: player,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 2\n    });\n\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const distance = Phaser.Math.Distance.Between(\n      this.player.x, this.player.y,\n      this.enemy.x, this.enemy.y\n    );\n\n    this.statusText.setText([\n      `被追到次数: ${this.caughtCount}`,\n      `逃脱时间: ${this.escapeTime.toFixed(1)}秒`,\n      `距离敌人: ${Math.floor(distance)}px`,\n      `玩家速度: ${this.playerSpeed} | 敌人速度: ${this.enemySpeed}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001569_v1", "prompt_id": "seed_001569", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的橙色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的橙色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算六边形6个顶点坐标\n4. 循环12次，每次生成随机位置(x, y)，绘制橙色六边形\n5. 使用 fillStyle 设置橙色，使用 beginPath/lineTo/closePath/fillPath 绘制填充六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 橙色填充\n  graphics.fillStyle(0xFF8C00, 1);\n  \n  // 六边形大小（从中心到顶点的距离）\n  const size = 16; // 32像素直径，半径16\n  \n  // 绘制六边形的函数\n  function drawHexagon(g, x, y, radius) {\n    g.beginPath();\n    \n    // 计算六边形的6个顶点（从顶部开始，顺时针）\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度起始，使顶点朝上\n      const px = x + radius * Math.cos(angle);\n      const py = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        g.moveTo(px, py);\n      } else {\n        g.lineTo(px, py);\n      }\n    }\n    \n    g.closePath();\n    g.fillPath();\n  }\n  \n  // 绘制12个随机位置的六边形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置，留出边距避免六边形被裁切\n    const x = size + Math.random() * (800 - size * 2);\n    const y = size + Math.random() * (600 - size * 2);\n    \n    drawHexagon(graphics, x, y, size);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000500_v1", "prompt_id": "seed_000500", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Graphics 对象用于绘制\n2. 设置紫色填充样式\n3. 计算菱形四个顶点坐标（中心点为画布中心，边长48像素）\n4. 使用 fillPath 绘制菱形多边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充样式 (紫色 RGB: 128, 0, 128)\n  graphics.fillStyle(0x800080, 1);\n  \n  // 计算菱形四个顶点坐标\n  // 菱形是一个旋转45度的正方形，对角线长度为48像素\n  const halfSize = 24; // 从中心到顶点的距离\n  \n  // 菱形顶点：上、右、下、左\n  const points = [\n    centerX, centerY - halfSize,  // 上顶点\n    centerX + halfSize, centerY,  // 右顶点\n    centerX, centerY + halfSize,  // 下顶点\n    centerX - halfSize, centerY   // 左顶点\n  ];\n  \n  // 创建多边形并填充\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000112_v2", "prompt_id": "seed_000112", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的蓝色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的蓝色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次\n3. 每次循环创建一个 Graphics 对象，设置蓝色填充\n4. 使用 fillTriangle 绘制等边三角形（大小16像素）\n5. 使用 setRandomPosition 或 Math.random 设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建20个随机位置的蓝色三角形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置蓝色填充\n    graphics.fillStyle(0x0000ff, 1);\n    \n    // 绘制等边三角形（大小16像素）\n    // 等边三角形的顶点坐标（中心在原点）\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    // 三个顶点坐标（顶点朝上）\n    const x1 = 0;\n    const y1 = -height * 2 / 3; // 顶点\n    const x2 = -size / 2;\n    const y2 = height / 3; // 左下角\n    const x3 = size / 2;\n    const y3 = height / 3; // 右下角\n    \n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const randomX = Phaser.Math.Between(size, config.width - size);\n    const randomY = Phaser.Math.Between(size, config.height - size);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000781_v1", "prompt_id": "seed_000781", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现波次敌人生成：每波 10 个灰色敌人，敌人速度 360，消灭完后等 2 秒进入下一波，显示当前波次。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现波次敌人生成系统，每波10个灰色敌人速度360，消灭后等2秒进入下一波并显示波次\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Time.TimerEvent, Phaser.GameObjects.Text, Phaser.GameObjects.Group\nSTEPS:\n1. 创建玩家角色（绿色方块）和敌人组（灰色圆形），配置物理系统\n2. 实现敌人生成逻辑：每波生成10个敌人，随机位置，固定速度360朝玩家移动\n3. 添加碰撞检测：玩家点击或键盘控制发射子弹消灭敌人\n4. 检测当前波次敌人全部消灭后，启动2秒延迟定时器进入下一波\n5. 显示当前波次文本，记录游戏状态（波次、剩余敌人数）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentWave = 1;\n    this.enemiesPerWave = 10;\n    this.enemySpeed = 360;\n    this.waveDelay = 2000; // 2秒\n    this.isWaveActive = false;\n    this.remainingEnemies = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（灰色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x808080, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建子弹纹理（黄色小圆）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 30\n    });\n\n    // 碰撞检测：子弹击中敌人\n    this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);\n\n    // 碰撞检测：敌人碰到玩家（游戏结束逻辑可选）\n    this.physics.add.overlap(this.player, this.enemies, this.hitPlayer, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.lastFired = 0;\n    this.fireRate = 200; // 射击间隔\n\n    // UI文本\n    this.waveText = this.add.text(16, 16, `Wave: ${this.currentWave}`, {\n      fontSize: '24px',\n      fill: '#fff',\n      fontFamily: 'Arial'\n    });\n\n    this.enemyCountText = this.add.text(16, 48, `Enemies: ${this.remainingEnemies}`, {\n      fontSize: '20px',\n      fill: '#fff',\n      fontFamily: 'Arial'\n    });\n\n    this.statusText = this.add.text(16, 80, '', {\n      fontSize: '18px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 开始第一波\n    this.startWave();\n  }\n\n  update(time, delta) {\n    // 玩家移动\n    const speed = 300;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 射击\n    if (this.spaceKey.isDown && time > this.lastFired) {\n      this.fireBullet();\n      this.lastFired = time + this.fireRate;\n    }\n\n    // 更新敌人朝向玩家移动\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active) {\n        this.physics.moveToObject(enemy, this.player, this.enemySpeed);\n      }\n    });\n\n    // 检查波次完成\n    if (this.isWaveActive && this.remainingEnemies === 0) {\n      this.completeWave();\n    }\n  }\n\n  startWave() {\n    this.isWaveActive = true;\n    this.remainingEnemies = this.enemiesPerWave;\n    this.statusText.setText('');\n\n    // 生成敌人\n    for (let i = 0; i < this.enemiesPerWave; i++) {\n      this.spawnEnemy();\n    }\n\n    this.updateUI();\n  }\n\n  spawnEnemy() {\n    // 随机生成位置（屏幕边缘）\n    let x, y;\n    const side = Phaser.Math.Between(0, 3);\n    \n    switch(side) {\n      case 0: // 上方\n        x = Phaser.Math.Between(0, 800);\n        y = -20;\n        break;\n      case 1: // 右方\n        x = 820;\n        y = Phaser.Math.Between(0, 600);\n        break;\n      case 2: // 下方\n        x = Phaser.Math.Between(0, 800);\n        y = 620;\n        break;\n      case 3: // 左方\n        x = -20;\n        y = Phaser.Math.Between(0, 600);\n        break;\n    }\n\n    const enemy = this.enemies.create(x, y, 'enemy');\n    enemy.setCollideWorldBounds(false); // 允许离开边界后销毁\n  }\n\n  fireBullet() {\n    const bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocityY(-400);\n      \n      // 子弹离开屏幕后销毁\n      this.time.delayedCall(2000, () => {\n        if (bullet.active) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      });\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 销毁子弹和敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    enemy.destroy();\n\n    this.remainingEnemies--;\n    this.updateUI();\n  }\n\n  hitPlayer(player, enemy) {\n    // 可选：玩家被击中逻辑\n    enemy.destroy();\n    this.remainingEnemies--;\n    this.updateUI();\n  }\n\n  completeWave() {\n    this.isWaveActive = false;\n    this.statusText.setText('Wave Complete! Next wave in 2s...');\n\n    // 2秒后开始下一波\n    this.time.delayedCall(this.waveDelay, () => {\n      this.currentWave++;\n      this.startWave();\n    });\n  }\n\n  updateUI() {\n    this.waveText.setText(`Wave: ${this.currentWave}`);\n    this.enemyCountText.setText(`Enemies: ${this.remainingEnemies}`);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001749_v1", "prompt_id": "seed_001749", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现重力场效果：5 个小球受中心点吸引，吸引力与距离成反比，吸引速度基准 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 实现5个小球受中心点引力吸引，吸引力与距离成反比，基准速度300\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Math.Distance.Between, Phaser.Math.Angle.Between\nSTEPS:\n1. 创建物理系统场景，关闭默认重力\n2. 使用 Graphics 生成小球纹理，创建5个物理精灵小球\n3. 在 update 中计算每个小球到中心点的距离和角度\n4. 根据距离计算引力大小（反比关系），应用速度基准300\n5. 使用 setVelocity 设置小球朝向中心的速度分量\n6. 添加状态信号：记录小球平均距离作为可验证状态\n[/PLAN]\n\n```javascript\nclass GravityFieldScene extends Phaser.Scene {\n  constructor() {\n    super('GravityFieldScene');\n    this.balls = [];\n    this.centerX = 400;\n    this.centerY = 300;\n    this.baseSpeed = 300;\n    this.averageDistance = 0; // 状态信号：小球平均距离\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建中心点标记\n    const centerGraphics = this.add.graphics();\n    centerGraphics.fillStyle(0xffff00, 1);\n    centerGraphics.fillCircle(this.centerX, this.centerY, 10);\n    centerGraphics.lineStyle(2, 0xffff00, 0.5);\n    centerGraphics.strokeCircle(this.centerX, this.centerY, 50);\n    centerGraphics.strokeCircle(this.centerX, this.centerY, 100);\n    centerGraphics.strokeCircle(this.centerX, this.centerY, 150);\n\n    // 使用 Graphics 生成小球纹理\n    const ballGraphics = this.add.graphics();\n    ballGraphics.fillStyle(0x00ff00, 1);\n    ballGraphics.fillCircle(15, 15, 15);\n    ballGraphics.generateTexture('ball', 30, 30);\n    ballGraphics.destroy();\n\n    // 创建5个小球，随机分布在场景中\n    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff, 0x00ffff];\n    \n    for (let i = 0; i < 5; i++) {\n      // 为每个小球生成不同颜色的纹理\n      const colorGraphics = this.add.graphics();\n      colorGraphics.fillStyle(colors[i], 1);\n      colorGraphics.fillCircle(15, 15, 15);\n      colorGraphics.generateTexture(`ball${i}`, 30, 30);\n      colorGraphics.destroy();\n\n      // 随机位置（避免太靠近中心）\n      const angle = (Math.PI * 2 / 5) * i;\n      const distance = 150 + Math.random() * 100;\n      const x = this.centerX + Math.cos(angle) * distance;\n      const y = this.centerY + Math.sin(angle) * distance;\n\n      // 创建物理精灵\n      const ball = this.physics.add.sprite(x, y, `ball${i}`);\n      ball.setCollideWorldBounds(true);\n      ball.setBounce(0.8);\n      \n      // 给小球一些初始随机速度\n      ball.setVelocity(\n        (Math.random() - 0.5) * 100,\n        (Math.random() - 0.5) * 100\n      );\n\n      this.balls.push(ball);\n    }\n\n    // 添加信息文本\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, '5个小球受中心黄点引力吸引\\n吸引力与距离成反比', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    let totalDistance = 0;\n\n    // 对每个小球应用引力\n    this.balls.forEach(ball => {\n      // 计算小球到中心点的距离\n      const distance = Phaser.Math.Distance.Between(\n        ball.x, ball.y,\n        this.centerX, this.centerY\n      );\n\n      totalDistance += distance;\n\n      // 计算角度\n      const angle = Phaser.Math.Angle.Between(\n        ball.x, ball.y,\n        this.centerX, this.centerY\n      );\n\n      // 计算引力大小（与距离成反比）\n      // 使用距离的平方反比，并限制最小距离避免除零和过大加速度\n      const minDistance = 30;\n      const effectiveDistance = Math.max(distance, minDistance);\n      \n      // 引力强度 = 基准速度 / 距离\n      // 这样距离越近，引力越大\n      const gravityStrength = this.baseSpeed / effectiveDistance;\n\n      // 计算速度分量\n      const vx = Math.cos(angle) * gravityStrength;\n      const vy = Math.sin(angle) * gravityStrength;\n\n      // 应用速度（累加到现有速度上，模拟加速度效果）\n      // 使用 delta 时间来平滑处理\n      const deltaSeconds = delta / 1000;\n      ball.setVelocity(\n        ball.body.velocity.x + vx * deltaSeconds,\n        ball.body.velocity.y + vy * deltaSeconds\n      );\n\n      // 限制最大速度，避免过快\n      const maxSpeed = 400;\n      const currentSpeed = Math.sqrt(\n        ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2\n      );\n      if (currentSpeed > maxSpeed) {\n        const scale = maxSpeed / currentSpeed;\n        ball.setVelocity(\n          ball.body.velocity.x * scale,\n          ball.body.velocity.y * scale\n        );\n      }\n    });\n\n    // 更新状态信号\n    this.averageDistance = totalDistance / this.balls.length;\n\n    // 更新信息显示\n    this.infoText.setText([\n      `平均距离: ${this.averageDistance.toFixed(1)} px`,\n      `基准速度: ${this.baseSpeed}`,\n      `小球数量: ${this.balls.length}`,\n      `状态: ${this.averageDistance < 100 ? '接近中心' : '远离中心'}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 关闭默认重力，使用自定义引力\n      debug: false\n    }\n  },\n  scene: GravityFieldScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001164_v2", "prompt_id": "seed_001164", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.465}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在 4 秒内缩放到 24% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Ellipse, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 或 Ellipse 创建椭圆对象\n2. 使用 tweens 创建缩放动画，从 scale 1 到 0.24\n3. 设置 yoyo 为 true 实现恢复效果，duration 为 2000ms（单程 2 秒）\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建椭圆对象（使用 Ellipse GameObject）\n  const ellipse = this.add.ellipse(\n    400,        // x 位置（居中）\n    300,        // y 位置（居中）\n    200,        // 宽度\n    120,        // 高度\n    0x00ff88,   // 填充颜色（青绿色）\n    1           // 透明度\n  );\n\n  // 添加描边使椭圆更明显\n  ellipse.setStrokeStyle(3, 0xffffff);\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标\n    scaleX: 0.24,              // X 轴缩放到 24%\n    scaleY: 0.24,              // Y 轴缩放到 24%\n    duration: 2000,            // 单程时长 2 秒\n    yoyo: true,                // 启用往返效果（缩小后自动恢复）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'     // 缓动函数，使动画更平滑\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Ellipse Scale Animation (4s cycle)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, 'Scale: 100% → 24% → 100% (Loop)', {\n    fontSize: '18px',\n    color: '#aaaaaa',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000265_v2", "prompt_id": "seed_000265", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, GameObject.rotation, Scene.time\nSTEPS:\n1. 创建 Graphics 对象绘制六边形\n2. 计算六边形的六个顶点坐标（使用三角函数）\n3. 在 update 方法中根据 delta 时间累加旋转角度\n4. 每秒旋转 160 度，即每毫秒旋转 160/1000 度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形\n  const centerX = 0;\n  const centerY = 0;\n  const radius = 80;\n  const sides = 6;\n  \n  graphics.beginPath();\n  \n  // 计算六边形的顶点\n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使六边形更明显\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 将六边形放置在屏幕中心\n  graphics.setPosition(400, 300);\n  \n  // 保存引用以便在 update 中使用\n  hexagon = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 160 度\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 160; // 度/秒\n  const rotationRadians = Phaser.Math.DegToRad(rotationSpeed); // 转换为弧度/秒\n  \n  // 根据 delta 时间增加旋转角度\n  hexagon.rotation += rotationRadians * (delta / 1000);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000280_v2", "prompt_id": "seed_000280", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现键盘方向键控制一个橙色矩形移动，移动速度为 160，限制在画布边界内。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 键盘方向键控制橙色矩形移动，速度160，限制在画布边界内\nAPI: this.input.keyboard.createCursorKeys(), this.add.graphics(), graphics.fillRect(), graphics.generateTexture()\nSTEPS:\n1. 创建 Graphics 对象绘制橙色矩形并生成纹理\n2. 创建 Sprite 使用生成的纹理\n3. 在 create 中获取方向键输入对象\n4. 在 update 中检测方向键状态并更新矩形位置\n5. 使用 Phaser.Math.Clamp 限制矩形在画布边界内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet cursors;\nconst SPEED = 160;\n\nfunction preload() {\n  // 创建橙色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8C00, 1); // 橙色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerRect', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵，初始位置在画布中心\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 设置原点为中心点\n  player.setOrigin(0.5, 0.5);\n  \n  // 创建方向键输入\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use Arrow Keys to Move', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算时间增量（秒）\n  const deltaSeconds = delta / 1000;\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测方向键输入\n  if (cursors.left.isDown) {\n    velocityX = -SPEED;\n  } else if (cursors.right.isDown) {\n    velocityX = SPEED;\n  }\n  \n  if (cursors.up.isDown) {\n    velocityY = -SPEED;\n  } else if (cursors.down.isDown) {\n    velocityY = SPEED;\n  }\n  \n  // 更新位置\n  player.x += velocityX * deltaSeconds;\n  player.y += velocityY * deltaSeconds;\n  \n  // 限制在画布边界内（考虑矩形的宽高）\n  const halfWidth = player.width / 2;\n  const halfHeight = player.height / 2;\n  \n  player.x = Phaser.Math.Clamp(player.x, halfWidth, config.width - halfWidth);\n  player.y = Phaser.Math.Clamp(player.y, halfHeight, config.height - halfHeight);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000790_v2", "prompt_id": "seed_000790", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色三角形平滑跟随鼠标指针移动，跟随速度为 200。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Pointer\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色三角形以速度200平滑跟随鼠标指针移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Pointer, Phaser.Math.Distance.Between, Phaser.Math.Angle.Between\nSTEPS:\n1. 使用 Graphics 绘制红色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 在 update 中获取鼠标指针位置\n4. 计算三角形到鼠标的距离和角度\n5. 根据速度和帧时间差更新三角形位置，实现平滑跟随\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet pointer;\nconst FOLLOW_SPEED = 200; // 每秒移动200像素\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制一个指向上方的三角形（中心在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -20);      // 顶点\n  graphics.lineTo(-15, 15);     // 左下角\n  graphics.lineTo(15, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 30, 35);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在屏幕中心\n  triangle = this.add.sprite(400, 300, 'triangleTexture');\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 获取指针引用\n  pointer = this.input.activePointer;\n}\n\nfunction update(time, delta) {\n  // 计算三角形到鼠标指针的距离\n  const distance = Phaser.Math.Distance.Between(\n    triangle.x,\n    triangle.y,\n    pointer.x,\n    pointer.y\n  );\n  \n  // 如果距离大于1像素，则移动三角形\n  if (distance > 1) {\n    // 计算从三角形到鼠标的角度\n    const angle = Phaser.Math.Angle.Between(\n      triangle.x,\n      triangle.y,\n      pointer.x,\n      pointer.y\n    );\n    \n    // 根据速度和帧时间差计算本帧应移动的距离\n    const moveDistance = FOLLOW_SPEED * (delta / 1000);\n    \n    // 如果移动距离大于剩余距离，直接到达目标点\n    if (moveDistance >= distance) {\n      triangle.x = pointer.x;\n      triangle.y = pointer.y;\n    } else {\n      // 计算新位置\n      triangle.x += Math.cos(angle) * moveDistance;\n      triangle.y += Math.sin(angle) * moveDistance;\n    }\n    \n    // 让三角形旋转指向鼠标方向（加90度因为三角形默认朝上）\n    triangle.rotation = angle + Math.PI / 2;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000692_v1", "prompt_id": "seed_000692", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 灰色玩家移出边界时从对侧出现，移动速度300\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), sprite.setVelocity(), Graphics.generateTexture()\nSTEPS:\n1. 创建灰色玩家精灵，使用 Graphics 绘制灰色方块纹理\n2. 启用 Arcade 物理系统，设置玩家速度为 300\n3. 使用键盘方向键控制玩家移动\n4. 在 update 中检测玩家位置，超出边界时从对侧重新出现\n5. 添加状态变量记录穿越次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossCount = 0; // 穿越边界次数（状态信号）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建灰色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('playerTexture', 40, 40);\n    graphics.destroy();\n\n    // 创建玩家精灵（居中位置）\n    this.player = this.physics.add.sprite(400, 300, 'playerTexture');\n    this.player.setCollideWorldBounds(false); // 允许移出边界\n\n    // 设置移动速度\n    this.moveSpeed = 300;\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示穿越次数文本\n    this.crossText = this.add.text(10, 10, 'Cross Count: 0', {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n\n    // 显示控制提示\n    this.add.text(10, 40, 'Use Arrow Keys to Move', {\n      fontSize: '16px',\n      color: '#cccccc'\n    });\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0, 0);\n\n    // 键盘控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.moveSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.moveSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-this.moveSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(this.moveSpeed);\n    }\n\n    // 边界循环检测\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n\n    // 左右边界循环\n    if (this.player.x > this.cameras.main.width + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      this.crossCount++;\n      this.updateCrossText();\n    } else if (this.player.x < -playerWidth / 2) {\n      this.player.x = this.cameras.main.width + playerWidth / 2;\n      this.crossCount++;\n      this.updateCrossText();\n    }\n\n    // 上下边界循环\n    if (this.player.y > this.cameras.main.height + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      this.crossCount++;\n      this.updateCrossText();\n    } else if (this.player.y < -playerHeight / 2) {\n      this.player.y = this.cameras.main.height + playerHeight / 2;\n      this.crossCount++;\n      this.updateCrossText();\n    }\n  }\n\n  updateCrossText() {\n    this.crossText.setText('Cross Count: ' + this.crossCount);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001490_v2", "prompt_id": "seed_001490", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色六边形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色六边形以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制白色六边形并生成纹理\n2. 创建带物理属性的 Sprite 使用该纹理\n3. 设置初始速度为 200，设置边界碰撞反弹\n4. 在 update 中检测边界并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const size = 30;\n  const centerX = size;\n  const centerY = size;\n  \n  // 绘制六边形（6个顶点）\n  graphics.fillStyle(0xffffff, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + size * Math.cos(angle);\n    const y = centerY + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建带物理属性的六边形精灵\n  hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 200;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 200;\n  \n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞边界\n  hexagon.setCollideWorldBounds(true);\n  hexagon.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 检测边界碰撞并反弹（物理引擎的 bounce 已处理，但这里添加额外检测以确保）\n  const bounds = hexagon.getBounds();\n  \n  // 左右边界检测\n  if (bounds.left <= 0 && hexagon.body.velocity.x < 0) {\n    hexagon.body.velocity.x *= -1;\n  } else if (bounds.right >= config.width && hexagon.body.velocity.x > 0) {\n    hexagon.body.velocity.x *= -1;\n  }\n  \n  // 上下边界检测\n  if (bounds.top <= 0 && hexagon.body.velocity.y < 0) {\n    hexagon.body.velocity.y *= -1;\n  } else if (bounds.bottom >= config.height && hexagon.body.velocity.y > 0) {\n    hexagon.body.velocity.y *= -1;\n  }\n  \n  // 保持速度恒定为200\n  const currentSpeed = Math.sqrt(\n    hexagon.body.velocity.x ** 2 + hexagon.body.velocity.y ** 2\n  );\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - 200) > 1) {\n    hexagon.body.velocity.x = (hexagon.body.velocity.x / currentSpeed) * 200;\n    hexagon.body.velocity.y = (hexagon.body.velocity.y / currentSpeed) * 200;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000385_v3", "prompt_id": "seed_000385", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色方块以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色方块以160速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带物理系统的游戏配置\n2. 使用Graphics绘制黄色方块并生成纹理\n3. 创建物理精灵并设置速度和边界碰撞\n4. 在update中检测边界并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet velocityX = 160;\nlet velocityY = 160;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用Graphics绘制黄色方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('yellowSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'yellowSquare');\n  \n  // 设置初始速度\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  square.setCollideWorldBounds(true);\n  square.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 物理引擎的bounce属性会自动处理反弹\n  // 但为了确保速度恒定为160，我们手动检测边界\n  const speed = 160;\n  \n  // 获取当前速度\n  const currentVelocity = square.body.velocity;\n  \n  // 归一化速度并乘以固定速度值，保持恒定速度\n  const magnitude = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);\n  \n  if (magnitude > 0) {\n    square.setVelocity(\n      (currentVelocity.x / magnitude) * speed,\n      (currentVelocity.y / magnitude) * speed\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000631_v1", "prompt_id": "seed_000631", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现灰色连击计数：4 秒内连续点击增加 combo，超时 combo 重置为 0，显示当前 combo，连击 8 次触发特效。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 4秒内连续点击增加combo，超时重置，显示计数，8连击触发特效\nAPI: Phaser.Time.TimerEvent, Phaser.Input.Pointer, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics, Phaser.Tweens\nSTEPS:\n1. 创建场景，添加背景和点击区域提示\n2. 添加 combo 计数文本显示，初始为 0\n3. 监听 pointerdown 事件，每次点击 combo+1 并重置 4 秒计时器\n4. 使用 TimerEvent 实现 4 秒超时逻辑，超时时重置 combo 为 0\n5. 当 combo 达到 8 时触发特效（闪光动画+文本提示）\n6. 添加状态变量用于验证（combo、lastClickTime）\n[/PLAN]\n\n```javascript\nclass ComboScene extends Phaser.Scene {\n  constructor() {\n    super('ComboScene');\n    this.combo = 0;\n    this.lastClickTime = 0;\n    this.comboTimer = null;\n    this.COMBO_TIMEOUT = 4000; // 4秒超时\n    this.COMBO_THRESHOLD = 8; // 8连击触发特效\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x2c3e50, 1);\n    bg.fillRect(0, 0, width, height);\n\n    // 创建点击区域提示\n    const clickArea = this.add.graphics();\n    clickArea.fillStyle(0x34495e, 1);\n    clickArea.fillRoundedRect(width / 2 - 200, height / 2 - 100, 400, 200, 16);\n    \n    // 添加点击提示文本\n    this.add.text(width / 2, height / 2, 'CLICK HERE', {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#7f8c8d',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建 Combo 显示文本\n    this.comboText = this.add.text(width / 2, 100, 'COMBO: 0', {\n      fontSize: '48px',\n      fontFamily: 'Arial',\n      color: '#ecf0f1',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建倒计时进度条背景\n    this.timerBarBg = this.add.graphics();\n    this.timerBarBg.fillStyle(0x34495e, 1);\n    this.timerBarBg.fillRect(width / 2 - 150, 160, 300, 10);\n\n    // 创建倒计时进度条\n    this.timerBar = this.add.graphics();\n\n    // 创建特效层（用于8连击特效）\n    this.effectLayer = this.add.graphics();\n\n    // 添加状态显示（用于验证）\n    this.statusText = this.add.text(10, 10, this.getStatusText(), {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#95a5a6'\n    });\n\n    // 监听点击事件\n    this.input.on('pointerdown', this.onPointerDown, this);\n\n    // 初始化计时器（不启动）\n    this.comboTimer = this.time.addEvent({\n      delay: this.COMBO_TIMEOUT,\n      callback: this.resetCombo,\n      callbackScope: this,\n      paused: true\n    });\n  }\n\n  onPointerDown(pointer) {\n    // 增加 combo\n    this.combo++;\n    this.lastClickTime = this.time.now;\n\n    // 更新显示\n    this.updateComboDisplay();\n\n    // 重置并启动计时器\n    if (this.comboTimer) {\n      this.comboTimer.reset({\n        delay: this.COMBO_TIMEOUT,\n        callback: this.resetCombo,\n        callbackScope: this,\n        paused: false\n      });\n    }\n\n    // 检查是否达到8连击\n    if (this.combo === this.COMBO_THRESHOLD) {\n      this.triggerComboEffect();\n    }\n\n    // 点击反馈动画\n    this.tweens.add({\n      targets: this.comboText,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 100,\n      yoyo: true,\n      ease: 'Power2'\n    });\n\n    // 更新状态文本\n    this.statusText.setText(this.getStatusText());\n  }\n\n  resetCombo() {\n    this.combo = 0;\n    this.updateComboDisplay();\n    \n    // 停止计时器\n    if (this.comboTimer) {\n      this.comboTimer.paused = true;\n    }\n\n    // 重置进度条\n    this.timerBar.clear();\n\n    // 更新状态文本\n    this.statusText.setText(this.getStatusText());\n  }\n\n  updateComboDisplay() {\n    this.comboText.setText(`COMBO: ${this.combo}`);\n    \n    // 根据 combo 数量改变颜色\n    if (this.combo >= this.COMBO_THRESHOLD) {\n      this.comboText.setColor('#f39c12'); // 金色\n    } else if (this.combo >= 5) {\n      this.comboText.setColor('#e74c3c'); // 红色\n    } else if (this.combo >= 3) {\n      this.comboText.setColor('#3498db'); // 蓝色\n    } else {\n      this.comboText.setColor('#ecf0f1'); // 灰白色\n    }\n  }\n\n  triggerComboEffect() {\n    const { width, height } = this.cameras.main;\n\n    // 创建闪光特效\n    this.effectLayer.clear();\n    this.effectLayer.fillStyle(0xf39c12, 0.5);\n    \n    // 绘制多个扩散圆环\n    for (let i = 0; i < 3; i++) {\n      const circle = this.add.graphics();\n      circle.lineStyle(8, 0xf39c12, 1);\n      circle.strokeCircle(width / 2, height / 2, 50);\n      \n      this.tweens.add({\n        targets: circle,\n        scaleX: 5,\n        scaleY: 5,\n        alpha: 0,\n        duration: 1000,\n        delay: i * 150,\n        ease: 'Power2',\n        onComplete: () => circle.destroy()\n      });\n    }\n\n    // 屏幕闪烁效果\n    const flash = this.add.graphics();\n    flash.fillStyle(0xffffff, 0.6);\n    flash.fillRect(0, 0, width, height);\n    \n    this.tweens.add({\n      targets: flash,\n      alpha: 0,\n      duration: 300,\n      ease: 'Power2',\n      onComplete: () => flash.destroy()\n    });\n\n    // 显示特效文本\n    const effectText = this.add.text(width / 2, height / 2 - 80, '8 COMBO!', {\n      fontSize: '64px',\n      fontFamily: 'Arial',\n      color: '#f39c12',\n      fontStyle: 'bold',\n      stroke: '#ffffff',\n      strokeThickness: 4\n    }).setOrigin(0.5).setAlpha(0);\n\n    this.tweens.add({\n      targets: effectText,\n      alpha: 1,\n      scaleX: 1.5,\n      scaleY: 1.5,\n      duration: 200,\n      yoyo: true,\n      repeat: 2,\n      ease: 'Back.easeOut',\n      onComplete: () => {\n        this.tweens.add({\n          targets: effectText,\n          alpha: 0,\n          y: height / 2 - 150,\n          duration: 500,\n          ease: 'Power2',\n          onComplete: () => effectText.destroy()\n        });\n      }\n    });\n\n    // 震动效果\n    this.cameras.main.shake(300, 0.005);\n  }\n\n  update(time, delta) {\n    // 更新倒计时进度条\n    if (this.comboTimer && !this.comboTimer.paused) {\n      const elapsed = this.comboTimer.getElapsed();\n      const progress = 1 - (elapsed / this.COMBO_TIMEOUT);\n      \n      this.timerBar.clear();\n      if (progress > 0) {\n        // 根据剩余时间改变颜色\n        let color = 0x2ecc71; // 绿色\n        if (progress < 0.3) {\n          color = 0xe74c3c; // 红色\n        } else if (progress < 0.6) {\n          color = 0xf39c12; // 橙色\n        }\n        \n        this.timerBar.fillStyle(color, 1);\n        this.timerBar.fillRect(\n          this.cameras.main.width / 2 - 150,\n          160,\n          300 * progress,\n          10\n        );\n      }\n    }\n  }\n\n  getStatusText() {\n    return `Status: Combo=${this.combo} | LastClick=${this.lastClickTime} | Active=${!this.comboTimer.paused}`;\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: ComboScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001916_v1", "prompt_id": "seed_001916", "source": "distill", "difficulty": "hard", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2.5秒内缩放到80%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，yoyo 模式实现恢复，loop -1 实现循环\n4. 设置 duration 为 1250ms（2.5秒的一半，因为 yoyo 会来回播放）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 150, 100);\n  graphics.generateTexture('rectTexture', 150, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵并放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setOrigin(0.5, 0.5);\n\n  // 创建缩放动画\n  // duration: 1250ms，因为 yoyo 会使动画来回播放，总时长为 2.5 秒\n  // yoyo: true 表示动画播放完后反向播放回到初始状态\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 1250,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut'\n  });\n\n  // 添加提示文本\n  const text = this.add.text(400, 50, '矩形缩放动画（循环播放）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000160_v3", "prompt_id": "seed_000160", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 AI 对战：绿色AI 角色以 160 速度追踪玩家，玩家收集 15 个物品获胜，被 AI 碰到失败。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现AI追踪玩家的收集游戏，玩家收集15个物品获胜，被AI碰到失败\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.moveToObject, Phaser.Physics.Arcade.overlap, Phaser.Input.Keyboard.createCursorKeys, Phaser.Scene.add.text\nSTEPS:\n1. 创建玩家（蓝色方块）和AI（绿色方块），使用arcade物理系统\n2. 生成15个可收集物品（黄色圆形），位置使用固定种子随机分布\n3. 实现玩家键盘控制（方向键移动）\n4. 实现AI追踪逻辑，使用moveToObject以160速度追踪玩家\n5. 检测玩家与物品的碰撞（收集），更新分数\n6. 检测玩家与AI的碰撞（失败），显示游戏结束\n7. 当收集15个物品时显示胜利信息\n8. 添加UI显示当前分数和游戏状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.gameWon = false;\n    this.targetScore = 15;\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建纹理\n    this.createTextures();\n\n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 创建玩家（蓝色方块）\n    this.player = this.physics.add.sprite(100, 300, 'playerTex');\n    this.player.setCollideWorldBounds(true);\n    this.player.setMaxVelocity(200);\n    this.player.setDrag(500);\n\n    // 创建AI敌人（绿色方块）\n    this.enemy = this.physics.add.sprite(700, 300, 'enemyTex');\n    this.enemy.setCollideWorldBounds(true);\n\n    // 创建可收集物品组\n    this.collectibles = this.physics.add.group();\n    this.createCollectibles();\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    this.physics.add.overlap(\n      this.player,\n      this.enemy,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // UI文本\n    this.scoreText = this.add.text(16, 16, `Score: 0/${this.targetScore}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.statusText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 }\n    });\n    this.statusText.setOrigin(0.5);\n    this.statusText.setVisible(false);\n\n    // 提示文本\n    this.hintText = this.add.text(400, 550, 'Use Arrow Keys to Move. Collect 15 items to win!', {\n      fontSize: '18px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.hintText.setOrigin(0.5);\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('playerTex', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（绿色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x00ff00, 1);\n    enemyGraphics.fillRect(0, 0, 32, 32);\n    enemyGraphics.generateTexture('enemyTex', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建收集物纹理（黄色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('itemTex', 24, 24);\n    itemGraphics.destroy();\n  }\n\n  createCollectibles() {\n    // 使用固定种子生成随机位置\n    const seed = 12345;\n    const random = this.createSeededRandom(seed);\n\n    for (let i = 0; i < this.targetScore; i++) {\n      let x, y;\n      let validPosition = false;\n\n      // 确保物品不会生成在玩家或AI附近\n      while (!validPosition) {\n        x = random() * 700 + 50; // 50-750\n        y = random() * 500 + 50; // 50-550\n\n        const distToPlayer = Phaser.Math.Distance.Between(x, y, 100, 300);\n        const distToEnemy = Phaser.Math.Distance.Between(x, y, 700, 300);\n\n        if (distToPlayer > 100 && distToEnemy > 100) {\n          validPosition = true;\n        }\n      }\n\n      const item = this.collectibles.create(x, y, 'itemTex');\n      item.setCircle(12);\n    }\n  }\n\n  // 创建固定种子的随机数生成器\n  createSeededRandom(seed) {\n    let currentSeed = seed;\n    return function() {\n      currentSeed = (currentSeed * 9301 + 49297) % 233280;\n      return currentSeed / 233280;\n    };\n  }\n\n  collectItem(player, item) {\n    if (this.gameOver || this.gameWon) return;\n\n    item.destroy();\n    this.score++;\n    this.scoreText.setText(`Score: ${this.score}/${this.targetScore}`);\n\n    // 检查是否获胜\n    if (this.score >= this.targetScore) {\n      this.gameWon = true;\n      this.winGame();\n    }\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver || this.gameWon) return;\n\n    this.gameOver = true;\n    this.loseGame();\n  }\n\n  winGame() {\n    this.physics.pause();\n    this.player.setTint(0x00ff00);\n    \n    this.statusText.setText('YOU WIN!');\n    this.statusText.setStyle({ fill: '#00ff00' });\n    this.statusText.setVisible(true);\n\n    this.hintText.setText('Congratulations! You collected all items!');\n    this.hintText.setStyle({ fill: '#00ff00' });\n  }\n\n  loseGame() {\n    this.physics.pause();\n    this.player.setTint(0xff0000);\n    \n    this.statusText.setText('GAME OVER!');\n    this.statusText.setStyle({ fill: '#ff0000' });\n    this.statusText.setVisible(true);\n\n    this.hintText.setText('You were caught by the AI!');\n    this.hintText.setStyle({ fill: '#ff0000' });\n  }\n\n  update(time, delta) {\n    if (this.gameOver || this.gameWon) return;\n\n    // 玩家移动控制\n    const speed = 200;\n    \n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // AI追踪玩家（速度160）\n    this.physics.moveToObject(this.enemy, this.player, 160);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001800_v2", "prompt_id": "seed_001800", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的绿色矩形，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现可拖拽绿色矩形，拖拽时变色，松手后回到初始位置\nAPI: Graphics, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制绿色矩形并生成纹理\n2. 创建 Sprite 并设置为可交互和可拖拽\n3. 监听 dragstart 事件改变颜色为黄色\n4. 监听 drag 事件更新位置\n5. 监听 dragend 事件恢复绿色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nlet rectangle;\nlet initialX;\nlet initialY;\n\nfunction preload() {\n  // 创建绿色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 80);\n  graphics.generateTexture('greenRect', 100, 80);\n  graphics.destroy();\n  \n  // 创建黄色矩形纹理（拖拽时使用）\n  const graphicsYellow = this.add.graphics();\n  graphicsYellow.fillStyle(0xffff00, 1);\n  graphicsYellow.fillRect(0, 0, 100, 80);\n  graphicsYellow.generateTexture('yellowRect', 100, 80);\n  graphicsYellow.destroy();\n}\n\nfunction create() {\n  // 创建矩形精灵\n  rectangle = this.add.sprite(400, 300, 'greenRect');\n  \n  // 记录初始位置\n  initialX = rectangle.x;\n  initialY = rectangle.y;\n  \n  // 设置为可交互和可拖拽\n  rectangle.setInteractive({ draggable: true });\n  \n  // 监听拖拽开始事件\n  rectangle.on('dragstart', function(pointer) {\n    // 改变为黄色\n    this.setTexture('yellowRect');\n  });\n  \n  // 监听拖拽中事件\n  rectangle.on('drag', function(pointer, dragX, dragY) {\n    // 更新位置跟随指针\n    this.x = dragX;\n    this.y = dragY;\n  });\n  \n  // 监听拖拽结束事件\n  rectangle.on('dragend', function(pointer) {\n    // 恢复绿色\n    this.setTexture('greenRect');\n    \n    // 回到初始位置\n    this.x = initialX;\n    this.y = initialY;\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 50, '拖拽绿色矩形试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '松手后会自动回到中心位置', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000613_v3", "prompt_id": "seed_000613", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的粉色星形，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现可拖拽的粉色星形，拖拽时变色，松手后回到初始位置\nAPI: Graphics.fillStar, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制粉色星形并生成纹理\n2. 创建 Sprite 并启用拖拽交互\n3. 监听 dragstart 事件改变颜色为黄色\n4. 监听 drag 事件更新星形位置\n5. 监听 dragend 事件恢复粉色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n  \n  // 创建粉色星形纹理\n  const pinkGraphics = this.add.graphics();\n  pinkGraphics.fillStyle(0xff69b4, 1); // 粉色\n  pinkGraphics.fillStar(64, 64, 5, 32, 60, 0); // 中心点(64,64), 5个角, 内半径32, 外半径60\n  pinkGraphics.generateTexture('pinkStar', 128, 128);\n  pinkGraphics.destroy();\n  \n  // 创建黄色星形纹理（拖拽时使用）\n  const yellowGraphics = this.add.graphics();\n  yellowGraphics.fillStyle(0xffff00, 1); // 黄色\n  yellowGraphics.fillStar(64, 64, 5, 32, 60, 0);\n  yellowGraphics.generateTexture('yellowStar', 128, 128);\n  yellowGraphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.sprite(initialX, initialY, 'pinkStar');\n  \n  // 启用拖拽交互\n  star.setInteractive({ draggable: true });\n  \n  // 添加提示文本\n  const hintText = this.add.text(400, 50, '拖动星星试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 监听拖拽开始事件\n  star.on('dragstart', (pointer) => {\n    // 改变为黄色\n    star.setTexture('yellowStar');\n    // 增加缩放效果\n    star.setScale(1.1);\n    hintText.setText('拖拽中...');\n  });\n  \n  // 监听拖拽移动事件\n  star.on('drag', (pointer, dragX, dragY) => {\n    // 更新星形位置\n    star.x = dragX;\n    star.y = dragY;\n  });\n  \n  // 监听拖拽结束事件\n  star.on('dragend', (pointer) => {\n    // 恢复粉色\n    star.setTexture('pinkStar');\n    // 恢复缩放\n    star.setScale(1);\n    \n    // 使用补间动画回到初始位置\n    this.tweens.add({\n      targets: star,\n      x: initialX,\n      y: initialY,\n      duration: 300,\n      ease: 'Back.easeOut'\n    });\n    \n    hintText.setText('拖动星星试试！');\n  });\n  \n  // 添加悬停效果\n  star.on('pointerover', () => {\n    star.setScale(1.05);\n  });\n  \n  star.on('pointerout', () => {\n    // 只在非拖拽状态下恢复缩放\n    if (!this.input.dragState) {\n      star.setScale(1);\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000243_v1", "prompt_id": "seed_000243", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现碰撞伤害与蓝色无敌帧：碰撞扣 1 血，之后 3 秒内无敌（闪烁提示），共 12 血，显示血量。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现玩家与敌人碰撞扣血系统，碰撞后进入3秒无敌状态并闪烁，血量上限12，显示血量条\nAPI: Phaser.Physics.Arcade.Collider, Phaser.Time.TimerEvent, Phaser.Tweens.Tween, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家精灵（绿色方块）和敌人精灵（红色方块），使用Graphics生成纯色纹理\n2. 设置Arcade物理系统，添加玩家与敌人的碰撞检测\n3. 实现碰撞回调：检查无敌状态，扣1血，触发3秒无敌计时器\n4. 使用Tween实现无敌期间的闪烁效果（alpha值在0.3和1之间切换）\n5. 绘制血量条UI，实时显示当前血量/最大血量\n6. 添加键盘控制让玩家可移动，敌人随机移动以触发碰撞\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.maxHealth = 12;\n    this.currentHealth = 12;\n    this.isInvincible = false;\n    this.invincibleDuration = 3000; // 3秒\n  }\n\n  preload() {\n    // 使用Graphics生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 40, 40);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人（多个敌人增加碰撞机会）\n    this.enemies = this.physics.add.group();\n    for (let i = 0; i < 3; i++) {\n      const x = Phaser.Math.Between(100, 700);\n      const y = Phaser.Math.Between(100, 500);\n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(1);\n      enemy.setVelocity(\n        Phaser.Math.Between(-150, 150),\n        Phaser.Math.Between(-150, 150)\n      );\n    }\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建血量条背景\n    this.healthBarBg = this.add.graphics();\n    this.healthBarBg.fillStyle(0x333333, 1);\n    this.healthBarBg.fillRect(20, 20, 244, 24);\n\n    // 创建血量条\n    this.healthBar = this.add.graphics();\n    this.updateHealthBar();\n\n    // 血量文本\n    this.healthText = this.add.text(20, 50, `HP: ${this.currentHealth}/${this.maxHealth}`, {\n      fontSize: '20px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 无敌状态文本\n    this.invincibleText = this.add.text(20, 80, '', {\n      fontSize: '18px',\n      color: '#00ffff',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏说明\n    this.add.text(400, 550, '使用方向键移动 | 碰撞红色方块扣1血 | 无敌时闪烁3秒', {\n      fontSize: '16px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setVisible(false);\n  }\n\n  update(time, delta) {\n    if (this.currentHealth <= 0) {\n      return; // 游戏结束，停止更新\n    }\n\n    // 玩家移动\n    const speed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n  }\n\n  handleCollision(player, enemy) {\n    // 如果处于无敌状态，不处理碰撞\n    if (this.isInvincible) {\n      return;\n    }\n\n    // 扣血\n    this.currentHealth -= 1;\n    this.updateHealthBar();\n    this.healthText.setText(`HP: ${this.currentHealth}/${this.maxHealth}`);\n\n    // 检查是否死亡\n    if (this.currentHealth <= 0) {\n      this.handleDeath();\n      return;\n    }\n\n    // 进入无敌状态\n    this.isInvincible = true;\n    this.invincibleText.setText('无敌中...');\n\n    // 创建闪烁效果\n    this.blinkTween = this.tweens.add({\n      targets: this.player,\n      alpha: 0.3,\n      duration: 200,\n      yoyo: true,\n      repeat: -1 // 无限重复\n    });\n\n    // 设置无敌计时器\n    this.time.delayedCall(this.invincibleDuration, () => {\n      this.isInvincible = false;\n      this.invincibleText.setText('');\n      \n      // 停止闪烁，恢复完全不透明\n      if (this.blinkTween) {\n        this.blinkTween.stop();\n        this.player.setAlpha(1);\n      }\n    });\n\n    // 击退效果\n    const angle = Phaser.Math.Angle.Between(\n      enemy.x, enemy.y,\n      player.x, player.y\n    );\n    this.player.setVelocity(\n      Math.cos(angle) * 300,\n      Math.sin(angle) * 300\n    );\n  }\n\n  updateHealthBar() {\n    this.healthBar.clear();\n    \n    // 根据血量比例选择颜色\n    let color;\n    const healthPercent = this.currentHealth / this.maxHealth;\n    if (healthPercent > 0.6) {\n      color = 0x00ff00; // 绿色\n    } else if (healthPercent > 0.3) {\n      color = 0xffff00; // 黄色\n    } else {\n      color = 0xff0000; // 红色\n    }\n\n    this.healthBar.fillStyle(color, 1);\n    const barWidth = (this.currentHealth / this.maxHealth) * 240;\n    this.healthBar.fillRect(22, 22, barWidth, 20);\n  }\n\n  handleDeath() {\n    // 停止物理引擎\n    this.physics.pause();\n    \n    // 停止闪烁\n    if (this.blinkTween) {\n      this.blinkTween.stop();\n    }\n    \n    // 玩家变灰\n    this.player.setTint(0x666666);\n    this.player.setAlpha(1);\n    \n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    \n    // 更新状态文本\n    this.invincibleText.setText('');\n    this.healthText.setText('HP: 0/12');\n    \n    // 添加重启提示\n    this.add.text(400, 370, '刷新页面重新开始', {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001612_v1", "prompt_id": "seed_001612", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按鼠标右键发射子弹，速度 120，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现鼠标右键发射子弹射击敌人，显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Pointer, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家（使用 Graphics 绘制矩形）和敌人组\n2. 监听鼠标右键点击事件，从玩家位置发射子弹\n3. 设置子弹速度为 120，使用物理碰撞检测子弹与敌人\n4. 碰撞时销毁子弹和敌人，增加击杀计数\n5. 在屏幕上显示击杀数文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(5, 5, 5);\n    bulletGraphics.generateTexture('bullet', 10, 10);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 生成初始敌人\n    this.spawnEnemies();\n\n    // 设置碰撞检测：子弹与敌人\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 监听鼠标右键点击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown()) {\n        this.shootBullet(pointer);\n      }\n    });\n\n    // 显示击杀数文本\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加键盘控制（可选，方便玩家移动）\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 定时生成敌人\n    this.time.addEvent({\n      delay: 2000,\n      callback: this.spawnEnemies,\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active && (bullet.y < -10 || bullet.y > 610 || bullet.x < -10 || bullet.x > 810)) {\n        bullet.setActive(false);\n        bullet.setVisible(false);\n      }\n    });\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active && enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  shootBullet(pointer) {\n    // 获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n\n      // 计算从玩家到鼠标点击位置的方向\n      const angle = Phaser.Math.Angle.Between(\n        this.player.x,\n        this.player.y,\n        pointer.x,\n        pointer.y\n      );\n\n      // 设置子弹速度（速度 120）\n      const speed = 120;\n      bullet.setVelocity(\n        Math.cos(angle) * speed,\n        Math.sin(angle) * speed\n      );\n\n      // 设置子弹旋转角度\n      bullet.setRotation(angle);\n    }\n  }\n\n  spawnEnemies() {\n    // 随机生成 2-4 个敌人\n    const count = Phaser.Math.Between(2, 4);\n    \n    for (let i = 0; i < count; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const enemy = this.enemies.create(x, -30, 'enemy');\n      \n      if (enemy) {\n        enemy.setVelocityY(Phaser.Math.Between(50, 100));\n      }\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹命中敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.setVelocity(0, 0);\n    \n    enemy.destroy();\n\n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001114_v3", "prompt_id": "seed_001114", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的红色矩形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的红色矩形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 生命周期中循环8次\n3. 每次循环创建一个 Graphics 对象，设置红色填充样式\n4. 使用 Phaser.Math.Between 生成随机 x、y 坐标\n5. 使用 fillRect 绘制 32x32 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建8个红色矩形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充样式\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 生成随机位置（确保矩形完全在画布内）\n    const x = Phaser.Math.Between(0, 800 - 32);\n    const y = Phaser.Math.Between(0, 600 - 32);\n    \n    // 绘制 32x32 的矩形\n    graphics.fillRect(x, y, 32, 32);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000175_v3", "prompt_id": "seed_000175", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 3 个金币，重力 1000，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集3个金币，重力1000，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 配置物理系统，设置重力为1000\n2. 使用Graphics创建玩家角色、平台和金币的纹理\n3. 添加键盘输入控制（左右移动和跳跃）\n4. 实现碰撞检测：玩家与平台、玩家与金币\n5. 收集金币时增加分数并销毁金币\n6. 在屏幕上显示分数文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.2);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 地面平台\n    this.platforms.create(400, 568, 'platform').setScale(4, 1).refreshBody();\n    \n    // 中间平台\n    this.platforms.create(200, 400, 'platform');\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(400, 250, 'platform');\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在平台上方放置3个金币\n    this.coins.create(200, 350, 'coin');\n    this.coins.create(600, 350, 'coin');\n    this.coins.create(400, 200, 'coin');\n\n    // 设置金币属性\n    this.coins.children.iterate((coin) => {\n      coin.setBounceY(Phaser.Math.FloatBetween(0.4, 0.6));\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n    \n    // 添加金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontStyle: 'bold'\n    });\n\n    // 添加游戏说明\n    this.add.text(400, 50, 'Use Arrow Keys to Move and Jump\\nCollect all 3 coins!', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      align: 'center'\n    }).setOrigin(0.5);\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      this.add.text(400, 300, 'You Win!\\nScore: ' + this.score, {\n        fontSize: '48px',\n        fill: '#00ff00',\n        fontStyle: 'bold',\n        align: 'center'\n      }).setOrigin(0.5);\n      \n      // 暂停游戏\n      this.physics.pause();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000872_v2", "prompt_id": "seed_000872", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.43}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 每隔 2.5 秒在随机位置生成一个蓝色椭圆，最多生成 12 个。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Time.TimerEvent\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 每隔2.5秒在随机位置生成蓝色椭圆，最多12个\nAPI: Phaser.Time.Clock#addEvent, Phaser.GameObjects.Graphics, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建 Scene 并初始化计数器变量\n2. 在 create 中使用 time.addEvent 创建定时器，设置 delay 为 2500ms，repeat 为 11 次（共12次）\n3. 在定时器回调中生成随机坐标（考虑边界），使用 Graphics 或 Ellipse 绘制蓝色椭圆\n4. 将生成的椭圆添加到场景中\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 椭圆计数器\n  let ellipseCount = 0;\n  const maxEllipses = 12;\n  \n  // 椭圆尺寸参数\n  const ellipseWidth = 60;\n  const ellipseHeight = 40;\n  \n  // 添加标题文本\n  this.add.text(10, 10, '蓝色椭圆生成器', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  \n  // 添加计数显示\n  const countText = this.add.text(10, 50, `已生成: ${ellipseCount} / ${maxEllipses}`, {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n  \n  // 创建定时器事件，每2.5秒触发一次\n  this.time.addEvent({\n    delay: 2500,                    // 2.5秒\n    callback: generateEllipse,      // 回调函数\n    callbackScope: this,            // 回调作用域\n    loop: false,                    // 不循环\n    repeat: maxEllipses - 1         // 重复11次（加上首次共12次）\n  });\n  \n  // 生成椭圆的函数\n  function generateEllipse() {\n    // 计算随机位置（考虑椭圆尺寸，避免超出边界）\n    const margin = Math.max(ellipseWidth, ellipseHeight) / 2;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin + 80, config.height - margin);\n    \n    // 使用 Graphics 绘制蓝色椭圆\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0066ff, 1);  // 蓝色\n    graphics.fillEllipse(randomX, randomY, ellipseWidth, ellipseHeight);\n    \n    // 添加轻微的边框效果\n    graphics.lineStyle(2, 0x0044cc, 1);\n    graphics.strokeEllipse(randomX, randomY, ellipseWidth, ellipseHeight);\n    \n    // 更新计数\n    ellipseCount++;\n    countText.setText(`已生成: ${ellipseCount} / ${maxEllipses}`);\n    \n    // 添加生成动画效果（可选）\n    const tempCircle = this.add.circle(randomX, randomY, 5, 0xffffff, 0.8);\n    this.tweens.add({\n      targets: tempCircle,\n      alpha: 0,\n      scale: 3,\n      duration: 500,\n      onComplete: () => {\n        tempCircle.destroy();\n      }\n    });\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000797_v3", "prompt_id": "seed_000797", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色椭圆，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色椭圆，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为橙色（0xFFA500）\n4. 使用 fillEllipse 在画布中央（400, 300）绘制椭圆，宽高约 80 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为橙色\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 为椭圆中心点坐标\n  // width 为椭圆宽度，height 为椭圆高度\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  const ellipseWidth = 80;\n  const ellipseHeight = 80;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000102_v2", "prompt_id": "seed_000102", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在2秒内缩放到24%再恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建缩放动画，从 scale=1 到 scale=0.24 再回到 scale=1\n4. 设置 Tween 的 yoyo 和 loop 属性实现往返循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 三角形中心点在 (50, 50)，边长约 80\n  graphics.beginPath();\n  graphics.moveTo(50, 10);      // 顶点\n  graphics.lineTo(10, 80);       // 左下角\n  graphics.lineTo(90, 80);       // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  // 使用 yoyo 实现从 1 -> 0.24 -> 1 的效果\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 1000,        // 1秒缩小到24%\n    yoyo: true,            // 动画反向播放（回到原始大小）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加提示文字\n  const text = this.add.text(400, 500, '三角形循环缩放动画\\n1秒缩小到24% → 1秒恢复', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000117_v2", "prompt_id": "seed_000117", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示 \"Hello Phaser\" 文字，字体大小 48px\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小 48px\n4. 将文本定位在屏幕下方中央位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文本对象\n  const text = this.add.text(\n    400,  // x 坐标（屏幕中央）\n    550,  // y 坐标（屏幕下方）\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '48px',  // 字体大小\n      color: '#ffffff',  // 文字颜色（白色）\n      fontFamily: 'Arial'  // 字体\n    }\n  );\n\n  // 设置文本原点为中心，使其居中对齐\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000022_v3", "prompt_id": "seed_000022", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色物体拖拽排序：15 个物体可拖拽，松手后按 Y 坐标自动排列。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现15个紫色物体可拖拽，松手后按Y坐标自动排列\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin.setDraggable, Phaser.Input.Events.DRAG, Phaser.Input.Events.DRAG_END, Phaser.Tweens.TweenManager\nSTEPS:\n1. 创建15个紫色矩形物体并生成纹理\n2. 为每个物体设置可拖拽属性，监听拖拽事件\n3. 拖拽时更新物体位置\n4. 松手后收集所有物体的Y坐标并排序\n5. 使用补间动画将物体移动到新的排序位置\n6. 添加状态变量记录拖拽次数和排序状态\n[/PLAN]\n\n```javascript\nclass DragSortScene extends Phaser.Scene {\n  constructor() {\n    super('DragSortScene');\n    this.dragCount = 0; // 状态信号：拖拽次数\n    this.sortedCount = 0; // 状态信号：排序次数\n    this.objects = [];\n  }\n\n  preload() {\n    // 使用 Graphics 创建紫色矩形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x9B59B6, 1); // 紫色\n    graphics.fillRect(0, 0, 60, 60);\n    graphics.lineStyle(2, 0xFFFFFF, 1);\n    graphics.strokeRect(0, 0, 60, 60);\n    graphics.generateTexture('purpleBox', 60, 60);\n    graphics.destroy();\n  }\n\n  create() {\n    // 添加标题\n    this.add.text(400, 30, '拖拽紫色方块，松手后自动按Y坐标排序', {\n      fontSize: '20px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 添加状态显示\n    this.statusText = this.add.text(400, 60, '拖拽次数: 0 | 排序次数: 0', {\n      fontSize: '16px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 创建15个紫色物体\n    const startX = 100;\n    const startY = 120;\n    const spacing = 50;\n\n    for (let i = 0; i < 15; i++) {\n      // 随机位置分布\n      const x = startX + (i % 5) * 140;\n      const y = startY + Math.floor(i / 5) * 140;\n      \n      const obj = this.add.sprite(x, y, 'purpleBox');\n      obj.setInteractive({ draggable: true });\n      \n      // 添加编号文本\n      const text = this.add.text(x, y, (i + 1).toString(), {\n        fontSize: '24px',\n        color: '#ffffff',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n      \n      // 将文本作为物体的子对象\n      obj.labelText = text;\n      obj.initialIndex = i;\n      \n      this.objects.push(obj);\n    }\n\n    // 设置拖拽事件\n    this.input.on('drag', (pointer, gameObject, dragX, dragY) => {\n      gameObject.x = dragX;\n      gameObject.y = dragY;\n      \n      // 同步更新文本位置\n      if (gameObject.labelText) {\n        gameObject.labelText.x = dragX;\n        gameObject.labelText.y = dragY;\n      }\n    });\n\n    this.input.on('dragstart', (pointer, gameObject) => {\n      // 拖拽开始时提升深度\n      gameObject.setDepth(1);\n      if (gameObject.labelText) {\n        gameObject.labelText.setDepth(2);\n      }\n      \n      // 增加拖拽计数\n      this.dragCount++;\n      this.updateStatus();\n    });\n\n    this.input.on('dragend', (pointer, gameObject) => {\n      // 恢复深度\n      gameObject.setDepth(0);\n      if (gameObject.labelText) {\n        gameObject.labelText.setDepth(1);\n      }\n      \n      // 松手后执行排序\n      this.sortObjectsByY();\n    });\n\n    // 添加提示文本\n    this.add.text(400, 550, '提示：拖动任意方块后松手，所有方块将按Y坐标排序', {\n      fontSize: '14px',\n      color: '#ffff00'\n    }).setOrigin(0.5);\n  }\n\n  sortObjectsByY() {\n    // 收集所有物体及其当前Y坐标\n    const objectsData = this.objects.map(obj => ({\n      obj: obj,\n      y: obj.y,\n      x: obj.x\n    }));\n\n    // 按Y坐标排序\n    objectsData.sort((a, b) => a.y - b.y);\n\n    // 计算新的排列位置（垂直排列，居中）\n    const startX = 400;\n    const startY = 120;\n    const verticalSpacing = 30;\n\n    // 为每个物体分配新位置并执行动画\n    objectsData.forEach((data, index) => {\n      const newY = startY + index * verticalSpacing;\n      const newX = startX;\n\n      // 使用补间动画移动到新位置\n      this.tweens.add({\n        targets: data.obj,\n        x: newX,\n        y: newY,\n        duration: 500,\n        ease: 'Power2',\n        onUpdate: () => {\n          // 同步更新文本位置\n          if (data.obj.labelText) {\n            data.obj.labelText.x = data.obj.x;\n            data.obj.labelText.y = data.obj.y;\n          }\n        }\n      });\n\n      // 同时为文本添加动画\n      if (data.obj.labelText) {\n        this.tweens.add({\n          targets: data.obj.labelText,\n          x: newX,\n          y: newY,\n          duration: 500,\n          ease: 'Power2'\n        });\n      }\n    });\n\n    // 增加排序计数\n    this.sortedCount++;\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    this.statusText.setText(`拖拽次数: ${this.dragCount} | 排序次数: ${this.sortedCount}`);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: DragSortScene,\n  parent: 'game-container'\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001426_v1", "prompt_id": "seed_001426", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在1.5秒内缩放到16%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制星形并生成纹理\n2. 创建星形精灵对象放置在画布中心\n3. 使用 Tween 动画实现缩放效果（scale: 1 -> 0.16 -> 1）\n4. 设置 loop: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.sprite(400, 300, 'star');\n  star.setOrigin(0.5, 0.5);\n  \n  // 创建缩放动画\n  // 使用 yoyo 实现缩放到16%后恢复\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 1500, // 1.5秒\n    ease: 'Sine.easeInOut',\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    loop: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 550, 'Star scaling animation: 100% → 16% → 100% (loop)', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000406_v3", "prompt_id": "seed_000406", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 5 个粉色物体以 80 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 5个粉色物体以80速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity, setCollideWorldBounds\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成粉色圆形纹理\n3. 创建物理组并添加 5 个粉色物体\n4. 为每个物体设置随机速度（80像素/秒）和反弹属性\n5. 设置物体间碰撞检测和世界边界碰撞\n6. 添加状态变量记录碰撞次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建粉色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF69B4, 1); // 粉色\n    graphics.fillCircle(20, 20, 20); // 半径20的圆\n    graphics.generateTexture('pinkBall', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.pinkBalls = this.physics.add.group({\n      key: 'pinkBall',\n      repeat: 4, // 创建5个物体（0-4）\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 为每个物体设置随机位置和速度\n    this.pinkBalls.children.iterate((ball) => {\n      // 随机位置（避免边界）\n      const x = Phaser.Math.Between(100, 700);\n      const y = Phaser.Math.Between(100, 500);\n      ball.setPosition(x, y);\n\n      // 随机方向，固定速度80\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 80;\n      const velocityY = Math.sin(angle) * 80;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体（更精确）\n      ball.setCircle(20);\n    });\n\n    // 设置物体之间的碰撞\n    this.physics.add.collider(\n      this.pinkBalls, \n      this.pinkBalls,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 显示碰撞计数（用于验证）\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示物体数量（用于验证）\n    this.countText = this.add.text(10, 40, 'Pink Balls: 5', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示平均速度（用于验证）\n    this.speedText = this.add.text(10, 70, 'Avg Speed: 80', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  handleCollision(ball1, ball2) {\n    // 记录碰撞次数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 计算平均速度用于验证\n    let totalSpeed = 0;\n    let count = 0;\n    \n    this.pinkBalls.children.iterate((ball) => {\n      const velocity = ball.body.velocity;\n      const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      totalSpeed += speed;\n      count++;\n    });\n\n    if (count > 0) {\n      const avgSpeed = Math.round(totalSpeed / count);\n      this.speedText.setText('Avg Speed: ' + avgSpeed);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001411_v3", "prompt_id": "seed_001411", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现 AI 对战：白色AI 角色以 300 速度追踪玩家，玩家收集 20 个物品获胜，被 AI 碰到失败。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现AI追踪玩家的收集游戏，玩家需收集20个物品获胜，被AI碰到则失败\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.moveToObject, Phaser.Input.Keyboard, Phaser.Physics.Arcade.overlap\nSTEPS:\n1. 创建物理系统和场景配置\n2. 使用Graphics生成玩家(蓝色)、AI(白色)、收集物(黄色)纹理\n3. 创建玩家精灵，使用键盘控制移动\n4. 创建AI精灵，使用moveToObject以300速度追踪玩家\n5. 随机生成20个收集物并使用物理组管理\n6. 添加碰撞检测：玩家与收集物重叠则计分，与AI重叠则失败\n7. 实现游戏状态管理(playing/win/lose)和UI显示\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.gameState = 'playing'; // playing, win, lose\n    this.totalItems = 20;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成纹理\n    this.createTextures();\n\n    // 创建玩家 (蓝色方块)\n    this.player = this.physics.add.sprite(100, 100, 'playerTex');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建AI (白色方块)\n    this.ai = this.physics.add.sprite(700, 500, 'aiTex');\n    this.ai.setCollideWorldBounds(true);\n\n    // 创建收集物组\n    this.items = this.physics.add.group();\n    this.createItems();\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(this.player, this.items, this.collectItem, null, this);\n    this.physics.add.overlap(this.player, this.ai, this.hitByAI, null, this);\n\n    // UI文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0 / 20', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    this.statusText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ffffff',\n      align: 'center'\n    }).setOrigin(0.5);\n    this.statusText.setVisible(false);\n  }\n\n  createTextures() {\n    // 玩家纹理 (蓝色)\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('playerTex', 32, 32);\n    playerGraphics.destroy();\n\n    // AI纹理 (白色)\n    const aiGraphics = this.add.graphics();\n    aiGraphics.fillStyle(0xffffff, 1);\n    aiGraphics.fillRect(0, 0, 32, 32);\n    aiGraphics.generateTexture('aiTex', 32, 32);\n    aiGraphics.destroy();\n\n    // 收集物纹理 (黄色圆形)\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(8, 8, 8);\n    itemGraphics.generateTexture('itemTex', 16, 16);\n    itemGraphics.destroy();\n  }\n\n  createItems() {\n    // 使用固定种子生成随机位置\n    const positions = [];\n    const seed = 12345;\n    let random = seed;\n    \n    // 简单的伪随机数生成器\n    const seededRandom = () => {\n      random = (random * 9301 + 49297) % 233280;\n      return random / 233280;\n    };\n\n    // 生成20个不重叠的位置\n    for (let i = 0; i < this.totalItems; i++) {\n      let x, y, valid;\n      let attempts = 0;\n      \n      do {\n        valid = true;\n        x = 50 + seededRandom() * 700;\n        y = 50 + seededRandom() * 500;\n        \n        // 检查与玩家和AI的距离\n        if (Phaser.Math.Distance.Between(x, y, 100, 100) < 80 ||\n            Phaser.Math.Distance.Between(x, y, 700, 500) < 80) {\n          valid = false;\n        }\n        \n        // 检查与其他物品的距离\n        for (let pos of positions) {\n          if (Phaser.Math.Distance.Between(x, y, pos.x, pos.y) < 40) {\n            valid = false;\n            break;\n          }\n        }\n        \n        attempts++;\n        if (attempts > 100) break; // 防止无限循环\n      } while (!valid);\n      \n      positions.push({ x, y });\n      const item = this.items.create(x, y, 'itemTex');\n      item.setCircle(8);\n    }\n  }\n\n  collectItem(player, item) {\n    if (this.gameState !== 'playing') return;\n\n    item.destroy();\n    this.score++;\n    this.scoreText.setText(`Score: ${this.score} / ${this.totalItems}`);\n\n    if (this.score >= this.totalItems) {\n      this.winGame();\n    }\n  }\n\n  hitByAI(player, ai) {\n    if (this.gameState !== 'playing') return;\n    this.loseGame();\n  }\n\n  winGame() {\n    this.gameState = 'win';\n    this.statusText.setText('YOU WIN!\\nCollected all items!');\n    this.statusText.setVisible(true);\n    this.physics.pause();\n  }\n\n  loseGame() {\n    this.gameState = 'lose';\n    this.statusText.setText('GAME OVER!\\nCaught by AI!');\n    this.statusText.setVisible(true);\n    this.physics.pause();\n  }\n\n  update(time, delta) {\n    if (this.gameState !== 'playing') return;\n\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 归一化对角线速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.setVelocity(\n        this.player.body.velocity.x * 0.707,\n        this.player.body.velocity.y * 0.707\n      );\n    }\n\n    // AI追踪玩家，速度固定为300\n    this.physics.moveToObject(this.ai, this.player, 300);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001692_v1", "prompt_id": "seed_001692", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 12 个灰色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 12 个灰色可复用对象，离开屏幕后自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, this.physics.add.group\nSTEPS:\n1. 创建 Graphics 生成灰色方块纹理\n2. 使用 physics.add.group 创建对象池，设置 maxSize 为 12\n3. 在 create 中初始化对象池，设置对象的初始速度和属性\n4. 在 update 中检测对象是否离开屏幕边界\n5. 对象离开屏幕后调用 kill/disableBody 回收到对象池\n6. 定时从对象池中获取对象并重新激活，形成循环复用\n7. 添加状态变量追踪活跃对象数和复用次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.recycleCount = 0;     // 总回收次数\n    this.spawnCount = 0;       // 总生成次数\n  }\n\n  preload() {\n    // 创建灰色方块纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('grayBox', 40, 40);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建对象池，最多 12 个对象\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'grayBox',\n      maxSize: 12,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n        obj.body.enable = false;\n      }\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 定时生成对象（每 500ms 生成一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 初始生成几个对象\n    for (let i = 0; i < 5; i++) {\n      this.time.delayedCall(i * 100, () => this.spawnObject());\n    }\n  }\n\n  spawnObject() {\n    // 从对象池获取或创建对象\n    let obj = this.objectPool.get();\n    \n    if (!obj) {\n      // 如果池已满且没有可用对象，不创建新对象\n      return;\n    }\n\n    // 激活对象\n    obj.setActive(true);\n    obj.setVisible(true);\n    obj.body.enable = true;\n\n    // 随机位置和速度\n    const startX = Phaser.Math.Between(50, 750);\n    const startY = -50;\n    const velocityX = Phaser.Math.Between(-100, 100);\n    const velocityY = Phaser.Math.Between(100, 200);\n\n    obj.setPosition(startX, startY);\n    obj.setVelocity(velocityX, velocityY);\n    obj.setAngularVelocity(Phaser.Math.Between(-180, 180));\n\n    this.spawnCount++;\n    this.activeCount++;\n  }\n\n  recycleObject(obj) {\n    // 回收对象到池中\n    obj.setActive(false);\n    obj.setVisible(false);\n    obj.body.enable = false;\n    obj.setVelocity(0, 0);\n    obj.setAngularVelocity(0);\n    obj.setRotation(0);\n\n    this.recycleCount++;\n    this.activeCount--;\n  }\n\n  update(time, delta) {\n    // 检查所有活跃对象\n    this.objectPool.children.entries.forEach((obj) => {\n      if (obj.active) {\n        // 检查是否离开屏幕\n        if (obj.y > 650 || obj.x < -50 || obj.x > 850) {\n          this.recycleObject(obj);\n        }\n      }\n    });\n\n    // 更新状态显示\n    const poolSize = this.objectPool.getLength();\n    const totalUsed = this.objectPool.getTotalUsed();\n    \n    this.statusText.setText([\n      `Pool Size: ${poolSize} / 12`,\n      `Active Objects: ${this.activeCount}`,\n      `Total Spawned: ${this.spawnCount}`,\n      `Total Recycled: ${this.recycleCount}`,\n      `Pool Used: ${totalUsed}`,\n      `Reuse Rate: ${this.spawnCount > 0 ? Math.floor((this.recycleCount / this.spawnCount) * 100) : 0}%`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001090_v2", "prompt_id": "seed_001090", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 20 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成20个白色可收集物体，玩家碰到后消失并加分，显示score\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 配置物理系统和场景\n2. 使用 Graphics 生成玩家和可收集物体的纹理\n3. 创建玩家精灵和物理组，随机生成20个可收集物体\n4. 添加键盘控制让玩家移动\n5. 使用 overlap 检测碰撞，碰到后销毁物体并增加分数\n6. 创建 Text 显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.scoreText = null;\n    this.player = null;\n    this.collectibles = null;\n    this.cursors = null;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建可收集物体纹理（白色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffffff, 1);\n    collectibleGraphics.fillCircle(10, 10, 10);\n    collectibleGraphics.generateTexture('collectible', 20, 20);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建可收集物体组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成20个可收集物体\n    for (let i = 0; i < 20; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCircle(10); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加边界\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0x00ff00, 1);\n    graphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁可收集物体\n    collectible.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有物体\n    if (this.collectibles.countActive(true) === 0) {\n      this.scoreText.setText('Score: ' + this.score + ' - YOU WIN!');\n      this.physics.pause();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000889_v2", "prompt_id": "seed_000889", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让青色椭圆在 2.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色椭圆，使用 Tween 动画在 2.5 秒内完成一次旋转并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.generateTexture, Phaser.GameObjects.Sprite, Phaser.Tweens.TweenManager.add\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画让椭圆旋转 360 度（2π 弧度）\n4. 设置 Tween 为循环模式（loop: -1）和持续时间 2500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制椭圆（中心点在 0,0，宽度 120，高度 80）\n  graphics.fillEllipse(0, 0, 120, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 在屏幕中心创建椭圆精灵\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    angle: 360,                 // 旋转到 360 度\n    duration: 2500,             // 持续时间 2.5 秒\n    ease: 'Linear',             // 线性缓动，保持匀速旋转\n    repeat: -1,                 // 无限循环 (-1 表示永久循环)\n    onRepeat: function() {\n      // 每次循环重置角度，避免数值累积\n      ellipse.angle = 0;\n    }\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '青色椭圆旋转动画\\n2.5秒一圈，无限循环', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000739_v2", "prompt_id": "seed_000739", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在0.5秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 实现缩放动画（scale: 0.32），设置 yoyo 模式实现恢复\n4. 设置 loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制菱形（中心点在 50, 50）\n  const size = 50;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 顶点\n  graphics.lineTo(size * 2, size);    // 右点\n  graphics.lineTo(size, size * 2);    // 底点\n  graphics.lineTo(0, size);           // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 500,        // 0.5秒\n    yoyo: true,           // 播放完后反向播放（恢复原始大小）\n    loop: -1,             // 无限循环\n    ease: 'Linear'        // 线性缓动\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 500, '菱形缩放动画（循环播放）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000408_v1", "prompt_id": "seed_000408", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色三角形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色三角形在1.5秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillTriangle, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制红色三角形\n2. 创建补间动画，设置起始位置在左侧，目标位置在右侧\n3. 设置动画时长为1.5秒，启用 yoyo 实现往返，repeat 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制三角形（等腰三角形）\n  // 参数：x1, y1, x2, y2, x3, y3\n  graphics.fillTriangle(\n    0, -30,    // 顶点（上）\n    -25, 30,   // 左下角\n    25, 30     // 右下角\n  );\n  \n  // 设置初始位置在左侧\n  graphics.setPosition(100, 300);\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 1500,              // 动画时长 1.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000220_v1", "prompt_id": "seed_000220", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 3 个金币，重力 1000，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集3个空中金币，重力1000，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力为 1000\n2. 使用 Graphics 生成角色、平台、金币的纹理\n3. 创建玩家精灵并添加物理属性，设置碰撞边界\n4. 创建静态平台组，放置地面和跳跃平台\n5. 创建金币组（3个），放置在空中不同位置\n6. 添加键盘输入监听（方向键控制移动和跳跃）\n7. 设置玩家与平台的碰撞检测\n8. 设置玩家与金币的重叠检测，收集时增加分数并销毁金币\n9. 创建分数文本显示，实时更新\n10. 在 update 中处理移动逻辑\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.player = null;\n    this.platforms = null;\n    this.coins = null;\n    this.cursors = null;\n    this.scoreText = null;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建地面纹理（深灰色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x444444, 1);\n    groundGraphics.fillRect(0, 0, 800, 32);\n    groundGraphics.generateTexture('ground', 800, 32);\n    groundGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 创建静态平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加地面\n    const ground = this.platforms.create(400, 584, 'ground');\n    ground.setScale(1).refreshBody();\n\n    // 添加跳跃平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 380, 'platform');\n    this.platforms.create(400, 280, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setGravityY(0); // 使用世界重力\n\n    // 创建金币组\n    this.coins = this.physics.add.group({\n      key: 'coin',\n      repeat: 2,\n      setXY: { x: 200, y: 350, stepX: 200 }\n    });\n\n    // 调整金币位置，使其更具挑战性\n    this.coins.children.entries[0].setPosition(200, 350);\n    this.coins.children.entries[1].setPosition(600, 280);\n    this.coins.children.entries[2].setPosition(400, 180);\n\n    // 设置金币的物理属性\n    this.coins.children.iterate((coin) => {\n      coin.setBounceY(Phaser.Math.FloatBetween(0.2, 0.4));\n      coin.setCollideWorldBounds(true);\n      coin.body.setAllowGravity(false); // 金币不受重力影响\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms);\n\n    // 添加金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 添加游戏说明文本\n    this.add.text(16, 56, 'Arrow Keys: Move & Jump', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n\n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      // 显示胜利信息\n      const winText = this.add.text(400, 300, 'YOU WIN!', {\n        fontSize: '64px',\n        fill: '#ffdd00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6\n      });\n      winText.setOrigin(0.5);\n\n      // 暂停物理系统\n      this.physics.pause();\n    }\n  }\n\n  update(time, delta) {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000872_v1", "prompt_id": "seed_000872", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.42000000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现碰撞伤害与粉色无敌帧：碰撞扣 1 血，之后 0.5 秒内无敌（闪烁提示），共 12 血，显示血量。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现碰撞伤害系统，玩家碰撞敌人扣1血，触发0.5秒无敌闪烁效果，总血量12，显示血量条\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Tweens, Phaser.Time.TimerEvent, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家精灵（绿色方块）和敌人精灵（红色方块），启用物理系统\n2. 添加碰撞检测，碰撞时扣1血并触发无敌状态\n3. 实现无敌状态：设置0.5秒计时器，期间闪烁（alpha透明度切换）并变为粉色\n4. 创建血量条UI，实时显示当前血量/最大血量\n5. 血量为0时显示游戏结束\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.maxHealth = 12;\n    this.currentHealth = 12;\n    this.isInvincible = false;\n    this.invincibleDuration = 500; // 0.5秒\n  }\n\n  preload() {\n    // 程序化生成纹理\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建玩家无敌状态纹理（粉色方块）\n    const invincibleGraphics = this.add.graphics();\n    invincibleGraphics.fillStyle(0xff69b4, 1); // 粉色\n    invincibleGraphics.fillRect(0, 0, 40, 40);\n    invincibleGraphics.generateTexture('playerInvincible', 40, 40);\n    invincibleGraphics.destroy();\n\n    // 创建敌人纹理（红色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 35, 35);\n    enemyGraphics.generateTexture('enemy', 35, 35);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 创建多个敌人\n    for (let i = 0; i < 5; i++) {\n      const x = 100 + i * 150;\n      const y = 100 + (i % 2) * 100;\n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setVelocity(\n        Phaser.Math.Between(-100, 100),\n        Phaser.Math.Between(-100, 100)\n      );\n      enemy.setBounce(1);\n      enemy.setCollideWorldBounds(true);\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建UI\n    this.createUI();\n\n    // 闪烁计时器引用\n    this.blinkTimer = null;\n  }\n\n  createUI() {\n    // 血量文本\n    this.healthText = this.add.text(16, 16, '', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.updateHealthDisplay();\n\n    // 血量条背景\n    this.healthBarBg = this.add.graphics();\n    this.healthBarBg.fillStyle(0x333333, 1);\n    this.healthBarBg.fillRect(16, 50, 204, 24);\n\n    // 血量条\n    this.healthBar = this.add.graphics();\n    this.updateHealthBar();\n\n    // 无敌状态指示\n    this.invincibleText = this.add.text(16, 85, '', {\n      fontSize: '18px',\n      fill: '#ff69b4',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000',\n      fontFamily: 'Arial'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n  }\n\n  updateHealthDisplay() {\n    this.healthText.setText(`Health: ${this.currentHealth} / ${this.maxHealth}`);\n  }\n\n  updateHealthBar() {\n    this.healthBar.clear();\n    \n    // 根据血量计算颜色\n    const healthPercent = this.currentHealth / this.maxHealth;\n    let color = 0x00ff00; // 绿色\n    if (healthPercent <= 0.3) {\n      color = 0xff0000; // 红色\n    } else if (healthPercent <= 0.6) {\n      color = 0xffaa00; // 橙色\n    }\n\n    this.healthBar.fillStyle(color, 1);\n    const barWidth = (this.currentHealth / this.maxHealth) * 200;\n    this.healthBar.fillRect(18, 52, barWidth, 20);\n  }\n\n  handleCollision(player, enemy) {\n    // 如果处于无敌状态，忽略碰撞\n    if (this.isInvincible) {\n      return;\n    }\n\n    // 扣血\n    this.currentHealth -= 1;\n    this.updateHealthDisplay();\n    this.updateHealthBar();\n\n    // 检查是否死亡\n    if (this.currentHealth <= 0) {\n      this.gameOver();\n      return;\n    }\n\n    // 触发无敌状态\n    this.startInvincibility();\n  }\n\n  startInvincibility() {\n    this.isInvincible = true;\n    \n    // 切换到粉色纹理\n    this.player.setTexture('playerInvincible');\n    \n    // 更新无敌状态文本\n    this.invincibleText.setText('INVINCIBLE!');\n\n    // 创建闪烁效果\n    let blinkCount = 0;\n    const maxBlinks = 10; // 0.5秒内闪烁10次\n    \n    this.blinkTimer = this.time.addEvent({\n      delay: this.invincibleDuration / maxBlinks,\n      callback: () => {\n        blinkCount++;\n        // 切换透明度实现闪烁\n        this.player.alpha = this.player.alpha === 1 ? 0.3 : 1;\n      },\n      repeat: maxBlinks - 1\n    });\n\n    // 无敌时间结束\n    this.time.delayedCall(this.invincibleDuration, () => {\n      this.endInvincibility();\n    });\n  }\n\n  endInvincibility() {\n    this.isInvincible = false;\n    \n    // 恢复正常纹理\n    this.player.setTexture('player');\n    this.player.alpha = 1;\n    \n    // 清除无敌状态文本\n    this.invincibleText.setText('');\n    \n    // 清理闪烁计时器\n    if (this.blinkTimer) {\n      this.blinkTimer.remove();\n      this.blinkTimer = null;\n    }\n  }\n\n  gameOver() {\n    // 停止所有物理运动\n    this.physics.pause();\n    \n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    \n    // 添加重启提示\n    const restartText = this.add.text(400, 380, 'Click to Restart', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    restartText.setOrigin(0.5);\n    \n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n\n  update(time, delta) {\n    // 如果游戏结束，不更新\n    if (this.currentHealth <= 0) {\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 200;\n    \n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001683_v3", "prompt_id": "seed_001683", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.4}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 暂停菜单：按空格键暂停并显示菜单（继续/重新开始/返回主菜单三个选项）。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Scene\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现带三个选项（继续/重新开始/返回主菜单）的暂停菜单，按空格键切换暂停状态\nAPI: Phaser.Scene, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.GameObjects.Rectangle, Phaser.Scene.scene\nSTEPS:\n1. 创建主游戏场景（GameScene）和主菜单场景（MainMenuScene），包含游戏状态变量（score/isPaused）\n2. 在 GameScene 中监听空格键，切换暂停状态\n3. 暂停时创建半透明遮罩层和菜单UI（标题+三个选项按钮）\n4. 为每个菜单选项添加鼠标悬停效果和点击事件处理\n5. 实现继续游戏、重新开始和返回主菜单的逻辑\n6. 暂停时停止游戏更新，恢复时继续更新\n[/PLAN]\n\n```javascript\n// 主菜单场景\nclass MainMenuScene extends Phaser.Scene {\n  constructor() {\n    super('MainMenuScene');\n  }\n\n  preload() {}\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x1a1a2e, 1);\n    bg.fillRect(0, 0, width, height);\n\n    // 标题\n    const title = this.add.text(width / 2, height / 3, 'MAIN MENU', {\n      fontSize: '48px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    });\n    title.setOrigin(0.5);\n\n    // 开始游戏按钮\n    const startButton = this.createButton(\n      width / 2,\n      height / 2,\n      'START GAME',\n      () => {\n        this.scene.start('GameScene');\n      }\n    );\n\n    // 提示文字\n    const hint = this.add.text(width / 2, height * 0.8, 'Press SPACE to pause during game', {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#888888'\n    });\n    hint.setOrigin(0.5);\n  }\n\n  createButton(x, y, text, callback) {\n    const button = this.add.container(x, y);\n\n    const bg = this.add.graphics();\n    bg.fillStyle(0x4a4a6a, 1);\n    bg.fillRoundedRect(-100, -25, 200, 50, 8);\n\n    const label = this.add.text(0, 0, text, {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n    label.setOrigin(0.5);\n\n    button.add([bg, label]);\n    button.setSize(200, 50);\n    button.setInteractive({ useHandCursor: true });\n\n    button.on('pointerover', () => {\n      bg.clear();\n      bg.fillStyle(0x6a6a8a, 1);\n      bg.fillRoundedRect(-100, -25, 200, 50, 8);\n    });\n\n    button.on('pointerout', () => {\n      bg.clear();\n      bg.fillStyle(0x4a4a6a, 1);\n      bg.fillRoundedRect(-100, -25, 200, 50, 8);\n    });\n\n    button.on('pointerdown', callback);\n\n    return button;\n  }\n}\n\n// 游戏场景\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.isPaused = false;\n    this.gameTime = 0;\n  }\n\n  preload() {}\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x0f3460, 1);\n    bg.fillRect(0, 0, width, height);\n\n    // 创建一个简单的玩家方块\n    this.player = this.add.graphics();\n    this.player.fillStyle(0x00ff00, 1);\n    this.player.fillRect(-20, -20, 40, 40);\n    this.player.x = width / 2;\n    this.player.y = height / 2;\n\n    // 分数显示\n    this.scoreText = this.add.text(20, 20, 'Score: 0', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n\n    // 游戏时间显示\n    this.timeText = this.add.text(20, 50, 'Time: 0s', {\n      fontSize: '20px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 监听空格键按下事件\n    this.spaceKey.on('down', () => {\n      this.togglePause();\n    });\n\n    // 暂停菜单容器（初始不可见）\n    this.pauseMenu = null;\n\n    // 自动增加分数（模拟游戏进行）\n    this.scoreTimer = this.time.addEvent({\n      delay: 1000,\n      callback: () => {\n        if (!this.isPaused) {\n          this.score += 10;\n          this.scoreText.setText('Score: ' + this.score);\n        }\n      },\n      loop: true\n    });\n  }\n\n  update(time, delta) {\n    if (this.isPaused) {\n      return; // 暂停时不更新游戏逻辑\n    }\n\n    // 更新游戏时间\n    this.gameTime += delta;\n    this.timeText.setText('Time: ' + Math.floor(this.gameTime / 1000) + 's');\n\n    // 玩家移动\n    const speed = 3;\n    if (this.cursors.left.isDown) {\n      this.player.x -= speed;\n    }\n    if (this.cursors.right.isDown) {\n      this.player.x += speed;\n    }\n    if (this.cursors.up.isDown) {\n      this.player.y -= speed;\n    }\n    if (this.cursors.down.isDown) {\n      this.player.y += speed;\n    }\n\n    // 边界检查\n    const { width, height } = this.cameras.main;\n    this.player.x = Phaser.Math.Clamp(this.player.x, 20, width - 20);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 20, height - 20);\n  }\n\n  togglePause() {\n    this.isPaused = !this.isPaused;\n\n    if (this.isPaused) {\n      this.showPauseMenu();\n    } else {\n      this.hidePauseMenu();\n    }\n  }\n\n  showPauseMenu() {\n    const { width, height } = this.cameras.main;\n\n    // 创建暂停菜单容器\n    this.pauseMenu = this.add.container(0, 0);\n    this.pauseMenu.setDepth(1000);\n\n    // 半透明遮罩\n    const overlay = this.add.graphics();\n    overlay.fillStyle(0x000000, 0.7);\n    overlay.fillRect(0, 0, width, height);\n    this.pauseMenu.add(overlay);\n\n    // 菜单背景\n    const menuBg = this.add.graphics();\n    menuBg.fillStyle(0x2d2d44, 1);\n    menuBg.lineStyle(4, 0xffffff, 1);\n    menuBg.fillRoundedRect(width / 2 - 200, height / 2 - 200, 400, 400, 16);\n    menuBg.strokeRoundedRect(width / 2 - 200, height / 2 - 200, 400, 400, 16);\n    this.pauseMenu.add(menuBg);\n\n    // 暂停标题\n    const pauseTitle = this.add.text(width / 2, height / 2 - 120, 'PAUSED', {\n      fontSize: '48px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    });\n    pauseTitle.setOrigin(0.5);\n    this.pauseMenu.add(pauseTitle);\n\n    // 当前分数显示\n    const currentScore = this.add.text(width / 2, height / 2 - 60, 'Score: ' + this.score, {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffcc00'\n    });\n    currentScore.setOrigin(0.5);\n    this.pauseMenu.add(currentScore);\n\n    // 继续按钮\n    const resumeBtn = this.createMenuButton(\n      width / 2,\n      height / 2 + 10,\n      'CONTINUE',\n      0x4caf50,\n      0x66bb6a,\n      () => {\n        this.togglePause();\n      }\n    );\n    this.pauseMenu.add(resumeBtn);\n\n    // 重新开始按钮\n    const restartBtn = this.createMenuButton(\n      width / 2,\n      height / 2 + 80,\n      'RESTART',\n      0xff9800,\n      0xffb74d,\n      () => {\n        this.hidePauseMenu();\n        this.scene.restart();\n      }\n    );\n    this.pauseMenu.add(restartBtn);\n\n    // 返回主菜单按钮\n    const mainMenuBtn = this.createMenuButton(\n      width / 2,\n      height / 2 + 150,\n      'MAIN MENU',\n      0xf44336,\n      0xe57373,\n      () => {\n        this.hidePauseMenu();\n        this.scene.start('MainMenuScene');\n      }\n    );\n    this.pauseMenu.add(mainMenuBtn);\n  }\n\n  hidePauseMenu() {\n    if (this.pauseMenu) {\n      this.pauseMenu.destroy();\n      this.pauseMenu = null;\n    }\n  }\n\n  createMenuButton(x, y, text, color, hoverColor, callback) {\n    const button = this.add.container(x, y);\n\n    const bg = this.add.graphics();\n    bg.fillStyle(color, 1);\n    bg.fillRoundedRect(-120, -25, 240, 50, 8);\n\n    const label = this.add.text(0, 0, text, {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    });\n    label.setOrigin(0.5);\n\n    button.add([bg, label]);\n    button.setSize(240, 50);\n    button.setInteractive({ useHandCursor: true });\n\n    button.on('pointerover', () => {\n      bg.clear();\n      bg.fillStyle(hoverColor, 1);\n      bg.fillRoundedRect(-120, -25, 240, 50, 8);\n      label.setScale(1.05);\n    });\n\n    button.on('pointerout', () => {\n      bg.clear();\n      bg.fillStyle(color, 1);\n      bg.fillRoundedRect(-120, -25, 240, 50, 8);\n      label.setScale(1);\n    });\n\n    button.on('pointerdown', callback);\n\n    return button;\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: [MainMenuScene, GameScene]\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001794_v2", "prompt_id": "seed_001794", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Input", "GameObjects"], "quality_score": 0.39666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现进度条 UI：从 0 到 15 的紫色进度条，每秒增加 1，满后显示完成。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现从0到15的紫色进度条，每秒增加1，满后显示完成文本\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Time.TimerEvent, Phaser.Time.Clock#addEvent\nSTEPS:\n1. 使用 Graphics 绘制进度条背景（灰色）和前景（紫色）\n2. 使用 TimerEvent 每秒触发一次，更新进度值\n3. 在 update 中根据进度值重绘进度条\n4. 当进度达到15时，显示\"完成\"文本并停止计时器\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量\nlet progress = 0;\nconst maxProgress = 15;\nlet progressBar;\nlet progressFill;\nlet progressText;\nlet completeText;\nlet timer;\nlet isComplete = false;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 进度条尺寸\n  const barWidth = 500;\n  const barHeight = 40;\n  const barX = centerX - barWidth / 2;\n  const barY = centerY - barHeight / 2;\n  \n  // 创建进度条背景（灰色边框和背景）\n  progressBar = this.add.graphics();\n  progressBar.fillStyle(0x333333, 1);\n  progressBar.fillRect(barX, barY, barWidth, barHeight);\n  progressBar.lineStyle(3, 0x666666, 1);\n  progressBar.strokeRect(barX, barY, barWidth, barHeight);\n  \n  // 创建进度条填充（紫色）\n  progressFill = this.add.graphics();\n  \n  // 进度文本（显示当前进度）\n  progressText = this.add.text(centerX, centerY, '0 / 15', {\n    fontSize: '24px',\n    fontFamily: 'Arial',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  });\n  progressText.setOrigin(0.5);\n  \n  // 完成文本（初始隐藏）\n  completeText = this.add.text(centerX, centerY + 60, '完成！', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#00ff00',\n    fontStyle: 'bold'\n  });\n  completeText.setOrigin(0.5);\n  completeText.setVisible(false);\n  \n  // 标题文本\n  const titleText = this.add.text(centerX, centerY - 80, '进度条演示', {\n    fontSize: '28px',\n    fontFamily: 'Arial',\n    color: '#ffffff'\n  });\n  titleText.setOrigin(0.5);\n  \n  // 创建定时器，每秒增加进度\n  timer = this.time.addEvent({\n    delay: 1000, // 1秒\n    callback: updateProgress,\n    callbackScope: this,\n    loop: true\n  });\n  \n  // 存储进度条参数到场景数据中\n  this.barX = barX;\n  this.barY = barY;\n  this.barWidth = barWidth;\n  this.barHeight = barHeight;\n  \n  // 初始绘制\n  drawProgressBar.call(this);\n}\n\nfunction updateProgress() {\n  if (progress < maxProgress) {\n    progress++;\n    progressText.setText(`${progress} / ${maxProgress}`);\n    \n    // 检查是否完成\n    if (progress >= maxProgress) {\n      isComplete = true;\n      completeText.setVisible(true);\n      timer.destroy(); // 停止计时器\n      \n      // 添加完成动画效果\n      this.tweens.add({\n        targets: completeText,\n        scale: { from: 0.5, to: 1.2 },\n        alpha: { from: 0, to: 1 },\n        duration: 500,\n        ease: 'Back.easeOut'\n      });\n    }\n  }\n}\n\nfunction drawProgressBar() {\n  // 清除之前的填充\n  progressFill.clear();\n  \n  // 计算填充宽度\n  const fillWidth = (progress / maxProgress) * this.barWidth;\n  \n  // 绘制紫色填充（带内边距）\n  const padding = 4;\n  if (fillWidth > 0) {\n    progressFill.fillStyle(0x9b59b6, 1); // 紫色\n    progressFill.fillRect(\n      this.barX + padding,\n      this.barY + padding,\n      fillWidth - padding * 2,\n      this.barHeight - padding * 2\n    );\n  }\n}\n\nfunction update(time, delta) {\n  // 每帧重绘进度条\n  drawProgressBar.call(this);\n  \n  // 可选：添加进度条闪烁效果（当接近完成时）\n  if (progress >= maxProgress - 2 && progress < maxProgress && !isComplete) {\n    const pulse = Math.sin(time / 200) * 0.3 + 0.7;\n    progressFill.setAlpha(pulse);\n  } else {\n    progressFill.setAlpha(1);\n  }\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001544_v1", "prompt_id": "seed_001544", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects"], "quality_score": 0.38}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：5 个菱形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色收集5个随机分布的菱形，收集完成后显示通关文字\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Overlap\nSTEPS:\n1. 创建玩家角色（使用Graphics绘制圆形）并添加物理属性\n2. 使用Graphics绘制5个菱形并随机分布在场景中，添加物理碰撞体\n3. 实现键盘控制玩家移动（方向键）\n4. 检测玩家与菱形的碰撞，收集时移除菱形并增加计数\n5. 当收集数量达到5时显示\"恭喜通关\"文字\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet diamonds;\nlet cursors;\nlet collectedCount = 0;\nlet totalDiamonds = 5;\nlet winText;\nlet scoreText;\n\nfunction preload() {\n  // 创建玩家纹理（圆形）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillCircle(20, 20, 20);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建菱形纹理\n  const diamondGraphics = this.add.graphics();\n  diamondGraphics.fillStyle(0xffff00, 1);\n  diamondGraphics.beginPath();\n  diamondGraphics.moveTo(15, 0);\n  diamondGraphics.lineTo(30, 15);\n  diamondGraphics.lineTo(15, 30);\n  diamondGraphics.lineTo(0, 15);\n  diamondGraphics.closePath();\n  diamondGraphics.fillPath();\n  diamondGraphics.generateTexture('diamond', 30, 30);\n  diamondGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setDrag(300);\n  player.setMaxVelocity(300);\n\n  // 创建菱形组\n  diamonds = this.physics.add.group();\n\n  // 随机生成5个菱形\n  for (let i = 0; i < totalDiamonds; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const diamond = diamonds.create(x, y, 'diamond');\n    diamond.setCollideWorldBounds(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: diamond,\n      alpha: 0.3,\n      duration: 800,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, diamonds, collectDiamond, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, '收集进度: 0/5', {\n    fontSize: '24px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 创建通关文本（初始隐藏）\n  winText = this.add.text(400, 300, '恭喜通关！', {\n    fontSize: '64px',\n    fill: '#ffff00',\n    fontFamily: 'Arial',\n    stroke: '#000000',\n    strokeThickness: 6\n  });\n  winText.setOrigin(0.5);\n  winText.setVisible(false);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 300;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectDiamond(player, diamond) {\n  // 移除被收集的菱形\n  diamond.destroy();\n  \n  // 增加收集计数\n  collectedCount++;\n  \n  // 更新分数文本\n  scoreText.setText('收集进度: ' + collectedCount + '/' + totalDiamonds);\n  \n  // 播放收集音效（使用缩放动画模拟）\n  this.tweens.add({\n    targets: player,\n    scaleX: 1.2,\n    scaleY: 1.2,\n    duration: 100,\n    yoyo: true\n  });\n  \n  // 检查是否收集完成\n  if (collectedCount >= totalDiamonds) {\n    winText.setVisible(true);\n    \n    // 停止玩家移动\n    player.setVelocity(0, 0);\n    \n    // 禁用键盘输入\n    cursors.left.enabled = false;\n    cursors.right.enabled = false;\n    cursors.up.enabled = false;\n    cursors.down.enabled = false;\n    \n    // 通关文字动画\n    this.tweens.add({\n      targets: winText,\n      scale: 1.2,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001386_v2", "prompt_id": "seed_001386", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.43000000000000005}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色椭圆在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现橙色椭圆在0.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色椭圆并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆（中心点40,30，宽80，高60）\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const ellipseSprite = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 500, // 持续时间 0.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果\n    loop: -1 // 无限循环（-1 表示永久循环）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000427_v2", "prompt_id": "seed_000427", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：20 个蓝色小球以 240 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 20个蓝色小球在封闭空间内以240速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade.Group, setBounce, setCollideWorldBounds, setVelocity, collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成蓝色圆形纹理作为小球贴图\n3. 创建物理组并添加 20 个小球，设置随机位置和速度\n4. 为每个小球设置边界碰撞和弹性系数\n5. 添加小球之间的碰撞检测\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass BallBounceScene extends Phaser.Scene {\n  constructor() {\n    super('BallBounceScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建蓝色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0066ff, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('blueBall', 32, 32);\n    graphics.destroy();\n\n    // 设置世界边界\n    this.physics.world.setBoundsCollision(true, true, true, true);\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'blueBall',\n      repeat: 19, // 创建 20 个小球（0-19）\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 为每个小球设置随机位置和速度\n    const ballSpeed = 240;\n    this.balls.children.iterate((ball) => {\n      // 随机位置（避免边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      ball.setPosition(x, y);\n\n      // 随机方向的速度，总速度为 240\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const vx = Math.cos(angle) * ballSpeed;\n      const vy = Math.sin(angle) * ballSpeed;\n      ball.setVelocity(vx, vy);\n\n      // 设置弹性\n      ball.setBounce(1, 1);\n      ball.setCollideWorldBounds(true);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示碰撞计数（用于验证）\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.collisionText.setDepth(1);\n\n    // 显示小球数量\n    this.ballCountText = this.add.text(10, 40, 'Balls: 20', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.ballCountText.setDepth(1);\n\n    // 绘制边界框（可视化）\n    const border = this.add.graphics();\n    border.lineStyle(4, 0xffffff, 1);\n    border.strokeRect(0, 0, 800, 600);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调，增加计数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保所有小球速度保持在 240 左右（可选的速度修正）\n    this.balls.children.iterate((ball) => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏差过大，进行修正\n      if (currentSpeed > 0 && Math.abs(currentSpeed - 240) > 10) {\n        const scale = 240 / currentSpeed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallBounceScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001208_v3", "prompt_id": "seed_001208", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中循环12次创建 Graphics 对象\n3. 使用 fillStyle 设置绿色，用 fillTriangle 绘制三角形\n4. 使用 setRandomPosition 随机放置每个三角形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 循环创建12个绿色三角形\n  for (let i = 0; i < 12; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置绿色填充\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制等边三角形，大小为16像素\n    // 计算三角形顶点坐标（中心对齐）\n    const height = 16;\n    const halfBase = height * Math.tan(Math.PI / 6); // 等边三角形底边的一半\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶点（上）\n      -halfBase, height / 2,    // 左下顶点\n      halfBase, height / 2      // 右下顶点\n    );\n    \n    // 随机设置位置\n    graphics.setRandomPosition(\n      0, \n      0, \n      config.width, \n      config.height\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000050_v3", "prompt_id": "seed_000050", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在4秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale: 1 -> 0.24 -> 1）\n4. 设置 Tween 的 duration 为 4000ms，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff88, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 100）\n  const centerX = 64;\n  const centerY = 64;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 顶点\n  graphics.lineTo(centerX + size, centerY);      // 右点\n  graphics.lineTo(centerX, centerY + size);      // 底点\n  graphics.lineTo(centerX - size, centerY);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 4000,        // 4秒缩放到24%\n    yoyo: true,            // 自动返回原始大小\n    loop: -1,              // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '菱形循环缩放动画 (1.0 ↔ 0.24)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000400_v3", "prompt_id": "seed_000400", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个可拖拽的青色椭圆，拖拽时改变颜色，松手后回到初始位置。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Events.GAMEOBJECT_DRAG\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个可拖拽的青色椭圆，拖拽时改变颜色，松手后回到初始位置\nAPI: Graphics.fillEllipse, setInteractive, on('drag'), on('dragstart'), on('dragend')\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆并生成纹理\n2. 创建 Sprite 并设置可交互和可拖拽\n3. 监听 dragstart 事件改变颜色为黄色\n4. 监听 drag 事件更新椭圆位置\n5. 监听 dragend 事件恢复青色并回到初始位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 记录初始位置\n  const initialX = 400;\n  const initialY = 300;\n  \n  // 创建青色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillEllipse(60, 40, 120, 80); // 中心点偏移，宽120，高80\n  graphics.generateTexture('cyanEllipse', 120, 80);\n  graphics.destroy();\n  \n  // 创建黄色椭圆纹理（拖拽时使用）\n  const graphicsYellow = this.add.graphics();\n  graphicsYellow.fillStyle(0xffff00, 1); // 黄色\n  graphicsYellow.fillEllipse(60, 40, 120, 80);\n  graphicsYellow.generateTexture('yellowEllipse', 120, 80);\n  graphicsYellow.destroy();\n  \n  // 创建椭圆精灵\n  const ellipse = this.add.sprite(initialX, initialY, 'cyanEllipse');\n  \n  // 设置可交互和可拖拽\n  ellipse.setInteractive({ draggable: true });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '拖拽椭圆试试！', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 监听拖拽开始事件\n  ellipse.on('dragstart', function(pointer) {\n    // 改变为黄色\n    this.setTexture('yellowEllipse');\n    text.setText('拖拽中...');\n  });\n  \n  // 监听拖拽事件\n  ellipse.on('drag', function(pointer, dragX, dragY) {\n    // 更新椭圆位置\n    this.x = dragX;\n    this.y = dragY;\n  });\n  \n  // 监听拖拽结束事件\n  ellipse.on('dragend', function(pointer) {\n    // 恢复青色\n    this.setTexture('cyanEllipse');\n    \n    // 使用补间动画回到初始位置\n    this.scene.tweens.add({\n      targets: this,\n      x: initialX,\n      y: initialY,\n      duration: 300,\n      ease: 'Back.easeOut'\n    });\n    \n    text.setText('拖拽椭圆试试！');\n  });\n  \n  // 添加鼠标悬停效果\n  ellipse.on('pointerover', function() {\n    this.setScale(1.1);\n  });\n  \n  ellipse.on('pointerout', function() {\n    this.setScale(1.0);\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000295_v1", "prompt_id": "seed_000295", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.GameObject.setVelocity, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds\nSTEPS:\n1. 配置物理系统（arcade）并创建场景\n2. 使用 Graphics 绘制橙色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为 360（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    points.push({\n      x: 32 + Math.cos(angle) * radius,\n      y: 32 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（360像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 360;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 360;\n  star.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞和反弹\n  star.setCollideWorldBounds(true);\n  star.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 可选：让星形旋转增加视觉效果\n  star.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000798_v2", "prompt_id": "seed_000798", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：8 个六边形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现一个收集游戏，玩家控制角色收集8个随机分布的六边形，收集完成后显示通关提示\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Text, Phaser.Input.Keyboard\nSTEPS:\n1. 创建物理系统场景，初始化玩家精灵和8个六边形收集物\n2. 使用Graphics绘制玩家（圆形）和六边形收集物的纹理\n3. 设置玩家键盘控制（方向键移动）\n4. 添加玩家与六边形的碰撞检测，碰撞后移除六边形并增加计数\n5. 当收集计数达到8时显示\"恭喜通关\"文本\n[/PLAN]\n\n```javascript\nclass CollectionGame extends Phaser.Scene {\n  constructor() {\n    super('CollectionGame');\n    this.collectedCount = 0; // 可验证状态信号\n    this.totalHexagons = 8;\n  }\n\n  preload() {\n    // 创建玩家纹理（圆形）\n    const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(20, 20, 20);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建六边形纹理\n    const hexGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    hexGraphics.fillStyle(0xffff00, 1);\n    hexGraphics.lineStyle(2, 0xff8800, 1);\n    \n    // 绘制六边形\n    const hexSize = 15;\n    const hexPath = [];\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i;\n      const x = 20 + hexSize * Math.cos(angle);\n      const y = 20 + hexSize * Math.sin(angle);\n      hexPath.push(new Phaser.Math.Vector2(x, y));\n    }\n    hexGraphics.fillPoints(hexPath, true);\n    hexGraphics.strokePoints(hexPath, true);\n    hexGraphics.generateTexture('hexagon', 40, 40);\n    hexGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDamping(true);\n    this.player.setDrag(0.8);\n    this.player.setMaxVelocity(300);\n\n    // 创建六边形收集物组\n    this.hexagons = this.physics.add.group();\n\n    // 随机分布8个六边形\n    const positions = this.generateRandomPositions(this.totalHexagons);\n    positions.forEach(pos => {\n      const hex = this.hexagons.create(pos.x, pos.y, 'hexagon');\n      hex.setScale(1.2);\n      // 添加旋转动画\n      this.tweens.add({\n        targets: hex,\n        angle: 360,\n        duration: 3000,\n        repeat: -1,\n        ease: 'Linear'\n      });\n    });\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.hexagons,\n      this.collectHexagon,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建UI文本\n    this.scoreText = this.add.text(16, 16, `收集进度: ${this.collectedCount}/${this.totalHexagons}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '64px',\n      fill: '#ffff00',\n      stroke: '#ff0000',\n      strokeThickness: 6,\n      shadow: {\n        offsetX: 3,\n        offsetY: 3,\n        color: '#000',\n        blur: 5,\n        fill: true\n      }\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n\n    // 添加提示文本\n    this.add.text(400, 550, '使用方向键移动收集六边形', {\n      fontSize: '20px',\n      fill: '#cccccc'\n    }).setOrigin(0.5);\n  }\n\n  update() {\n    // 玩家移动控制\n    const acceleration = 500;\n\n    if (this.cursors.left.isDown) {\n      this.player.setAccelerationX(-acceleration);\n    } else if (this.cursors.right.isDown) {\n      this.player.setAccelerationX(acceleration);\n    } else {\n      this.player.setAccelerationX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setAccelerationY(-acceleration);\n    } else if (this.cursors.down.isDown) {\n      this.player.setAccelerationY(acceleration);\n    } else {\n      this.player.setAccelerationY(0);\n    }\n  }\n\n  collectHexagon(player, hexagon) {\n    // 移除六边形\n    hexagon.destroy();\n    \n    // 增加收集计数\n    this.collectedCount++;\n    \n    // 更新UI\n    this.scoreText.setText(`收集进度: ${this.collectedCount}/${this.totalHexagons}`);\n\n    // 添加收集音效（使用闪烁效果代替）\n    this.cameras.main.flash(100, 255, 255, 0);\n\n    // 检查是否通关\n    if (this.collectedCount >= this.totalHexagons) {\n      this.gameWin();\n    }\n  }\n\n  gameWin() {\n    // 显示通关文本\n    this.winText.setVisible(true);\n    \n    // 添加通关动画\n    this.tweens.add({\n      targets: this.winText,\n      scale: { from: 0.5, to: 1.2 },\n      duration: 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n\n    // 停止玩家移动\n    this.player.setVelocity(0, 0);\n    this.player.setAcceleration(0, 0);\n\n    // 添加庆祝效果\n    this.cameras.main.flash(1000, 255, 215, 0);\n    \n    // 禁用输入\n    this.cursors.left.enabled = false;\n    this.cursors.right.enabled = false;\n    this.cursors.up.enabled = false;\n    this.cursors.down.enabled = false;\n  }\n\n  generateRandomPositions(count) {\n    const positions = [];\n    const minDistance = 80; // 最小间距\n    const margin = 60; // 边界边距\n    const maxAttempts = 100; // 最大尝试次数\n\n    for (let i = 0; i < count; i++) {\n      let validPosition = false;\n      let attempts = 0;\n      let x, y;\n\n      while (!validPosition && attempts < maxAttempts) {\n        x = Phaser.Math.Between(margin, 800 - margin);\n        y = Phaser.Math.Between(margin, 600 - margin);\n\n        // 检查与玩家初始位置的距离\n        const distToPlayer = Phaser.Math.Distance.Between(x, y, 400, 300);\n        if (distToPlayer < 100) {\n          attempts++;\n          continue;\n        }\n\n        // 检查与已有位置的距离\n        validPosition = true;\n        for (let pos of positions) {\n          const dist = Phaser.Math.Distance.Between(x, y, pos.x, pos.y);\n          if (dist < minDistance) {\n            validPosition = false;\n            break;\n          }\n        }\n\n        attempts++;\n      }\n\n      positions.push({ x, y });\n    }\n\n    return positions;\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectionGame\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001372_v2", "prompt_id": "seed_001372", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.42000000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色移动平台：平台以 240 速度水平往返移动，玩家可站在上面并跟随移动，重力 300。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现紫色移动平台，玩家可站立并跟随平台水平往返移动，重力300\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Body.velocity, Collider\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力为 300\n2. 使用 Graphics 生成紫色平台纹理和绿色玩家纹理\n3. 创建移动平台精灵，设置初始速度 240，配置边界检测\n4. 创建玩家精灵，添加键盘控制\n5. 设置玩家与平台的碰撞检测，启用平台摩擦力\n6. 在 update 中检测平台边界并反转速度\n7. 添加状态变量记录平台位置和移动方向\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    // 状态信号变量\n    this.platformDirection = 1; // 1=右, -1=左\n    this.platformPosition = 0;\n    this.playerOnPlatform = false;\n  }\n\n  preload() {\n    // 不需要外部资源\n  }\n\n  create() {\n    const { width, height } = this.sys.game.config;\n\n    // 创建紫色平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x9b59b6, 1); // 紫色\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platformTex', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建绿色玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x2ecc71, 1); // 绿色\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('playerTex', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建静态地面（用于参考）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1); // 棕色\n    groundGraphics.fillRect(0, height - 40, width, 40);\n    const ground = this.physics.add.staticImage(width / 2, height - 20, null);\n    ground.setDisplaySize(width, 40);\n    ground.refreshBody();\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(200, 400, 'platformTex');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.setVelocityX(240); // 初始速度 240\n    \n    // 设置平台移动范围\n    this.platformMinX = 100;\n    this.platformMaxX = width - 100;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 200, 'playerTex');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0);\n\n    // 设置玩家与平台的碰撞\n    this.platformCollider = this.physics.add.collider(\n      this.player, \n      this.platform,\n      this.onPlayerPlatformCollide,\n      null,\n      this\n    );\n\n    // 设置玩家与地面的碰撞\n    this.physics.add.collider(this.player, ground);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(width / 2, 50, '使用方向键移动玩家\\n站在紫色平台上会跟随移动', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      align: 'center'\n    }).setOrigin(0.5);\n  }\n\n  onPlayerPlatformCollide(player, platform) {\n    // 检测玩家是否在平台上方\n    if (player.body.touching.down && platform.body.touching.up) {\n      this.playerOnPlatform = true;\n    }\n  }\n\n  update(time, delta) {\n    // 更新平台位置状态\n    this.platformPosition = this.platform.x;\n\n    // 检测平台边界并反转速度\n    if (this.platform.x <= this.platformMinX) {\n      this.platform.setVelocityX(240);\n      this.platformDirection = 1;\n      this.platform.x = this.platformMinX; // 防止穿透\n    } else if (this.platform.x >= this.platformMaxX) {\n      this.platform.setVelocityX(-240);\n      this.platformDirection = -1;\n      this.platform.x = this.platformMaxX; // 防止穿透\n    }\n\n    // 检测玩家是否在平台上\n    const wasOnPlatform = this.playerOnPlatform;\n    this.playerOnPlatform = false;\n\n    if (this.player.body.touching.down && this.platform.body.touching.up) {\n      // 玩家在平台上，添加平台速度\n      const overlapX = Math.abs(\n        this.player.body.center.x - this.platform.body.center.x\n      );\n      const platformHalfWidth = this.platform.body.width / 2;\n      \n      if (overlapX < platformHalfWidth + this.player.body.halfWidth) {\n        this.playerOnPlatform = true;\n        // 让玩家跟随平台移动\n        this.player.x += this.platform.body.velocity.x * (delta / 1000);\n      }\n    }\n\n    // 玩家左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      // 如果在平台上，保持平台速度；否则停止\n      if (!this.playerOnPlatform) {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃控制\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `平台位置: ${Math.round(this.platformPosition)}`,\n      `平台方向: ${this.platformDirection === 1 ? '右' : '左'}`,\n      `玩家在平台上: ${this.playerOnPlatform ? '是' : '否'}`,\n      `玩家位置: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#34495e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001964_v1", "prompt_id": "seed_001964", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.42000000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个青色小球以 200 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个青色小球以200速度在封闭空间内移动，碰到边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Body.setBounce, Body.setCollideWorldBounds, Physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，启用世界边界\n2. 使用 Graphics 创建青色圆形纹理\n3. 创建物理精灵组，添加5个小球并设置随机初始速度\n4. 设置小球与世界边界碰撞反弹（bounce=1）\n5. 添加小球之间的碰撞检测，实现弹性碰撞\n6. 添加碰撞计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理精灵组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: 4, // 创建5个小球（1个默认 + 4个重复）\n      setXY: { \n        x: 100, \n        y: 100, \n        stepX: 150 // 横向间隔分布\n      }\n    });\n\n    // 配置每个小球\n    this.balls.children.iterate((ball, index) => {\n      // 设置随机速度（200左右的速度）\n      const angle = Phaser.Math.Between(0, 360);\n      const speed = 200;\n      this.physics.velocityFromAngle(angle, speed, ball.body.velocity);\n\n      // 设置碰撞属性\n      ball.setCollideWorldBounds(true); // 与世界边界碰撞\n      ball.setBounce(1); // 完全弹性碰撞（bounce=1）\n      ball.body.setCircle(16); // 设置圆形碰撞体\n      \n      // 设置阻力为0，保持恒定速度\n      ball.body.setDamping(false);\n      ball.body.setDrag(0);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.handleBallCollision, null, this);\n\n    // 显示碰撞计数\n    this.collisionText = this.add.text(16, 16, 'Collisions: 0', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示说明\n    this.add.text(16, 560, '5个青色小球在封闭空间内弹性碰撞', {\n      fontSize: '18px',\n      color: '#00ffff'\n    });\n  }\n\n  handleBallCollision(ball1, ball2) {\n    // 碰撞回调：增加碰撞计数\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 确保小球速度保持在200左右\n    this.balls.children.iterate((ball) => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏离200太多，进行修正\n      if (Math.abs(currentSpeed - 200) > 10) {\n        const scale = 200 / currentSpeed;\n        ball.body.velocity.x *= scale;\n        ball.body.velocity.y *= scale;\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000895_v3", "prompt_id": "seed_000895", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.4066666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在4秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 scale 属性从 1 到 0.24 再回到 1\n4. 设置 Tween 的 duration 为 2000ms（单程2秒，往返4秒）\n5. 设置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 半径50的圆形\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy();\n\n  // 创建圆形精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circle');\n\n  // 创建缩放动画\n  // 从原始大小(scale=1)缩放到24%(scale=0.24)，然后恢复\n  // yoyo: true 表示动画会反向播放（往返效果）\n  // duration: 2000 表示单程2秒，往返共4秒\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: circle,\n    scale: 0.24,           // 目标缩放值：24%\n    duration: 2000,        // 单程时长：2秒\n    yoyo: true,            // 启用往返效果（缩小后再放大）\n    loop: -1,              // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, 'Circle scaling to 24% and back (4s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000111_v1", "prompt_id": "seed_000111", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色菱形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个白色菱形在 1 秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建菱形精灵对象并设置初始位置\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 上顶点\n  graphics.lineTo(size * 2, size);    // 右顶点\n  graphics.lineTo(size, size * 2);    // 下顶点\n  graphics.lineTo(0, size);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，设置初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,                    // 目标位置（右侧）\n    duration: 1000,            // 持续时间 1 秒\n    yoyo: true,                // 启用往返效果\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000032_v1", "prompt_id": "seed_000032", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个移动平台组成路径，玩家需要跳跃通过，平台速度 200。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 10个移动平台组成路径，玩家跳跃通过，平台速度200\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.StaticGroup, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家精灵，添加重力和碰撞检测\n2. 生成10个平台，使用Graphics绘制纹理，设置为物理组\n3. 为每个平台添加水平往返移动逻辑（速度200）\n4. 实现键盘控制玩家左右移动和跳跃\n5. 添加碰撞检测，玩家可以站在平台上\n6. 添加得分系统，通过平台数量计数\n7. 添加游戏状态显示（位置、速度、通过平台数）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.platformsPassed = 0;\n    this.totalPlatforms = 10;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8B4513, 1);\n    platformGraphics.fillRect(0, 0, 120, 20);\n    platformGraphics.generateTexture('platform', 120, 20);\n    platformGraphics.destroy();\n\n    // 创建终点纹理\n    const goalGraphics = this.add.graphics();\n    goalGraphics.fillStyle(0xFFD700, 1);\n    goalGraphics.fillRect(0, 0, 80, 80);\n    goalGraphics.generateTexture('goal', 80, 80);\n    goalGraphics.destroy();\n  }\n\n  create() {\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#87CEEB');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setGravity(0, 800);\n\n    // 创建平台组\n    this.platforms = this.physics.add.group({\n      allowGravity: false,\n      immovable: true\n    });\n\n    // 创建起始平台（静止）\n    const startPlatform = this.platforms.create(100, 550, 'platform');\n    startPlatform.body.setVelocityX(0);\n    startPlatform.setData('minX', 50);\n    startPlatform.setData('maxX', 150);\n    startPlatform.setData('direction', 0);\n\n    // 创建10个移动平台\n    const platformPositions = [\n      { x: 250, y: 480, minX: 200, maxX: 400 },\n      { x: 450, y: 420, minX: 400, maxX: 600 },\n      { x: 650, y: 360, minX: 550, maxX: 750 },\n      { x: 200, y: 300, minX: 100, maxX: 350 },\n      { x: 500, y: 250, minX: 400, maxX: 650 },\n      { x: 700, y: 200, minX: 600, maxX: 750 },\n      { x: 300, y: 150, minX: 200, maxX: 450 },\n      { x: 550, y: 120, minX: 450, maxX: 700 },\n      { x: 250, y: 80, minX: 150, maxX: 400 },\n      { x: 600, y: 50, minX: 500, maxX: 700 }\n    ];\n\n    platformPositions.forEach((pos, index) => {\n      const platform = this.platforms.create(pos.x, pos.y, 'platform');\n      platform.setData('minX', pos.minX);\n      platform.setData('maxX', pos.maxX);\n      platform.setData('direction', 1);\n      platform.setData('index', index + 1);\n      platform.setData('passed', false);\n      platform.body.setVelocityX(200);\n    });\n\n    // 创建终点\n    this.goal = this.physics.add.sprite(650, 10, 'goal');\n    this.goal.setImmovable(true);\n    this.goal.body.setAllowGravity(false);\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms, this.onPlatformCollision, null, this);\n    this.physics.add.overlap(this.player, this.goal, this.onReachGoal, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 游戏说明\n    this.add.text(400, 580, '方向键移动，空格/上键跳跃', {\n      fontSize: '14px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 5, y: 3 }\n    }).setOrigin(0.5);\n\n    // 记录上一次站立的平台\n    this.lastPlatformIndex = 0;\n  }\n\n  onPlatformCollision(player, platform) {\n    // 检查玩家是否从上方落到平台上\n    if (player.body.touching.down && platform.body.touching.up) {\n      const platformIndex = platform.getData('index');\n      if (platformIndex && !platform.getData('passed') && platformIndex > this.lastPlatformIndex) {\n        platform.setData('passed', true);\n        this.platformsPassed++;\n        this.lastPlatformIndex = platformIndex;\n      }\n    }\n  }\n\n  onReachGoal(player, goal) {\n    if (!this.isGameOver) {\n      this.isGameOver = true;\n      this.physics.pause();\n      this.add.text(400, 300, '胜利！', {\n        fontSize: '48px',\n        fill: '#FFD700',\n        stroke: '#000',\n        strokeThickness: 4\n      }).setOrigin(0.5);\n    }\n  }\n\n  update() {\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 玩家控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 更新平台移动\n    this.platforms.getChildren().forEach(platform => {\n      const minX = platform.getData('minX');\n      const maxX = platform.getData('maxX');\n      const direction = platform.getData('direction');\n\n      if (direction !== 0) {\n        if (platform.x <= minX && platform.body.velocity.x < 0) {\n          platform.body.setVelocityX(200);\n          platform.setData('direction', 1);\n        } else if (platform.x >= maxX && platform.body.velocity.x > 0) {\n          platform.body.setVelocityX(-200);\n          platform.setData('direction', -1);\n        }\n      }\n    });\n\n    // 检查玩家是否掉落\n    if (this.player.y > 620) {\n      this.resetPlayer();\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `平台通过: ${this.platformsPassed}/${this.totalPlatforms}`,\n      `位置: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `速度: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`,\n      `触地: ${this.player.body.touching.down ? '是' : '否'}`\n    ]);\n  }\n\n  resetPlayer() {\n    this.player.setPosition(100, 500);\n    this.player.setVelocity(0, 0);\n    this.platformsPassed = Math.max(0, this.platformsPassed - 1);\n    this.lastPlatformIndex = 0;\n    \n    // 重置平台passed状态\n    this.platforms.getChildren().forEach(platform => {\n      platform.setData('passed', false);\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001968_v1", "prompt_id": "seed_001968", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41000000000000003}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让红色方块在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色方块的弹跳动画，3秒完成一次循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色方块并生成纹理\n2. 创建 Sprite 对象作为弹跳主体\n3. 使用 Tween 动画实现 y 轴弹跳效果，配置 yoyo 和 loop 实现循环\n4. 设置 ease 为 'Bounce.easeOut' 实现弹跳效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('redSquare', 80, 80);\n  graphics.destroy();\n  \n  // 创建精灵对象\n  const square = this.add.sprite(400, 300, 'redSquare');\n  \n  // 创建弹跳动画\n  // 从当前位置向上移动150像素，然后返回，整个过程3秒\n  this.tweens.add({\n    targets: square,\n    y: square.y - 150,  // 向上弹跳150像素\n    duration: 1500,      // 上升时间1.5秒\n    ease: 'Cubic.easeOut', // 上升时使用缓出效果\n    yoyo: true,          // 自动返回原位置\n    repeat: -1,          // 无限循环\n    repeatDelay: 0       // 无延迟\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Bouncing Red Square', {\n    fontSize: '32px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '3-second bounce cycle (loop)', {\n    fontSize: '20px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000731_v1", "prompt_id": "seed_000731", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色三角形在 2.5 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色三角形在 2.5 秒内完成抖动动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建 Sprite 对象承载三角形纹理\n3. 使用 Tween 创建抖动效果（x/y 位置随机偏移）\n4. 设置 Tween 持续时间为 2.5 秒并循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制三角形（等边三角形）\n  const triangleSize = 60;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize / 2);\n  graphics.lineTo(-triangleSize / 2, triangleSize / 2);\n  graphics.lineTo(triangleSize / 2, triangleSize / 2);\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 记录初始位置\n  const originalX = triangle.x;\n  const originalY = triangle.y;\n  \n  // 创建抖动动画\n  // 使用 timeline 来创建复杂的抖动效果\n  const shakeIntensity = 10; // 抖动强度\n  \n  this.tweens.add({\n    targets: triangle,\n    duration: 2500, // 2.5 秒\n    ease: 'Linear',\n    repeat: -1, // 无限循环\n    onUpdate: (tween) => {\n      // 在动画更新时随机偏移位置\n      const progress = tween.progress;\n      \n      // 使用正弦波模拟抖动衰减效果\n      const intensity = Math.sin(progress * Math.PI * 20) * shakeIntensity;\n      \n      triangle.x = originalX + Phaser.Math.Between(-intensity, intensity);\n      triangle.y = originalY + Phaser.Math.Between(-intensity, intensity);\n    },\n    onRepeat: () => {\n      // 每次循环重置位置\n      triangle.x = originalX;\n      triangle.y = originalY;\n    }\n  });\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '灰色三角形抖动动画 (2.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000469_v1", "prompt_id": "seed_000469", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让青色椭圆在 2 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色椭圆在2秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 使用 Graphics 或 Ellipse 创建青色椭圆对象\n2. 使用 Tween 创建 y 轴方向的弹跳动画，持续时间2秒\n3. 设置 yoyo 和 repeat: -1 实现循环弹跳效果\n4. 使用 easing 函数（如 Bounce.easeOut）增强弹跳真实感\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建青色椭圆\n  const ellipse = this.add.ellipse(\n    400,           // x 位置（屏幕中心）\n    200,           // y 位置（起始位置）\n    100,           // 宽度\n    60,            // 高度\n    0x00ffff       // 青色\n  );\n\n  // 创建弹跳动画\n  // 使用 yoyo 模式实现上下弹跳\n  this.tweens.add({\n    targets: ellipse,\n    y: 500,                    // 目标 y 位置（底部）\n    duration: 1000,            // 单程持续时间 1 秒\n    ease: 'Bounce.easeOut',    // 弹跳缓动效果\n    yoyo: true,                // 启用往返模式\n    repeat: -1,                // 无限循环\n    hold: 0,                   // 到达目标后不停留\n    repeatDelay: 0             // 重复之间无延迟\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, '弹跳的青色椭圆', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 580, '2秒完成一次完整弹跳循环', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 创建并启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000313_v3", "prompt_id": "seed_000313", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的青色矩形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的青色矩形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环3次，每次生成随机 x、y 坐标（确保矩形完全在画布内）\n4. 设置青色填充样式（0x00ffff）并绘制 16x16 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充样式\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制3个随机位置的矩形\n  for (let i = 0; i < 3; i++) {\n    // 生成随机位置，确保矩形完全在画布内（减去矩形大小16）\n    const randomX = Phaser.Math.Between(0, config.width - 16);\n    const randomY = Phaser.Math.Between(0, config.height - 16);\n    \n    // 绘制 16x16 的矩形\n    graphics.fillRect(randomX, randomY, 16, 16);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000245_v3", "prompt_id": "seed_000245", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可在空中跳跃一次，跳跃力度200，重力300\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，设置重力为300\n2. 使用Graphics绘制玩家角色和地面平台\n3. 添加键盘输入监听，检测空格键或上箭头键\n4. 实现跳跃计数器，允许最多2次跳跃\n5. 角色着地时重置跳跃计数器\n6. 显示当前跳跃次数和总跳跃计数作为状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#87CEEB'\n};\n\n// 游戏状态变量\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet jumpCount = 0; // 当前已跳跃次数\nlet totalJumps = 0; // 总跳跃次数统计\nlet jumpText;\nlet statsText;\nconst MAX_JUMPS = 2; // 最大跳跃次数\nconst JUMP_VELOCITY = -200; // 跳跃力度\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建地面\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x228B22, 1);\n  graphics.fillRect(0, 550, 800, 50);\n  graphics.generateTexture('ground', 800, 50);\n  graphics.destroy();\n\n  ground = this.physics.add.staticGroup();\n  ground.create(400, 575, 'ground');\n\n  // 创建玩家角色\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0xFF6347, 1);\n  playerGraphics.fillRect(0, 0, 40, 50);\n  playerGraphics.generateTexture('player', 40, 50);\n  playerGraphics.destroy();\n\n  player = this.physics.add.sprite(100, 450, 'player');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 添加碰撞检测\n  this.physics.add.collider(player, ground, onLanding, null, this);\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 创建显示文本\n  jumpText = this.add.text(16, 16, 'Jumps Available: 2/2', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  statsText = this.add.text(16, 50, 'Total Jumps: 0', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(400, 100, 'Press SPACE or UP to Jump', {\n    fontSize: '24px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  }).setOrigin(0.5);\n\n  this.add.text(400, 140, 'You can jump twice before landing!', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  }).setOrigin(0.5);\n\n  // 添加左右移动说明\n  this.add.text(400, 180, 'Use LEFT/RIGHT arrows to move', {\n    fontSize: '18px',\n    fill: '#666',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃逻辑\n  if (Phaser.Input.Keyboard.JustDown(cursors.up) || Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    if (jumpCount < MAX_JUMPS) {\n      player.setVelocityY(JUMP_VELOCITY);\n      jumpCount++;\n      totalJumps++;\n      updateUI();\n    }\n  }\n\n  // 更新UI显示\n  const remaining = MAX_JUMPS - jumpCount;\n  jumpText.setText(`Jumps Available: ${remaining}/${MAX_JUMPS}`);\n  statsText.setText(`Total Jumps: ${totalJumps}`);\n\n  // 根据跳跃次数改变颜色提示\n  if (jumpCount === 0) {\n    jumpText.setStyle({ fill: '#00ff00' });\n  } else if (jumpCount === 1) {\n    jumpText.setStyle({ fill: '#ff9900' });\n  } else {\n    jumpText.setStyle({ fill: '#ff0000' });\n  }\n}\n\n// 着陆回调函数\nfunction onLanding() {\n  // 当玩家接触地面且向下速度大于0时，重置跳跃计数\n  if (player.body.touching.down && player.body.velocity.y >= 0) {\n    jumpCount = 0;\n    updateUI();\n  }\n}\n\nfunction updateUI() {\n  const remaining = MAX_JUMPS - jumpCount;\n  jumpText.setText(`Jumps Available: ${remaining}/${MAX_JUMPS}`);\n  statsText.setText(`Total Jumps: ${totalJumps}`);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001274_v1", "prompt_id": "seed_001274", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.45666666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色角色冲刺：按鼠标左键进行短距离冲刺，冲刺速度为 300*3，冷却 2.5 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现紫色角色按鼠标左键冲刺，速度300*3，冷却2.5秒\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Pointer, Phaser.Time.TimerEvent, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建紫色角色精灵并启用物理系统\n2. 监听鼠标左键点击事件\n3. 点击时如果冷却完成，计算冲刺方向并施加速度（900）\n4. 使用 TimerEvent 实现冲刺持续时间（短距离）和冷却时间（2.5秒）\n5. 添加状态变量跟踪冲刺次数和冷却状态\n[/PLAN]\n\n```javascript\nclass DashScene extends Phaser.Scene {\n  constructor() {\n    super('DashScene');\n    this.dashCount = 0; // 可验证的状态信号：冲刺次数\n    this.isDashing = false; // 是否正在冲刺\n    this.canDash = true; // 是否可以冲刺（冷却状态）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建紫色角色纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x9b59b6, 1); // 紫色\n    graphics.fillCircle(20, 20, 20);\n    graphics.generateTexture('player', 40, 40);\n    graphics.destroy();\n\n    // 创建角色精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDamping(true);\n    this.player.setDrag(0.95); // 添加阻力使冲刺后逐渐减速\n\n    // 添加冷却指示器（圆环）\n    this.cooldownIndicator = this.add.graphics();\n    this.cooldownProgress = 1; // 冷却进度 0-1\n\n    // 添加状态文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 监听鼠标左键点击\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        this.attemptDash(pointer);\n      }\n    });\n\n    // 添加提示文本\n    this.add.text(400, 550, '点击鼠标左键进行冲刺', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    }).setOrigin(0.5);\n  }\n\n  attemptDash(pointer) {\n    // 检查是否可以冲刺\n    if (!this.canDash || this.isDashing) {\n      return;\n    }\n\n    // 计算冲刺方向（从角色指向鼠标位置）\n    const angle = Phaser.Math.Angle.Between(\n      this.player.x,\n      this.player.y,\n      pointer.x,\n      pointer.y\n    );\n\n    const dashSpeed = 300 * 3; // 900\n    const velocityX = Math.cos(angle) * dashSpeed;\n    const velocityY = Math.sin(angle) * dashSpeed;\n\n    // 施加冲刺速度\n    this.player.setVelocity(velocityX, velocityY);\n\n    // 设置冲刺状态\n    this.isDashing = true;\n    this.canDash = false;\n    this.dashCount++;\n\n    // 冲刺持续时间（短距离冲刺，持续150ms）\n    this.time.delayedCall(150, () => {\n      this.isDashing = false;\n      // 冲刺结束后减速\n      this.player.setVelocity(\n        this.player.body.velocity.x * 0.3,\n        this.player.body.velocity.y * 0.3\n      );\n    });\n\n    // 冷却时间 2.5 秒\n    this.cooldownProgress = 0;\n    this.time.addEvent({\n      delay: 2500,\n      callback: () => {\n        this.canDash = true;\n        this.cooldownProgress = 1;\n      }\n    });\n  }\n\n  update(time, delta) {\n    // 更新冷却进度\n    if (!this.canDash && this.cooldownProgress < 1) {\n      this.cooldownProgress += delta / 2500;\n      if (this.cooldownProgress > 1) {\n        this.cooldownProgress = 1;\n      }\n    }\n\n    // 绘制冷却指示器\n    this.cooldownIndicator.clear();\n    this.cooldownIndicator.lineStyle(4, this.canDash ? 0x00ff00 : 0xff0000, 1);\n    \n    const startAngle = -90; // 从顶部开始\n    const endAngle = startAngle + (360 * this.cooldownProgress);\n    \n    this.cooldownIndicator.beginPath();\n    this.cooldownIndicator.arc(\n      this.player.x,\n      this.player.y,\n      30,\n      Phaser.Math.DegToRad(startAngle),\n      Phaser.Math.DegToRad(endAngle),\n      false\n    );\n    this.cooldownIndicator.strokePath();\n\n    // 更新状态文本\n    const speed = Math.sqrt(\n      this.player.body.velocity.x ** 2 + \n      this.player.body.velocity.y ** 2\n    ).toFixed(0);\n    \n    this.statusText.setText([\n      `冲刺次数: ${this.dashCount}`,\n      `当前速度: ${speed}`,\n      `冲刺状态: ${this.isDashing ? '冲刺中' : '正常'}`,\n      `冷却状态: ${this.canDash ? '就绪' : '冷却中'}`,\n      `冷却进度: ${(this.cooldownProgress * 100).toFixed(0)}%`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DashScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001153_v3", "prompt_id": "seed_001153", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现橙色移动平台：平台以 200 速度水平往返移动，玩家可站在上面并跟随移动，重力 1000。\n\n难度: 困难\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 尽量保持行为确定性（固定随机种子或可配置 seed）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Tweens.Tween", "output": "[PLAN]\nREQ: 实现橙色移动平台，玩家可站立并跟随平台移动，重力1000\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Body.setVelocityX, Phaser.Physics.Arcade.collider\nSTEPS:\n1. 创建物理系统配置，设置重力为1000\n2. 使用Graphics绘制橙色平台和玩家纹理\n3. 创建移动平台精灵，设置初始速度200\n4. 创建玩家精灵，添加碰撞器实现站立跟随\n5. 在update中检测平台边界并反转速度实现往返移动\n6. 添加键盘控制让玩家可左右移动\n7. 添加状态变量记录平台位置和速度用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    // 状态信号变量\n    this.platformX = 0;\n    this.platformVelocity = 200;\n    this.playerOnPlatform = false;\n    this.platformDirection = 1; // 1: 向右, -1: 向左\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建橙色平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0xFF8C00, 1); // 橙色\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0080FF, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面（静态）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x808080, 1);\n    groundGraphics.fillRect(0, 0, 800, 32);\n    groundGraphics.generateTexture('ground', 800, 32);\n    groundGraphics.destroy();\n\n    this.ground = this.physics.add.sprite(400, 584, 'ground');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建移动平台\n    this.platform = this.physics.add.sprite(400, 400, 'platform');\n    this.platform.setImmovable(true);\n    this.platform.body.allowGravity = false;\n    this.platform.setVelocityX(this.platformVelocity);\n    \n    // 设置平台移动边界\n    this.platformMinX = 100;\n    this.platformMaxX = 700;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 200, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.platformCollider = this.physics.add.collider(\n      this.player, \n      this.platform,\n      this.onPlayerPlatformCollide,\n      null,\n      this\n    );\n\n    this.physics.add.collider(this.player, this.ground);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加信息文本显示状态\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  onPlayerPlatformCollide(player, platform) {\n    // 检测玩家是否在平台上方\n    if (player.body.touching.down && platform.body.touching.up) {\n      this.playerOnPlatform = true;\n    }\n  }\n\n  update(time, delta) {\n    // 更新平台位置状态\n    this.platformX = this.platform.x;\n\n    // 平台往返移动逻辑\n    if (this.platform.x <= this.platformMinX) {\n      this.platform.setVelocityX(this.platformVelocity);\n      this.platformDirection = 1;\n    } else if (this.platform.x >= this.platformMaxX) {\n      this.platform.setVelocityX(-this.platformVelocity);\n      this.platformDirection = -1;\n    }\n\n    // 玩家控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      // 如果玩家在平台上，跟随平台移动\n      if (this.playerOnPlatform && this.player.body.touching.down) {\n        this.player.setVelocityX(this.platform.body.velocity.x);\n      } else {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 重置平台状态标记\n    if (!this.player.body.touching.down) {\n      this.playerOnPlatform = false;\n    }\n\n    // 更新信息显示\n    this.infoText.setText([\n      `Platform X: ${Math.round(this.platformX)}`,\n      `Platform Velocity: ${this.platform.body.velocity.x}`,\n      `Platform Direction: ${this.platformDirection > 0 ? 'Right' : 'Left'}`,\n      `Player on Platform: ${this.playerOnPlatform}`,\n      `Player Y: ${Math.round(this.player.y)}`,\n      `Use Arrow Keys to Move`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001674_v1", "prompt_id": "seed_001674", "source": "distill", "difficulty": "hard", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.41500000000000004}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示\"Hello Phaser\"文字，字体大小80像素\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左下角（x: 20, y: 520），字体大小为 80px\n4. 设置文本样式（字体、颜色等）使其清晰可见\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕左下角创建文本\n  // x: 20 为左侧留白，y: 520 为距离顶部的位置（600 - 80 = 520，使文本底部对齐底部）\n  const text = this.add.text(20, 520, 'Hello Phaser', {\n    fontFamily: 'Arial',\n    fontSize: '80px',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  });\n\n  // 设置文本原点为左下角，使定位更精确\n  text.setOrigin(0, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000249_v1", "prompt_id": "seed_000249", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.42333333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色圆形平滑跟随鼠标指针移动，跟随速度为 160。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Pointer\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建紫色圆形平滑跟随鼠标指针，速度160\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin, Phaser.Math.Distance.Between, Phaser.Math.Angle.Between\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建 Sprite 对象作为跟随物体\n3. 在 update 中获取鼠标指针位置\n4. 计算圆形与鼠标的距离和角度\n5. 根据速度和 delta 时间平滑移动圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\nlet pointer;\nconst FOLLOW_SPEED = 160; // 每秒移动的像素数\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建圆形 Sprite，初始位置在屏幕中心\n  circle = this.add.sprite(400, 300, 'purpleCircle');\n  \n  // 获取指针引用\n  pointer = this.input.activePointer;\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Move your mouse to see the circle follow', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算圆形与鼠标指针之间的距离\n  const distance = Phaser.Math.Distance.Between(\n    circle.x,\n    circle.y,\n    pointer.x,\n    pointer.y\n  );\n  \n  // 只有当距离大于1像素时才移动（避免抖动）\n  if (distance > 1) {\n    // 计算从圆形到鼠标的角度\n    const angle = Phaser.Math.Angle.Between(\n      circle.x,\n      circle.y,\n      pointer.x,\n      pointer.y\n    );\n    \n    // 计算本帧应该移动的距离（速度 * 时间差，delta 单位是毫秒）\n    const moveDistance = FOLLOW_SPEED * (delta / 1000);\n    \n    // 如果本帧移动距离大于剩余距离，直接移动到目标位置\n    if (moveDistance >= distance) {\n      circle.x = pointer.x;\n      circle.y = pointer.y;\n    } else {\n      // 根据角度和移动距离更新位置\n      circle.x += Math.cos(angle) * moveDistance;\n      circle.y += Math.sin(angle) * moveDistance;\n    }\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000617_v3", "prompt_id": "seed_000617", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.44}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现血条+回血：显示 3 格生命值，按鼠标右键扣血，每 0.5 秒自动回复 1 点。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.Time.TimerEvent", "output": "[PLAN]\nREQ: 实现3格血条显示，鼠标右键扣血，每0.5秒自动回复1点生命值\nAPI: Graphics, Input.on, Time.addEvent, Container\nSTEPS:\n1. 创建3个血条方块用Graphics绘制，使用Container管理\n2. 监听鼠标右键事件，每次点击扣除1点生命值\n3. 使用TimerEvent每0.5秒触发回血逻辑，最多回复到3点\n4. 根据当前生命值动态更新血条显示（红色为有血，灰色为无血）\n5. 添加文本显示当前生命值用于验证状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 游戏状态\nlet health = 3;\nconst MAX_HEALTH = 3;\n\n// 游戏对象\nlet healthBars = [];\nlet healthText;\nlet healTimer;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建标题\n  const title = this.add.text(400, 50, '血条系统演示', {\n    fontSize: '32px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  // 创建说明文字\n  const instruction = this.add.text(400, 100, '鼠标右键扣血 | 每0.5秒自动回复1点', {\n    fontSize: '18px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n\n  // 创建血条容器\n  const healthContainer = this.add.container(250, 300);\n\n  // 创建3个血条方块\n  for (let i = 0; i < MAX_HEALTH; i++) {\n    const barBg = this.add.graphics();\n    barBg.fillStyle(0x333333, 1);\n    barBg.fillRect(0, 0, 80, 80);\n    barBg.lineStyle(3, 0x666666, 1);\n    barBg.strokeRect(0, 0, 80, 80);\n\n    const barFill = this.add.graphics();\n    barFill.fillStyle(0xff0000, 1);\n    barFill.fillRect(5, 5, 70, 70);\n\n    const barContainer = this.add.container(i * 100, 0);\n    barContainer.add([barBg, barFill]);\n\n    healthBars.push(barFill);\n    healthContainer.add(barContainer);\n  }\n\n  // 创建生命值文本显示\n  healthText = this.add.text(400, 420, `生命值: ${health}/${MAX_HEALTH}`, {\n    fontSize: '24px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 20, y: 10 }\n  }).setOrigin(0.5);\n\n  // 创建状态提示文本\n  const statusText = this.add.text(400, 500, '', {\n    fontSize: '20px',\n    color: '#ffff00'\n  }).setOrigin(0.5);\n\n  // 监听鼠标右键事件\n  this.input.on('pointerdown', (pointer) => {\n    if (pointer.rightButtonDown()) {\n      if (health > 0) {\n        health--;\n        updateHealthDisplay();\n        statusText.setText('受到伤害！-1 HP');\n        \n        // 清除之前的提示\n        this.time.delayedCall(1000, () => {\n          statusText.setText('');\n        });\n      } else {\n        statusText.setText('生命值已为0！');\n        this.time.delayedCall(1000, () => {\n          statusText.setText('');\n        });\n      }\n    }\n  });\n\n  // 创建自动回血定时器 - 每0.5秒触发一次\n  healTimer = this.time.addEvent({\n    delay: 500,  // 0.5秒 = 500毫秒\n    callback: () => {\n      if (health < MAX_HEALTH) {\n        health++;\n        updateHealthDisplay();\n        statusText.setText('自动回复！+1 HP');\n        \n        // 清除提示\n        this.time.delayedCall(800, () => {\n          statusText.setText('');\n        });\n      }\n    },\n    loop: true  // 循环执行\n  });\n\n  // 更新血条显示的函数\n  function updateHealthDisplay() {\n    // 更新每个血条的显示状态\n    for (let i = 0; i < MAX_HEALTH; i++) {\n      healthBars[i].clear();\n      if (i < health) {\n        // 有血 - 红色\n        healthBars[i].fillStyle(0xff0000, 1);\n      } else {\n        // 无血 - 深灰色\n        healthBars[i].fillStyle(0x444444, 1);\n      }\n      healthBars[i].fillRect(5, 5, 70, 70);\n    }\n\n    // 更新文本显示\n    healthText.setText(`生命值: ${health}/${MAX_HEALTH}`);\n    \n    // 根据生命值改变文本颜色\n    if (health === 0) {\n      healthText.setColor('#ff0000');\n    } else if (health === MAX_HEALTH) {\n      healthText.setColor('#00ff00');\n    } else {\n      healthText.setColor('#ffff00');\n    }\n  }\n\n  // 初始化显示\n  updateHealthDisplay();\n\n  // 添加调试信息\n  const debugText = this.add.text(10, 10, '', {\n    fontSize: '14px',\n    color: '#888888'\n  });\n\n  // 在update中更新调试信息\n  this.updateDebug = () => {\n    const elapsed = healTimer.getElapsed();\n    const remaining = healTimer.getRemaining();\n    debugText.setText(\n      `Debug Info:\\n` +\n      `Health: ${health}/${MAX_HEALTH}\\n` +\n      `Next Heal: ${(remaining / 1000).toFixed(2)}s\\n` +\n      `Timer Elapsed: ${(elapsed / 1000).toFixed(2)}s`\n    );\n  };\n}\n\nfunction update(time, delta) {\n  // 更新调试信息\n  if (this.updateDebug) {\n    this.updateDebug();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001377_v1", "prompt_id": "seed_001377", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.42}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绿色玩家移出边界时从对侧出现（循环地图效果），移动速度 240。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 绿色玩家移出边界时从对侧出现（循环地图效果），移动速度 240\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), sprite.setVelocity(), Phaser.Math.Wrap\nSTEPS:\n1. 创建 800x600 的游戏场景，启用 Arcade 物理系统\n2. 使用 Graphics 生成绿色玩家纹理（32x32 方块）\n3. 创建物理精灵，设置移动速度为 240\n4. 在 create 中绑定键盘方向键输入\n5. 在 update 中根据方向键控制玩家速度\n6. 在 update 中使用 Phaser.Math.Wrap 实现边界循环效果\n7. 添加位置信息作为可验证状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nlet playerSpeed = 240;\n\n// 状态信号变量\nlet positionX = 400;\nlet positionY = 300;\nlet wrapCount = 0; // 记录穿越边界次数\n\nfunction preload() {\n  // 使用 Graphics 创建绿色玩家纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵（位于屏幕中心）\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n  \n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加 WASD 键支持\n  this.keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 显示状态信息\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 显示说明\n  this.add.text(400, 550, '使用方向键或 WASD 移动 | 移出边界会从对侧出现', {\n    fontSize: '14px',\n    fill: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0, 0);\n  \n  // 处理键盘输入\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  if (cursors.left.isDown || this.keys.a.isDown) {\n    velocityX = -playerSpeed;\n  } else if (cursors.right.isDown || this.keys.d.isDown) {\n    velocityX = playerSpeed;\n  }\n  \n  if (cursors.up.isDown || this.keys.w.isDown) {\n    velocityY = -playerSpeed;\n  } else if (cursors.down.isDown || this.keys.s.isDown) {\n    velocityY = playerSpeed;\n  }\n  \n  // 对角线移动时归一化速度\n  if (velocityX !== 0 && velocityY !== 0) {\n    const diagonal = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX = (velocityX / diagonal) * playerSpeed;\n    velocityY = (velocityY / diagonal) * playerSpeed;\n  }\n  \n  player.setVelocity(velocityX, velocityY);\n  \n  // 记录循环前的位置\n  const oldX = player.x;\n  const oldY = player.y;\n  \n  // 边界循环效果 - 使用 Phaser.Math.Wrap\n  // Wrap 函数：当值超出范围时从另一端重新出现\n  player.x = Phaser.Math.Wrap(player.x, -16, config.width + 16);\n  player.y = Phaser.Math.Wrap(player.y, -16, config.height + 16);\n  \n  // 检测是否发生了边界穿越\n  if (Math.abs(player.x - oldX) > 100 || Math.abs(player.y - oldY) > 100) {\n    wrapCount++;\n  }\n  \n  // 更新状态信号\n  positionX = Math.round(player.x);\n  positionY = Math.round(player.y);\n  \n  // 更新状态显示\n  this.statusText.setText([\n    `Position: (${positionX}, ${positionY})`,\n    `Speed: ${playerSpeed}`,\n    `Wrap Count: ${wrapCount}`,\n    `Velocity: (${Math.round(player.body.velocity.x)}, ${Math.round(player.body.velocity.y)})`\n  ]);\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000865_v2", "prompt_id": "seed_000865", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色六边形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色六边形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的六个顶点坐标（中心点为画布中央，半径约 40 像素）\n4. 使用 Graphics API 绘制路径并填充红色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 六边形半径（从中心到顶点的距离）\n  const radius = 40;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制六边形的六个顶点\n  // 六边形的顶点角度间隔为 60 度（Math.PI / 3）\n  // 从顶部开始（-90 度或 -Math.PI / 2）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - (Math.PI / 2);\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000597_v1", "prompt_id": "seed_000597", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.39}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 5 个青色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成5个青色可收集物体，玩家碰撞后消失并加分\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家和可收集物的纹理（玩家用绿色方块，收集物用青色圆形）\n3. 创建玩家精灵，添加键盘控制（方向键移动）\n4. 创建物理组，随机位置生成5个青色收集物\n5. 使用 overlap 检测玩家与收集物碰撞，碰撞后销毁收集物并加分\n6. 创建文本显示当前分数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（青色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x00ffff, 1);\n  collectibleGraphics.fillCircle(16, 16, 16);\n  collectibleGraphics.generateTexture('collectible', 32, 32);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成5个收集物\n  for (let i = 0; i < 5; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数显示\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect Cyan Circles', {\n    fontSize: '16px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 检查是否收集完所有物品\n  if (collectibles.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - ALL COLLECTED!');\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001091_v1", "prompt_id": "seed_001091", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.405}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色星形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个灰色星形在1秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色星形并生成纹理\n2. 创建 Sprite 对象使用该星形纹理\n3. 使用 tweens 创建 x 坐标补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x888888, 1); // 灰色\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push({\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0].x, starPoints[0].y);\n  for (let i = 1; i < starPoints.length; i++) {\n    graphics.lineTo(starPoints[i].x, starPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右，1秒完成，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 1000, // 1秒\n    yoyo: true, // 往返\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000760_v1", "prompt_id": "seed_000760", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.45666666666666667}}
