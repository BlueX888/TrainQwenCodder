{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的灰色方块，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制10个24像素的灰色方块\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置灰色，fillRect 绘制 24x24 的方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#ffffff',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色 (0x808080)\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制10个随机位置的方块\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保方块完全在画布内\n    // x: 0 到 (800 - 24)，y: 0 到 (600 - 24)\n    const x = Phaser.Math.Between(0, 776);\n    const y = Phaser.Math.Between(0, 576);\n    \n    // 绘制 24x24 的方块\n    graphics.fillRect(x, y, 24, 24);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000373_v3", "prompt_id": "seed_000373", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色星形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色星形以240速度移动并在边界反弹\nAPI: Graphics.fillStyle, Graphics.fillStar, Graphics.generateTexture, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制青色星形并生成纹理\n2. 创建启用物理的精灵对象，应用星形纹理\n3. 设置精灵速度为240（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色星形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制星形 (x, y, points, innerRadius, outerRadius)\n  // 中心点设为 (40, 40)，5个角，内半径20，外半径40\n  graphics.fillStar(40, 40, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 80, 80);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（斜向移动，速度大约为240）\n  // 使用勾股定理：sqrt(170^2 + 170^2) ≈ 240\n  star.setVelocity(170, 170);\n  \n  // 设置完全反弹（弹性系数为1）\n  star.setBounce(1, 1);\n  \n  // 启用与世界边界的碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 确保物理体大小与显示对象匹配\n  star.body.setSize(80, 80);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000033_v3", "prompt_id": "seed_000033", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 80 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Scene.input.keyboard.addKey\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建 Sprite 使用六边形纹理\n4. 添加 WASD 键盘输入监听\n5. 在 update 中根据按键状态移动六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet cursors;\nconst SPEED = 80;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制六边形（中心点在 32, 32）\n  const hexRadius = 30;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = 32 + hexRadius * Math.cos(angle);\n    const y = 32 + hexRadius * Math.sin(angle);\n    hexPoints.push(x, y);\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0], hexPoints[1]);\n  for (let i = 2; i < hexPoints.length; i += 2) {\n    graphics.lineTo(hexPoints[i], hexPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 64, 64);\n  graphics.destroy();\n  \n  // 创建六边形精灵，放置在屏幕中央\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 添加 WASD 键盘输入\n  cursors = {\n    w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检查 WASD 键状态并设置移动方向\n  if (cursors.w.isDown) {\n    velocityY = -1;\n  } else if (cursors.s.isDown) {\n    velocityY = 1;\n  }\n  \n  if (cursors.a.isDown) {\n    velocityX = -1;\n  } else if (cursors.d.isDown) {\n    velocityX = 1;\n  }\n  \n  // 归一化对角线移动速度（避免对角线移动过快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n  \n  // 应用移动\n  hexagon.x += velocityX * distance;\n  hexagon.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000343_v3", "prompt_id": "seed_000343", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆形状\n2. 在 create 中初始化椭圆的位置和旋转角度\n3. 在 update 中根据 delta 时间增量计算旋转角度（160度/秒 = 160 * (delta/1000) 度/帧）\n4. 将角度转换为弧度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipseGraphics;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象并绘制椭圆\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置椭圆的填充颜色\n  ellipseGraphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制椭圆（中心在原点，宽度 200，高度 100）\n  ellipseGraphics.fillEllipse(0, 0, 200, 100);\n  \n  // 设置椭圆位置到屏幕中心\n  ellipseGraphics.x = 400;\n  ellipseGraphics.y = 300;\n  \n  // 初始化旋转角度\n  currentRotation = 0;\n  \n  // 添加文字提示\n  this.add.text(10, 10, '椭圆旋转速度: 160度/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧应该旋转的角度（度）\n  // 160 度/秒 * (delta 毫秒 / 1000) = 本帧旋转角度\n  const rotationDegrees = 160 * (delta / 1000);\n  \n  // 累加旋转角度\n  currentRotation += rotationDegrees;\n  \n  // 将角度转换为弧度并应用到 Graphics 对象\n  // Phaser 使用弧度制，1度 = Math.PI / 180 弧度\n  ellipseGraphics.rotation = Phaser.Math.DegToRad(currentRotation);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000281_v1", "prompt_id": "seed_000281", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色菱形以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色菱形以80速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 使用 Graphics 绘制黄色菱形并生成纹理\n2. 创建 Arcade 物理精灵并应用菱形纹理\n3. 设置初始速度为 80（x和y方向）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);        // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始速度（80速度，沿对角线方向）\n  diamond.setVelocity(80, 80);\n  \n  // 启用世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, '黄色菱形以80速度移动并反弹', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000144_v3", "prompt_id": "seed_000144", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 360 度的速度持续旋转\nAPI: Graphics, Scene.update, GameObject.rotation\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 或 Image 对象使用该纹理\n3. 在 update 方法中根据 delta 时间增量更新旋转角度\n4. 每秒旋转 360 度，即每毫秒旋转 360/1000 度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('squareTex', 100, 100);\n  graphics.destroy();\n  \n  // 创建方块精灵并设置到屏幕中心\n  square = this.add.sprite(400, 300, 'squareTex');\n  \n  // 设置旋转中心点为方块中心\n  square.setOrigin(0.5, 0.5);\n  \n  // 添加提示文本\n  this.add.text(10, 10, '方块以每秒 360° 的速度旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 每秒旋转 360 度 = 2π 弧度\n  // 每毫秒旋转的弧度 = (2 * Math.PI) / 1000\n  // rotation 使用弧度制\n  const rotationSpeed = (2 * Math.PI) / 1000; // 每毫秒旋转的弧度\n  square.rotation += rotationSpeed * delta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000683_v2", "prompt_id": "seed_000683", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的绿色三角形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的绿色三角形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillTriangle, Graphics#fillStyle, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环20次，每次生成随机坐标位置\n4. 使用 fillTriangle 绘制等边三角形，计算三个顶点坐标\n5. 设置绿色填充样式，每个三角形大小为32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 三角形的大小（边长）\n  const triangleSize = 32;\n  \n  // 计算等边三角形的高度\n  const height = (Math.sqrt(3) / 2) * triangleSize;\n  \n  // 绘制20个随机位置的三角形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置，确保三角形完全在画布内\n    const x = Phaser.Math.Between(triangleSize, config.width - triangleSize);\n    const y = Phaser.Math.Between(triangleSize, config.height - triangleSize);\n    \n    // 计算等边三角形的三个顶点坐标（顶点朝上）\n    const x1 = x;                           // 顶点\n    const y1 = y - height / 2;\n    \n    const x2 = x - triangleSize / 2;        // 左下角\n    const y2 = y + height / 2;\n    \n    const x3 = x + triangleSize / 2;        // 右下角\n    const y3 = y + height / 2;\n    \n    // 绘制填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000303_v3", "prompt_id": "seed_000303", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色星形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色星形并生成纹理\n2. 创建星形精灵并定位到左侧起点\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  const drawStar = (graphics, cx, cy, spikes, outerRadius, innerRadius, color) => {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.fillStyle(color, 1);\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillPath();\n  };\n\n  // 绘制橙色星形（中心在 50, 50，用于生成纹理）\n  drawStar(graphics, 50, 50, 5, 40, 20, 0xFF8C00);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n\n  // 创建星形精灵\n  const star = this.add.sprite(100, 300, 'star');\n\n  // 创建补间动画：从左到右，然后往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5秒\n    ease: 'Linear',\n    yoyo: true, // 启用往返效果\n    repeat: -1 // 无限循环\n  });\n\n  // 添加说明文字\n  this.add.text(400, 50, '橙色星形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000566_v3", "prompt_id": "seed_000566", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在0.5秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 系统创建缩放动画，设置 scale 从 1 到 0.32 再到 1\n4. 设置 Tween 的 duration 为 500ms，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 64）\n  const size = 64;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 上顶点\n  graphics.lineTo(size * 2, size);    // 右顶点\n  graphics.lineTo(size, size * 2);    // 下顶点\n  graphics.lineTo(0, size);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 500,      // 0.5秒缩小到32%\n    yoyo: true,         // 自动返回原始值\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Diamond scaling to 32% and back', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000408_v3", "prompt_id": "seed_000408", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的粉色六边形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的粉色六边形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算六个顶点坐标（半径12像素）\n4. 循环20次，每次在随机位置绘制粉色六边形\n5. 使用 fillStyle 设置粉色，beginPath/lineTo 绘制路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xFFC0CB, 1);\n  \n  // 绘制20个随机位置的六边形\n  for (let i = 0; i < 20; i++) {\n    // 随机位置（留出边距避免六边形超出边界）\n    const x = Math.random() * (800 - 48) + 24;\n    const y = Math.random() * (600 - 48) + 24;\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, 12);\n  }\n}\n\n/**\n * 绘制正六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} radius - 外接圆半径（12像素，使六边形大小为24像素）\n */\nfunction drawHexagon(graphics, x, y, radius) {\n  graphics.beginPath();\n  \n  // 计算六边形的六个顶点\n  // 从顶部开始，顺时针绘制（角度从 -90° 开始）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每个顶点间隔60度\n    const vx = x + radius * Math.cos(angle);\n    const vy = y + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vx, vy);\n    } else {\n      graphics.lineTo(vx, vy);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000072_v3", "prompt_id": "seed_000072", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的圆形对象\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 使用 Graphics 绘制圆形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 使用物理系统让圆形自动向右下移动\n4. 调用 camera.startFollow 让相机跟随圆形对象\n5. 扩大世界边界以容纳移动范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\n\nfunction preload() {\n  // 使用 Graphics 创建圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 扩大世界边界，允许对象移动到更大的范围\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 创建玩家对象（圆形）\n  player = this.physics.add.sprite(400, 300, 'circle');\n  \n  // 设置圆形向右下方移动的速度\n  player.setVelocity(150, 150);\n  \n  // 设置对象在世界边界内碰撞反弹\n  player.setCollideWorldBounds(true);\n  player.setBounce(1, 1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3000, 3000);\n  \n  // 相机跟随玩家对象，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 添加背景网格以便观察相机移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    gridGraphics.moveTo(x, 0);\n    gridGraphics.lineTo(x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(3000, y);\n  }\n  gridGraphics.strokePath();\n  \n  // 添加文字提示\n  const text = this.add.text(16, 16, '相机跟随圆形移动', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 固定文字在相机视图中\n  text.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 当前物理系统会自动处理圆形的移动和碰撞\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000437_v3", "prompt_id": "seed_000437", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色矩形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色矩形在2.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Game\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制青色矩形\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 实现往返效果，设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\n// Phaser3 补间动画示例：青色矩形左右往返循环\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制青色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillRect(0, 0, 60, 60); // 绘制 60x60 的矩形\n  \n  // 生成纹理供 Sprite 使用\n  graphics.generateTexture('cyanRect', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建使用该纹理的精灵\n  const rect = this.add.sprite(100, 300, 'cyanRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（从左移到右）\n    duration: 2500,          // 持续时间 2.5 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向播放）\n    repeat: -1,              // 无限循环（-1 表示永久重复）\n    ease: 'Linear'           // 线性缓动函数，匀速移动\n  });\n  \n  // 添加提示文字\n  this.add.text(300, 50, 'Cyan Rectangle Tween Loop', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000122_v1", "prompt_id": "seed_000122", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的绿色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的绿色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用循环创建8个 Graphics 对象\n3. 对每个 Graphics 对象使用 fillTriangle 绘制绿色三角形（大小16像素）\n4. 使用 setRandomPosition 将三角形随机分布在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建8个绿色三角形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制等边三角形，大小为16像素\n    // 三角形顶点坐标（以中心为原点）\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height * 2/3,           // 顶点（上）\n      -size / 2, height * 1/3,    // 左下顶点\n      size / 2, height * 1/3      // 右下顶点\n    );\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const padding = size;\n    const randomX = Phaser.Math.Between(padding, 800 - padding);\n    const randomY = Phaser.Math.Between(padding, 600 - padding);\n    \n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000764_v2", "prompt_id": "seed_000764", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算菱形四个顶点坐标（中心点在画布中央，菱形对角线长度为 48 像素）\n4. 使用 Graphics API 绘制菱形路径并填充灰色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 菱形大小（对角线长度的一半）\n  const size = 24; // 48 / 2 = 24\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000100_v3", "prompt_id": "seed_000100", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 创建 Phaser Game 配置，使用 HEADLESS 或 AUTO 类型\n2. 在 create 方法中使用 Graphics 绘制一个矩形\n3. 在 update 方法中根据 delta 时间增量计算旋转角度（每秒 160 度）\n4. 将计算的角度累加到矩形的 rotation 属性上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet rectangle;\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个矩形\n  rectangle = this.add.graphics();\n  rectangle.fillStyle(0xff6600, 1);\n  \n  // 绘制矩形，以中心点为原点（-50, -30 到 50, 30）\n  rectangle.fillRect(-50, -30, 100, 60);\n  \n  // 设置矩形位置到屏幕中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 160 度\n  // delta 是毫秒，需要转换为秒\n  // 160 度转换为弧度：160 * (Math.PI / 180)\n  const rotationSpeed = 160 * (Math.PI / 180); // 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000); // 本帧旋转量\n  \n  // 累加旋转角度\n  rectangle.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000752_v3", "prompt_id": "seed_000752", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的橙色椭圆，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的橙色椭圆，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环3次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置橙色（0xFFA500），使用 fillEllipse 绘制椭圆（中心0,0，半径32）\n4. 使用 setRandomPosition 将每个椭圆随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建3个橙色椭圆\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const ellipse = this.add.graphics();\n    \n    // 设置橙色填充（0xFFA500 是橙色的十六进制值）\n    ellipse.fillStyle(0xFFA500, 1);\n    \n    // 绘制椭圆，中心点在(0, 0)，宽高各64像素（半径32）\n    ellipse.fillEllipse(0, 0, 64, 64);\n    \n    // 设置随机位置（考虑椭圆大小，避免超出边界）\n    const randomX = Phaser.Math.Between(32, 800 - 32);\n    const randomY = Phaser.Math.Between(32, 600 - 32);\n    ellipse.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000288_v3", "prompt_id": "seed_000288", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色椭圆在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色椭圆从左到右1秒往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillEllipse(40, 30, 80, 60); // 在中心绘制椭圆\n  \n  // 生成纹理\n  graphics.generateTexture('pinkEllipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象\n  const ellipseSprite = this.add.sprite(100, 300, 'pinkEllipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    x: 700, // 移动到右侧\n    duration: 1000, // 1秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环 (-1 表示永久循环)\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000012_v3", "prompt_id": "seed_000012", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现紫色血条 UI，显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Scene 并初始化生命值变量为 10\n2. 使用 Graphics 绘制 10 个紫色矩形作为血条格子\n3. 监听空格键按下事件，每次扣除 1 点生命值\n4. 根据当前生命值重新绘制血条（显示剩余格子）\n5. 当生命值为 0 时显示 Game Over 文本并停止接受输入\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.health = 10; // 当前生命值\n    this.maxHealth = 10; // 最大生命值\n    this.healthBarGraphics = null;\n    this.gameOverText = null;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建血条标题\n    this.add.text(50, 50, 'Health:', {\n      fontSize: '24px',\n      color: '#ffffff'\n    });\n\n    // 创建血条 Graphics 对象\n    this.healthBarGraphics = this.add.graphics();\n    this.drawHealthBar();\n\n    // 创建操作提示\n    this.add.text(50, 150, 'Press SPACE to take damage', {\n      fontSize: '18px',\n      color: '#cccccc'\n    });\n\n    // 创建生命值数字显示\n    this.healthText = this.add.text(50, 180, `HP: ${this.health}/${this.maxHealth}`, {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.spaceKey.on('down', this.takeDamage, this);\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n  }\n\n  drawHealthBar() {\n    // 清空之前的绘制\n    this.healthBarGraphics.clear();\n\n    const barX = 150; // 血条起始 X 坐标\n    const barY = 50; // 血条起始 Y 坐标\n    const cellWidth = 40; // 每格宽度\n    const cellHeight = 30; // 每格高度\n    const gap = 5; // 格子间隙\n\n    // 绘制背景（空血条）\n    this.healthBarGraphics.fillStyle(0x333333, 1);\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = barX + i * (cellWidth + gap);\n      this.healthBarGraphics.fillRect(x, barY, cellWidth, cellHeight);\n    }\n\n    // 绘制当前生命值（紫色）\n    this.healthBarGraphics.fillStyle(0x9b59b6, 1); // 紫色\n    for (let i = 0; i < this.health; i++) {\n      const x = barX + i * (cellWidth + gap);\n      this.healthBarGraphics.fillRect(x, barY, cellWidth, cellHeight);\n    }\n\n    // 绘制边框\n    this.healthBarGraphics.lineStyle(2, 0xffffff, 1);\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = barX + i * (cellWidth + gap);\n      this.healthBarGraphics.strokeRect(x, barY, cellWidth, cellHeight);\n    }\n  }\n\n  takeDamage() {\n    // 如果游戏已结束，不再处理\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 扣除生命值\n    if (this.health > 0) {\n      this.health--;\n      this.drawHealthBar();\n      this.healthText.setText(`HP: ${this.health}/${this.maxHealth}`);\n\n      // 检查是否死亡\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  triggerGameOver() {\n    this.isGameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 移除空格键监听\n    this.spaceKey.off('down', this.takeDamage, this);\n\n    // 添加重启提示\n    this.add.text(400, 400, 'Press R to Restart', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 监听 R 键重启游戏\n    const restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n    restartKey.on('down', () => {\n      this.scene.restart();\n    });\n  }\n\n  update(time, delta) {\n    // 此游戏不需要每帧更新逻辑\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000994_v3", "prompt_id": "seed_000994", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 启用世界边界碰撞和反弹\n5. 设置精灵与世界边界碰撞\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制椭圆（中心点在 40, 30，半径为 40x30）\n  graphics.fillEllipse(40, 30, 80, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（速度为200，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 200;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 200;\n  ellipse.setVelocity(velocityX, velocityY);\n  \n  // 启用与世界边界的碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 确保世界边界碰撞已启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000081_v3", "prompt_id": "seed_000081", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形\n2. 使用 tweens.add 创建缩放补间动画\n3. 设置 scale 属性从 1 缩放到 0.8，duration 为 3000ms\n4. 设置 yoyo 为 true 实现往返效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个矩形 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制一个矩形（中心点在 0,0）\n  const rectWidth = 200;\n  const rectHeight = 150;\n  graphics.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);\n  \n  // 设置矩形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放补间动画\n  this.tweens.add({\n    targets: graphics,        // 动画目标对象\n    scaleX: 0.8,             // X 轴缩放到 80%\n    scaleY: 0.8,             // Y 轴缩放到 80%\n    duration: 3000,          // 持续时间 3 秒\n    yoyo: true,              // 启用往返效果（缩放后自动恢复）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'   // 缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '矩形将在 3 秒内缩放到 80% 并循环播放', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000646_v1", "prompt_id": "seed_000646", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让紫色矩形在 2.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色矩形，使用 Tween 实现 2.5 秒弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建 y 轴弹跳动画，设置 ease 为 'Bounce.easeOut'\n4. 设置动画持续时间为 2500ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('purpleRect', 100, 100);\n  graphics.destroy();\n\n  // 创建紫色矩形精灵，放置在画面中央偏上位置\n  const rect = this.add.sprite(400, 200, 'purpleRect');\n\n  // 创建弹跳动画\n  // 使用 yoyo 和 Bounce.easeOut 实现弹跳效果\n  this.tweens.add({\n    targets: rect,\n    y: 400, // 从 200 弹跳到 400\n    duration: 2500, // 2.5 秒完成一次弹跳\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返运动\n    repeat: -1, // 无限循环\n    hold: 0, // 不在终点停留\n    repeatDelay: 0 // 重复之间无延迟\n  });\n\n  // 添加说明文字\n  this.add.text(400, 550, '紫色矩形弹跳动画 (2.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000461_v2", "prompt_id": "seed_000461", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环15次，每次创建一个 Graphics 对象\n3. 计算六边形的6个顶点坐标（基于中心点和半径32像素）\n4. 使用 Graphics API 绘制紫色填充的六边形\n5. 为每个六边形设置随机位置（确保在画布范围内）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  const hexagonCount = 15;\n  const hexagonSize = 64; // 六边形的\"宽度\"\n  const hexagonRadius = hexagonSize / 2; // 从中心到顶点的距离\n  \n  // 创建15个随机位置的紫色六边形\n  for (let i = 0; i < hexagonCount; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充\n    graphics.fillStyle(0x9932cc, 1); // 紫色 (DarkOrchid)\n    \n    // 计算随机位置（确保六边形完全在画布内）\n    const x = Phaser.Math.Between(hexagonRadius, config.width - hexagonRadius);\n    const y = Phaser.Math.Between(hexagonRadius, config.height - hexagonRadius);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, hexagonRadius);\n  }\n}\n\n/**\n * 绘制一个正六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} centerX - 中心点 X 坐标\n * @param {number} centerY - 中心点 Y 坐标\n * @param {number} radius - 从中心到顶点的距离\n */\nfunction drawHexagon(graphics, centerX, centerY, radius) {\n  graphics.beginPath();\n  \n  // 六边形有6个顶点，每个顶点间隔60度（Math.PI / 3）\n  // 从顶部开始绘制（-90度 或 -Math.PI / 2）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - (Math.PI / 2); // 每个顶点的角度\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000644_v3", "prompt_id": "seed_000644", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 80 像素/秒速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建 Scene 配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 生成椭圆纹理\n3. 创建椭圆精灵对象并设置初始位置\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态计算速度并更新椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 生成椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色椭圆\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40, 30)，宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n\n  // 创建椭圆精灵，放置在画布中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n\n  // 添加 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间间隔(秒)\n  const distance = SPEED * (delta / 1000);\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 根据按键状态设置移动方向\n  if (keys.w.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.s.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.a.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.d.isDown) {\n    velocityX = 1; // 向右\n  }\n\n  // 对角线移动时归一化速度（避免速度变快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const magnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= magnitude;\n    velocityY /= magnitude;\n  }\n\n  // 更新椭圆位置\n  ellipse.x += velocityX * distance;\n  ellipse.y += velocityY * distance;\n\n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 40, 760);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 30, 570);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000203_v1", "prompt_id": "seed_000203", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 8 个金币，重力 400，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集8个金币，重力400，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力为 400\n2. 使用 Graphics 生成玩家（蓝色方块）和金币（黄色圆形）纹理\n3. 创建地面平台和空中平台（使用 StaticGroup）\n4. 生成 8 个金币分布在平台上方\n5. 添加键盘输入控制（左右移动+跳跃）\n6. 实现碰撞检测：玩家与平台、玩家与金币\n7. 收集金币时增加分数并销毁金币\n8. 显示分数文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x4a90e2, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffd700, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n\n    // 生成平台纹理（绿色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x2ecc71, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 生成地面纹理（深绿色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x27ae60, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n\n    // 创建地面\n    this.platforms = this.physics.add.staticGroup();\n    this.platforms.create(400, 580, 'ground');\n\n    // 创建空中平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(400, 300, 'platform');\n    this.platforms.create(150, 250, 'platform');\n    this.platforms.create(650, 200, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在平台上方生成 8 个金币\n    const coinPositions = [\n      { x: 200, y: 400 },\n      { x: 250, y: 400 },\n      { x: 600, y: 350 },\n      { x: 650, y: 350 },\n      { x: 400, y: 250 },\n      { x: 150, y: 200 },\n      { x: 650, y: 150 },\n      { x: 700, y: 150 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.3);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n    \n    // 设置玩家与金币的重叠检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 添加游戏说明\n    this.add.text(16, 56, 'Arrow Keys: Move & Jump', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 2\n    });\n\n    // 胜利文本（初始隐藏）\n    this.winText = this.add.text(400, 300, 'You Win!', {\n      fontSize: '64px',\n      fill: '#ffd700',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 6\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n  }\n\n  update() {\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃（只有在地面或平台上才能跳）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.score === 80) {\n      this.winText.setVisible(true);\n      \n      // 2秒后重新开始游戏\n      this.time.delayedCall(2000, () => {\n        this.scene.restart();\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001047_v2", "prompt_id": "seed_001047", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.905}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 青色玩家移出边界时从对侧出现（循环地图效果），移动速度 80。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 青色玩家移出边界时从对侧出现（循环地图效果），移动速度 80\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard.createCursorKeys, Graphics.fillStyle, Graphics.fillCircle, Graphics.generateTexture\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制青色圆形纹理作为玩家\n3. 创建物理精灵并设置移动速度为 80\n4. 监听键盘输入（方向键）控制玩家移动\n5. 在 update 中检测边界，实现循环地图效果（左边界→右边界，上边界→下边界等）\n6. 添加状态信号（记录穿越边界次数作为验证）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nlet boundaryText;\nlet crossCount = 0; // 状态信号：记录穿越边界次数\n\nconst PLAYER_SPEED = 80;\n\nfunction preload() {\n  // 使用 Graphics 创建青色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(16, 16, 16); // 半径 16 的圆形\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵（初始位置在屏幕中心）\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n  \n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加 WASD 键支持\n  this.wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  this.aKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  this.sKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  this.dKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 显示状态信息\n  this.add.text(16, 16, '使用方向键或 WASD 移动', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n  \n  boundaryText = this.add.text(16, 50, '穿越边界次数: 0', {\n    fontSize: '18px',\n    fill: '#00ffff'\n  });\n  \n  // 显示玩家位置（用于调试验证）\n  this.positionText = this.add.text(16, 84, '', {\n    fontSize: '16px',\n    fill: '#aaaaaa'\n  });\n}\n\nfunction update() {\n  // 重置速度\n  player.setVelocity(0);\n  \n  // 处理键盘输入\n  if (cursors.left.isDown || this.aKey.isDown) {\n    player.setVelocityX(-PLAYER_SPEED);\n  } else if (cursors.right.isDown || this.dKey.isDown) {\n    player.setVelocityX(PLAYER_SPEED);\n  }\n  \n  if (cursors.up.isDown || this.wKey.isDown) {\n    player.setVelocityY(-PLAYER_SPEED);\n  } else if (cursors.down.isDown || this.sKey.isDown) {\n    player.setVelocityY(PLAYER_SPEED);\n  }\n  \n  // 循环地图效果：检测边界并从对侧出现\n  const playerRadius = 16; // 玩家半径\n  \n  // 左边界 → 右边界\n  if (player.x < -playerRadius) {\n    player.x = config.width + playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 右边界 → 左边界\n  if (player.x > config.width + playerRadius) {\n    player.x = -playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 上边界 → 下边界\n  if (player.y < -playerRadius) {\n    player.y = config.height + playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 下边界 → 上边界\n  if (player.y > config.height + playerRadius) {\n    player.y = -playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 更新位置显示\n  this.positionText.setText(`位置: (${Math.round(player.x)}, ${Math.round(player.y)})`);\n}\n\nfunction updateBoundaryText() {\n  boundaryText.setText(`穿越边界次数: ${crossCount}`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000857_v1", "prompt_id": "seed_000857", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的方块在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的方块并保持居中\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个方块纹理\n2. 创建 Sprite 对象作为移动的方块\n3. 在 create 中设置方块的初始位置和速度（向右上移动）\n4. 使用 camera.startFollow 让相机跟随方块\n5. 在 update 中持续更新方块位置实现自动移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet velocityX = 100; // 向右移动速度\nlet velocityY = -80; // 向上移动速度\n\nfunction preload() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('player', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个大的背景网格以便观察相机移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x555555, 0.5);\n  \n  // 绘制网格（扩大范围以便方块移动）\n  for (let x = 0; x <= 3000; x += 50) {\n    gridGraphics.lineBetween(x, 0, x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 50) {\n    gridGraphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加坐标标记\n  const style = { fontSize: '14px', color: '#ffffff' };\n  this.add.text(50, 50, 'Start (0,0)', style);\n  this.add.text(1500, 50, '(1500,0)', style);\n  this.add.text(50, 1000, '(0,1000)', style);\n  \n  // 创建玩家方块\n  player = this.add.sprite(100, 500, 'player');\n  player.setOrigin(0.5, 0.5);\n  \n  // 设置相机边界（扩大场景范围）\n  this.cameras.main.setBounds(0, 0, 3000, 2000);\n  \n  // 相机跟随玩家，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 添加提示文本（固定在相机上）\n  const infoText = this.add.text(10, 10, 'Camera following green square', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让方块持续向右上移动\n  player.x += velocityX * (delta / 1000);\n  player.y += velocityY * (delta / 1000);\n  \n  // 可选：当方块移出场景边界时重置位置\n  if (player.x > 2900 || player.y < 100) {\n    player.x = 100;\n    player.y = 500;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000517_v1", "prompt_id": "seed_000517", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8733333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：蓝色敌人从上方以 360 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，蓝色敌人从上方以360速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（绿色方块）和敌人（蓝色方块）纹理\n3. 创建玩家精灵，设置键盘控制（左右方向键）\n4. 定时生成敌人精灵，设置下落速度为360\n5. 添加碰撞检测，碰撞时游戏结束并显示文本\n6. 在 update 中处理玩家移动和敌人回收逻辑\n7. 添加分数系统，记录存活时间\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.enemySpeed = 360;\n    this.playerSpeed = 300;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每0.8秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 800,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 370, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 空格键重启\n    this.spaceKey = this.input.keyboard.addKey(\n      Phaser.Input.Keyboard.KeyCodes.SPACE\n    );\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      // 游戏结束后，按空格重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.scene.restart();\n        this.score = 0;\n        this.gameOver = false;\n      }\n      return;\n    }\n\n    // 玩家左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 更新分数（每秒增加10分）\n    this.score += delta / 100;\n    this.scoreText.setText('Score: ' + Math.floor(this.score));\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) return;\n\n    // 随机 x 位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  hitEnemy(player, enemy) {\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.enemyTimer.remove();\n\n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 玩家变红\n    player.setTint(0xff0000);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001079_v2", "prompt_id": "seed_001079", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9191666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, this.cameras.main\nSTEPS:\n1. 创建 Scene 并设置较大的世界边界以容纳星形移动\n2. 使用 Graphics 绘制一个星形作为跟随目标\n3. 在 update 中让星形持续向上移动\n4. 使用 camera.startFollow 让主相机跟随星形对象\n5. 设置相机边界与世界边界一致\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 每秒移动像素\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 设置世界边界，让星形有足够的移动空间\n    this.cameras.main.setBounds(0, 0, 800, 3000);\n    this.physics.world.setBounds(0, 0, 800, 3000);\n\n    // 创建星形图形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1); // 黄色星形\n    graphics.lineStyle(2, 0xff6600, 1); // 橙色边框\n\n    // 绘制星形（5个角）\n    const points = [];\n    const centerX = 0;\n    const centerY = 0;\n    const outerRadius = 30;\n    const innerRadius = 15;\n    const numPoints = 5;\n\n    for (let i = 0; i < numPoints * 2; i++) {\n      const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      points.push({\n        x: centerX + Math.cos(angle) * radius,\n        y: centerY + Math.sin(angle) * radius\n      });\n    }\n\n    graphics.beginPath();\n    graphics.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      graphics.lineTo(points[i].x, points[i].y);\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n\n    // 生成纹理\n    graphics.generateTexture('starTexture', 60, 60);\n    graphics.destroy();\n\n    // 创建星形精灵并启用物理\n    this.star = this.physics.add.sprite(400, 2800, 'starTexture');\n    this.star.setCollideWorldBounds(true);\n\n    // 设置相机跟随星形\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机跟随偏移，让星形显示在屏幕中心稍下方\n    // this.cameras.main.setFollowOffset(0, 0);\n\n    // 添加提示文本（固定在相机上）\n    const instructionText = this.add.text(10, 10, 'Star moving up\\nCamera following', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    instructionText.setScrollFactor(0); // 固定在相机视口上\n\n    // 添加位置信息文本\n    this.positionText = this.add.text(10, 80, '', {\n      fontSize: '14px',\n      fill: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.positionText.setScrollFactor(0);\n  }\n\n  update(time, delta) {\n    if (this.star) {\n      // 让星形向上移动（Y坐标减小）\n      this.star.y -= (this.speed * delta) / 1000;\n\n      // 如果到达世界顶部，重置到底部\n      if (this.star.y < 30) {\n        this.star.y = 2970;\n      }\n\n      // 更新位置信息\n      this.positionText.setText(\n        `Star Y: ${Math.round(this.star.y)}\\n` +\n        `Camera Y: ${Math.round(this.cameras.main.scrollY)}`\n      );\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000497_v2", "prompt_id": "seed_000497", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让方块在1秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，duration 设为 1000ms\n4. 设置 Tween 的 yoyo 为 true 和 repeat 为 -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 1000,            // 动画持续时间 1 秒\n    yoyo: true,                // 反向播放（不透明再变回透明）\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    ease: 'Linear'             // 线性缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000386_v1", "prompt_id": "seed_000386", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在1.5秒内缩放到48%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果：scale 从 1 到 0.48 再回到 1\n4. 设置 Tween 的 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 1500ms（1.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('squareTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'squareTexture');\n  square.setOrigin(0.5, 0.5);\n\n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.48,  // 缩放到 48%\n    scaleY: 0.48,\n    duration: 1500, // 1.5 秒\n    yoyo: true,     // 往返效果（缩小后再放大）\n    loop: -1,       // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Square scaling to 48% and back', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, 'Loop animation: 1.5s to 48%, 1.5s back to 100%', {\n    fontSize: '18px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000607_v1", "prompt_id": "seed_000607", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让紫色矩形在 2.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色矩形，使用 Tween 实现 2.5 秒弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 使用 Graphics 绘制紫色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建 y 轴弹跳动画，设置 ease 为 Bounce，duration 为 2500ms\n4. 设置 yoyo 和 repeat: -1 实现循环弹跳效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建紫色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('purpleRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const rect = this.add.sprite(400, 200, 'purpleRect');\n  \n  // 创建弹跳动画\n  this.tweens.add({\n    targets: rect,\n    y: 500, // 弹跳到的目标位置\n    duration: 2500, // 2.5 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 来回运动\n    repeat: -1, // 无限循环\n    hold: 0 // 到达目标后立即返回\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Purple Rectangle Bounce Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 580, 'Loop: 2.5s per bounce cycle', {\n    fontSize: '16px',\n    color: '#888888'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000461_v3", "prompt_id": "seed_000461", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 0.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建使用该纹理的 Sprite 对象，初始 alpha 设为 0\n3. 使用 Tween 动画让 alpha 从 0 到 1，持续 500ms，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（四个顶点）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建使用菱形纹理的精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 500,               // 持续时间 0.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 反向播放（从 1 回到 0）\n    repeat: -1                   // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000435_v1", "prompt_id": "seed_000435", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并设置初始 alpha 为 0\n3. 使用 Tween 动画让 alpha 从 0 到 1，持续 2 秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80; // 六边形外接圆半径\n  const centerX = 128; // 纹理中心 X\n  const centerY = 128; // 纹理中心 Y\n  \n  // 绘制六边形（6个顶点，从顶部开始顺时针）\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 256, 256);\n  graphics.destroy(); // 销毁 graphics 对象，不再需要\n  \n  // 创建六边形精灵并放置在屏幕中心\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexagon.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1, // 目标透明度：完全不透明\n    duration: 2000, // 持续时间：2 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: false, // 不反向播放\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '六边形淡入动画（循环播放）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000180_v3", "prompt_id": "seed_000180", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个橙色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理20个橙色可复用对象，离屏自动回收\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建橙色圆形纹理用于对象显示\n2. 使用 Physics.Arcade.Group 创建对象池，设置最大数量为20\n3. 定时从对象池获取对象并发射到屏幕\n4. 在 update 中检测对象是否离开屏幕边界\n5. 离屏对象调用 kill() 回收到对象池\n6. 添加状态变量跟踪活跃对象数和总发射数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.totalSpawned = 0;     // 总发射数\n    this.recycledCount = 0;    // 回收次数\n  }\n\n  preload() {\n    // 创建橙色圆形纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xFF6600, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('orangeCircle', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池，最大20个对象\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'orangeCircle',\n      maxSize: 20,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 定时发射对象（每500ms发射一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界提示\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0xffffff, 0.3);\n    graphics.strokeRect(0, 0, 800, 600);\n\n    this.updateStatus();\n  }\n\n  spawnObject() {\n    // 从对象池获取或创建对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 激活对象\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 随机位置和速度\n      const spawnSide = Phaser.Math.Between(0, 3);\n      let x, y, velocityX, velocityY;\n      \n      switch(spawnSide) {\n        case 0: // 从左边发射\n          x = -20;\n          y = Phaser.Math.Between(50, 550);\n          velocityX = Phaser.Math.Between(100, 200);\n          velocityY = Phaser.Math.Between(-100, 100);\n          break;\n        case 1: // 从右边发射\n          x = 820;\n          y = Phaser.Math.Between(50, 550);\n          velocityX = Phaser.Math.Between(-200, -100);\n          velocityY = Phaser.Math.Between(-100, 100);\n          break;\n        case 2: // 从上边发射\n          x = Phaser.Math.Between(50, 750);\n          y = -20;\n          velocityX = Phaser.Math.Between(-100, 100);\n          velocityY = Phaser.Math.Between(100, 200);\n          break;\n        case 3: // 从下边发射\n          x = Phaser.Math.Between(50, 750);\n          y = 620;\n          velocityX = Phaser.Math.Between(-100, 100);\n          velocityY = Phaser.Math.Between(-200, -100);\n          break;\n      }\n      \n      obj.setPosition(x, y);\n      obj.setVelocity(velocityX, velocityY);\n      \n      this.totalSpawned++;\n      this.updateStatus();\n    }\n  }\n\n  update() {\n    // 检查所有活跃对象\n    const children = this.objectPool.getChildren();\n    this.activeCount = 0;\n    \n    children.forEach((obj) => {\n      if (obj.active) {\n        this.activeCount++;\n        \n        // 检测是否离开屏幕边界（带缓冲区）\n        const buffer = 50;\n        if (obj.x < -buffer || obj.x > 800 + buffer || \n            obj.y < -buffer || obj.y > 600 + buffer) {\n          // 回收对象\n          obj.setActive(false);\n          obj.setVisible(false);\n          obj.setVelocity(0, 0);\n          this.recycledCount++;\n        }\n      }\n    });\n    \n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const poolSize = this.objectPool.getLength();\n    const maxSize = this.objectPool.maxSize;\n    \n    this.statusText.setText([\n      `对象池状态:`,\n      `池大小: ${poolSize}/${maxSize}`,\n      `活跃对象: ${this.activeCount}`,\n      `总发射数: ${this.totalSpawned}`,\n      `回收次数: ${this.recycledCount}`,\n      `复用率: ${this.totalSpawned > 0 ? \n        ((this.recycledCount / this.totalSpawned) * 100).toFixed(1) : 0}%`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000939_v3", "prompt_id": "seed_000939", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, this.cameras.main\nSTEPS:\n1. 创建 Scene 并配置游戏窗口\n2. 使用 Graphics 绘制星形对象作为可移动的精灵\n3. 在 create 中设置相机跟随星形对象\n4. 在 update 中让星形持续向下移动\n5. 添加背景网格以便观察相机跟随效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 每秒移动像素\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建背景网格，用于观察相机移动效果\n    this.createBackgroundGrid();\n\n    // 使用 Graphics 创建星形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1);\n    graphics.strokeStyle(0xff8800, 2);\n    \n    // 绘制五角星\n    const points = [];\n    const outerRadius = 30;\n    const innerRadius = 15;\n    for (let i = 0; i < 10; i++) {\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const angle = (i * Math.PI) / 5 - Math.PI / 2;\n      points.push({\n        x: Math.cos(angle) * radius,\n        y: Math.sin(angle) * radius\n      });\n    }\n    \n    graphics.beginPath();\n    graphics.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      graphics.lineTo(points[i].x, points[i].y);\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 生成纹理\n    graphics.generateTexture('star', 64, 64);\n    graphics.destroy();\n\n    // 创建星形精灵，初始位置在屏幕中央上方\n    this.star = this.add.sprite(400, 100, 'star');\n    this.star.setOrigin(0.5, 0.5);\n\n    // 设置相机跟随星形对象\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机边界（让星形可以移动到更大的区域）\n    this.cameras.main.setBounds(0, 0, 800, 2000);\n\n    // 添加提示文字（固定在相机视图中）\n    const text = this.add.text(10, 10, '星形自动向下移动\\n相机跟随中...', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机视图，不随相机移动\n  }\n\n  update(time, delta) {\n    // 让星形持续向下移动\n    if (this.star) {\n      // delta 是毫秒，转换为秒\n      this.star.y += this.speed * (delta / 1000);\n\n      // 可选：到达底部后重置位置（循环效果）\n      if (this.star.y > 1900) {\n        this.star.y = 100;\n      }\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建网格背景，方便观察相机移动\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n\n    const gridSize = 50;\n    const worldHeight = 2000;\n    const worldWidth = 800;\n\n    // 绘制垂直线\n    for (let x = 0; x <= worldWidth; x += gridSize) {\n      graphics.moveTo(x, 0);\n      graphics.lineTo(x, worldHeight);\n    }\n\n    // 绘制水平线\n    for (let y = 0; y <= worldHeight; y += gridSize) {\n      graphics.moveTo(0, y);\n      graphics.lineTo(worldWidth, y);\n    }\n\n    graphics.strokePath();\n\n    // 添加坐标标记\n    for (let y = 0; y <= worldHeight; y += 200) {\n      const label = this.add.text(10, y, `Y: ${y}`, {\n        fontSize: '14px',\n        color: '#00ff00',\n        backgroundColor: '#000000'\n      });\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: GameScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000205_v2", "prompt_id": "seed_000205", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8633333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色矩形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色矩形以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成橙色矩形纹理\n3. 创建物理精灵并设置速度\n4. 设置世界边界碰撞和反弹系数\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet rectangle;\nlet velocityX = 200;\nlet velocityY = 200;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建橙色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillRect(0, 0, 60, 40);\n  graphics.generateTexture('orangeRect', 60, 40);\n  graphics.destroy();\n\n  // 创建物理精灵\n  rectangle = this.physics.add.sprite(400, 300, 'orangeRect');\n  \n  // 设置初始速度\n  rectangle.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  rectangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数\n  rectangle.setBounce(1, 1);\n  \n  // 确保物理体大小与纹理匹配\n  rectangle.body.setSize(60, 40);\n}\n\nfunction update(time, delta) {\n  // Arcade 物理系统的 bounce 和 collideWorldBounds 会自动处理反弹\n  // 不需要手动检测边界\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000311_v2", "prompt_id": "seed_000311", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 4 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Tween 动画让方块在 4 秒内缩放到 64% 并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens 创建缩放动画，设置 scale 从 1 到 0.64\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2000ms（单程 2 秒，往返共 4 秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('squareTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵\n  const square = this.add.sprite(400, 300, 'squareTexture');\n\n  // 创建缩放 Tween 动画\n  // 单程 2 秒，往返共 4 秒\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 2000,      // 单程 2 秒\n    yoyo: true,          // 启用往返效果（缩小后再放大）\n    loop: -1,            // 无限循环\n    ease: 'Linear'       // 线性缓动\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, '方块缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, '缩放范围: 100% -> 64% -> 100%\\n循环周期: 4 秒', {\n    fontSize: '16px',\n    color: '#cccccc',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000784_v3", "prompt_id": "seed_000784", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 500，移动速度 80，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色左右移动、跳跃、重力效果及地面碰撞的平台跳跃游戏\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 500\n2. 使用 Graphics 生成角色和地面的纹理\n3. 创建物理精灵并设置碰撞\n4. 监听键盘输入（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑，速度 80，跳跃速度 -330\n6. 添加状态变量（jumpCount）用于验证\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建角色纹理（使用 Graphics）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面\n    this.ground = this.physics.add.staticGroup();\n    this.ground.create(400, 575, 'ground');\n\n    // 创建多个平台\n    this.platforms = this.physics.add.staticGroup();\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 350, 'platform');\n    this.platforms.create(400, 250, 'platform');\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.ground, () => {\n      this.isGrounded = true;\n    });\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置接地状态（每帧检测）\n    const touchingDown = this.player.body.touching.down;\n    this.isGrounded = touchingDown;\n\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-80);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(80);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃逻辑\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.isGrounded) {\n      this.player.setVelocityY(-330);\n      this.jumpCount++;\n      this.updateStatusText();\n    }\n\n    // 如果玩家掉落到底部，重置位置\n    if (this.player.y > 600) {\n      this.player.setPosition(400, 100);\n      this.player.setVelocity(0, 0);\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Jump Count: ${this.jumpCount}\\n` +\n      `Position: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})\\n` +\n      `Grounded: ${this.isGrounded}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001036_v2", "prompt_id": "seed_001036", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让红色星形在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色星形，使用 Tween 实现 0.5 秒淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制红色星形并生成纹理\n2. 创建 Sprite 对象使用生成的星形纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  \n  // 绘制星形的路径\n  const points = 5; // 五角星\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const centerX = 50;\n  const centerY = 50;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('redStar', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'redStar');\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    alpha: 0,                // 目标透明度（从1淡出到0）\n    duration: 500,           // 持续时间 0.5 秒\n    yoyo: true,              // 反向播放（淡出后再淡入）\n    repeat: -1,              // 无限循环 (-1 表示永久重复)\n    ease: 'Linear'           // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000521_v1", "prompt_id": "seed_000521", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 800。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次，跳跃力度200，重力800\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理场景，设置重力为800\n2. 使用Graphics绘制玩家矩形和地面\n3. 监听空格键输入，实现双跳逻辑（跳跃次数<=2）\n4. 玩家落地时重置跳跃次数\n5. 添加文本显示当前跳跃状态和剩余跳跃次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量（可验证）\nlet jumpCount = 0;\nlet maxJumps = 2;\nlet totalJumps = 0;\nlet isOnGround = false;\n\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet statusText;\nlet jumpCountText;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建地面纹理\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x00aa00, 1);\n  groundGraphics.fillRect(0, 0, 800, 50);\n  groundGraphics.generateTexture('groundTex', 800, 50);\n  groundGraphics.destroy();\n\n  // 创建玩家纹理\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x0088ff, 1);\n  playerGraphics.fillRect(0, 0, 40, 60);\n  playerGraphics.generateTexture('playerTex', 40, 60);\n  playerGraphics.destroy();\n\n  // 创建地面（静态物理体）\n  ground = this.physics.add.staticSprite(400, 575, 'groundTex');\n  ground.refreshBody();\n\n  // 创建玩家（动态物理体）\n  player = this.physics.add.sprite(400, 300, 'playerTex');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 设置碰撞检测\n  this.physics.add.collider(player, ground, () => {\n    // 玩家落地时重置跳跃次数\n    if (player.body.touching.down) {\n      jumpCount = 0;\n      isOnGround = true;\n    }\n  });\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 创建状态显示文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  jumpCountText = this.add.text(16, 50, '', {\n    fontSize: '18px',\n    fill: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 说明文本\n  this.add.text(16, 90, '按空格键跳跃（可双跳）', {\n    fontSize: '16px',\n    fill: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 初始化状态\n  updateStatusText();\n}\n\nfunction update() {\n  // 检测玩家是否在地面上\n  const wasOnGround = isOnGround;\n  isOnGround = player.body.touching.down;\n\n  // 如果刚落地，重置跳跃次数\n  if (!wasOnGround && isOnGround) {\n    jumpCount = 0;\n  }\n\n  // 跳跃逻辑\n  if (Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    // 只要跳跃次数小于最大跳跃次数就可以跳\n    if (jumpCount < maxJumps) {\n      player.setVelocityY(-200); // 跳跃力度为 200\n      jumpCount++;\n      totalJumps++;\n      updateStatusText();\n    }\n  }\n\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 更新状态文本\n  updateStatusText();\n}\n\nfunction updateStatusText() {\n  const remainingJumps = maxJumps - jumpCount;\n  const groundStatus = isOnGround ? '在地面' : '在空中';\n  \n  statusText.setText(`状态: ${groundStatus} | 总跳跃次数: ${totalJumps}`);\n  jumpCountText.setText(`剩余跳跃次数: ${remainingJumps}/${maxJumps} (当前已跳: ${jumpCount})`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000881_v1", "prompt_id": "seed_000881", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 64px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字位置为屏幕右下角（考虑文字尺寸偏移）\n4. 设置字体大小为 64px，并设置原点为右下角对齐\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建文字对象，位置设置在屏幕右下角\n  const text = this.add.text(\n    this.scale.width - 20,  // x 坐标：画布宽度 - 右边距\n    this.scale.height - 20, // y 坐标：画布高度 - 下边距\n    'Hello Phaser',\n    {\n      fontSize: '64px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }\n  );\n  \n  // 设置文字原点为右下角 (1, 1)，使文字从右下角对齐\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000572_v2", "prompt_id": "seed_000572", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色三角形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建 x 轴移动动画，设置 duration 为 2000ms\n4. 配置 yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制三角形（使用 beginPath 和 fillTriangle）\n  // 三角形中心点在 (0, 0)，方便后续定位\n  graphics.fillTriangle(\n    0, -30,    // 顶点\n    -25, 30,   // 左下角\n    25, 30     // 右下角\n  );\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('triangle', 50, 60);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用该纹理的 Sprite，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 2000,              // 持续时间 2 秒\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    loop: -1,                    // 无限循环（-1 表示永久循环）\n    ease: 'Linear'               // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000608_v3", "prompt_id": "seed_000608", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在4秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象应用该纹理\n3. 使用 Tween 实现缩放动画（scale 从 1 到 0.48 再回到 1）\n4. 设置 Tween 循环播放（loop: -1）和持续时间（duration: 2000，yoyo: true）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  const triangleSize = 100;\n  const height = triangleSize * Math.sqrt(3) / 2;\n  \n  graphics.beginPath();\n  graphics.moveTo(0, -height / 2);  // 顶点\n  graphics.lineTo(-triangleSize / 2, height / 2);  // 左下角\n  graphics.lineTo(triangleSize / 2, height / 2);  // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  graphics.destroy();\n  \n  // 创建三角形精灵并居中\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  // 4秒完成一个完整循环（缩小到48%再恢复）\n  // 使用 yoyo 实现往返效果，每个方向2秒\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 2000,  // 2秒缩小到48%\n    yoyo: true,      // 2秒恢复到100%，总共4秒\n    loop: -1,        // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '三角形缩放动画（4秒循环）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% → 48% → 100%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000381_v3", "prompt_id": "seed_000381", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色三角形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色三角形以240速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Arcade 物理精灵并应用三角形纹理\n3. 设置精灵速度为240，启用世界边界碰撞和反弹\n4. 配置物理系统使精灵在碰到边界时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置速度为240（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 240;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 240;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：让三角形朝向运动方向旋转\n  this.physics.world.on('worldbounds', () => {\n    // 边界碰撞时的额外处理（可选）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000256_v3", "prompt_id": "seed_000256", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的粉色矩形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的粉色矩形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建基础 Game 配置和 Scene\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机坐标\n4. 使用 fillStyle 设置粉色，fillRect 绘制 64x64 矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充颜色 (0xff69b4 是粉色的十六进制值)\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制10个随机位置的矩形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机坐标，确保矩形完全在画布内\n    // x: 0 到 (800 - 64)，y: 0 到 (600 - 64)\n    const x = Phaser.Math.Between(0, 736);\n    const y = Phaser.Math.Between(0, 536);\n    \n    // 绘制 64x64 的矩形\n    graphics.fillRect(x, y, 64, 64);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000774_v3", "prompt_id": "seed_000774", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的橙色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的橙色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillTriangle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环5次创建 Graphics 对象\n3. 每个 Graphics 对象使用 fillStyle 设置橙色（0xff8800）\n4. 使用 fillTriangle 绘制等边三角形，边长16像素\n5. 使用 setRandomPosition 将三角形随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建5个橙色三角形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xff8800, 1);\n    \n    // 绘制等边三角形\n    // 三角形顶点坐标（以中心为原点，边长16像素）\n    const size = 16;\n    const height = (Math.sqrt(3) / 2) * size; // 等边三角形高度\n    \n    // 三个顶点坐标（相对于图形中心）\n    const x1 = 0;           // 顶部顶点\n    const y1 = -height * 2/3;\n    \n    const x2 = -size / 2;   // 左下顶点\n    const y2 = height * 1/3;\n    \n    const x3 = size / 2;    // 右下顶点\n    const y3 = height * 1/3;\n    \n    // 填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 随机设置位置（确保三角形完全在画布内）\n    const margin = 20; // 边距\n    graphics.setRandomPosition(\n      margin,\n      margin,\n      config.width - margin * 2,\n      config.height - margin * 2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000348_v1", "prompt_id": "seed_000348", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的红色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的红色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算6个顶点坐标\n4. 循环20次，每次在随机位置绘制一个红色六边形\n5. 确保六边形完全在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 六边形大小（从中心到顶点的距离）\n  const hexSize = 16;\n  \n  // 绘制20个随机位置的六边形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const x = Phaser.Math.Between(hexSize + 10, config.width - hexSize - 10);\n    const y = Phaser.Math.Between(hexSize + 10, config.height - hexSize - 10);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, hexSize);\n  }\n}\n\n/**\n * 绘制正六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} size - 六边形大小（中心到顶点的距离）\n */\nfunction drawHexagon(graphics, x, y, size) {\n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点坐标\n  // 从顶部开始，顺时针绘制\n  for (let i = 0; i < 6; i++) {\n    // 每个顶点的角度（60度间隔，从-90度开始使顶点朝上）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const vertexX = x + size * Math.cos(angle);\n    const vertexY = y + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vertexX, vertexY);\n    } else {\n      graphics.lineTo(vertexX, vertexY);\n    }\n  }\n  \n  // 闭合路径并填充\n  graphics.closePath();\n  graphics.fillPath();\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000499_v2", "prompt_id": "seed_000499", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色三角形在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色三角形并实现 2 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#generateTexture, Phaser.GameObjects.Sprite, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建抖动效果（x/y 方向随机偏移）\n4. 设置 Tween 循环和持续时间为 2 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制等边三角形（中心点在原点）\n  const size = 60;\n  const height = size * Math.sqrt(3) / 2;\n  graphics.beginPath();\n  graphics.moveTo(0, -height * 2/3); // 顶点\n  graphics.lineTo(-size / 2, height * 1/3); // 左下\n  graphics.lineTo(size / 2, height * 1/3); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', size, size * 1.2);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建抖动动画\n  // 使用多个 Tween 组合实现抖动效果\n  this.tweens.add({\n    targets: triangle,\n    x: '+=10', // 向右偏移\n    y: '+=8',  // 向下偏移\n    duration: 50,\n    yoyo: true, // 往返\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加旋转抖动\n  this.tweens.add({\n    targets: triangle,\n    angle: { from: -5, to: 5 }, // 左右旋转抖动\n    duration: 100,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加缩放抖动\n  this.tweens.add({\n    targets: triangle,\n    scaleX: { from: 0.95, to: 1.05 },\n    scaleY: { from: 0.95, to: 1.05 },\n    duration: 150,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 创建主循环控制（2秒一个完整周期）\n  // 使用时间轴控制抖动的强度变化\n  this.tweens.addCounter({\n    from: 0,\n    to: 1,\n    duration: 2000,\n    repeat: -1,\n    onUpdate: (tween) => {\n      const progress = tween.getValue();\n      // 使用正弦波形让抖动强度周期性变化\n      const intensity = Math.sin(progress * Math.PI * 2) * 0.5 + 0.5;\n      // 可以根据 intensity 调整抖动效果（这里作为演示）\n    }\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 550, '青色三角形抖动动画 (2秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000325_v1", "prompt_id": "seed_000325", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.GameObject.setVelocity, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds\nSTEPS:\n1. 配置物理系统（arcade）并创建场景\n2. 使用 Graphics 绘制橙色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为 360（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    points.push({\n      x: 32 + Math.cos(angle) * radius,\n      y: 32 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（360像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 360;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 360;\n  star.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞和反弹\n  star.setCollideWorldBounds(true);\n  star.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 可选：让星形旋转增加视觉效果\n  star.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000798_v2", "prompt_id": "seed_000798", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的蓝色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的蓝色星形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Graphics 对象并定义星形路径绘制函数\n2. 使用循环创建20个星形，每个星形使用蓝色填充\n3. 为每个星形设置随机位置（考虑画布边界和星形大小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 星形参数\n  const starSize = 64;\n  const starCount = 20;\n  const starColor = 0x0000ff; // 蓝色\n  \n  // 创建20个星形\n  for (let i = 0; i < starCount; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为蓝色\n    graphics.fillStyle(starColor, 1);\n    \n    // 绘制星形路径\n    drawStar(graphics, 0, 0, 5, starSize / 2, starSize / 4);\n    \n    // 设置随机位置（确保星形完全在画布内）\n    const randomX = Phaser.Math.Between(starSize / 2, config.width - starSize / 2);\n    const randomY = Phaser.Math.Between(starSize / 2, config.height - starSize / 2);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n/**\n * 绘制星形路径\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心 x 坐标\n * @param {number} cy - 中心 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n  \n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n  \n  for (let i = 0; i < spikes; i++) {\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n    \n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n  \n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000150_v2", "prompt_id": "seed_000150", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 5 个紫色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，玩家碰撞紫色物体后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，使用 arcade 物理引擎\n2. 使用 Graphics 生成玩家和收集物纹理（玩家绿色方块，收集物紫色圆形）\n3. 创建玩家精灵和收集物物理组，随机分布 5 个收集物\n4. 添加键盘控制让玩家可以移动（方向键）\n5. 使用 overlap 检测玩家与收集物碰撞，碰撞后移除收集物并增加分数\n6. 创建文本对象显示当前分数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建玩家纹理（绿色方块）\n  const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 使用 Graphics 创建收集物纹理（紫色圆形）\n  const collectibleGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  collectibleGraphics.fillStyle(0x9d4edd, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物物理组\n  collectibles = this.physics.add.group();\n\n  // 随机生成 5 个收集物\n  for (let i = 0; i < 5; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    // 添加轻微的随机速度让收集物移动\n    collectible.setVelocity(\n      Phaser.Math.Between(-50, 50),\n      Phaser.Math.Between(-50, 50)\n    );\n    collectible.setBounce(1); // 碰到边界反弹\n  }\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加玩家与收集物的重叠检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\n// 收集物品回调函数\nfunction collectItem(player, collectible) {\n  // 移除收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 如果所有收集物都被收集，显示胜利信息\n  if (collectibles.countActive(true) === 0) {\n    const winText = this.add.text(400, 300, 'YOU WIN!', {\n      fontSize: '64px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n    winText.setOrigin(0.5);\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000849_v1", "prompt_id": "seed_000849", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个自动向左上移动的菱形，相机跟随该对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象作为可移动的菱形\n3. 使用 Camera.startFollow 让相机跟随菱形对象\n4. 在 update 中让菱形持续向左上方移动（x减小，y减小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst moveSpeed = 2; // 移动速度（像素/帧）\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让菱形有足够的移动空间\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1); // 红色菱形\n  graphics.lineStyle(3, 0xffffff, 1); // 白色边框\n  \n  // 绘制菱形（中心点为 32, 32）\n  const size = 32;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);      // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamondTexture', size * 2, size * 2);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建菱形精灵，初始位置在场景中心\n  diamond = this.add.sprite(400, 300, 'diamondTexture');\n  \n  // 设置相机跟随菱形\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（保持菱形在屏幕中心）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加提示文字（固定在相机视图上）\n  const text = this.add.text(10, 10, '菱形自动向左上移动\\n相机跟随中...', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界移动\n  \n  // 添加位置信息文字\n  this.positionText = this.add.text(10, 80, '', {\n    fontSize: '14px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让菱形向左上方移动\n  // 左上方：x 减小，y 减小\n  diamond.x -= moveSpeed;\n  diamond.y -= moveSpeed;\n  \n  // 更新位置信息显示\n  this.positionText.setText(\n    `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})\\n` +\n    `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n  );\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000179_v3", "prompt_id": "seed_000179", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现粉色血条 UI，显示 10 格生命值，空格键扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化 10 格生命值变量\n2. 使用 Graphics 绘制 10 个粉色矩形作为血条格子\n3. 监听空格键输入事件，每次按下扣除 1 格生命值\n4. 更新血条显示，根据当前生命值重绘血条\n5. 当生命值为 0 时显示 Game Over 文本\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 当前生命值\n    this.maxHealth = 10; // 最大生命值\n    this.healthBarGraphics = null;\n    this.gameOverText = null;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建血条背景和前景图形对象\n    this.healthBarGraphics = this.add.graphics();\n    \n    // 初始绘制血条\n    this.drawHealthBar();\n    \n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n    \n    // 添加说明文本\n    this.add.text(400, 500, 'Press SPACE to take damage', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n    \n    // 监听空格键输入\n    this.input.keyboard.on('keydown-SPACE', () => {\n      if (!this.isGameOver && this.health > 0) {\n        this.takeDamage();\n      }\n    });\n  }\n\n  /**\n   * 绘制血条\n   */\n  drawHealthBar() {\n    // 清除之前的绘制\n    this.healthBarGraphics.clear();\n    \n    const barX = 200; // 血条起始 X 坐标\n    const barY = 100; // 血条起始 Y 坐标\n    const cellWidth = 40; // 每格宽度\n    const cellHeight = 30; // 每格高度\n    const cellGap = 5; // 格子间距\n    \n    // 绘制每一格血条\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = barX + i * (cellWidth + cellGap);\n      \n      // 绘制背景（深灰色边框）\n      this.healthBarGraphics.lineStyle(2, 0x666666, 1);\n      this.healthBarGraphics.strokeRect(x, barY, cellWidth, cellHeight);\n      \n      // 根据当前生命值决定填充颜色\n      if (i < this.health) {\n        // 有生命值的格子填充粉色\n        this.healthBarGraphics.fillStyle(0xff69b4, 1); // 粉色\n        this.healthBarGraphics.fillRect(x + 2, barY + 2, cellWidth - 4, cellHeight - 4);\n      } else {\n        // 没有生命值的格子填充暗色\n        this.healthBarGraphics.fillStyle(0x333333, 1);\n        this.healthBarGraphics.fillRect(x + 2, barY + 2, cellWidth - 4, cellHeight - 4);\n      }\n    }\n    \n    // 显示当前生命值文本\n    this.healthBarGraphics.fillStyle(0xffffff, 1);\n    // 使用独立的文本对象来显示生命值\n    if (this.healthText) {\n      this.healthText.destroy();\n    }\n    this.healthText = this.add.text(barX, barY + cellHeight + 20, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n  }\n\n  /**\n   * 扣血逻辑\n   */\n  takeDamage() {\n    if (this.health > 0) {\n      this.health -= 1;\n      this.drawHealthBar();\n      \n      // 检查是否游戏结束\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  /**\n   * 触发游戏结束\n   */\n  triggerGameOver() {\n    this.isGameOver = true;\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n\n  update(time, delta) {\n    // 每帧更新逻辑（当前不需要）\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: HealthBarScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000887_v3", "prompt_id": "seed_000887", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的白色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的白色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.lineStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.strokePath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象计算六边形的6个顶点坐标（基于中心点和半径32像素）\n4. 使用 Graphics API 绘制白色六边形路径\n5. 为每个六边形设置随机位置（x: 32-768, y: 32-568，确保六边形完全在画布内）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 六边形参数\n  const hexRadius = 32; // 半径32像素，总大小64像素\n  const hexCount = 20;\n  \n  // 创建20个随机位置的白色六边形\n  for (let i = 0; i < hexCount; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置白色描边样式\n    graphics.lineStyle(2, 0xffffff, 1);\n    \n    // 计算六边形的6个顶点（相对于中心点）\n    const vertices = [];\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j; // 每个顶点间隔60度\n      const vx = hexRadius * Math.cos(angle);\n      const vy = hexRadius * Math.sin(angle);\n      vertices.push({ x: vx, y: vy });\n    }\n    \n    // 绘制六边形路径\n    graphics.beginPath();\n    graphics.moveTo(vertices[0].x, vertices[0].y);\n    for (let j = 1; j < 6; j++) {\n      graphics.lineTo(vertices[j].x, vertices[j].y);\n    }\n    graphics.closePath();\n    graphics.strokePath();\n    \n    // 设置随机位置（确保六边形完全在画布内）\n    const randomX = Phaser.Math.Between(hexRadius, 800 - hexRadius);\n    const randomY = Phaser.Math.Between(hexRadius, 600 - hexRadius);\n    graphics.setPosition(randomX, randomY);\n  }\n  \n  // 添加提示文本\n  this.add.text(10, 10, '20个随机位置的白色六边形', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000363_v2", "prompt_id": "seed_000363", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右侧显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.GameObjects.Text, Scene.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字内容为 \"Hello Phaser\"，字体大小 32px\n4. 将文字定位到屏幕右侧（x 坐标接近画布宽度）\n5. 设置文字对齐方式，确保显示在右侧区域\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右侧创建文字\n  // x 坐标设置为 750（距离右边缘 50 像素）\n  // y 坐标设置为屏幕中央\n  const text = this.add.text(750, 300, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字锚点为右中，确保文字从右侧对齐\n  text.setOrigin(1, 0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000071_v2", "prompt_id": "seed_000071", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色六边形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色六边形以200速度移动并在画布边界反弹\nAPI: Graphics.fillStyle, Graphics.fillCircle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 启用 Arcade 物理系统\n3. 创建物理精灵并应用六边形纹理\n4. 设置初始速度为 200（x和y方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制六边形\n  const hexRadius = 40;\n  const hexagonPath = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = hexRadius + hexRadius * Math.cos(angle);\n    const y = hexRadius + hexRadius * Math.sin(angle);\n    hexagonPath.push(x, y);\n  }\n  \n  graphics.fillPoints(hexagonPath, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（200速度，使用勾股定理分解到x和y方向）\n  const speed = 200;\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = speed * Math.cos(Phaser.Math.DegToRad(angle));\n  const velocityY = speed * Math.sin(Phaser.Math.DegToRad(angle));\n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 可选：添加文字提示\n  this.add.text(10, 10, '绿色六边形以200速度移动\\n碰到边界时反弹', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000710_v3", "prompt_id": "seed_000710", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
