{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 360 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并使用 fillTriangle 绘制三角形\n2. 在 create 中设置三角形的初始位置（居中）\n3. 在 update 中根据 delta 时间增量更新 rotation 属性，每秒旋转 360 度（2π 弧度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制一个等边三角形（中心在原点）\n  // 三角形顶点相对于中心点的坐标\n  const size = 80;\n  const height = size * Math.sqrt(3) / 2;\n  \n  graphics.fillTriangle(\n    0, -height * 2/3,           // 顶部顶点\n    -size/2, height * 1/3,      // 左下顶点\n    size/2, height * 1/3        // 右下顶点\n  );\n  \n  // 设置三角形位置到画布中心\n  graphics.setPosition(400, 300);\n  \n  // 将 graphics 对象保存到 scene 数据中，以便在 update 中访问\n  this.triangle = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 360 度 = 2π 弧度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 旋转速度：2 * Math.PI 弧度/秒\n  const rotationSpeed = 2 * Math.PI; // 弧度/秒\n  \n  // 更新旋转角度\n  this.triangle.rotation += rotationSpeed * (delta / 1000);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000276_v1", "prompt_id": "seed_000276", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的橙色方块，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的橙色方块，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用循环5次，每次生成随机坐标（确保方块不超出边界）\n4. 使用 fillStyle 设置橙色（0xFFA500），用 fillRect 绘制48x48的方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制方块\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 方块大小\n  const squareSize = 48;\n  \n  // 绘制5个随机位置的橙色方块\n  for (let i = 0; i < 5; i++) {\n    // 生成随机坐标，确保方块完全在画布内\n    const x = Math.random() * (config.width - squareSize);\n    const y = Math.random() * (config.height - squareSize);\n    \n    // 绘制方块\n    graphics.fillRect(x, y, squareSize, squareSize);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000045_v3", "prompt_id": "seed_000045", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色方块以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色方块以360速度移动并在边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成灰色方块纹理\n3. 创建物理精灵并设置速度为360\n4. 设置边界碰撞和反弹属性\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nlet square;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('squareTex', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'squareTex');\n  \n  // 设置初始速度（360像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 360;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 360;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 物理系统会自动处理边界反弹\n  // 确保速度保持恒定（可选：防止浮点误差导致速度衰减）\n  const currentSpeed = Math.sqrt(\n    square.body.velocity.x ** 2 + \n    square.body.velocity.y ** 2\n  );\n  \n  if (Math.abs(currentSpeed - 360) > 1) {\n    const scale = 360 / currentSpeed;\n    square.setVelocity(\n      square.body.velocity.x * scale,\n      square.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000149_v2", "prompt_id": "seed_000149", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色六边形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色六边形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的六个顶点坐标（中心点在画布中央，半径 24 像素）\n4. 使用 Graphics API 绘制六边形路径并填充灰色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 六边形半径（从中心到顶点的距离）\n  const radius = 24;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制六边形的六个顶点\n  // 六边形的顶点角度：0°, 60°, 120°, 180°, 240°, 300°\n  for (let i = 0; i < 6; i++) {\n    // 角度转弧度，从顶部开始（-90度偏移）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000442_v3", "prompt_id": "seed_000442", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在1.5秒内缩放到16%再恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 scale 属性从 1 到 0.16 再回到 1\n4. 设置 Tween 的 yoyo 为 true 实现往返效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 100）\n  graphics.beginPath();\n  graphics.moveTo(64, 14);      // 上顶点\n  graphics.lineTo(114, 64);     // 右顶点\n  graphics.lineTo(64, 114);     // 下顶点\n  graphics.lineTo(14, 64);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建菱形 Sprite 并放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  // 从原始大小 (scale: 1) 缩放到 16% (scale: 0.16)\n  // 使用 yoyo 实现缩小后恢复\n  // duration 为 1500ms (1.5秒)，yoyo 会让整个动画时长为 3秒（1.5秒缩小 + 1.5秒恢复）\n  this.tweens.add({\n    targets: diamond,\n    scale: 0.16,           // 目标缩放值 16%\n    duration: 1500,        // 单程时长 1.5 秒\n    yoyo: true,            // 启用往返效果（缩小后恢复）\n    loop: -1,              // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Diamond scaling animation (1 -> 0.16 -> 1) in 1.5s each way', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000234_v3", "prompt_id": "seed_000234", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2秒内从透明渐变到完全不透明并循环播放\nAPI: Graphics, Tween, setAlpha\nSTEPS:\n1. 使用 Graphics 绘制一个椭圆形状并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 设置初始透明度为 0（完全透明）\n4. 使用 Tween 动画让 alpha 从 0 到 1，持续 2 秒，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制椭圆（中心点在 100, 75，横向半径 100，纵向半径 75）\n  graphics.fillEllipse(100, 75, 200, 150);\n  \n  // 将 Graphics 生成为纹理\n  graphics.generateTexture('ellipseTexture', 200, 150);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用该纹理的精灵，放置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'ellipseTexture');\n  \n  // 设置初始透明度为 0（完全透明）\n  ellipse.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    alpha: 1,                   // 目标透明度值（完全不透明）\n    duration: 2000,             // 持续时间 2 秒（2000 毫秒）\n    ease: 'Linear',             // 线性缓动\n    yoyo: false,                // 不反向播放\n    repeat: -1,                 // 无限循环（-1 表示永久重复）\n    repeatDelay: 0              // 重复之间无延迟\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '椭圆从透明渐变到不透明（2秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000436_v1", "prompt_id": "seed_000436", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色三角形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色三角形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置蓝色填充\n5. 使用 fillTriangle 绘制等边三角形，顶点在中心点周围，边长约32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形大小（从中心点到顶点的距离）\n  const size = 32;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size * 0.6;\n  \n  // 顶点2：左下角\n  const x2 = centerX - size * 0.866;\n  const y2 = centerY + size * 0.5;\n  \n  // 顶点3：右下角\n  const x3 = centerX + size * 0.866;\n  const y3 = centerY + size * 0.5;\n  \n  // 设置蓝色填充 (0x0000ff)\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 绘制填充的三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加白色描边使三角形更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000616_v2", "prompt_id": "seed_000616", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2秒内缩放到16%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 创建 Graphics 对象绘制矩形\n2. 使用 tweens 创建缩放动画，目标 scale 为 0.16\n3. 设置动画持续时间为 2000ms，yoyo 为 true 实现恢复效果\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建矩形图形对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制一个矩形（中心点在原点，便于缩放）\n  const rectWidth = 200;\n  const rectHeight = 150;\n  graphics.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);\n  \n  // 设置矩形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    scaleX: 0.16,               // X轴缩放到16%\n    scaleY: 0.16,               // Y轴缩放到16%\n    duration: 2000,             // 持续时间2秒\n    yoyo: true,                 // 动画结束后反向播放（恢复原始大小）\n    loop: -1,                   // 无限循环（-1表示永久循环）\n    ease: 'Sine.easeInOut'      // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '矩形缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '2秒缩放到16% → 2秒恢复 → 循环', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000327_v3", "prompt_id": "seed_000327", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色星形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央使用 Graphics 绘制一个粉色星形，大小约为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个顶点和 5 个内凹点的坐标（使用三角函数）\n4. 使用 Graphics API 绘制星形路径并填充粉色\n5. 将星形定位在画布中央 (400, 300)\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 星形参数\n  const centerX = 400;\n  const centerY = 300;\n  const outerRadius = 32; // 外半径\n  const innerRadius = 14; // 内半径（约为外半径的 0.4-0.5）\n  const points = 5; // 五角星\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1); // 粉色 (hot pink)\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算星形的顶点坐标\n  for (let i = 0; i < points * 2; i++) {\n    // 每个点的角度（从顶部开始，顺时针）\n    const angle = (Math.PI / points) * i - Math.PI / 2;\n    \n    // 奇数点使用外半径，偶数点使用内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充星形\n  graphics.fillPath();\n  \n  // 可选：添加描边使星形更清晰\n  graphics.lineStyle(2, 0xffffff, 0.8);\n  graphics.strokePath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000754_v1", "prompt_id": "seed_000754", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让菱形在4秒内从透明渐变到完全不透明并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建精灵对象并设置初始透明度为0\n3. 使用 Tween 动画控制 alpha 属性从0到1，持续4秒\n4. 设置 Tween 为循环播放模式\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点为原点）\n  const size = 100;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建菱形精灵并设置位置\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，4秒循环播放\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1,                    // 目标透明度为1（完全不透明）\n    duration: 4000,              // 持续时间4秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: false,                 // 不反向播放\n    repeat: -1,                  // 无限循环（-1表示永远重复）\n    repeatDelay: 0               // 重复之间无延迟\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Diamond Fade-In Animation (4s loop)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000279_v1", "prompt_id": "seed_000279", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 300 像素/秒速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Phaser.Input.Keyboard.addKey\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建 Sprite 并应用六边形纹理\n4. 设置 WASD 键盘输入监听\n5. 在 update 中根据按键状态控制六边形移动，速度 300 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 30;\n  const hexColor = 0x00ff00;\n  \n  // 绘制六边形\n  graphics.fillStyle(hexColor, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 计算六边形的六个顶点（中心在原点）\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角度 60 度\n    const x = hexRadius * Math.cos(angle);\n    const y = hexRadius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制多边形\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n  graphics.strokePoints(polygon.points, true);\n  \n  // 生成纹理（大小需要能容纳六边形）\n  const textureSize = hexRadius * 2 + 10;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建六边形精灵并放置在屏幕中央\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置 WASD 键\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间差）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 WASD 按键状态\n  if (keys.W.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.S.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.A.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.D.isDown) {\n    velocityX = 1; // 向右\n  }\n  \n  // 如果同时按下多个键，归一化速度向量（保持恒定速度）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const magnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= magnitude;\n    velocityY /= magnitude;\n  }\n  \n  // 更新六边形位置\n  hexagon.x += velocityX * distance;\n  hexagon.y += velocityY * distance;\n  \n  // 边界限制（可选，防止六边形移出屏幕）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000748_v1", "prompt_id": "seed_000748", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色菱形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现蓝色菱形在2.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色菱形并生成纹理\n2. 创建 Sprite 对象并应用菱形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0066ff, 1);\n  \n  // 绘制菱形（四个顶点）\n  // 中心点在 (30, 30)，菱形大小为 60x60\n  graphics.beginPath();\n  graphics.moveTo(30, 0);      // 上顶点\n  graphics.lineTo(60, 30);     // 右顶点\n  graphics.lineTo(30, 60);     // 下顶点\n  graphics.lineTo(0, 30);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 60, 60);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 2500,             // 持续时间 2.5 秒\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 启用往返效果（到达终点后反向播放）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    loopDelay: 0                // 循环之间无延迟\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '蓝色菱形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '循环周期: 2.5秒 (单程)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000719_v3", "prompt_id": "seed_000719", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随一个自动向左上移动的矩形对象\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建一个较大的世界边界（超出相机视口）\n2. 使用 Graphics 或 Rectangle 创建一个可见的矩形对象\n3. 在 create 中通过 this.cameras.main.startFollow() 让相机跟随该矩形\n4. 在 update 中让矩形持续向左上方移动（x减小，y减小）\n5. 添加世界边界和背景网格以便观察相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界为更大的范围，方便观察相机跟随\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n\n  // 绘制背景网格，帮助观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 2000; x += 100) {\n    graphics.lineBetween(x, 0, x, 2000);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 2000; y += 100) {\n    graphics.lineBetween(0, y, 2000, y);\n  }\n\n  // 创建玩家矩形（使用 Rectangle 游戏对象）\n  this.player = this.add.rectangle(1000, 1000, 50, 50, 0xff0000);\n  \n  // 添加一个文本标签跟随玩家\n  this.playerLabel = this.add.text(0, 0, 'Player', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 5, y: 5 }\n  });\n\n  // 设置相机跟随玩家矩形\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的平滑度\n  // 参数说明：startFollow(target, roundPixels, lerpX, lerpY)\n  // lerpX 和 lerpY 控制跟随的平滑度，值越小越平滑但延迟越大\n\n  // 添加说明文字（固定在相机视口）\n  this.infoText = this.add.text(10, 10, 'Camera following the red square\\nMoving to upper-left', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 10 }\n  });\n  this.infoText.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n\n  // 显示坐标信息\n  this.coordText = this.add.text(10, 80, '', {\n    fontSize: '14px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.coordText.setScrollFactor(0);\n\n  // 移动速度\n  this.moveSpeed = 2;\n}\n\nfunction update(time, delta) {\n  // 让矩形向左上方移动\n  this.player.x -= this.moveSpeed;\n  this.player.y -= this.moveSpeed;\n\n  // 边界检测：如果到达世界边界，则重置位置\n  if (this.player.x < 50) {\n    this.player.x = 1950;\n  }\n  if (this.player.y < 50) {\n    this.player.y = 1950;\n  }\n\n  // 更新标签位置（显示在矩形上方）\n  this.playerLabel.setPosition(\n    this.player.x - this.playerLabel.width / 2,\n    this.player.y - 40\n  );\n\n  // 更新坐标显示\n  this.coordText.setText(\n    `Player Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})\\n` +\n    `Camera Position: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000338_v3", "prompt_id": "seed_000338", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个自动向左移动的星形，相机跟随并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Graphics.generateTexture\nSTEPS:\n1. 创建场景并设置较大的世界边界以便移动\n2. 使用 Graphics 绘制星形并生成纹理\n3. 创建星形精灵对象并设置自动向左移动的速度\n4. 使用相机的 startFollow 方法让相机跟随星形\n5. 在 update 中持续更新星形位置\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 每秒移动的像素数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 设置世界边界，使其足够大以便星形移动\n    this.cameras.main.setBounds(0, 0, 2000, 600);\n    this.physics.world.setBounds(0, 0, 2000, 600);\n\n    // 使用 Graphics 绘制星形并生成纹理\n    const graphics = this.add.graphics();\n    \n    // 绘制黄色星形\n    graphics.fillStyle(0xffff00, 1);\n    graphics.lineStyle(2, 0xffa500, 1);\n    \n    // 绘制五角星\n    const points = [];\n    const outerRadius = 30;\n    const innerRadius = 15;\n    const numPoints = 5;\n    \n    for (let i = 0; i < numPoints * 2; i++) {\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n      points.push({\n        x: 40 + Math.cos(angle) * radius,\n        y: 40 + Math.sin(angle) * radius\n      });\n    }\n    \n    graphics.beginPath();\n    graphics.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      graphics.lineTo(points[i].x, points[i].y);\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 生成纹理\n    graphics.generateTexture('starTexture', 80, 80);\n    graphics.destroy();\n\n    // 创建星形精灵，初始位置在世界中央偏右\n    this.star = this.add.sprite(1000, 300, 'starTexture');\n    this.star.setOrigin(0.5, 0.5);\n\n    // 设置相机跟随星形\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机跟随的偏移量（这里保持居中，所以偏移为0）\n    this.cameras.main.setFollowOffset(0, 0);\n\n    // 添加背景网格以便观察移动效果\n    this.createBackgroundGrid();\n\n    // 添加提示文本（固定在相机上）\n    const text = this.add.text(10, 10, '星形自动向左移动\\n相机跟随居中', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机上，不随世界移动\n  }\n\n  update(time, delta) {\n    // 星形向左移动\n    this.star.x -= this.speed * (delta / 1000);\n\n    // 如果星形移出左边界，循环到右边\n    if (this.star.x < -40) {\n      this.star.x = 2040;\n    }\n\n    // 如果星形移出右边界，循环到左边\n    if (this.star.x > 2040) {\n      this.star.x = -40;\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建网格背景以便观察相机移动\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n\n    // 绘制垂直线\n    for (let x = 0; x <= 2000; x += 100) {\n      graphics.lineTo(x, 0);\n      graphics.lineTo(x, 600);\n      graphics.moveTo(x + 100, 0);\n    }\n\n    // 绘制水平线\n    for (let y = 0; y <= 600; y += 100) {\n      graphics.moveTo(0, y);\n      graphics.lineTo(2000, y);\n    }\n\n    graphics.strokePath();\n\n    // 添加坐标标记\n    for (let x = 0; x <= 2000; x += 200) {\n      const label = this.add.text(x + 5, 5, `${x}`, {\n        fontSize: '12px',\n        fill: '#666666'\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      debug: false\n    }\n  }\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000555_v3", "prompt_id": "seed_000555", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8737500000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并设置初始 alpha 为 0\n3. 使用 Tween 动画让 alpha 从 0 到 1，持续 2 秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80; // 六边形外接圆半径\n  const centerX = 128; // 纹理中心 X\n  const centerY = 128; // 纹理中心 Y\n  \n  // 绘制六边形（6个顶点，从顶部开始顺时针）\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 256, 256);\n  graphics.destroy(); // 销毁 graphics 对象，不再需要\n  \n  // 创建六边形精灵并放置在屏幕中心\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexagon.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1, // 目标透明度：完全不透明\n    duration: 2000, // 持续时间：2 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: false, // 不反向播放\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '六边形淡入动画（循环播放）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000180_v3", "prompt_id": "seed_000180", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 0.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形，使用 Tween 动画实现 0.5 秒内缩放到 64%，然后恢复原始大小，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建 Sprite 使用星形纹理\n3. 使用 tweens.add 创建缩放动画，从 1 缩放到 0.64\n4. 设置 yoyo 为 true 实现自动恢复，duration 为 500ms\n5. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 星形的参数\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 20;\n  const points = 5;\n  \n  // 开始绘制星形路径\n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵并放置在屏幕中心\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 500,        // 0.5 秒\n    yoyo: true,           // 自动恢复到原始大小\n    repeat: -1,           // 无限循环\n    ease: 'Linear'        // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Star scaling animation (64% - 100%)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000364_v2", "prompt_id": "seed_000364", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色椭圆在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色椭圆从左到右1秒往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillEllipse(40, 30, 80, 60); // 在中心绘制椭圆\n  \n  // 生成纹理\n  graphics.generateTexture('pinkEllipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象\n  const ellipseSprite = this.add.sprite(100, 300, 'pinkEllipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    x: 700, // 移动到右侧\n    duration: 1000, // 1秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环 (-1 表示永久循环)\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000012_v3", "prompt_id": "seed_000012", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现紫色血条 UI，显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Scene 并初始化生命值变量为 10\n2. 使用 Graphics 绘制 10 个紫色矩形作为血条格子\n3. 监听空格键按下事件，每次扣除 1 点生命值\n4. 根据当前生命值重新绘制血条（显示剩余格子）\n5. 当生命值为 0 时显示 Game Over 文本并停止接受输入\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.health = 10; // 当前生命值\n    this.maxHealth = 10; // 最大生命值\n    this.healthBarGraphics = null;\n    this.gameOverText = null;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建血条标题\n    this.add.text(50, 50, 'Health:', {\n      fontSize: '24px',\n      color: '#ffffff'\n    });\n\n    // 创建血条 Graphics 对象\n    this.healthBarGraphics = this.add.graphics();\n    this.drawHealthBar();\n\n    // 创建操作提示\n    this.add.text(50, 150, 'Press SPACE to take damage', {\n      fontSize: '18px',\n      color: '#cccccc'\n    });\n\n    // 创建生命值数字显示\n    this.healthText = this.add.text(50, 180, `HP: ${this.health}/${this.maxHealth}`, {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.spaceKey.on('down', this.takeDamage, this);\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n  }\n\n  drawHealthBar() {\n    // 清空之前的绘制\n    this.healthBarGraphics.clear();\n\n    const barX = 150; // 血条起始 X 坐标\n    const barY = 50; // 血条起始 Y 坐标\n    const cellWidth = 40; // 每格宽度\n    const cellHeight = 30; // 每格高度\n    const gap = 5; // 格子间隙\n\n    // 绘制背景（空血条）\n    this.healthBarGraphics.fillStyle(0x333333, 1);\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = barX + i * (cellWidth + gap);\n      this.healthBarGraphics.fillRect(x, barY, cellWidth, cellHeight);\n    }\n\n    // 绘制当前生命值（紫色）\n    this.healthBarGraphics.fillStyle(0x9b59b6, 1); // 紫色\n    for (let i = 0; i < this.health; i++) {\n      const x = barX + i * (cellWidth + gap);\n      this.healthBarGraphics.fillRect(x, barY, cellWidth, cellHeight);\n    }\n\n    // 绘制边框\n    this.healthBarGraphics.lineStyle(2, 0xffffff, 1);\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = barX + i * (cellWidth + gap);\n      this.healthBarGraphics.strokeRect(x, barY, cellWidth, cellHeight);\n    }\n  }\n\n  takeDamage() {\n    // 如果游戏已结束，不再处理\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 扣除生命值\n    if (this.health > 0) {\n      this.health--;\n      this.drawHealthBar();\n      this.healthText.setText(`HP: ${this.health}/${this.maxHealth}`);\n\n      // 检查是否死亡\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  triggerGameOver() {\n    this.isGameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 移除空格键监听\n    this.spaceKey.off('down', this.takeDamage, this);\n\n    // 添加重启提示\n    this.add.text(400, 400, 'Press R to Restart', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 监听 R 键重启游戏\n    const restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n    restartKey.on('down', () => {\n      this.scene.restart();\n    });\n  }\n\n  update(time, delta) {\n    // 此游戏不需要每帧更新逻辑\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000994_v3", "prompt_id": "seed_000994", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让青色六边形在 1 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色六边形闪烁动画，1秒完成一次循环\nAPI: Graphics, generateTexture, Tween, alpha\nSTEPS:\n1. 使用 Graphics 绘制青色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 透明度实现闪烁效果\n4. 设置循环和 yoyo 效果实现往复闪烁\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制六边形（中心点为 64, 64，半径为 50）\n  const hexagonRadius = 50;\n  const centerX = 64;\n  const centerY = 64;\n  const sides = 6;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;\n    const x = centerX + hexagonRadius * Math.cos(angle);\n    const y = centerY + hexagonRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 128, 128);\n  graphics.destroy();\n  \n  // 创建六边形精灵并放置在屏幕中央\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建闪烁动画（通过 alpha 透明度变化）\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 500,      // 单程持续时间 500ms\n    yoyo: true,         // 往返效果（透明后再恢复）\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut'  // 使用正弦缓动使闪烁更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000602_v2", "prompt_id": "seed_000602", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在1秒内缩放到32%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建缩放动画，从 scale 1 到 0.32 再回到 1\n4. 设置 loop: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('squareTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'squareTexture');\n\n  // 创建缩放动画\n  // 使用 yoyo 实现来回缩放效果\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 1000,  // 1秒缩小到32%\n    yoyo: true,      // 自动反向播放（恢复到原始大小）\n    loop: -1,        // -1 表示无限循环\n    ease: 'Linear'   // 线性缓动\n  });\n\n  // 添加文字提示\n  this.add.text(400, 500, '方块循环缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000516_v2", "prompt_id": "seed_000516", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现粉色三角形左右往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建 x 轴移动补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建粉色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制三角形（使用 beginPath 和 fillPath）\n  graphics.beginPath();\n  graphics.moveTo(30, 0);      // 顶点\n  graphics.lineTo(60, 50);     // 右下角\n  graphics.lineTo(0, 50);      // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 500,               // 持续时间 0.5 秒\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    loop: -1,                    // 无限循环（-1 表示永久循环）\n    ease: 'Linear'               // 线性缓动函数，保持匀速运动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000523_v3", "prompt_id": "seed_000523", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的矩形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#x\nSTEPS:\n1. 创建 Scene 配置，设置游戏画布尺寸和场景\n2. 在 create 中使用 Graphics 绘制一个矩形作为玩家对象\n3. 使用 camera.startFollow() 让主相机跟随矩形对象\n4. 在 update 中让矩形持续向右移动\n5. 设置世界边界确保有足够的移动空间\n[/PLAN]\n\n```javascript\n// Phaser3 相机跟随示例 - 自动向右移动的矩形\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nconst moveSpeed = 2; // 每帧移动的像素数\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，让场景足够大以便移动\n  this.cameras.main.setBounds(0, 0, 3000, 600);\n  this.physics.world.setBounds(0, 0, 3000, 600);\n\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 生成纹理用于玩家对象\n  graphics.generateTexture('playerRect', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建玩家对象（使用生成的纹理）\n  player = this.add.sprite(100, 300, 'playerRect');\n  player.setOrigin(0.5, 0.5);\n\n  // 相机跟随玩家对象\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量，使对象居中\n  this.cameras.main.setFollowOffset(0, 0);\n\n  // 添加一些参考点，帮助观察相机移动\n  for (let i = 0; i < 3000; i += 200) {\n    const marker = this.add.graphics();\n    marker.lineStyle(2, 0xffffff, 0.5);\n    marker.strokeRect(i, 0, 200, 600);\n    \n    // 添加位置标记文字\n    const text = this.add.text(i + 10, 10, `X: ${i}`, {\n      fontSize: '16px',\n      color: '#ffffff'\n    });\n  }\n\n  // 添加提示信息\n  const instructions = this.add.text(10, 10, '相机跟随矩形自动向右移动', {\n    fontSize: '20px',\n    color: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  instructions.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 让玩家对象持续向右移动\n  player.x += moveSpeed;\n\n  // 当玩家到达世界边界时停止（可选）\n  if (player.x >= 2950) {\n    player.x = 2950;\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000504_v3", "prompt_id": "seed_000504", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8820833333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色六边形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 绘制六边形（中心点在 50, 50，半径 40）\n  const hexRadius = 40;\n  const hexCenterX = 50;\n  const hexCenterY = 50;\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角60度\n    const x = hexCenterX + hexRadius * Math.cos(angle);\n    const y = hexCenterY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建使用六边形纹理的精灵\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 2500, // 2.5 秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环 (-1 表示永久循环)\n    ease: 'Linear' // 线性缓动\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000691_v2", "prompt_id": "seed_000691", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 5 个紫色敌人巡逻移动，在 120 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 5个紫色敌人左右巡逻，玩家靠近时追踪，速度120\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建物理系统配置，使用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（绿色）和敌人（紫色）纹理\n3. 创建玩家精灵，支持键盘控制移动\n4. 创建敌人物理组，生成5个敌人并设置初始位置和巡逻速度\n5. 在 update 中检测玩家与敌人距离，近距离时敌人追踪玩家，远距离时巡逻\n6. 实现敌人巡逻边界检测，到达边界时反向移动\n7. 添加状态变量（enemiesChasing）用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesChasing = 0; // 状态信号：正在追踪的敌人数量\n    this.patrolDistance = 200; // 巡逻距离\n    this.chaseDistance = 150; // 追踪触发距离\n    this.enemySpeed = 120; // 敌人速度\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成敌人纹理（紫色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x9900ff, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 生成5个敌人，分布在不同位置\n    const enemyPositions = [\n      { x: 150, y: 150 },\n      { x: 350, y: 200 },\n      { x: 550, y: 150 },\n      { x: 250, y: 350 },\n      { x: 650, y: 300 }\n    ];\n\n    enemyPositions.forEach(pos => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      \n      // 存储敌人的初始位置和巡逻状态\n      enemy.patrolStartX = pos.x;\n      enemy.patrolDirection = 1; // 1 向右，-1 向左\n      enemy.isChasing = false;\n      \n      // 设置初始巡逻速度\n      enemy.setVelocityX(this.enemySpeed * enemy.patrolDirection);\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加文本显示状态\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文字\n    this.add.text(10, 570, 'Arrow keys to move. Enemies patrol and chase when close.', {\n      fontSize: '14px',\n      fill: '#cccccc'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    }\n\n    // 重置追踪计数\n    this.enemiesChasing = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x,\n        this.player.y,\n        enemy.x,\n        enemy.y\n      );\n\n      // 判断是否应该追踪玩家\n      if (distance < this.chaseDistance) {\n        // 追踪模式\n        enemy.isChasing = true;\n        this.enemiesChasing++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x,\n          enemy.y,\n          this.player.x,\n          this.player.y\n        );\n\n        // 设置速度朝向玩家\n        this.physics.velocityFromRotation(\n          angle,\n          this.enemySpeed,\n          enemy.body.velocity\n        );\n\n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          // 从追踪模式切换回巡逻模式，重置速度\n          enemy.isChasing = false;\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(this.enemySpeed * enemy.patrolDirection);\n        }\n\n        // 检查巡逻边界\n        const distanceFromStart = enemy.x - enemy.patrolStartX;\n        \n        if (distanceFromStart > this.patrolDistance) {\n          // 到达右边界，向左移动\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(this.enemySpeed * enemy.patrolDirection);\n        } else if (distanceFromStart < -this.patrolDistance) {\n          // 到达左边界，向右移动\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(this.enemySpeed * enemy.patrolDirection);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText([\n      `Enemies Chasing: ${this.enemiesChasing}/5`,\n      `Player Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001074_v1", "prompt_id": "seed_001074", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绿色玩家移出边界时从对侧出现（循环地图效果），移动速度 240。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 绿色玩家移出边界时从对侧出现（循环地图效果），移动速度 240\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), sprite.setVelocity(), Phaser.Math.Wrap\nSTEPS:\n1. 创建 800x600 的游戏场景，启用 Arcade 物理系统\n2. 使用 Graphics 生成绿色玩家纹理（32x32 方块）\n3. 创建物理精灵，设置移动速度为 240\n4. 在 create 中绑定键盘方向键输入\n5. 在 update 中根据方向键控制玩家速度\n6. 在 update 中使用 Phaser.Math.Wrap 实现边界循环效果\n7. 添加位置信息作为可验证状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nlet playerSpeed = 240;\n\n// 状态信号变量\nlet positionX = 400;\nlet positionY = 300;\nlet wrapCount = 0; // 记录穿越边界次数\n\nfunction preload() {\n  // 使用 Graphics 创建绿色玩家纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵（位于屏幕中心）\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n  \n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加 WASD 键支持\n  this.keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 显示状态信息\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 显示说明\n  this.add.text(400, 550, '使用方向键或 WASD 移动 | 移出边界会从对侧出现', {\n    fontSize: '14px',\n    fill: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0, 0);\n  \n  // 处理键盘输入\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  if (cursors.left.isDown || this.keys.a.isDown) {\n    velocityX = -playerSpeed;\n  } else if (cursors.right.isDown || this.keys.d.isDown) {\n    velocityX = playerSpeed;\n  }\n  \n  if (cursors.up.isDown || this.keys.w.isDown) {\n    velocityY = -playerSpeed;\n  } else if (cursors.down.isDown || this.keys.s.isDown) {\n    velocityY = playerSpeed;\n  }\n  \n  // 对角线移动时归一化速度\n  if (velocityX !== 0 && velocityY !== 0) {\n    const diagonal = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX = (velocityX / diagonal) * playerSpeed;\n    velocityY = (velocityY / diagonal) * playerSpeed;\n  }\n  \n  player.setVelocity(velocityX, velocityY);\n  \n  // 记录循环前的位置\n  const oldX = player.x;\n  const oldY = player.y;\n  \n  // 边界循环效果 - 使用 Phaser.Math.Wrap\n  // Wrap 函数：当值超出范围时从另一端重新出现\n  player.x = Phaser.Math.Wrap(player.x, -16, config.width + 16);\n  player.y = Phaser.Math.Wrap(player.y, -16, config.height + 16);\n  \n  // 检测是否发生了边界穿越\n  if (Math.abs(player.x - oldX) > 100 || Math.abs(player.y - oldY) > 100) {\n    wrapCount++;\n  }\n  \n  // 更新状态信号\n  positionX = Math.round(player.x);\n  positionY = Math.round(player.y);\n  \n  // 更新状态显示\n  this.statusText.setText([\n    `Position: (${positionX}, ${positionY})`,\n    `Speed: ${playerSpeed}`,\n    `Wrap Count: ${wrapCount}`,\n    `Velocity: (${Math.round(player.body.velocity.x)}, ${Math.round(player.body.velocity.y)})`\n  ]);\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000865_v2", "prompt_id": "seed_000865", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色三角形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色三角形以200速度移动并在边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制黄色三角形并生成纹理\n2. 启用 Arcade 物理系统创建精灵\n3. 设置精灵速度为200，启用边界碰撞和反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 绘制黄色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(32, 8);      // 顶点\n  graphics.lineTo(8, 56);      // 左下角\n  graphics.lineTo(56, 56);     // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 64, 64);\n  \n  // 销毁临时 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建带物理属性的三角形精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（200像素/秒，方向为右下45度）\n  triangle.setVelocity(200, 200);\n  \n  // 设置与世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：添加旋转效果使运动更生动\n  triangle.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000545_v2", "prompt_id": "seed_000545", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：15 个矩形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色移动收集15个随机分布的矩形，收集完成后显示通关文字\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家角色（使用Graphics绘制蓝色矩形）\n2. 创建15个可收集物品（使用Graphics绘制黄色矩形），随机分布在场景中\n3. 添加物理碰撞检测，当玩家碰到收集物时移除该物品并增加计数\n4. 使用键盘方向键控制玩家移动\n5. 当收集数量达到15时，显示\"恭喜通关\"文字并停止游戏\n[/PLAN]\n\n```javascript\nclass CollectGame extends Phaser.Scene {\n  constructor() {\n    super('CollectGame');\n    this.collectedCount = 0;\n    this.totalCollectibles = 15;\n    this.gameCompleted = false;\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，不需要外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffff00, 1);\n    collectibleGraphics.fillRect(0, 0, 20, 20);\n    collectibleGraphics.generateTexture('collectible', 20, 20);\n    collectibleGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成15个收集物\n    for (let i = 0; i < this.totalCollectibles; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCollideWorldBounds(true);\n      collectible.setBounce(0.5);\n      collectible.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n    }\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建计数文本\n    this.scoreText = this.add.text(16, 16, '收集: 0 / 15', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n  }\n\n  collectItem(player, collectible) {\n    // 移除收集物\n    collectible.destroy();\n\n    // 增加计数\n    this.collectedCount++;\n\n    // 更新文本\n    this.scoreText.setText(`收集: ${this.collectedCount} / ${this.totalCollectibles}`);\n\n    // 检查是否通关\n    if (this.collectedCount >= this.totalCollectibles) {\n      this.gameCompleted = true;\n      this.winText.setVisible(true);\n      this.player.setVelocity(0, 0);\n      // 禁用玩家输入\n      this.cursors = null;\n    }\n  }\n\n  update() {\n    if (this.gameCompleted || !this.cursors) {\n      return;\n    }\n\n    // 重置速度\n    this.player.setVelocity(0);\n\n    // 键盘控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectGame\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000951_v2", "prompt_id": "seed_000951", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色菱形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色菱形在1.5秒内左右往返循环移动\nAPI: Graphics.fillStyle, Graphics.fillPath, Tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制灰色菱形形状\n2. 创建补间动画，设置从左到右的移动（x坐标变化）\n3. 配置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n5. 设置 duration 为 1500 毫秒（1.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制菱形（使用路径）\n  const diamondSize = 50;\n  graphics.beginPath();\n  graphics.moveTo(0, -diamondSize); // 上顶点\n  graphics.lineTo(diamondSize, 0);  // 右顶点\n  graphics.lineTo(0, diamondSize);  // 下顶点\n  graphics.lineTo(-diamondSize, 0); // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置初始位置（左侧）\n  const startX = 100;\n  const endX = 700;\n  const centerY = 300;\n  \n  graphics.setPosition(startX, centerY);\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: graphics,\n    x: endX,              // 目标 x 坐标（右侧）\n    duration: 1500,       // 持续时间 1.5 秒\n    ease: 'Linear',       // 线性缓动\n    yoyo: true,           // 启用往返效果（到达终点后反向播放）\n    repeat: -1            // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000744_v2", "prompt_id": "seed_000744", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Phaser.Scene.cameras\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个星形纹理\n2. 创建一个使用该纹理的精灵对象\n3. 在 create 中设置相机跟随该精灵对象\n4. 在 update 中让星形自动向右下移动\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 移动速度（像素/秒）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 1. 创建背景网格以便观察相机移动\n    this.createBackgroundGrid();\n\n    // 2. 使用 Graphics 创建星形纹理\n    this.createStarTexture();\n\n    // 3. 创建星形精灵并放置在起始位置\n    this.star = this.add.sprite(400, 300, 'starTexture');\n    this.star.setScale(2); // 放大星形以便观察\n\n    // 4. 设置相机跟随星形对象，保持居中\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机边界，让星形可以在更大的世界中移动\n    this.cameras.main.setBounds(0, 0, 2000, 2000);\n    \n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 2000, 2000);\n\n    // 添加提示文本（固定在相机上）\n    const infoText = this.add.text(10, 10, '星形自动向右下移动\\n相机跟随并保持居中', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    infoText.setScrollFactor(0); // 固定在相机上，不随世界移动\n  }\n\n  update(time, delta) {\n    // 让星形自动向右下移动\n    // delta 是毫秒，转换为秒\n    const deltaSeconds = delta / 1000;\n    \n    // 向右下方向移动（45度角）\n    const moveX = this.speed * deltaSeconds;\n    const moveY = this.speed * deltaSeconds;\n    \n    this.star.x += moveX;\n    this.star.y += moveY;\n\n    // 可选：当星形超出世界边界时重置位置\n    if (this.star.x > 1900 || this.star.y > 1900) {\n      this.star.x = 100;\n      this.star.y = 100;\n    }\n  }\n\n  // 创建星形纹理\n  createStarTexture() {\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    \n    // 绘制黄色星形\n    graphics.fillStyle(0xffff00, 1);\n    graphics.lineStyle(2, 0xffa500, 1);\n    \n    // 绘制五角星\n    const centerX = 32;\n    const centerY = 32;\n    const outerRadius = 30;\n    const innerRadius = 12;\n    const points = 5;\n    \n    graphics.beginPath();\n    for (let i = 0; i < points * 2; i++) {\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const angle = (i * Math.PI) / points - Math.PI / 2;\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n      \n      if (i === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 生成纹理\n    graphics.generateTexture('starTexture', 64, 64);\n    graphics.destroy();\n  }\n\n  // 创建背景网格以便观察相机移动\n  createBackgroundGrid() {\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n    \n    // 绘制网格\n    const gridSize = 100;\n    const worldWidth = 2000;\n    const worldHeight = 2000;\n    \n    // 垂直线\n    for (let x = 0; x <= worldWidth; x += gridSize) {\n      graphics.lineBetween(x, 0, x, worldHeight);\n    }\n    \n    // 水平线\n    for (let y = 0; y <= worldHeight; y += gridSize) {\n      graphics.lineBetween(0, y, worldWidth, y);\n    }\n    \n    // 添加坐标标记\n    for (let x = 0; x <= worldWidth; x += 200) {\n      for (let y = 0; y <= worldHeight; y += 200) {\n        const text = this.add.text(x + 5, y + 5, `${x},${y}`, {\n          fontSize: '12px',\n          fill: '#666666'\n        });\n      }\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000659_v3", "prompt_id": "seed_000659", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8737500000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示 \"Hello Phaser\" 文字，字体大小 16 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 将文本定位在屏幕下方（y 坐标接近底部），水平居中\n4. 设置字体大小为 16 像素，颜色为白色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕下方创建文本，字体大小 16 像素\n  const text = this.add.text(\n    400,  // x 坐标（屏幕中心）\n    550,  // y 坐标（屏幕下方）\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '16px',  // 字体大小\n      color: '#ffffff',  // 白色文字\n      fontFamily: 'Arial'  // 字体\n    }\n  );\n  \n  // 设置文本的原点为中心，使其水平居中对齐\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000615_v3", "prompt_id": "seed_000615", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制橙色三角形并生成纹理\n2. 创建启用物理的精灵对象，应用三角形纹理\n3. 设置初始速度为 160（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制一个等边三角形（中心在 32, 32，边长约 50）\n  graphics.fillTriangle(\n    32, 10,      // 顶点\n    10, 54,      // 左下顶点\n    54, 54       // 右下顶点\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 64, 64);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（160 速度，斜向移动）\n  triangle.setVelocity(160 * Math.cos(Math.PI / 4), 160 * Math.sin(Math.PI / 4));\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：调整碰撞体大小以更贴合三角形\n  triangle.body.setSize(44, 44);\n  triangle.body.setOffset(10, 10);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000522_v2", "prompt_id": "seed_000522", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左移动的圆形对象并保持居中\nAPI: Graphics#fillCircle, Graphics#generateTexture, Physics.add.sprite, Camera#startFollow, Sprite#setVelocity\nSTEPS:\n1. 创建一个足够大的世界边界，让对象有足够移动空间\n2. 使用 Graphics 绘制圆形并生成纹理\n3. 创建物理精灵对象并设置向左移动的速度\n4. 设置相机跟随该对象并调整相机边界\n5. 添加边界检测，当对象移出世界边界时重置位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet cursors;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，创建一个更大的游戏世界\n  this.physics.world.setBounds(0, 0, 3200, 600);\n  \n  // 使用 Graphics 创建圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  graphics.generateTexture('playerCircle', 50, 50);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n  \n  // 创建玩家精灵（在世界中间位置）\n  player = this.physics.add.sprite(1600, 300, 'playerCircle');\n  player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许循环\n  \n  // 设置玩家向左移动\n  player.setVelocityX(-150);\n  \n  // 设置相机跟随玩家\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3200, 600);\n  \n  // 添加一些参考网格线，帮助观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x555555, 0.5);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 3200; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 600);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 600; y += 100) {\n    gridGraphics.lineBetween(0, y, 3200, y);\n  }\n  \n  // 添加文字提示\n  const text = this.add.text(16, 16, 'Camera follows the green circle\\nCircle moves left automatically', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 10 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n  \n  // 添加位置信息显示\n  this.positionText = this.add.text(16, 100, '', {\n    fontSize: '16px',\n    fill: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 更新位置信息显示\n  this.positionText.setText(\n    `Player X: ${Math.round(player.x)}\\n` +\n    `Player Y: ${Math.round(player.y)}\\n` +\n    `Camera X: ${Math.round(this.cameras.main.scrollX)}`\n  );\n  \n  // 当玩家移出左边界时，将其传送到右边界\n  if (player.x < -25) {\n    player.x = 3200 + 25;\n  }\n  \n  // 当玩家移出右边界时，将其传送到左边界\n  if (player.x > 3200 + 25) {\n    player.x = -25;\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000772_v3", "prompt_id": "seed_000772", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8642857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色圆形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个粉色圆形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建基础的 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充样式为粉色（0xff69b4）\n4. 使用 fillCircle 在画布中央（400, 300）绘制半径为 16 的圆形\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为粉色\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数：x坐标, y坐标, 半径\n  graphics.fillCircle(400, 300, 16);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000233_v3", "prompt_id": "seed_000233", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个粉色小球以 160 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个粉色小球以160速度在封闭空间内移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.sprite, Body.setBounce, Body.setCollideWorldBounds, Physics.add.collider, Body.setVelocity\nSTEPS:\n1. 配置物理系统，启用 arcade 物理引擎\n2. 使用 Graphics 绘制粉色圆形纹理\n3. 创建 5 个物理精灵球体，设置随机初始位置和速度\n4. 为每个球设置边界碰撞反弹和完全弹性碰撞系数\n5. 添加球与球之间的碰撞检测\n6. 添加碰撞计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 可验证状态信号：碰撞计数\n    this.ballCount = 5; // 球的数量\n    this.ballSpeed = 160; // 球的速度\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建粉色球纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF69B4, 1); // 粉色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('pinkBall', 32, 32);\n    graphics.destroy();\n\n    // 创建球组\n    this.balls = this.physics.add.group({\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 创建5个球，设置随机位置和速度\n    for (let i = 0; i < this.ballCount; i++) {\n      // 随机位置（避免边缘生成）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      const ball = this.balls.create(x, y, 'pinkBall');\n      \n      // 设置随机速度方向，但保持速度大小为160\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const vx = Math.cos(angle) * this.ballSpeed;\n      const vy = Math.sin(angle) * this.ballSpeed;\n      \n      ball.setVelocity(vx, vy);\n      ball.setBounce(1); // 确保完全弹性\n      ball.setCollideWorldBounds(true);\n      \n      // 设置圆形碰撞体，更精确\n      ball.body.setCircle(16);\n    }\n\n    // 添加球与球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示状态信息\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 边界可视化（可选，帮助调试）\n    const bounds = this.add.graphics();\n    bounds.lineStyle(2, 0xffffff, 0.5);\n    bounds.strokeRect(0, 0, 800, 600);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调，增加计数器\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    // 更新显示信息\n    this.infoText.setText([\n      `Balls: ${this.ballCount}`,\n      `Speed: ${this.ballSpeed}`,\n      `Collisions: ${this.collisionCount}`,\n      `Time: ${Math.floor(time / 1000)}s`\n    ]);\n\n    // 确保球的速度保持恒定（可选，补偿浮点误差）\n    this.balls.children.entries.forEach(ball => {\n      const body = ball.body;\n      const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n      \n      // 如果速度偏差超过1%，进行修正\n      if (Math.abs(currentSpeed - this.ballSpeed) > this.ballSpeed * 0.01) {\n        const scale = this.ballSpeed / currentSpeed;\n        body.setVelocity(body.velocity.x * scale, body.velocity.y * scale);\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false // 设为 true 可查看碰撞体\n    }\n  },\n  scene: BallCollisionScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001156_v1", "prompt_id": "seed_001156", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9042857142857141}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示\"Hello Phaser\"文字，字体大小32像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本位置在屏幕下方（y 坐标接近底部），水平居中\n4. 设置字体大小为 32 像素，并设置文本颜色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕下方显示文字\n  const text = this.add.text(\n    400,  // x 坐标：屏幕水平居中\n    550,  // y 坐标：屏幕下方\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '32px',  // 字体大小\n      color: '#ffffff',  // 文字颜色（白色）\n      fontFamily: 'Arial'  // 字体\n    }\n  );\n  \n  // 设置文本锚点为中心，使其真正居中\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000227_v2", "prompt_id": "seed_000227", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的六边形\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建精灵对象并设置初始位置\n3. 在 update 中让六边形持续向左下移动\n4. 使用相机的 startFollow 方法跟随六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst moveSpeed = 2; // 每帧移动的像素数\n\nfunction preload() {\n  // 创建六边形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  const hexRadius = 30;\n  const centerX = hexRadius + 5;\n  const centerY = hexRadius + 5;\n  \n  // 绘制六边形的6个顶点\n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', (hexRadius + 5) * 2, (hexRadius + 5) * 2);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建六边形精灵，初始位置在场景中心偏右上\n  hexagon = this.add.sprite(600, 200, 'hexagon');\n  \n  // 设置相机边界为一个更大的区域，允许六边形移动\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  \n  // 设置世界边界\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n  \n  // 让相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 添加提示文字（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随六边形\\n六边形向左下移动', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n  \n  // 添加网格参考线，帮助观察移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 2000);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 2000; y += 100) {\n    gridGraphics.lineBetween(0, y, 2000, y);\n  }\n}\n\nfunction update(time, delta) {\n  // 让六边形向左下移动\n  // 左：x减小，下：y增大\n  hexagon.x -= moveSpeed;\n  hexagon.y += moveSpeed;\n  \n  // 可选：当六边形移出边界时重置位置\n  if (hexagon.x < -50 || hexagon.y > 2050) {\n    hexagon.setPosition(600, 200);\n  }\n  \n  // 可选：添加旋转效果使移动更明显\n  hexagon.rotation += 0.02;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000445_v2", "prompt_id": "seed_000445", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8920833333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色方块以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 创建物理引擎配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制蓝色方块并生成纹理\n3. 创建物理精灵，设置初始速度为200\n4. 设置世界边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 不需要重力\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1);  // 蓝色\n  graphics.fillRect(0, 0, 50, 50);  // 50x50 的方块\n  \n  // 生成纹理\n  graphics.generateTexture('blueSquare', 50, 50);\n  graphics.destroy();  // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵，位置在画布中心\n  const square = this.physics.add.sprite(400, 300, 'blueSquare');\n  \n  // 设置初始速度（斜向移动，速度大小约为200）\n  // 使用勾股定理：sqrt(141^2 + 141^2) ≈ 200\n  square.setVelocity(141, 141);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000663_v2", "prompt_id": "seed_000663", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 5 个青色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成5个青色可收集物体，玩家碰到后消失并加分，显示score\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 在 create 中使用 Graphics 创建玩家和收集物纹理\n3. 创建物理精灵组，生成5个青色收集物随机分布在场景中\n4. 添加键盘控制实现玩家移动\n5. 使用 overlap 检测玩家与收集物碰撞，碰撞时销毁收集物并增加分数\n6. 创建文本对象显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（青色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0x00ffff, 1);\n    collectibleGraphics.fillCircle(15, 15, 15);\n    collectibleGraphics.generateTexture('collectible', 30, 30);\n    collectibleGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成5个收集物\n    const positions = [\n      { x: 150, y: 150 },\n      { x: 650, y: 150 },\n      { x: 400, y: 200 },\n      { x: 250, y: 350 },\n      { x: 550, y: 350 }\n    ];\n\n    positions.forEach(pos => {\n      const collectible = this.collectibles.create(pos.x, pos.y, 'collectible');\n      collectible.setCollideWorldBounds(true);\n      // 添加轻微的浮动效果\n      this.tweens.add({\n        targets: collectible,\n        y: collectible.y - 10,\n        duration: 1000,\n        yoyo: true,\n        repeat: -1,\n        ease: 'Sine.easeInOut'\n      });\n    });\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.scoreText.setDepth(10);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加提示文本\n    this.add.text(400, 550, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update() {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁收集物\n    collectible.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 添加收集特效（闪烁文本）\n    const collectText = this.add.text(collectible.x, collectible.y, '+10', {\n      fontSize: '24px',\n      fill: '#00ffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 3\n    }).setOrigin(0.5);\n\n    this.tweens.add({\n      targets: collectText,\n      y: collectText.y - 50,\n      alpha: 0,\n      duration: 800,\n      ease: 'Power2',\n      onComplete: () => {\n        collectText.destroy();\n      }\n    });\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0) {\n      const winText = this.add.text(400, 300, 'All Collected!\\nFinal Score: ' + this.score, {\n        fontSize: '48px',\n        fill: '#ffff00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6,\n        align: 'center'\n      }).setOrigin(0.5);\n\n      // 停止玩家移动\n      this.player.setVelocity(0, 0);\n      this.cursors = null;\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001091_v3", "prompt_id": "seed_001091", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8950000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果，从 1.0 到 0.8 再回到 1.0\n4. 设置 Tween 的 loop 属性为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 在屏幕中心创建方块精灵\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 创建缩放动画\n  // yoyo: true 表示动画会反向播放（缩小后再放大）\n  // duration: 2000 表示单程 2 秒，来回共 4 秒\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 2000,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字提示\n  this.add.text(400, 500, 'Square scaling animation (loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000548_v2", "prompt_id": "seed_000548", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按WASD键发射白色子弹的例子，子弹速度 300，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按WASD键发射白色子弹，速度300，离开边界自动回收到对象池\nAPI: Physics.Arcade, Input.Keyboard, GameObjects.Group, Graphics.generateTexture\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成白色子弹纹理\n3. 创建子弹对象池（Group），设置最大数量和回收逻辑\n4. 监听 WASD 键盘输入，按键时从对象池获取子弹并发射\n5. 在 update 中检测子弹是否离开边界，离开则回收到对象池\n6. 添加状态变量记录发射的子弹总数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用 Graphics 生成白色子弹纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(8, 8, 8);\n    graphics.generateTexture('bullet', 16, 16);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建子弹对象池\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: true\n    });\n\n    // 创建 WASD 键盘输入\n    this.keys = {\n      W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n      A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n      S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n      D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n    };\n\n    // 添加文本显示发射的子弹数量\n    this.bulletText = this.add.text(16, 16, 'Bullets Fired: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, 'Press WASD to fire bullets', {\n      fontSize: '16px',\n      fill: '#cccccc'\n    });\n  }\n\n  update(time, delta) {\n    // 检测 WASD 键按下并发射子弹\n    if (Phaser.Input.Keyboard.JustDown(this.keys.W)) {\n      this.fireBullet(400, 300, 0, -300); // 向上\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.A)) {\n      this.fireBullet(400, 300, -300, 0); // 向左\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.S)) {\n      this.fireBullet(400, 300, 0, 300); // 向下\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.D)) {\n      this.fireBullet(400, 300, 300, 0); // 向右\n    }\n\n    // 检查子弹是否离开边界，离开则回收\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        const bounds = this.physics.world.bounds;\n        if (bullet.x < bounds.x - 50 || \n            bullet.x > bounds.x + bounds.width + 50 ||\n            bullet.y < bounds.y - 50 || \n            bullet.y > bounds.y + bounds.height + 50) {\n          this.bullets.killAndHide(bullet);\n          bullet.body.reset(0, 0);\n        }\n      }\n    });\n  }\n\n  fireBullet(x, y, velocityX, velocityY) {\n    // 从对象池获取子弹\n    const bullet = this.bullets.get(x, y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹速度\n      bullet.body.setVelocity(velocityX, velocityY);\n      \n      // 更新发射计数\n      this.bulletsFired++;\n      this.bulletText.setText('Bullets Fired: ' + this.bulletsFired);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000921_v1", "prompt_id": "seed_000921", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让红色方块在 2 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色方块的弹跳动画效果，2秒一次循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 创建红色方块纹理\n2. 创建 Sprite 对象并应用纹理\n3. 使用 Tween 实现 y 轴弹跳动画，配置 yoyo 和 repeat 实现循环\n4. 设置缓动函数为 Bounce.easeOut 实现弹跳效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建红色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  graphics.generateTexture('redSquare', 80, 80);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建红色方块精灵\n  const redSquare = this.add.sprite(400, 500, 'redSquare');\n  \n  // 添加弹跳动画\n  // 从当前位置向上移动 200 像素，然后返回，整个过程 2 秒\n  this.tweens.add({\n    targets: redSquare,\n    y: 300, // 向上弹跳到的位置\n    duration: 1000, // 单程 1 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返运动\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟立即重复\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Bouncing Red Square', {\n    fontSize: '32px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000595_v1", "prompt_id": "seed_000595", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让红色矩形在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个红色矩形，使用 Tween 实现 2 秒抖动循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建抖动动画，通过快速改变 x/y 位置模拟抖动\n4. 设置 yoyo 和 loop 实现循环抖动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('redRect', 100, 100);\n  graphics.destroy();\n\n  // 创建红色矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'redRect');\n\n  // 记录原始位置\n  const originalX = rect.x;\n  const originalY = rect.y;\n\n  // 创建抖动动画\n  // 通过在短时间内快速改变位置来模拟抖动效果\n  this.tweens.add({\n    targets: rect,\n    x: originalX + 10, // 向右抖动\n    y: originalY + 10, // 向下抖动\n    duration: 50, // 每次抖动持续 50ms\n    ease: 'Linear',\n    yoyo: true, // 来回抖动\n    repeat: 19, // 重复 19 次（加上初始 1 次，共 20 次往返，总计约 2 秒）\n    loop: -1, // 无限循环\n    onRepeat: function() {\n      // 在每次重复时随机改变抖动方向，增加抖动的随机性\n      const randomX = originalX + Phaser.Math.Between(-10, 10);\n      const randomY = originalY + Phaser.Math.Between(-10, 10);\n      \n      this.updateTo('x', randomX, true);\n      this.updateTo('y', randomY, true);\n    }\n  });\n\n  // 添加说明文字\n  this.add.text(400, 50, '红色矩形抖动动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, '抖动周期: 2秒循环', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000652_v2", "prompt_id": "seed_000652", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中循环15次\n3. 每次循环创建一个 Graphics 对象\n4. 使用三角函数计算六边形的6个顶点坐标（半径32像素）\n5. 使用 beginPath、lineTo、closePath、fillPath 绘制填充的六边形\n6. 使用 Math.random 为每个六边形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 绘制15个随机位置的紫色六边形\n  for (let i = 0; i < 15; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充\n    graphics.fillStyle(0x9966ff, 1);\n    \n    // 六边形半径（大小64像素，半径32像素）\n    const radius = 32;\n    \n    // 随机位置（确保六边形完全在画布内）\n    const x = Phaser.Math.Between(radius, config.width - radius);\n    const y = Phaser.Math.Between(radius, config.height - radius);\n    \n    // 绘制六边形\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点（从顶部开始，顺时针）\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j - Math.PI / 2; // 从顶部开始（-90度）\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(vx, vy);\n      } else {\n        graphics.lineTo(vx, vy);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000644_v1", "prompt_id": "seed_000644", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的橙色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的橙色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算六边形6个顶点坐标\n4. 循环12次，每次生成随机位置(x, y)，绘制橙色六边形\n5. 使用 fillStyle 设置橙色，使用 beginPath/lineTo/closePath/fillPath 绘制填充六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 橙色填充\n  graphics.fillStyle(0xFF8C00, 1);\n  \n  // 六边形大小（从中心到顶点的距离）\n  const size = 16; // 32像素直径，半径16\n  \n  // 绘制六边形的函数\n  function drawHexagon(g, x, y, radius) {\n    g.beginPath();\n    \n    // 计算六边形的6个顶点（从顶部开始，顺时针）\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度起始，使顶点朝上\n      const px = x + radius * Math.cos(angle);\n      const py = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        g.moveTo(px, py);\n      } else {\n        g.lineTo(px, py);\n      }\n    }\n    \n    g.closePath();\n    g.fillPath();\n  }\n  \n  // 绘制12个随机位置的六边形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置，留出边距避免六边形被裁切\n    const x = size + Math.random() * (800 - size * 2);\n    const y = size + Math.random() * (600 - size * 2);\n    \n    drawHexagon(graphics, x, y, size);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000500_v1", "prompt_id": "seed_000500", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1.5 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在1.5秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建精灵对象使用菱形纹理\n3. 使用 Tween 系统创建缩放动画，从 1 到 0.24 再回到 1\n4. 设置 Tween 循环播放（loop: -1）和 yoyo 效果\n5. 设置动画时长为 1500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 50, 50）\n  const size = 50;\n  graphics.beginPath();\n  graphics.moveTo(50, 0);           // 上顶点\n  graphics.lineTo(100, 50);         // 右顶点\n  graphics.lineTo(50, 100);         // 下顶点\n  graphics.lineTo(0, 50);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.24,        // 缩放到 24%\n    scaleY: 0.24,        // 缩放到 24%\n    duration: 1500,      // 1.5 秒\n    yoyo: true,          // 动画结束后反向播放（恢复）\n    loop: -1,            // 无限循环\n    ease: 'Linear'       // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Diamond scaling to 24% and back (Loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000611_v3", "prompt_id": "seed_000611", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9133333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色六边形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色六边形以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制白色六边形并生成纹理\n2. 创建带物理引擎的精灵并设置速度为200\n3. 启用世界边界碰撞并设置反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 计算六边形顶点（半径为30）\n  const radius = 30;\n  const hexagonPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = radius + Math.cos(angle) * radius;\n    const y = radius + Math.sin(angle) * radius;\n    hexagonPoints.push(x, y);\n  }\n  \n  // 绘制六边形\n  graphics.beginPath();\n  graphics.moveTo(hexagonPoints[0], hexagonPoints[1]);\n  for (let i = 2; i < hexagonPoints.length; i += 2) {\n    graphics.lineTo(hexagonPoints[i], hexagonPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', radius * 2, radius * 2);\n  graphics.destroy();\n  \n  // 创建带物理引擎的六边形精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 200;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 200;\n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 可选：添加旋转效果使运动更有趣\n  hexagon.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000385_v2", "prompt_id": "seed_000385", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右侧显示 \"Hello Phaser\" 文字，字体大小 64px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸\n2. 在 create 方法中使用 add.text 创建文字对象\n3. 设置文字位置在屏幕右侧，字体大小 64px\n4. 调整文字原点以实现右对齐效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右侧创建文字\n  // x 坐标设置为画布宽度减去一些边距（例如 50px）\n  // y 坐标设置为画布中心\n  const text = this.add.text(750, 300, 'Hello Phaser', {\n    fontSize: '64px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字原点为右中心 (1, 0.5)\n  // 这样文字会从右向左排列，实现右对齐效果\n  text.setOrigin(1, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000757_v2", "prompt_id": "seed_000757", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个方块并以每秒120度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制一个方块\n2. 在 update 方法中根据 delta 时间增量计算旋转角度\n3. 每帧更新方块的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制方块\n  square = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  square.fillStyle(0x3498db, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在原点\n  // 使用负偏移使方块中心对齐旋转中心\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 设置方块位置到屏幕中心\n  square.x = 400;\n  square.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 120 度\n  // delta 是毫秒，需要转换为秒\n  // 120 度 = 120 * (Math.PI / 180) 弧度\n  const rotationSpeed = 120 * (Math.PI / 180); // 每秒旋转的弧度数\n  const deltaSeconds = delta / 1000; // 将毫秒转换为秒\n  \n  // 更新旋转角度\n  square.rotation += rotationSpeed * deltaSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000135_v3", "prompt_id": "seed_000135", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的蓝色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的蓝色星形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Graphics 对象并定义星形路径绘制函数\n2. 使用循环创建20个星形，每个星形使用蓝色填充\n3. 为每个星形设置随机位置（考虑画布边界和星形大小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 星形参数\n  const starSize = 64;\n  const starCount = 20;\n  const starColor = 0x0000ff; // 蓝色\n  \n  // 创建20个星形\n  for (let i = 0; i < starCount; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为蓝色\n    graphics.fillStyle(starColor, 1);\n    \n    // 绘制星形路径\n    drawStar(graphics, 0, 0, 5, starSize / 2, starSize / 4);\n    \n    // 设置随机位置（确保星形完全在画布内）\n    const randomX = Phaser.Math.Between(starSize / 2, config.width - starSize / 2);\n    const randomY = Phaser.Math.Between(starSize / 2, config.height - starSize / 2);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n/**\n * 绘制星形路径\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心 x 坐标\n * @param {number} cy - 中心 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n  \n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n  \n  for (let i = 0; i < spikes; i++) {\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n    \n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n  \n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000150_v2", "prompt_id": "seed_000150", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在4秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果：从 scale 1 到 0.32，yoyo 模式自动恢复，duration 为 2000ms（单程2秒，往返4秒）\n4. 设置 loop: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (50, 50)，边长约 80\n  graphics.beginPath();\n  graphics.moveTo(50, 10);      // 顶点\n  graphics.lineTo(10, 90);       // 左下角\n  graphics.lineTo(90, 90);       // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的 Sprite\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置三角形的原点为中心\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    scaleX: 0.32,               // X 轴缩放到 32%\n    scaleY: 0.32,               // Y 轴缩放到 32%\n    duration: 2000,             // 单程持续时间 2 秒\n    yoyo: true,                 // 启用 yoyo 模式，动画结束后反向播放（实现恢复效果）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '三角形缩放动画：1.0 → 0.32 → 1.0 (4秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000297_v1", "prompt_id": "seed_000297", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 360，重力 400。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可在空中跳跃一次，跳跃力度360，重力400\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，设置重力为400\n2. 使用Graphics绘制玩家方块和地面平台\n3. 添加键盘输入监听，检测空格键或上方向键\n4. 实现双跳逻辑：记录跳跃次数，最多允许2次跳跃\n5. 玩家落地时重置跳跃次数\n6. 添加跳跃计数器作为状态信号用于验证\n[/PLAN]\n\n```javascript\nclass DoubleJumpScene extends Phaser.Scene {\n  constructor() {\n    super('DoubleJumpScene');\n    this.jumpCount = 0; // 当前已跳跃次数\n    this.maxJumps = 2; // 最大跳跃次数\n    this.totalJumps = 0; // 总跳跃次数（用于验证）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00aa00, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建地面平台\n    this.ground = this.physics.add.sprite(400, 575, 'ground');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground, () => {\n      // 玩家落地时重置跳跃次数\n      if (this.player.body.touching.down) {\n        this.jumpCount = 0;\n      }\n    });\n\n    // 添加键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 创建UI文本显示状态\n    this.jumpText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, '按空格键或上方向键跳跃\\n可在空中跳跃一次（双跳）', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateUI();\n  }\n\n  update(time, delta) {\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃逻辑\n    const jumpPressed = Phaser.Input.Keyboard.JustDown(this.cursors.up) || \n                       Phaser.Input.Keyboard.JustDown(this.spaceKey);\n\n    if (jumpPressed && this.jumpCount < this.maxJumps) {\n      // 执行跳跃\n      this.player.setVelocityY(-360);\n      this.jumpCount++;\n      this.totalJumps++;\n      this.updateUI();\n\n      // 视觉反馈：改变颜色\n      if (this.jumpCount === 1) {\n        this.player.setTint(0x00ff00); // 第一次跳跃变绿\n      } else if (this.jumpCount === 2) {\n        this.player.setTint(0xff0000); // 第二次跳跃变红\n      }\n    }\n\n    // 落地时恢复颜色\n    if (this.player.body.touching.down && this.jumpCount > 0) {\n      this.jumpCount = 0;\n      this.player.clearTint();\n      this.updateUI();\n    }\n  }\n\n  updateUI() {\n    const remainingJumps = this.maxJumps - this.jumpCount;\n    this.jumpText.setText(\n      `剩余跳跃次数: ${remainingJumps}/${this.maxJumps}\\n` +\n      `总跳跃次数: ${this.totalJumps}\\n` +\n      `当前状态: ${this.player.body.touching.down ? '地面' : '空中'}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: DoubleJumpScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000832_v2", "prompt_id": "seed_000832", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色方块以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色方块以120速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制紫色方块纹理\n3. 创建物理精灵并设置初始速度为120\n4. 启用世界边界碰撞和反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet square;\nconst SPEED = 120;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建紫色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1);  // 紫色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('purpleSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'purpleSquare');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * SPEED;\n  const velocityY = Math.sin(angle * Math.PI / 180) * SPEED;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1，实现完美弹性碰撞\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为120\n  // 由于反弹可能导致速度变化，需要归一化速度向量\n  const currentVelocity = square.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  if (currentSpeed !== 0 && Math.abs(currentSpeed - SPEED) > 0.1) {\n    // 归一化并重新设置为目标速度\n    square.setVelocity(\n      (currentVelocity.x / currentSpeed) * SPEED,\n      (currentVelocity.y / currentSpeed) * SPEED\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000228_v1", "prompt_id": "seed_000228", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：紫色敌人从上方以 120 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现紫色敌人从上方以120速度落下，玩家左右移动躲避，碰到游戏结束的躲避游戏\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.overlap\nSTEPS:\n1. 创建 Arcade 物理系统配置，初始化游戏场景\n2. 使用 Graphics 生成玩家（绿色矩形）和敌人（紫色矩形）纹理\n3. 创建玩家精灵，添加键盘左右控制（A/D 或方向键）\n4. 创建敌人组，定时从顶部随机位置生成敌人，设置向下速度 120\n5. 添加碰撞检测，碰到敌人时触发游戏结束，显示 Game Over 文本\n6. 添加得分系统，敌人离开屏幕底部时增加分数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet enemies;\nlet cursors;\nlet gameOver = false;\nlet score = 0;\nlet scoreText;\nlet gameOverText;\nlet keysAD;\n\nfunction preload() {\n  // 创建玩家纹理（绿色矩形）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建敌人纹理（紫色矩形）\n  const enemyGraphics = this.add.graphics();\n  enemyGraphics.fillStyle(0x9900ff, 1);\n  enemyGraphics.fillRect(0, 0, 30, 30);\n  enemyGraphics.generateTexture('enemy', 30, 30);\n  enemyGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 550, 'player');\n  player.setCollideWorldBounds(true);\n  player.body.setSize(40, 40);\n\n  // 创建敌人组\n  enemies = this.physics.add.group();\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  keysAD = this.input.keyboard.addKeys({\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff'\n  });\n\n  // 创建游戏结束文本（初始隐藏）\n  gameOverText = this.add.text(400, 300, 'GAME OVER', {\n    fontSize: '64px',\n    fill: '#ff0000'\n  });\n  gameOverText.setOrigin(0.5);\n  gameOverText.setVisible(false);\n\n  // 定时生成敌人（每1秒）\n  this.time.addEvent({\n    delay: 1000,\n    callback: spawnEnemy,\n    callbackScope: this,\n    loop: true\n  });\n\n  // 添加碰撞检测\n  this.physics.add.overlap(player, enemies, hitEnemy, null, this);\n}\n\nfunction update() {\n  if (gameOver) {\n    return;\n  }\n\n  // 玩家左右移动控制\n  if (cursors.left.isDown || keysAD.a.isDown) {\n    player.setVelocityX(-300);\n  } else if (cursors.right.isDown || keysAD.d.isDown) {\n    player.setVelocityX(300);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 检查敌人是否离开屏幕底部\n  enemies.children.entries.forEach(enemy => {\n    if (enemy.y > 600) {\n      enemy.destroy();\n      score += 10;\n      scoreText.setText('Score: ' + score);\n    }\n  });\n}\n\nfunction spawnEnemy() {\n  if (gameOver) {\n    return;\n  }\n\n  // 在顶部随机位置生成敌人\n  const x = Phaser.Math.Between(50, 750);\n  const enemy = enemies.create(x, -30, 'enemy');\n  \n  // 设置敌人向下速度为 120\n  enemy.setVelocityY(120);\n  enemy.body.setSize(30, 30);\n}\n\nfunction hitEnemy(player, enemy) {\n  // 游戏结束\n  gameOver = true;\n  \n  // 停止物理引擎\n  this.physics.pause();\n  \n  // 玩家变红\n  player.setTint(0xff0000);\n  \n  // 显示游戏结束文本\n  gameOverText.setVisible(true);\n  \n  // 添加重启提示\n  const restartText = this.add.text(400, 370, 'Click to Restart', {\n    fontSize: '24px',\n    fill: '#ffffff'\n  });\n  restartText.setOrigin(0.5);\n  \n  // 点击重启游戏\n  this.input.once('pointerdown', () => {\n    this.scene.restart();\n    gameOver = false;\n    score = 0;\n  });\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000954_v3", "prompt_id": "seed_000954", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9107692307692308}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让粉色方块在 2.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色方块淡入淡出循环动画，周期2.5秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色方块并生成纹理\n2. 创建 Sprite 对象显示粉色方块\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 参数实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkSquare', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象并居中显示\n  const square = this.add.sprite(400, 300, 'pinkSquare');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果（从1到0再回到1）\n  // duration 设置为 1250ms，yoyo 会让总周期为 2500ms (2.5秒)\n  this.tweens.add({\n    targets: square,\n    alpha: 0,           // 目标透明度为0（完全透明）\n    duration: 1250,     // 单程时间1.25秒\n    yoyo: true,         // 往返效果（淡出后再淡入）\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 550, '粉色方块淡入淡出循环动画 (2.5秒周期)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000799_v1", "prompt_id": "seed_000799", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的六边形\nAPI: Graphics.fillStyle, Graphics.fillCircle, Graphics.generateTexture, Sprite, Camera.startFollow, Camera.setBounds\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 在 update 中让六边形自动向右移动\n4. 设置相机跟随该 Sprite 对象\n5. 设置场景边界确保相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst MOVE_SPEED = 100; // 每秒移动的像素数\n\nfunction preload() {\n  // 使用 Graphics 创建六边形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  const hexRadius = 30;\n  const hexPath = [];\n  \n  // 计算六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = hexRadius + hexRadius * Math.cos(angle);\n    const y = hexRadius + hexRadius * Math.sin(angle);\n    hexPath.push(new Phaser.Math.Vector2(x, y));\n  }\n  \n  graphics.fillPoints(hexPath, true);\n  graphics.strokePoints(hexPath, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让六边形可以移动\n  const worldWidth = 3000;\n  const worldHeight = 600;\n  this.physics.world.setBounds(0, 0, worldWidth, worldHeight);\n  \n  // 创建六边形精灵\n  hexagon = this.add.sprite(100, 300, 'hexagon');\n  \n  // 设置相机边界（与世界边界一致）\n  this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);\n  \n  // 让相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 添加背景网格以便观察相机移动\n  this.createGrid(worldWidth, worldHeight);\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '六边形自动向右移动，相机跟随', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界滚动\n}\n\nfunction update(time, delta) {\n  // 让六边形自动向右移动\n  const moveDistance = MOVE_SPEED * (delta / 1000);\n  hexagon.x += moveDistance;\n  \n  // 当六边形到达世界边界时，重置位置\n  if (hexagon.x > 2900) {\n    hexagon.x = 100;\n  }\n  \n  // 添加轻微的上下浮动效果\n  hexagon.y = 300 + Math.sin(time / 500) * 50;\n}\n\n// 辅助函数：创建背景网格\nPhaser.Scene.prototype.createGrid = function(width, height) {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  const gridSize = 100;\n  \n  // 绘制垂直线\n  for (let x = 0; x <= width; x += gridSize) {\n    graphics.lineBetween(x, 0, x, height);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= height; y += gridSize) {\n    graphics.lineBetween(0, y, width, y);\n  }\n  \n  // 添加坐标标记\n  for (let x = 0; x <= width; x += gridSize * 2) {\n    const label = this.add.text(x + 5, 5, `${x}`, {\n      fontSize: '12px',\n      color: '#888888'\n    });\n  }\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000359_v1", "prompt_id": "seed_000359", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8688888888888889}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色圆形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色圆形以200速度移动并在边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 arcade 物理系统配置\n2. 使用 Graphics 绘制青色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 设置边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 使用 Graphics 创建青色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1);  // 青色\n  graphics.fillCircle(25, 25, 25);  // 半径25的圆形\n  graphics.generateTexture('cyanCircle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'cyanCircle');\n  \n  // 设置初始速度（随机方向，速度大小为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 200);\n  circle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n  \n  // 可选：添加文字提示\n  this.add.text(10, 10, 'Cyan circle bouncing at speed 200', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000623_v2", "prompt_id": "seed_000623", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
