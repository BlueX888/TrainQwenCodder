{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色三角形在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色三角形在3秒内完成弹跳动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 Tween 创建弹跳动画（y轴移动+缩放效果模拟弹跳）\n4. 设置 Tween 为循环模式，duration 为 3000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心点在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -40);      // 顶点\n  graphics.lineTo(-35, 30);     // 左下角\n  graphics.lineTo(35, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 70, 70);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建弹跳动画\n  // 使用 yoyo 和缩放效果模拟真实的弹跳\n  this.tweens.add({\n    targets: triangle,\n    y: 150,                    // 向上弹跳到 y=150\n    scaleY: 1.1,               // 垂直拉伸（起跳时的拉伸效果）\n    duration: 750,             // 上升阶段 0.75 秒\n    ease: 'Quad.easeOut',      // 减速上升\n    yoyo: true,                // 返回原位置\n    hold: 0,                   // 在顶点不停留\n    repeat: -1,                // 无限循环\n    repeatDelay: 0,            // 无延迟\n    onYoyo: function() {\n      // 下落阶段，三角形被压扁（模拟着地时的形变）\n      this.tweens.add({\n        targets: triangle,\n        scaleY: 0.8,           // 压扁效果\n        scaleX: 1.1,           // 横向拉伸\n        duration: 375,         // 0.375 秒\n        ease: 'Quad.easeIn',   // 加速下落\n        yoyo: true,            // 恢复形状\n        hold: 100              // 在压扁状态保持 0.1 秒\n      });\n    },\n    callbackScope: this\n  });\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '绿色三角形弹跳动画\\n循环周期：3秒', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000439_v1", "prompt_id": "seed_000439", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让绿色矩形在 1.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色矩形，使用 Tween 动画在 1.5 秒内旋转 360 度并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制绿色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 angle 属性从 0 到 360\n4. 设置动画持续时间为 1500ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('greenRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'greenRect');\n  \n  // 设置旋转中心点为矩形中心\n  rect.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    angle: 360,              // 旋转到 360 度\n    duration: 1500,          // 持续时间 1.5 秒\n    ease: 'Linear',          // 线性缓动，保持匀速旋转\n    repeat: -1,              // -1 表示无限循环\n    onRepeat: function() {\n      // 每次循环重复时重置角度，避免累积\n      rect.angle = 0;\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000074_v1", "prompt_id": "seed_000074", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色星形以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Physics.Arcade, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 在 create 中使用 Graphics 绘制红色星形并生成纹理\n3. 创建物理精灵并应用星形纹理，设置初始速度为360\n4. 设置精灵与世界边界碰撞并反弹\n5. 可选：在 update 中保持恒定速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet star;\nconst SPEED = 360;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制星形（5个尖角）\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: 40 + Math.cos(angle) * radius,\n      y: 40 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 80, 80);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置随机初始速度方向，但保持速度大小为360\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  star.setVelocity(\n    Math.cos(angle) * SPEED,\n    Math.sin(angle) * SPEED\n  );\n  \n  // 设置与世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  star.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（修正由于浮点数误差导致的速度变化）\n  const currentSpeed = Math.sqrt(\n    star.body.velocity.x ** 2 + star.body.velocity.y ** 2\n  );\n  \n  if (Math.abs(currentSpeed - SPEED) > 1) {\n    const scale = SPEED / currentSpeed;\n    star.setVelocity(\n      star.body.velocity.x * scale,\n      star.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000182_v3", "prompt_id": "seed_000182", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色六边形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色六边形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.lineStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.strokePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的六个顶点坐标（中心点在画布中央，半径约 24 像素）\n4. 使用 Graphics API 绘制六边形路径并填充灰色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 六边形半径（从中心到顶点的距离）\n  const radius = 24;\n  \n  // 计算六边形的六个顶点坐标\n  // 六边形每个角度间隔 60 度（π/3 弧度）\n  // 从顶部开始（-90度），顺时针绘制\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从-90度开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 移动到第一个顶点\n  graphics.moveTo(points[0].x, points[0].y);\n  \n  // 连接其余顶点\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充六边形\n  graphics.fillPath();\n  \n  // 可选：添加描边使六边形更清晰\n  graphics.lineStyle(2, 0x404040, 1);\n  graphics.strokePath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000442_v2", "prompt_id": "seed_000442", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 红色玩家移出边界时从对侧出现（循环地图效果），移动速度 120。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 红色玩家移出边界时从对侧出现，移动速度120\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), this.physics.world.wrap()\nSTEPS:\n1. 创建带物理系统的配置，使用 arcade 物理引擎\n2. 使用 Graphics 生成红色方块纹理作为玩家\n3. 创建物理精灵并设置速度为 120\n4. 监听键盘输入控制玩家移动\n5. 在 update 中使用 physics.world.wrap 实现边界循环效果\n6. 添加位置坐标作为可验证状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nlet positionText;\nlet wrapCount = 0; // 可验证状态：记录循环次数\n\nfunction preload() {\n  // 使用 Graphics 生成红色玩家纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 关闭世界边界碰撞以允许穿越\n  \n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加 WASD 键支持\n  this.wasd = this.input.keyboard.addKeys({\n    up: Phaser.Input.Keyboard.KeyCodes.W,\n    down: Phaser.Input.Keyboard.KeyCodes.S,\n    left: Phaser.Input.Keyboard.KeyCodes.A,\n    right: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 显示位置和循环次数信息（可验证状态）\n  positionText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 添加说明文字\n  this.add.text(10, 50, 'Use Arrow Keys or WASD to move\\nSpeed: 120px/s', {\n    fontSize: '14px',\n    fill: '#aaaaaa'\n  });\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0);\n  \n  // 检测输入并设置速度（速度为 120）\n  const speed = 120;\n  \n  if (cursors.left.isDown || this.wasd.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown || this.wasd.right.isDown) {\n    player.setVelocityX(speed);\n  }\n  \n  if (cursors.up.isDown || this.wasd.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown || this.wasd.down.isDown) {\n    player.setVelocityY(speed);\n  }\n  \n  // 记录移动前的位置用于检测边界穿越\n  const prevX = player.x;\n  const prevY = player.y;\n  \n  // 使用 wrap 实现循环地图效果\n  // 参数：sprite, padding（额外边距）\n  this.physics.world.wrap(player, 16);\n  \n  // 检测是否发生了边界循环\n  const wrapped = Math.abs(player.x - prevX) > 100 || Math.abs(player.y - prevY) > 100;\n  if (wrapped) {\n    wrapCount++;\n  }\n  \n  // 更新状态显示\n  positionText.setText([\n    `Position: (${Math.floor(player.x)}, ${Math.floor(player.y)})`,\n    `Velocity: (${Math.floor(player.body.velocity.x)}, ${Math.floor(player.body.velocity.y)})`,\n    `Wrap Count: ${wrapCount}`\n  ]);\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001209_v2", "prompt_id": "seed_001209", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, this.cameras.main\nSTEPS:\n1. 创建 Scene 并设置较大的世界边界以容纳星形移动\n2. 使用 Graphics 绘制一个星形作为跟随目标\n3. 在 update 中让星形持续向上移动\n4. 使用 camera.startFollow 让主相机跟随星形对象\n5. 设置相机边界与世界边界一致\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 每秒移动像素\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 设置世界边界，让星形有足够的移动空间\n    this.cameras.main.setBounds(0, 0, 800, 3000);\n    this.physics.world.setBounds(0, 0, 800, 3000);\n\n    // 创建星形图形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1); // 黄色星形\n    graphics.lineStyle(2, 0xff6600, 1); // 橙色边框\n\n    // 绘制星形（5个角）\n    const points = [];\n    const centerX = 0;\n    const centerY = 0;\n    const outerRadius = 30;\n    const innerRadius = 15;\n    const numPoints = 5;\n\n    for (let i = 0; i < numPoints * 2; i++) {\n      const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      points.push({\n        x: centerX + Math.cos(angle) * radius,\n        y: centerY + Math.sin(angle) * radius\n      });\n    }\n\n    graphics.beginPath();\n    graphics.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      graphics.lineTo(points[i].x, points[i].y);\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n\n    // 生成纹理\n    graphics.generateTexture('starTexture', 60, 60);\n    graphics.destroy();\n\n    // 创建星形精灵并启用物理\n    this.star = this.physics.add.sprite(400, 2800, 'starTexture');\n    this.star.setCollideWorldBounds(true);\n\n    // 设置相机跟随星形\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机跟随偏移，让星形显示在屏幕中心稍下方\n    // this.cameras.main.setFollowOffset(0, 0);\n\n    // 添加提示文本（固定在相机上）\n    const instructionText = this.add.text(10, 10, 'Star moving up\\nCamera following', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    instructionText.setScrollFactor(0); // 固定在相机视口上\n\n    // 添加位置信息文本\n    this.positionText = this.add.text(10, 80, '', {\n      fontSize: '14px',\n      fill: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.positionText.setScrollFactor(0);\n  }\n\n  update(time, delta) {\n    if (this.star) {\n      // 让星形向上移动（Y坐标减小）\n      this.star.y -= (this.speed * delta) / 1000;\n\n      // 如果到达世界顶部，重置到底部\n      if (this.star.y < 30) {\n        this.star.y = 2970;\n      }\n\n      // 更新位置信息\n      this.positionText.setText(\n        `Star Y: ${Math.round(this.star.y)}\\n` +\n        `Camera Y: ${Math.round(this.cameras.main.scrollY)}`\n      );\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000497_v2", "prompt_id": "seed_000497", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象用于绘制三角形\n2. 使用 fillTriangle 方法绘制一个三角形\n3. 在 update 方法中根据 delta 时间增量更新旋转角度\n4. 将每秒 200 度转换为弧度增量并应用到 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  triangle = this.add.graphics();\n  \n  // 设置填充颜色\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（相对于 Graphics 对象的中心点）\n  // 三角形顶点坐标：顶部(0, -50), 左下(50, 50), 右下(-50, 50)\n  triangle.fillTriangle(\n    0, -50,   // 顶部顶点\n    -50, 50,  // 左下顶点\n    50, 50    // 右下顶点\n  );\n  \n  // 将三角形移动到屏幕中心\n  triangle.x = 400;\n  triangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒 200 度 = 200 * (Math.PI / 180) 弧度/秒\n  // delta 是毫秒，需要转换为秒：delta / 1000\n  const rotationSpeed = 200 * (Math.PI / 180); // 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000); // 本帧旋转量\n  \n  // 更新旋转角度\n  triangle.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000168_v2", "prompt_id": "seed_000168", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色椭圆，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色椭圆，大小约为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充样式为白色\n4. 使用 fillEllipse 在画布中央绘制椭圆，宽高均为24像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  const centerX = config.width / 2;  // 400\n  const centerY = config.height / 2; // 300\n  const ellipseWidth = 24;\n  const ellipseHeight = 24;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000755_v1", "prompt_id": "seed_000755", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的粉色菱形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的粉色菱形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 使用 Graphics.fillPath 和 Polygon 绘制菱形（4个顶点构成菱形）\n4. 设置粉色填充颜色（0xff69b4）\n5. 使用 setRandomPosition 将每个菱形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 菱形大小\n  const size = 48;\n  const halfSize = size / 2;\n  \n  // 创建8个随机位置的粉色菱形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 定义菱形的4个顶点（相对于中心点）\n    // 菱形：上、右、下、左\n    const diamond = new Phaser.Geom.Polygon([\n      0, -halfSize,      // 上顶点\n      halfSize, 0,       // 右顶点\n      0, halfSize,       // 下顶点\n      -halfSize, 0       // 左顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(diamond.points, true);\n    \n    // 设置随机位置（考虑边界，避免菱形超出画布）\n    const randomX = Phaser.Math.Between(halfSize, config.width - halfSize);\n    const randomY = Phaser.Math.Between(halfSize, config.height - halfSize);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000167_v2", "prompt_id": "seed_000167", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：蓝色敌人从上方以 360 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，蓝色敌人从上方以360速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（绿色方块）和敌人（蓝色方块）纹理\n3. 创建玩家精灵，设置键盘控制（左右方向键）\n4. 定时生成敌人精灵，设置下落速度为360\n5. 添加碰撞检测，碰撞时游戏结束并显示文本\n6. 在 update 中处理玩家移动和敌人回收逻辑\n7. 添加分数系统，记录存活时间\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.enemySpeed = 360;\n    this.playerSpeed = 300;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每0.8秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 800,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 370, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 空格键重启\n    this.spaceKey = this.input.keyboard.addKey(\n      Phaser.Input.Keyboard.KeyCodes.SPACE\n    );\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      // 游戏结束后，按空格重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.scene.restart();\n        this.score = 0;\n        this.gameOver = false;\n      }\n      return;\n    }\n\n    // 玩家左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 更新分数（每秒增加10分）\n    this.score += delta / 100;\n    this.scoreText.setText('Score: ' + Math.floor(this.score));\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) return;\n\n    // 随机 x 位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  hitEnemy(player, enemy) {\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.enemyTimer.remove();\n\n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 玩家变红\n    player.setTint(0xff0000);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001079_v2", "prompt_id": "seed_001079", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9191666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：20 个橙色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 20个橙色小球在封闭空间内以360速度移动，碰到边界和彼此时弹性碰撞\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, Body.setBounce, Body.setCollideWorldBounds, Physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，启用世界边界\n2. 使用 Graphics 创建橙色圆形纹理\n3. 创建物理组，生成 20 个小球并设置随机速度和位置\n4. 设置小球与世界边界的碰撞反弹\n5. 设置小球之间的碰撞检测和弹性反弹\n6. 添加碰撞计数器作为可验证状态\n[/PLAN]\n\n```javascript\nclass BallBounceScene extends Phaser.Scene {\n  constructor() {\n    super('BallBounceScene');\n    this.collisionCount = 0; // 可验证状态：碰撞计数\n    this.ballCount = 20; // 可验证状态：小球数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8C00, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('orangeBall', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 生成20个小球\n    for (let i = 0; i < this.ballCount; i++) {\n      // 随机位置（避免边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      const ball = this.balls.create(x, y, 'orangeBall');\n      \n      // 设置随机方向的360速度\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 360;\n      const velocityY = Math.sin(angle) * 360;\n      \n      ball.setVelocity(velocityX, velocityY);\n      ball.setBounce(1, 1); // 完全弹性碰撞\n      ball.setCollideWorldBounds(true);\n    }\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n\n    // 添加边界可视化\n    const bounds = this.add.graphics();\n    bounds.lineStyle(2, 0xffffff, 1);\n    bounds.strokeRect(0, 0, 800, 600);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞计数\n    this.collisionCount++;\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Ball Count: ${this.ballCount}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 360 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 验证小球速度保持在360左右（考虑浮点误差）\n    this.balls.children.entries.forEach(ball => {\n      const body = ball.body;\n      const speed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n      \n      // 如果速度偏离360太多，重新归一化（处理累积误差）\n      if (Math.abs(speed - 360) > 10) {\n        const scale = 360 / speed;\n        body.velocity.x *= scale;\n        body.velocity.y *= scale;\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallBounceScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000963_v2", "prompt_id": "seed_000963", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 160 像素/秒的速度移动\nAPI: Phaser.Game, Phaser.Scene, Graphics.fillStyle, Graphics.fillPath, Input.Keyboard.addKeys, GameObject.setVelocity\nSTEPS:\n1. 创建 Scene 类，配置游戏画布和场景\n2. 在 create 中使用 Graphics 绘制菱形形状并生成纹理\n3. 创建 Sprite 对象并启用物理引擎\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态设置速度向量，实现八方向移动\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.keys = null;\n    this.speed = 160;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 绘制菱形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制菱形路径（中心点为 16,16，边长约 32）\n    const path = new Phaser.Geom.Polygon([\n      16, 0,    // 上顶点\n      32, 16,   // 右顶点\n      16, 32,   // 下顶点\n      0, 16     // 左顶点\n    ]);\n    graphics.fillPoints(path.points, true);\n    \n    // 生成纹理\n    graphics.generateTexture('diamond', 32, 32);\n    graphics.destroy();\n    \n    // 创建玩家精灵并启用物理引擎\n    this.player = this.physics.add.sprite(400, 300, 'diamond');\n    this.player.setCollideWorldBounds(true);\n    \n    // 设置 WASD 键盘输入\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n  }\n\n  update(time, delta) {\n    // 重置速度\n    let velocityX = 0;\n    let velocityY = 0;\n    \n    // 检测按键并设置速度\n    if (this.keys.w.isDown) {\n      velocityY = -this.speed;\n    } else if (this.keys.s.isDown) {\n      velocityY = this.speed;\n    }\n    \n    if (this.keys.a.isDown) {\n      velocityX = -this.speed;\n    } else if (this.keys.d.isDown) {\n      velocityX = this.speed;\n    }\n    \n    // 对角线移动时归一化速度，保持恒定速度\n    if (velocityX !== 0 && velocityY !== 0) {\n      const factor = Math.sqrt(2) / 2; // 约 0.707\n      velocityX *= factor;\n      velocityY *= factor;\n    }\n    \n    // 应用速度\n    this.player.setVelocity(velocityX, velocityY);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000377_v3", "prompt_id": "seed_000377", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9066666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 200 像素/秒速度移动\nAPI: Graphics.fillTriangle, input.keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制三角形\n2. 使用 input.keyboard.addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间更新三角形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建三角形 Graphics 对象\n  triangle = this.add.graphics();\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（以中心点为基准）\n  triangle.fillTriangle(\n    0, -20,    // 顶点\n    -17, 10,   // 左下\n    17, 10     // 右下\n  );\n  \n  // 设置初始位置在屏幕中心\n  triangle.x = 400;\n  triangle.y = 300;\n  \n  // 创建 WASD 键位绑定\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // 计算本帧应移动的距离（速度 * 时间）\n  // delta 单位是毫秒，需要转换为秒\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.W.isDown) {\n    triangle.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    triangle.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    triangle.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    triangle.x += distance; // 向右移动\n  }\n  \n  // 可选：限制三角形在屏幕范围内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000109_v3", "prompt_id": "seed_000109", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色方块以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色方块以120速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成橙色方块纹理\n3. 创建物理精灵并设置速度为120\n4. 设置世界边界碰撞和反弹系数\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet velocity = { x: 120, y: 120 };\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建橙色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8800, 1); // 橙色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('orangeSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'orangeSquare');\n  \n  // 设置初始速度\n  square.setVelocity(velocity.x, velocity.y);\n  \n  // 设置精灵在世界边界内\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数\n  square.setBounce(1, 1);\n  \n  // 确保世界边界开启\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nfunction update(time, delta) {\n  // Arcade 物理系统的 bounce 和 collideWorldBounds 会自动处理反弹\n  // 无需手动检测边界\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000372_v2", "prompt_id": "seed_000372", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 300 像素/秒速度移动\nAPI: Graphics.fillTriangle, input.keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象并应用三角形纹理\n3. 使用 addKey 监听 WASD 四个按键\n4. 在 update 中根据按键状态更新三角形位置，速度为 300 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个朝上的三角形（中心在原点）\n  graphics.fillTriangle(\n    0, -20,    // 顶点\n    -15, 20,   // 左下角\n    15, 20     // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 30, 40);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已保存\n  \n  // 创建三角形精灵，初始位置在屏幕中心\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置键盘输入\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文字\n  this.add.text(10, 10, 'Use WASD to move the triangle', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧移动距离（速度 * 时间差，delta 单位是毫秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动三角形\n  if (keys.W.isDown) {\n    triangle.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    triangle.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    triangle.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    triangle.x += distance; // 向右移动\n  }\n  \n  // 可选：限制三角形在屏幕范围内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000756_v2", "prompt_id": "seed_000756", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色椭圆，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色椭圆，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置灰色填充样式（0x808080）\n4. 使用 fillEllipse 在画布中央（400, 300）绘制椭圆，宽高约 48 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充样式\n  graphics.fillStyle(0x808080, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // 中心点：(400, 300)，宽度：48，高度：48\n  graphics.fillEllipse(400, 300, 48, 48);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000028_v1", "prompt_id": "seed_000028", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左移动的圆形对象并保持居中\nAPI: Graphics#fillCircle, Graphics#generateTexture, Physics.add.sprite, Camera#startFollow, Sprite#setVelocity\nSTEPS:\n1. 创建一个圆形纹理使用 Graphics 绘制并生成纹理\n2. 使用物理系统创建精灵对象并设置向左移动的速度\n3. 获取主相机并设置跟随该精灵对象\n4. 设置相机边界以展示跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();\n\n  // 创建一个更大的世界边界，让相机有空间跟随\n  this.physics.world.setBounds(0, 0, 3000, 600);\n\n  // 创建玩家精灵（圆形）\n  this.player = this.physics.add.sprite(1500, 300, 'circle');\n  \n  // 设置精灵向左移动\n  this.player.setVelocityX(-150);\n\n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3000, 600);\n  \n  // 让相机跟随玩家\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n\n  // 添加一些参考网格线，方便观察相机跟随效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 3000; x += 100) {\n    gridGraphics.moveTo(x, 0);\n    gridGraphics.lineTo(x, 600);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 600; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(3000, y);\n  }\n  \n  gridGraphics.strokePath();\n\n  // 添加文字提示\n  const text = this.add.text(400, 50, '相机跟随圆形对象', {\n    fontSize: '24px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 当圆形移动到世界边界左侧时，重置到右侧\n  if (this.player.x < 0) {\n    this.player.x = 3000;\n  }\n  \n  // 当圆形移动到世界边界右侧时，重置到左侧\n  if (this.player.x > 3000) {\n    this.player.x = 0;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000772_v2", "prompt_id": "seed_000772", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8742857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色星形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现橙色星形在4秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置 duration 为 4000 毫秒（4秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push(radius * Math.cos(angle));\n    starPoints.push(radius * Math.sin(angle));\n  }\n  \n  graphics.fillPoints(starPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 4000, // 4秒\n    yoyo: true, // 往返效果\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性移动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '橙色星形往返移动动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000618_v3", "prompt_id": "seed_000618", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 2.5 秒内从原始大小缩放到 48%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建使用该纹理的 Sprite 对象\n3. 使用 Tween 系统创建缩放动画，从 1 到 0.48 再回到 1\n4. 设置 Tween 循环播放（loop: -1）和持续时间 2500ms\n5. 使用 yoyo: true 实现自动恢复效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 60;\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  graphics.beginPath();\n  \n  // 绘制六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每60度一个顶点\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  const textureSize = hexRadius * 2;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  \n  // 清除 graphics 对象（已生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的 Sprite\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: hexSprite,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 2500,        // 2.5 秒\n    yoyo: true,            // 自动恢复到原始值\n    loop: -1,              // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Hexagon scaling animation (48% - 100%)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000166_v3", "prompt_id": "seed_000166", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让蓝色星形在 2 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个蓝色星形，使用 Tween 动画在 2 秒内完成 360 度旋转并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Image, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制蓝色星形并生成纹理\n2. 创建 Image 对象使用生成的星形纹理\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 2000ms，rotation 从 0 到 2π，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  const drawStar = (graphics, cx, cy, spikes, outerRadius, innerRadius, color) => {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n    \n    graphics.fillStyle(color, 1);\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n    \n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n      \n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n    \n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillPath();\n  };\n  \n  // 绘制蓝色星形（中心在 100, 100 位置，方便生成纹理）\n  drawStar(graphics, 100, 100, 5, 80, 40, 0x4169E1);\n  \n  // 生成纹理\n  graphics.generateTexture('blueStar', 200, 200);\n  \n  // 清除 graphics 对象（已经生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建星形图像对象，放置在屏幕中心\n  const star = this.add.image(400, 300, 'blueStar');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    rotation: Math.PI * 2,   // 旋转 360 度（2π 弧度）\n    duration: 2000,          // 持续时间 2 秒\n    ease: 'Linear',          // 线性缓动，匀速旋转\n    repeat: -1,              // 无限循环（-1 表示永久重复）\n    yoyo: false              // 不回放，直接循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '蓝色星形旋转动画 - 2秒一圈', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000733_v2", "prompt_id": "seed_000733", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色圆形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现绿色圆形左右往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建 x 坐标补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('greenCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象，初始位置在左侧\n  const circle = this.add.sprite(100, 300, 'greenCircle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 1000, // 持续时间 1 秒\n    yoyo: true, // 启用往返效果（到达目标后反向播放）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000515_v1", "prompt_id": "seed_000515", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色星形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色星形以160速度移动并在画布边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, setVelocity, setBounce, setCollideWorldBounds\nSTEPS:\n1. 创建物理系统配置，启用 Arcade Physics\n2. 使用 Graphics 绘制紫色星形并生成纹理\n3. 创建物理精灵，设置初始速度为160\n4. 设置精灵与世界边界碰撞并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  \n  // 绘制星形（中心点在 50, 50，半径为 40）\n  graphics.fillStar(50, 50, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（160像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 160);\n  star.setVelocity(velocity.x, velocity.y);\n  \n  // 设置与世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  star.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000062_v3", "prompt_id": "seed_000062", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按鼠标左键发射子弹，速度 80，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现鼠标点击发射子弹射击敌人，命中后敌人消失并显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Pointer, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家飞船、敌人组、子弹组，使用 Graphics 绘制纹理\n2. 监听鼠标点击事件，从玩家位置发射子弹（速度 80）\n3. 设置子弹与敌人的碰撞检测，命中时销毁双方并增加击杀数\n4. 显示击杀数文本，并在击杀时更新\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillTriangle(0, -20, -15, 15, 15, 15);\n    playerGraphics.generateTexture('player', 30, 35);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillRect(0, 0, 4, 10);\n    bulletGraphics.generateTexture('bullet', 4, 10);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 20\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 生成初始敌人\n    this.spawnEnemies();\n\n    // 监听鼠标点击事件\n    this.input.on('pointerdown', (pointer) => {\n      this.shootBullet();\n    });\n\n    // 设置子弹与敌人的碰撞检测\n    this.physics.add.collider(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数文本\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.killText.setDepth(100);\n\n    // 添加键盘控制（可选，方便移动玩家）\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的子弹\n    this.bullets.children.entries.forEach((bullet) => {\n      if (bullet.active && bullet.y < -10) {\n        bullet.setActive(false);\n        bullet.setVisible(false);\n      }\n    });\n\n    // 敌人简单移动\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.active) {\n        enemy.y += 1; // 缓慢向下移动\n        if (enemy.y > 650) {\n          enemy.destroy();\n        }\n      }\n    });\n\n    // 定期生成新敌人\n    if (time % 2000 < delta) {\n      this.spawnEnemy();\n    }\n  }\n\n  shootBullet() {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y - 20);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.body.enable = true;\n      \n      // 设置子弹速度为 80（向上）\n      bullet.setVelocityY(-80);\n      \n      // 设置子弹边界\n      bullet.setCollideWorldBounds(false);\n    }\n  }\n\n  spawnEnemies() {\n    // 初始生成 5 个敌人\n    for (let i = 0; i < 5; i++) {\n      this.spawnEnemy();\n    }\n  }\n\n  spawnEnemy() {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 200);\n    const enemy = this.enemies.create(x, y, 'enemy');\n    enemy.setVelocity(\n      Phaser.Math.Between(-50, 50),\n      Phaser.Math.Between(20, 50)\n    );\n    enemy.setBounce(1);\n    enemy.setCollideWorldBounds(true);\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹命中敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.body.enable = false;\n    \n    enemy.destroy();\n    \n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n    \n    // 生成新敌人保持数量\n    this.spawnEnemy();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001211_v3", "prompt_id": "seed_001211", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕上显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕上显示 \"Hello Phaser\" 文字，字体大小 64px\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 64px\n4. 将文本定位到屏幕中心位置\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕中心创建文本对象\n  const text = this.add.text(\n    400,  // x 坐标\n    300,  // y 坐标\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '64px',  // 字体大小\n      color: '#ffffff',  // 文字颜色（白色）\n      fontFamily: 'Arial'  // 字体族\n    }\n  );\n  \n  // 设置文本的原点为中心，使其居中显示\n  text.setOrigin(0.5, 0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000271_v3", "prompt_id": "seed_000271", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个星形在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个使用该纹理的精灵对象，初始透明度设为 0\n3. 使用 Tween 动画让精灵的 alpha 属性在 1 秒内从 0 渐变到 1\n4. 设置 Tween 为循环模式（yoyo + repeat: -1）实现往复循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色星形\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'star');\n  star.alpha = 0; // 初始设置为完全透明\n  \n  // 创建渐变动画 Tween\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    alpha: 1,                // 目标透明度为 1（完全不透明）\n    duration: 1000,          // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',          // 线性缓动\n    yoyo: true,              // 往复播放（透明->不透明->透明）\n    repeat: -1               // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000258_v2", "prompt_id": "seed_000258", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的蓝色方块，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的蓝色方块，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环创建 3 个 Graphics 对象\n3. 为每个 Graphics 对象设置蓝色填充样式并绘制 32x32 的矩形\n4. 使用 setRandomPosition 方法将每个方块放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建3个蓝色方块\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置蓝色填充样式 (RGB: 0x0000ff)\n    graphics.fillStyle(0x0000ff, 1);\n    \n    // 绘制 32x32 的矩形，以左上角为原点\n    graphics.fillRect(0, 0, 32, 32);\n    \n    // 设置随机位置\n    // 确保方块完全在画布内（考虑32像素的宽高）\n    const randomX = Phaser.Math.Between(0, config.width - 32);\n    const randomY = Phaser.Math.Between(0, config.height - 32);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000614_v3", "prompt_id": "seed_000614", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的粉色圆形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的粉色圆形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 设置粉色填充样式（0xff69b4）\n4. 使用 fillCircle 绘制半径为8的圆形（直径16像素）\n5. 使用 setRandomPosition 将圆形随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建8个粉色圆形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式（#ff69b4）\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 绘制圆形，半径为8（直径16像素）\n    // 圆心在 (0, 0)，后续通过 setRandomPosition 移动整个 Graphics 对象\n    graphics.fillCircle(0, 0, 8);\n    \n    // 随机设置位置\n    // 考虑圆形半径，确保圆形完全在画布内\n    graphics.setRandomPosition(8, 8, 800 - 16, 600 - 16);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000134_v3", "prompt_id": "seed_000134", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色方块左右往返循环移动的补间动画\nAPI: this.add.graphics(), graphics.generateTexture(), this.add.image(), this.tweens.add(), Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制白色方块并生成纹理\n2. 创建 Image 对象显示方块\n3. 使用 tweens.add() 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo: true 实现往返效果\n5. 配置 loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建方块图像，初始位置在左侧\n  const square = this.add.image(100, 300, 'whiteSquare');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 2000,            // 持续时间 2 秒\n    yoyo: true,                // 启用往返效果（到达目标后反向播放）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动函数，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'White Square Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'The square moves left-right in a loop', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000737_v2", "prompt_id": "seed_000737", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现蓝色血条 UI：显示 3 格生命值，按方向键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现蓝色血条 UI，显示 3 格生命值，按方向键扣血，血量为 0 时显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 类，初始化生命值为 3\n2. 在 create 中使用 Graphics 绘制 3 个蓝色血条方块\n3. 监听键盘方向键输入事件，每次按下扣除 1 点生命值\n4. 根据当前生命值动态更新血条显示（隐藏对应的血条方块）\n5. 当生命值为 0 时显示 \"Game Over\" 文本并停止输入响应\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 3; // 可验证的状态信号\n    this.maxHealth = 3;\n    this.healthBars = [];\n    this.gameOver = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, 'Press Arrow Keys to Take Damage', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器位置\n    const startX = 250;\n    const startY = 200;\n    const barWidth = 80;\n    const barHeight = 30;\n    const barSpacing = 20;\n\n    // 绘制 3 个蓝色血条\n    for (let i = 0; i < this.maxHealth; i++) {\n      const graphics = this.add.graphics();\n      \n      // 绘制边框\n      graphics.lineStyle(3, 0x4444ff, 1);\n      graphics.strokeRect(\n        startX + i * (barWidth + barSpacing),\n        startY,\n        barWidth,\n        barHeight\n      );\n      \n      // 填充蓝色\n      graphics.fillStyle(0x0088ff, 1);\n      graphics.fillRect(\n        startX + i * (barWidth + barSpacing) + 3,\n        startY + 3,\n        barWidth - 6,\n        barHeight - 6\n      );\n      \n      this.healthBars.push(graphics);\n    }\n\n    // 创建生命值文本显示\n    this.healthText = this.add.text(400, 260, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 350, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setVisible(false);\n\n    // 监听方向键\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加键盘事件监听（防止连续按键）\n    this.input.keyboard.on('keydown', (event) => {\n      if (this.gameOver) return;\n      \n      // 检查是否是方向键\n      if (event.code === 'ArrowUp' || \n          event.code === 'ArrowDown' || \n          event.code === 'ArrowLeft' || \n          event.code === 'ArrowRight') {\n        this.takeDamage();\n      }\n    });\n\n    // 显示当前状态信息\n    this.add.text(10, 10, 'Status: Playing', {\n      fontSize: '16px',\n      color: '#ffffff'\n    });\n  }\n\n  takeDamage() {\n    if (this.health > 0) {\n      this.health--;\n      \n      // 隐藏对应的血条（从右往左消失）\n      if (this.health < this.maxHealth) {\n        this.healthBars[this.health].setVisible(false);\n      }\n      \n      // 更新生命值文本\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n      \n      // 根据生命值改变文本颜色\n      if (this.health === 2) {\n        this.healthText.setColor('#ffff00'); // 黄色\n      } else if (this.health === 1) {\n        this.healthText.setColor('#ff8800'); // 橙色\n      } else if (this.health === 0) {\n        this.healthText.setColor('#ff0000'); // 红色\n        this.showGameOver();\n      }\n    }\n  }\n\n  showGameOver() {\n    this.gameOver = true;\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n    \n    // 显示重启提示\n    this.add.text(400, 450, 'Refresh to Restart', {\n      fontSize: '20px',\n      color: '#888888'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: HealthBarScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001097_v2", "prompt_id": "seed_001097", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在2秒内缩放到24%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制一个圆形\n2. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.24\n3. 设置 yoyo 为 true 实现往返效果，duration 为 2000ms\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制圆形：圆心在 (0, 0)，半径为 50\n  graphics.fillCircle(0, 0, 50);\n  \n  // 将 graphics 对象定位到屏幕中心\n  graphics.setPosition(400, 300);\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    scaleX: 0.24,               // X 轴缩放到 24%\n    scaleY: 0.24,               // Y 轴缩放到 24%\n    duration: 2000,             // 动画持续时间 2 秒\n    yoyo: true,                 // 动画结束后反向播放（恢复原始大小）\n    repeat: -1,                 // 无限循环 (-1 表示永久重复)\n    ease: 'Linear'              // 线性缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Circle Scale Animation (24% - 100%)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000174_v2", "prompt_id": "seed_000174", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色椭圆，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色椭圆，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布宽高为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为橙色（0xFFA500）\n4. 使用 fillEllipse 在画布中央（400, 300）绘制椭圆，宽高均为 80 像素\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 在画布中央绘制橙色椭圆\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为橙色\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  graphics.fillEllipse(400, 300, 80, 80);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000102_v3", "prompt_id": "seed_000102", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个敌人同时追踪玩家，敌人速度 200，玩家需躲避。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 20个敌人以速度200追踪玩家，玩家需躲避\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Phaser.Math.Angle.Between\nSTEPS:\n1. 创建物理系统配置，初始化 arcade 物理引擎\n2. 使用 Graphics 生成玩家和敌人的纹理（不同颜色区分）\n3. 创建玩家精灵，设置键盘控制（WASD/方向键）\n4. 创建 20 个敌人的物理组，设置初始随机位置\n5. 在 update 中让每个敌人计算朝向玩家的角度并移动\n6. 添加碰撞检测，碰到敌人减少生命值\n7. 显示生命值和存活时间作为状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet enemies;\nlet cursors;\nlet wasd;\nlet health = 100;\nlet survivalTime = 0;\nlet healthText;\nlet timeText;\nlet gameOver = false;\nlet lastHitTime = 0;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00aaff, 1);\n  playerGraphics.fillCircle(16, 16, 16);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建敌人纹理（红色方块）\n  const enemyGraphics = this.add.graphics();\n  enemyGraphics.fillStyle(0xff0000, 1);\n  enemyGraphics.fillCircle(12, 12, 12);\n  enemyGraphics.generateTexture('enemy', 24, 24);\n  enemyGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setDrag(500);\n  player.setMaxVelocity(300);\n\n  // 创建敌人组\n  enemies = this.physics.add.group({\n    key: 'enemy',\n    repeat: 19, // 创建20个敌人\n    setXY: {\n      x: Phaser.Math.Between(50, 750),\n      y: Phaser.Math.Between(50, 550),\n      stepX: 0,\n      stepY: 0\n    }\n  });\n\n  // 随机分散敌人位置\n  enemies.children.iterate((enemy) => {\n    enemy.setPosition(\n      Phaser.Math.Between(50, 750),\n      Phaser.Math.Between(50, 550)\n    );\n    enemy.setCollideWorldBounds(true);\n    enemy.setBounce(0.5);\n  });\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, enemies, hitEnemy, null, this);\n\n  // 键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n  wasd = this.input.keyboard.addKeys({\n    up: Phaser.Input.Keyboard.KeyCodes.W,\n    down: Phaser.Input.Keyboard.KeyCodes.S,\n    left: Phaser.Input.Keyboard.KeyCodes.A,\n    right: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // UI 文本\n  healthText = this.add.text(16, 16, 'Health: 100', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  timeText = this.add.text(16, 50, 'Time: 0s', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(400, 16, 'Use Arrow Keys or WASD to move. Avoid the red enemies!', {\n    fontSize: '16px',\n    fill: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setOrigin(0.5, 0);\n}\n\nfunction update(time, delta) {\n  if (gameOver) {\n    return;\n  }\n\n  // 更新存活时间\n  survivalTime += delta / 1000;\n  timeText.setText('Time: ' + survivalTime.toFixed(1) + 's');\n\n  // 玩家移动控制\n  const acceleration = 600;\n\n  if (cursors.left.isDown || wasd.left.isDown) {\n    player.setAccelerationX(-acceleration);\n  } else if (cursors.right.isDown || wasd.right.isDown) {\n    player.setAccelerationX(acceleration);\n  } else {\n    player.setAccelerationX(0);\n  }\n\n  if (cursors.up.isDown || wasd.up.isDown) {\n    player.setAccelerationY(-acceleration);\n  } else if (cursors.down.isDown || wasd.down.isDown) {\n    player.setAccelerationY(acceleration);\n  } else {\n    player.setAccelerationY(0);\n  }\n\n  // 敌人追踪玩家\n  enemies.children.iterate((enemy) => {\n    if (enemy.active) {\n      // 计算敌人到玩家的角度\n      const angle = Phaser.Math.Angle.Between(\n        enemy.x,\n        enemy.y,\n        player.x,\n        player.y\n      );\n\n      // 设置敌人速度，朝向玩家移动\n      const speed = 200;\n      enemy.setVelocity(\n        Math.cos(angle) * speed,\n        Math.sin(angle) * speed\n      );\n\n      // 旋转敌人朝向玩家\n      enemy.rotation = angle;\n    }\n  });\n\n  // 检查游戏结束\n  if (health <= 0 && !gameOver) {\n    gameOver = true;\n    player.setTint(0x888888);\n    player.setVelocity(0, 0);\n    player.setAcceleration(0, 0);\n\n    enemies.children.iterate((enemy) => {\n      enemy.setVelocity(0, 0);\n    });\n\n    const gameOverText = this.add.text(400, 300, 'GAME OVER\\nSurvived: ' + survivalTime.toFixed(1) + 's', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 },\n      align: 'center'\n    });\n    gameOverText.setOrigin(0.5);\n  }\n}\n\nfunction hitEnemy(player, enemy) {\n  const currentTime = Date.now();\n  \n  // 添加无敌时间（0.5秒），避免连续扣血\n  if (currentTime - lastHitTime > 500) {\n    health -= 10;\n    lastHitTime = currentTime;\n\n    // 更新生命值显示\n    healthText.setText('Health: ' + Math.max(0, health));\n\n    // 玩家受击闪烁效果\n    player.setTint(0xff0000);\n    player.scene.time.delayedCall(100, () => {\n      if (!gameOver) {\n        player.clearTint();\n      }\n    });\n\n    // 击退效果\n    const angle = Phaser.Math.Angle.Between(\n      enemy.x,\n      enemy.y,\n      player.x,\n      player.y\n    );\n    player.setVelocity(\n      Math.cos(angle) * 400,\n      Math.sin(angle) * 400\n    );\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000942_v2", "prompt_id": "seed_000942", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9400000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 2 秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点为 64, 64，边长约 100）\n  graphics.beginPath();\n  graphics.moveTo(64, 14);      // 上顶点\n  graphics.lineTo(114, 64);     // 右顶点\n  graphics.lineTo(64, 114);     // 下顶点\n  graphics.lineTo(14, 64);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建菱形精灵并放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建渐变动画：从透明到不透明，持续 2 秒，循环播放\n  this.tweens.add({\n    targets: diamond,           // 目标对象\n    alpha: 1,                   // 目标透明度（完全不透明）\n    duration: 2000,             // 持续时间 2 秒\n    ease: 'Linear',             // 线性渐变\n    yoyo: true,                 // 来回播放（透明->不透明->透明）\n    repeat: -1                  // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000388_v3", "prompt_id": "seed_000388", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的黄色菱形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的黄色菱形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景大小为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 使用 Graphics API 绘制菱形路径（4个顶点连接成菱形）\n4. 为每个菱形设置随机位置（确保在画布范围内）\n5. 使用黄色填充菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建20个随机位置的黄色菱形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置黄色填充\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制菱形（32像素大小，即从中心到边缘16像素）\n    graphics.beginPath();\n    graphics.moveTo(0, -16);    // 上顶点\n    graphics.lineTo(16, 0);     // 右顶点\n    graphics.lineTo(0, 16);     // 下顶点\n    graphics.lineTo(-16, 0);    // 左顶点\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（留出边距避免菱形超出画布）\n    const randomX = Phaser.Math.Between(32, 768);\n    const randomY = Phaser.Math.Between(32, 568);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000529_v3", "prompt_id": "seed_000529", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色星形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央使用 Graphics 绘制一个白色星形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个外顶点和 5 个内顶点坐标（基于中心点和半径）\n4. 使用 beginPath、moveTo、lineTo 依次连接顶点绘制星形路径\n5. 使用白色填充星形并渲染到画布中央\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 星形参数\n  const outerRadius = 48; // 外半径\n  const innerRadius = 20; // 内半径\n  const points = 5; // 五角星\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算星形的顶点坐标并绘制\n  for (let i = 0; i < points * 2; i++) {\n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算角度（从顶部开始，顺时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其余使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充星形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000155_v1", "prompt_id": "seed_000155", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 160，重力 400。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色双跳功能，跳跃力度160，重力400\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.addKey, body.setVelocityY, this.add.graphics\nSTEPS:\n1. 创建物理世界，设置重力为400\n2. 使用Graphics生成角色和地面纹理\n3. 创建角色精灵，添加物理属性和碰撞\n4. 监听空格键输入，实现双跳逻辑（记录跳跃次数）\n5. 在update中检测角色着地状态，重置跳跃次数\n6. 添加跳跃次数显示文本作为状态验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.jumpCount = 0; // 当前已跳跃次数\n    this.maxJumps = 2; // 最大跳跃次数\n    this.jumpVelocity = -160; // 跳跃力度\n  }\n\n  preload() {\n    // 使用Graphics生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建角色纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建地面\n    this.ground = this.physics.add.sprite(400, 575, 'ground');\n    this.ground.setImmovable(true);\n    this.ground.body.allowGravity = false;\n\n    // 创建角色\n    this.player = this.physics.add.sprite(100, 400, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground, () => {\n      // 角色着地时重置跳跃次数\n      if (this.player.body.touching.down) {\n        this.jumpCount = 0;\n      }\n    });\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加操作提示\n    this.add.text(16, 550, 'Press SPACE to jump (Double Jump Available)', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#87ceeb');\n  }\n\n  update(time, delta) {\n    // 更新状态显示\n    const onGround = this.player.body.touching.down;\n    this.statusText.setText([\n      `Jump Count: ${this.jumpCount}/${this.maxJumps}`,\n      `On Ground: ${onGround}`,\n      `Velocity Y: ${Math.round(this.player.body.velocity.y)}`,\n      `Position Y: ${Math.round(this.player.y)}`\n    ]);\n\n    // 检测角色是否在地面上\n    if (this.player.body.touching.down) {\n      this.jumpCount = 0;\n    }\n\n    // 处理跳跃输入\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      // 检查是否可以跳跃\n      if (this.jumpCount < this.maxJumps) {\n        this.player.setVelocityY(this.jumpVelocity);\n        this.jumpCount++;\n        \n        // 视觉反馈：跳跃时改变颜色\n        if (this.jumpCount === 1) {\n          this.player.setTint(0xffff00); // 第一次跳跃：黄色\n        } else if (this.jumpCount === 2) {\n          this.player.setTint(0xff00ff); // 第二次跳跃：紫色\n        }\n      }\n    }\n\n    // 恢复原色（当在地面上时）\n    if (this.player.body.touching.down) {\n      this.player.clearTint();\n    }\n\n    // 简单的左右移动控制\n    const cursors = this.input.keyboard.createCursorKeys();\n    if (cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001197_v3", "prompt_id": "seed_001197", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.865}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1.5秒内缩放到64%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 实现缩放动画（scale: 1 -> 0.64 -> 1）\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 50;\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  graphics.beginPath();\n  \n  // 绘制六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy();\n  \n  // 创建六边形精灵，放置在屏幕中央\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 从原始大小(1)缩放到64%(0.64)，然后恢复到原始大小(1)\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 1500, // 1.5秒缩小到64%\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '六边形缩放动画 (1.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000304_v1", "prompt_id": "seed_000304", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色矩形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色矩形在4秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制蓝色矩形并生成纹理\n2. 创建精灵对象放置在左侧起始位置\n3. 使用 tweens.add() 创建补间动画，设置4秒duration，yoyo往返，repeat无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建蓝色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1);\n  graphics.fillRect(0, 0, 60, 60);\n  graphics.generateTexture('blueRect', 60, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建蓝色矩形精灵，初始位置在左侧\n  const rectangle = this.add.sprite(100, 300, 'blueRect');\n  \n  // 创建补间动画：4秒从左移到右，yoyo往返，无限循环\n  this.tweens.add({\n    targets: rectangle,\n    x: 700,                    // 目标位置（右侧）\n    duration: 4000,            // 4秒完成单程\n    ease: 'Linear',            // 线性移动\n    yoyo: true,                // 往返效果\n    repeat: -1                 // 无限循环（-1表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Blue rectangle moving left-right (4s loop)', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000186_v3", "prompt_id": "seed_000186", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中循环12次\n3. 每次循环创建一个 Graphics 对象\n4. 使用三角函数计算六边形的6个顶点坐标（半径8像素）\n5. 使用 beginPath/lineTo/closePath/fillPath 绘制填充的六边形\n6. 使用 Math.random 为每个六边形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制12个随机位置的绿色六边形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置绿色填充\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 六边形参数\n    const radius = 8; // 半径8像素，直径16像素\n    const sides = 6;\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    for (let j = 0; j < sides; j++) {\n      const angle = (Math.PI * 2 / sides) * j - Math.PI / 2; // 从顶部开始\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（确保六边形完全在画布内）\n    const randomX = radius + Math.random() * (800 - radius * 2);\n    const randomY = radius + Math.random() * (600 - radius * 2);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000331_v3", "prompt_id": "seed_000331", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 创建一个方块形状\n2. 将方块的旋转中心设置为中心点\n3. 在 update 方法中根据 delta 时间累加旋转角度（300度/秒 = 300 * (Math.PI/180) 弧度/秒）\n4. 应用旋转角度到方块的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nconst rotationSpeed = 300; // 度/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建一个 Graphics 对象绘制方块\n  square = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  square.fillStyle(0x3498db, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在 (0, 0)\n  // 这样旋转时会围绕中心旋转\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 将方块放置在画布中心\n  square.x = 400;\n  square.y = 300;\n}\n\nfunction update(time, delta) {\n  // 将旋转速度从度/秒转换为弧度/秒\n  const rotationSpeedRad = Phaser.Math.DegToRad(rotationSpeed);\n  \n  // 根据 delta 时间（毫秒）计算本帧应旋转的角度\n  // delta 是毫秒，需要除以 1000 转换为秒\n  const rotationThisFrame = rotationSpeedRad * (delta / 1000);\n  \n  // 累加旋转角度\n  square.rotation += rotationThisFrame;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000405_v3", "prompt_id": "seed_000405", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按WASD键发射子弹，速度 200，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现WASD键发射子弹击杀敌人并显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.Physics.Arcade.World#overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家精灵，使用Graphics绘制，添加物理属性\n2. 创建敌人组和子弹组，使用Arcade物理系统\n3. 监听WASD键盘输入，按键时从玩家位置发射对应方向的子弹\n4. 设置子弹与敌人的碰撞检测，命中时销毁敌人和子弹\n5. 使用Text显示击杀数，碰撞时更新计数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 生成初始敌人\n    this.spawnEnemies(5);\n\n    // 设置键盘输入\n    this.keys = {\n      W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n      A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n      S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n      D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n    };\n\n    // 防止连续发射的冷却时间\n    this.lastFireTime = 0;\n    this.fireDelay = 200; // 200ms冷却\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数文本\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.killText.setScrollFactor(0);\n    this.killText.setDepth(100);\n\n    // 添加提示文本\n    this.add.text(16, 50, 'Press WASD to shoot', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n  }\n\n  update(time, delta) {\n    const currentTime = time;\n\n    // 检测WASD键发射子弹\n    if (currentTime - this.lastFireTime > this.fireDelay) {\n      if (this.keys.W.isDown) {\n        this.shootBullet(0, -1); // 向上\n        this.lastFireTime = currentTime;\n      } else if (this.keys.S.isDown) {\n        this.shootBullet(0, 1); // 向下\n        this.lastFireTime = currentTime;\n      } else if (this.keys.A.isDown) {\n        this.shootBullet(-1, 0); // 向左\n        this.lastFireTime = currentTime;\n      } else if (this.keys.D.isDown) {\n        this.shootBullet(1, 0); // 向右\n        this.lastFireTime = currentTime;\n      }\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        const bounds = this.physics.world.bounds;\n        if (bullet.x < bounds.x || bullet.x > bounds.right ||\n            bullet.y < bounds.y || bullet.y > bounds.bottom) {\n          bullet.destroy();\n        }\n      }\n    });\n\n    // 当敌人数量少于3个时补充\n    if (this.enemies.countActive(true) < 3) {\n      this.spawnEnemies(2);\n    }\n  }\n\n  shootBullet(dirX, dirY) {\n    // 从玩家位置创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y, 'bullet');\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹速度为200\n      bullet.body.velocity.x = dirX * 200;\n      bullet.body.velocity.y = dirY * 200;\n      \n      // 设置子弹不受世界边界限制\n      bullet.setCollideWorldBounds(false);\n    }\n  }\n\n  spawnEnemies(count) {\n    for (let i = 0; i < count; i++) {\n      // 随机位置生成敌人，避免与玩家重叠\n      let x, y;\n      do {\n        x = Phaser.Math.Between(50, 750);\n        y = Phaser.Math.Between(50, 550);\n      } while (Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y) < 100);\n\n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(1);\n      \n      // 给敌人随机速度\n      enemy.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹命中敌人\n    bullet.destroy();\n    enemy.destroy();\n    \n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n    \n    // 可选：添加视觉反馈\n    const explosion = this.add.circle(enemy.x, enemy.y, 20, 0xffffff, 0.8);\n    this.tweens.add({\n      targets: explosion,\n      alpha: 0,\n      scale: 2,\n      duration: 300,\n      onComplete: () => explosion.destroy()\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000809_v2", "prompt_id": "seed_000809", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色矩形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个24像素的绿色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充样式为绿色（0x00ff00）\n4. 计算画布中心位置，绘制 24x24 的矩形，使其中心对齐画布中心\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算矩形左上角坐标，使其中心位于画布中央\n  // 画布中心: (400, 300)\n  // 矩形大小: 24x24\n  // 左上角坐标: (400 - 12, 300 - 12) = (388, 288)\n  const rectSize = 24;\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000125_v3", "prompt_id": "seed_000125", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制矩形\n2. 将矩形的原点设置为中心点以便旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度\n4. 将角度转换为弧度并应用到 Graphics 的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制矩形，以中心点为原点\n  // 矩形宽 150，高 100，原点在中心 (-75, -50)\n  graphics.fillRect(-75, -50, 150, 100);\n  \n  // 将 Graphics 对象定位到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 中以便在 update 中访问\n  this.rotatingRect = graphics;\n  \n  // 初始化旋转速度（度/秒）\n  this.rotationSpeed = 160;\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，需要转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 计算本帧应旋转的角度（度）\n  const rotationDegrees = this.rotationSpeed * deltaInSeconds;\n  \n  // 将角度转换为弧度并累加到当前旋转值\n  // Phaser 使用弧度制，1度 = Math.PI / 180 弧度\n  this.rotatingRect.rotation += Phaser.Math.DegToRad(rotationDegrees);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000752_v1", "prompt_id": "seed_000752", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制一个三角形以 160 像素/秒的速度移动\nAPI: Phaser.Game, Phaser.Scene, Graphics.fillTriangle, input.keyboard.addKey, KeyCodes.W/A/S/D\nSTEPS:\n1. 创建 Game 配置和 Scene，设置画布尺寸\n2. 在 create 中使用 Graphics 绘制三角形并生成纹理\n3. 创建 Sprite 使用生成的三角形纹理\n4. 使用 addKey 监听 WASD 键盘输入\n5. 在 update 中根据按键状态更新三角形位置，速度为 160 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向上方的三角形\n  graphics.fillTriangle(\n    0, -20,    // 顶点（上）\n    -15, 20,   // 左下角\n    15, 20     // 右下角\n  );\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('triangleTex', 30, 40);\n  graphics.destroy(); // 销毁 Graphics 对象，只保留纹理\n  \n  // 创建三角形精灵，放置在屏幕中央\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置键盘输入\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // 计算实际移动距离（速度 * 时间差）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 WASD 按键状态并更新速度\n  if (keyW.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keyS.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keyA.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keyD.isDown) {\n    velocityX = 1; // 向右\n  }\n  \n  // 如果同时按下多个方向键，进行归一化处理以保持恒定速度\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新三角形位置\n  triangle.x += velocityX * distance;\n  triangle.y += velocityY * distance;\n  \n  // 限制三角形在画布范围内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000158_v1", "prompt_id": "seed_000158", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色矩形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色矩形以240速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制黄色矩形并生成纹理\n3. 创建物理精灵并设置初始速度为240\n4. 启用世界边界碰撞和精灵边界反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nlet rectangle;\nconst SPEED = 240;\n\nfunction preload() {\n  // 使用 Graphics 创建黄色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 50, 30);\n  graphics.generateTexture('yellowRect', 50, 30);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  rectangle = this.physics.add.sprite(400, 300, 'yellowRect');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * SPEED;\n  const velocityY = Math.sin(angle * Math.PI / 180) * SPEED;\n  rectangle.setVelocity(velocityX, velocityY);\n  \n  // 启用与世界边界的碰撞\n  rectangle.setCollideWorldBounds(true);\n  \n  // 启用边界反弹\n  rectangle.setBounce(1, 1);\n  \n  // 设置世界边界\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（防止速度衰减）\n  const velocity = rectangle.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed > 0) {\n    const scale = SPEED / currentSpeed;\n    rectangle.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000528_v2", "prompt_id": "seed_000528", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 120 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建精灵对象使用生成的三角形纹理\n3. 使用 this.input.keyboard.addKey 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新精灵位置，速度为 120 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向上方的三角形\n  graphics.beginPath();\n  graphics.moveTo(0, -20);  // 顶点\n  graphics.lineTo(-15, 20);  // 左下角\n  graphics.lineTo(15, 20);   // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 30, 40);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中央\n  triangle = this.add.sprite(400, 300, 'triangleTexture');\n  \n  // 设置键盘输入\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // 计算每帧应移动的距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 根据按键状态设置速度方向\n  if (keyW.isDown) {\n    velocityY = -1;\n  }\n  if (keyS.isDown) {\n    velocityY = 1;\n  }\n  if (keyA.isDown) {\n    velocityX = -1;\n  }\n  if (keyD.isDown) {\n    velocityX = 1;\n  }\n  \n  // 归一化对角线移动（避免对角线速度过快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新三角形位置\n  triangle.x += velocityX * distance;\n  triangle.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000255_v1", "prompt_id": "seed_000255", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色椭圆以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色椭圆以120速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建启用 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制紫色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为120\n4. 启用世界边界碰撞和精灵边界反弹\n5. 在 update 中保持速度恒定（可选优化）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建紫色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillEllipse(40, 30, 80, 60); // 椭圆：中心(40,30)，宽80，高60\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  this.ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（120像素/秒，方向为右下45度）\n  const speed = 120;\n  const angle = Phaser.Math.DegToRad(45);\n  this.ellipse.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 启用世界边界碰撞\n  this.ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  this.ellipse.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（修正物理引擎可能的速度衰减）\n  const velocity = this.ellipse.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - 120) > 0.1) {\n    const scale = 120 / currentSpeed;\n    this.ellipse.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000212_v2", "prompt_id": "seed_000212", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右上显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右上角显示 \"Hello Phaser\" 文字，字体大小 16px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建基础 Game 配置，设置画布尺寸\n2. 在 create 方法中使用 add.text 创建文字对象\n3. 设置文字位置为右上角（靠近画布右上边界）\n4. 设置字体大小为 16px，并调整对齐方式\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文字对象，位置设置在右上角\n  // x: 780 (距离右边界 20px)\n  // y: 20 (距离上边界 20px)\n  const text = this.add.text(780, 20, 'Hello Phaser', {\n    fontSize: '16px',\n    fontFamily: 'Arial',\n    color: '#ffffff'\n  });\n  \n  // 设置原点为右上角 (1, 0)，使文字右对齐\n  // 这样文字会从设定的坐标点向左延伸，确保不会超出画布边界\n  text.setOrigin(1, 0);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000490_v1", "prompt_id": "seed_000490", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 Tween 动画实现缩放效果：从 1 缩放到 0.16，然后恢复到 1\n4. 设置 Tween 的 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(50, 50, 50); // 半径为 50 的圆形\n  graphics.generateTexture('circleTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建圆形精灵并放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circleTexture');\n\n  // 创建缩放动画\n  // 从原始大小 (scale: 1) 缩放到 16% (scale: 0.16)\n  // duration: 1500ms (1.5秒)\n  // yoyo: true 表示动画完成后反向播放（恢复到原始大小）\n  // loop: -1 表示无限循环\n  // ease: 'Sine.easeInOut' 使动画更流畅\n  this.tweens.add({\n    targets: circle,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 1500,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut'\n  });\n\n  // 添加文本说明\n  this.add.text(400, 50, 'Circle Scale Animation\\n(1.0 → 0.16 → 1.0)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000577_v2", "prompt_id": "seed_000577", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让青色椭圆在 2 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色椭圆在2秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 使用 Graphics 或 Ellipse 创建青色椭圆对象\n2. 使用 Tweens 创建 y 轴方向的弹跳动画\n3. 设置 ease 为 'Bounce.easeOut' 实现弹跳效果\n4. 配置动画循环播放，持续时间 2 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建青色椭圆\n  const ellipse = this.add.ellipse(400, 300, 120, 80, 0x00ffff);\n  \n  // 记录初始位置\n  const startY = 300;\n  const bounceHeight = 200; // 弹跳高度\n  \n  // 创建弹跳动画\n  this.tweens.add({\n    targets: ellipse,\n    y: startY - bounceHeight, // 向上弹跳\n    duration: 1000, // 上升时间 1 秒\n    ease: 'Quad.easeOut', // 上升时减速\n    yoyo: true, // 返回原位置\n    yoyoEase: 'Bounce.easeOut', // 下落时弹跳效果\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加地面参考线（可选，用于视觉参考）\n  const ground = this.add.graphics();\n  ground.lineStyle(2, 0xffffff, 0.3);\n  ground.lineBetween(200, startY + 40, 600, startY + 40);\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, 'Bouncing Ellipse', {\n    fontSize: '32px',\n    color: '#00ffff',\n    fontFamily: 'Arial'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000313_v1", "prompt_id": "seed_000313", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色六边形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色六边形以360速度移动并在边界反弹\nAPI: Graphics, Polygon, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色六边形并生成纹理\n3. 创建物理精灵并应用六边形纹理\n4. 设置初始速度为360（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  \n  // 计算六边形顶点（半径40）\n  const radius = 40;\n  const hexagonPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    hexagonPoints.push({\n      x: radius + Math.cos(angle) * radius,\n      y: radius + Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制六边形\n  graphics.beginPath();\n  graphics.moveTo(hexagonPoints[0].x, hexagonPoints[0].y);\n  for (let i = 1; i < hexagonPoints.length; i++) {\n    graphics.lineTo(hexagonPoints[i].x, hexagonPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', radius * 2, radius * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置圆形碰撞体（更接近六边形的碰撞效果）\n  hexagon.setCircle(radius * 0.9);\n  \n  // 计算随机方向的速度（速度大小为360）\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const velocityX = Math.cos(angle) * 360;\n  const velocityY = Math.sin(angle) * 360;\n  \n  // 设置初始速度\n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 可选：添加一些视觉效果（旋转）\n  this.tweens.add({\n    targets: hexagon,\n    angle: 360,\n    duration: 2000,\n    repeat: -1,\n    ease: 'Linear'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000562_v3", "prompt_id": "seed_000562", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 0.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个椭圆形状\n2. 设置椭圆初始透明度为 0（完全透明）\n3. 使用 Tween 动画让椭圆的 alpha 属性在 0.5 秒内从 0 变为 1\n4. 设置 Tween 为循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制椭圆（中心点在画布中央，宽度 200，高度 120）\n  graphics.fillEllipse(400, 300, 200, 120);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建 Tween 动画，让椭圆从透明渐变到不透明\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 500,               // 持续时间 0.5 秒（500 毫秒）\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 往返播放（透明 -> 不透明 -> 透明）\n    repeat: -1                   // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆淡入淡出动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000230_v1", "prompt_id": "seed_000230", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 使用 Tween 动画实现缩放效果（scale: 1 -> 0.32 -> 1）\n4. 设置 Tween 循环播放（loop: -1）和持续时间（3秒往返）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 100, 100); // 100x100 的矩形\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 创建矩形精灵对象，放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n\n  // 创建缩放动画\n  // 使用 yoyo 实现往返效果：1 -> 0.32 -> 1\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.32,  // 缩放到 32%\n    scaleY: 0.32,  // 缩放到 32%\n    duration: 1500, // 单程 1.5 秒\n    yoyo: true,     // 自动返回原始值\n    repeat: -1,     // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n\n  // 添加提示文本\n  const text = this.add.text(400, 50, '矩形缩放动画（3秒循环）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000550_v1", "prompt_id": "seed_000550", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的青色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的青色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环10次，每次创建一个 Graphics 对象\n3. 使用 Math.random() 生成随机 x, y 坐标\n4. 使用 Graphics API 绘制六边形路径（计算6个顶点坐标）\n5. 填充青色（0x00ffff）并渲染\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制10个随机位置的青色六边形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置（留出边界空间）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为青色\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, 16);\n  }\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心 x 坐标\n * @param {number} y - 中心 y 坐标\n * @param {number} size - 六边形大小（从中心到顶点的距离）\n */\nfunction drawHexagon(graphics, x, y, size) {\n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点（从顶部开始，顺时针）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每个角60度，起始角度-90度\n    const vx = x + size * Math.cos(angle);\n    const vy = y + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vx, vy);\n    } else {\n      graphics.lineTo(vx, vy);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000568_v3", "prompt_id": "seed_000568", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色六边形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色六边形以240速度移动并在画布边界反弹\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Physics.Arcade.Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 启用 Arcade 物理系统创建精灵\n3. 设置初始速度为240（随机方向）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建粉色六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点坐标（中心在64,64，半径50）\n  const hexRadius = 50;\n  const centerX = 64;\n  const centerY = 64;\n  const points = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 绘制粉色六边形\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 128, 128);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置随机方向的速度，总速度为240\n  const angle = Math.random() * Math.PI * 2;\n  const velocityX = Math.cos(angle) * 240;\n  const velocityY = Math.sin(angle) * 240;\n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 设置世界边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1，实现完美反弹\n  hexagon.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 不需要每帧更新逻辑\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000037_v1", "prompt_id": "seed_000037", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现紫色角色按键切换 idle/run 状态，使用帧动画或 tween 体现差异\nAPI: Scene, Graphics, Animations, Input.Keyboard, Tween\nSTEPS:\n1. 使用 Graphics 程序化生成紫色角色的多帧纹理（idle 和 run 状态各 4 帧）\n2. 创建 idle 和 run 两个帧动画\n3. 监听键盘输入（空格键切换状态，方向键触发 run）\n4. 根据当前状态播放对应动画，添加状态文本显示\n5. 使用 tween 为 run 状态添加额外的缩放效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle'; // 状态信号：idle 或 run\n    this.stateChangeCount = 0; // 状态切换计数器（可验证信号）\n  }\n\n  preload() {\n    // 程序化生成角色纹理\n    this.generateCharacterTextures();\n  }\n\n  create() {\n    // 创建紫色角色精灵\n    this.player = this.add.sprite(400, 300, 'idle_0');\n    this.player.setScale(2);\n\n    // 创建 idle 动画（4 帧，慢速循环）\n    this.anims.create({\n      key: 'idle',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' },\n        { key: 'idle_2' },\n        { key: 'idle_3' }\n      ],\n      frameRate: 4,\n      repeat: -1\n    });\n\n    // 创建 run 动画（4 帧，快速循环）\n    this.anims.create({\n      key: 'run',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 10,\n      repeat: -1\n    });\n\n    // 播放初始动画\n    this.player.play('idle');\n\n    // 创建状态显示文本\n    this.stateText = this.add.text(400, 100, 'State: IDLE', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.stateText.setOrigin(0.5);\n\n    // 创建计数器文本\n    this.counterText = this.add.text(400, 150, 'State Changes: 0', {\n      fontSize: '24px',\n      fill: '#ffff00'\n    });\n    this.counterText.setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 500, 'Press SPACE to toggle IDLE/RUN\\nPress ARROW KEYS to RUN', {\n      fontSize: '20px',\n      fill: '#aaaaaa',\n      align: 'center'\n    }).setOrigin(0.5);\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 空格键切换状态\n    this.spaceKey.on('down', () => {\n      if (this.currentState === 'idle') {\n        this.switchToRun();\n      } else {\n        this.switchToIdle();\n      }\n    });\n\n    // 用于 tween 的引用\n    this.runTween = null;\n  }\n\n  update() {\n    // 方向键触发 run 状态\n    if (this.cursors.left.isDown || this.cursors.right.isDown || \n        this.cursors.up.isDown || this.cursors.down.isDown) {\n      if (this.currentState === 'idle') {\n        this.switchToRun();\n      }\n      \n      // 根据方向移动角色\n      if (this.cursors.left.isDown) {\n        this.player.x -= 3;\n        this.player.setFlipX(true);\n      }\n      if (this.cursors.right.isDown) {\n        this.player.x += 3;\n        this.player.setFlipX(false);\n      }\n      if (this.cursors.up.isDown) {\n        this.player.y -= 3;\n      }\n      if (this.cursors.down.isDown) {\n        this.player.y += 3;\n      }\n    }\n  }\n\n  switchToIdle() {\n    this.currentState = 'idle';\n    this.stateChangeCount++;\n    \n    // 播放 idle 动画\n    this.player.play('idle');\n    \n    // 停止 run 的 tween 效果\n    if (this.runTween) {\n      this.runTween.stop();\n      this.runTween = null;\n    }\n    \n    // 重置缩放\n    this.player.setScale(2);\n    \n    // 更新显示\n    this.stateText.setText('State: IDLE');\n    this.stateText.setStyle({ fill: '#ffffff' });\n    this.counterText.setText(`State Changes: ${this.stateChangeCount}`);\n  }\n\n  switchToRun() {\n    this.currentState = 'run';\n    this.stateChangeCount++;\n    \n    // 播放 run 动画\n    this.player.play('run');\n    \n    // 添加 tween 缩放效果（run 状态特有）\n    if (this.runTween) {\n      this.runTween.stop();\n    }\n    \n    this.runTween = this.tweens.add({\n      targets: this.player,\n      scaleX: 2.2,\n      scaleY: 1.9,\n      duration: 200,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n    \n    // 更新显示\n    this.stateText.setText('State: RUN');\n    this.stateText.setStyle({ fill: '#00ff00' });\n    this.counterText.setText(`State Changes: ${this.stateChangeCount}`);\n  }\n\n  generateCharacterTextures() {\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    \n    // 生成 idle 动画的 4 帧（紫色，轻微变化）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      \n      // 身体（矩形，紫色渐变）\n      const bodyHeight = 40 + Math.sin(i * Math.PI / 2) * 2; // 轻微呼吸效果\n      graphics.fillStyle(0x9933ff, 1);\n      graphics.fillRect(16, 20, 32, bodyHeight);\n      \n      // 头部（圆形）\n      graphics.fillStyle(0xbb66ff, 1);\n      graphics.fillCircle(32, 16, 12);\n      \n      // 眼睛\n      graphics.fillStyle(0xffffff, 1);\n      graphics.fillCircle(28, 14, 3);\n      graphics.fillCircle(36, 14, 3);\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(28, 14, 1);\n      graphics.fillCircle(36, 14, 1);\n      \n      graphics.generateTexture(`idle_${i}`, 64, 64);\n    }\n    \n    // 生成 run 动画的 4 帧（更动感的姿态）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      \n      // 身体（倾斜效果）\n      const tilt = Math.sin(i * Math.PI / 2) * 5;\n      graphics.fillStyle(0x9933ff, 1);\n      graphics.save();\n      graphics.translate(32, 32);\n      graphics.rotate(tilt * 0.1);\n      graphics.fillRect(-16, -12, 32, 40);\n      graphics.restore();\n      \n      // 头部\n      graphics.fillStyle(0xbb66ff, 1);\n      graphics.fillCircle(32 + tilt, 16, 12);\n      \n      // 眼睛（更有神）\n      graphics.fillStyle(0xffffff, 1);\n      graphics.fillCircle(28 + tilt, 14, 4);\n      graphics.fillCircle(36 + tilt, 14, 4);\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(28 + tilt, 14, 2);\n      graphics.fillCircle(36 + tilt, 14, 2);\n      \n      // 腿部动画（交替）\n      graphics.fillStyle(0x7722cc, 1);\n      if (i % 2 === 0) {\n        graphics.fillRect(20, 60, 8, 4); // 左腿前\n        graphics.fillRect(36, 58, 8, 4); // 右腿后\n      } else {\n        graphics.fillRect(20, 58, 8, 4); // 左腿后\n        graphics.fillRect(36, 60, 8, 4); // 右腿前\n      }\n      \n      graphics.generateTexture(`run_${i}`, 64, 64);\n    }\n    \n    graphics.destroy();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene,\n  pixelArt: true\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000808_v3", "prompt_id": "seed_000808", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.97}}
