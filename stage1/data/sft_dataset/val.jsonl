{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随一个自动向左上移动的三角形\nAPI: Graphics.fillTriangle, Camera.startFollow, Sprite.setVelocity, Physics.Arcade\nSTEPS:\n1. 创建一个更大的世界边界，确保有足够的移动空间\n2. 使用 Graphics 绘制三角形并生成纹理\n3. 创建物理精灵并设置向左上方移动的速度\n4. 设置主相机跟随该三角形对象\n5. 在 update 中保持三角形持续移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使其足够大以便三角形移动\n  this.physics.world.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 使用 Graphics 绘制三角形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6600, 1);\n  // 绘制一个指向上方的三角形\n  graphics.fillTriangle(\n    30, 10,   // 顶点\n    10, 50,   // 左下\n    50, 50    // 右下\n  );\n  graphics.generateTexture('triangleTex', 60, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵，放置在场景中心\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置三角形的速度：向左上移动\n  // 负 x 值表示向左，负 y 值表示向上\n  triangle.setVelocity(-150, -150);\n  \n  // 设置三角形的碰撞边界\n  triangle.setCollideWorldBounds(false);\n  \n  // 设置主相机跟随三角形\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 添加背景网格以便观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x333333, 0.5);\n  \n  // 绘制网格\n  for (let x = -2000; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, -2000, x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += 100) {\n    gridGraphics.lineBetween(-2000, y, 2000, y);\n  }\n  \n  // 在中心位置绘制一个参考点\n  const centerGraphics = this.add.graphics();\n  centerGraphics.fillStyle(0x00ff00, 1);\n  centerGraphics.fillCircle(400, 300, 5);\n  \n  // 添加文本提示\n  const text = this.add.text(10, 10, '三角形向左上方移动\\n相机跟随中...', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 物理引擎会自动更新三角形位置\n  // 相机会自动跟随三角形\n  \n  // 可选：如果需要限制移动范围，可以在这里添加边界检查\n  // 这里让三角形可以无限移动\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000058_v2", "prompt_id": "seed_000058", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左侧显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.Game, Scene.add.text, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 方法中使用 this.add.text() 创建文本对象\n3. 设置文本位置在屏幕左侧，字体大小为 48 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本任务不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕左侧创建文本\n  // x: 50 表示距离左边 50 像素\n  // y: 300 表示垂直居中\n  const text = this.add.text(50, 300, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本的垂直对齐，使其在 y 坐标上居中\n  text.setOrigin(0, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000382_v3", "prompt_id": "seed_000382", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale: 0.48, yoyo: true, duration: 2000）\n4. 设置 Tween 的 loop 属性为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n\n  // 创建缩放动画\n  // 从原始大小 (scale: 1) 缩放到 48% (scale: 0.48)\n  // yoyo: true 表示动画结束后反向播放（恢复到原始大小）\n  // duration: 2000 表示单向动画持续 2 秒\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 2000,\n    yoyo: true,\n    loop: -1,\n    ease: 'Linear'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, '矩形循环缩放动画 (48% ↔ 100%)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000581_v3", "prompt_id": "seed_000581", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆形状\n2. 在 create 中初始化椭圆的位置和初始旋转角度\n3. 在 update 中根据 delta 时间增量计算旋转角度（160度/秒 = 160 * delta/1000 度/帧）\n4. 将角度转换为弧度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipseGraphics;\nlet currentRotation = 0; // 当前旋转角度（弧度）\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置椭圆样式和绘制\n  ellipseGraphics.fillStyle(0x00ff00, 1); // 绿色填充\n  ellipseGraphics.fillEllipse(0, 0, 200, 100); // 在局部坐标 (0,0) 绘制椭圆，宽200高100\n  \n  // 设置椭圆位置到屏幕中心\n  ellipseGraphics.x = 400;\n  ellipseGraphics.y = 300;\n  \n  // 添加边框以便更清楚地看到旋转效果\n  ellipseGraphics.lineStyle(3, 0xffffff, 1);\n  ellipseGraphics.strokeEllipse(0, 0, 200, 100);\n  \n  // 添加一个标记点，方便观察旋转\n  ellipseGraphics.fillStyle(0xff0000, 1);\n  ellipseGraphics.fillCircle(100, 0, 8); // 在椭圆右侧添加红色圆点\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 160 度\n  // delta 是毫秒，需要转换为秒：delta / 1000\n  // 角度转弧度：度 * Math.PI / 180\n  const rotationSpeed = 160; // 度/秒\n  const rotationIncrement = (rotationSpeed * delta / 1000) * (Math.PI / 180);\n  \n  // 累加旋转角度\n  currentRotation += rotationIncrement;\n  \n  // 应用旋转到椭圆\n  ellipseGraphics.rotation = currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000281_v2", "prompt_id": "seed_000281", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 600，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色左右移动、跳跃，带重力和地面碰撞检测的平台跳跃游戏\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 600\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建角色精灵，设置物理属性和碰撞体\n4. 创建静态地面平台组，设置碰撞\n5. 监听键盘输入（左右方向键和空格跳跃）\n6. 在 update 中处理移动逻辑，左右速度 200，跳跃速度 -400\n7. 添加状态变量记录跳跃次数作为验证信号\n[/PLAN]\n\n```javascript\n// 平台跳跃游戏场景\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 状态信号：跳跃次数\n    this.isGrounded = false; // 状态信号：是否在地面\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，不依赖外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色方块）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 400, 32);\n    groundGraphics.generateTexture('ground', 400, 32);\n    groundGraphics.destroy();\n\n    // 创建平台纹理（棕色方块）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8b4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建角色\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面和平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加主地面\n    this.platforms.create(200, 568, 'ground');\n    this.platforms.create(600, 568, 'ground');\n\n    // 添加平台\n    this.platforms.create(600, 450, 'platform');\n    this.platforms.create(50, 350, 'platform');\n    this.platforms.create(750, 300, 'platform');\n    this.platforms.create(400, 200, 'platform');\n\n    // 设置角色与平台碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      // 碰撞回调，检测是否着地\n      if (this.player.body.touching.down) {\n        this.isGrounded = true;\n      }\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加控制说明\n    this.add.text(16, 60, '控制: ← → 移动, 空格/↑ 跳跃', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 重置着地状态\n    if (!this.player.body.touching.down) {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面时才能跳跃）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `跳跃次数: ${this.jumpCount}`,\n      `着地状态: ${this.isGrounded ? '是' : '否'}`,\n      `位置: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      `速度: (${Math.floor(this.player.body.velocity.x)}, ${Math.floor(this.player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000945_v2", "prompt_id": "seed_000945", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个菱形并生成纹理\n2. 创建一个 Sprite 使用该菱形纹理并居中显示\n3. 使用 Tween 动画实现缩放效果：从 1 缩放到 0.8，持续 3 秒\n4. 设置 yoyo 为 true 实现自动恢复，设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制菱形（四个顶点）\n  // 中心点在 (50, 50)，大小为 100x100\n  const centerX = 50;\n  const centerY = 50;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    scaleX: 0.8,               // X 轴缩放到 0.8\n    scaleY: 0.8,               // Y 轴缩放到 0.8\n    duration: 3000,            // 持续 3 秒（3000 毫秒）\n    ease: 'Sine.easeInOut',    // 缓动函数，使动画更平滑\n    yoyo: true,                // 动画结束后反向播放（恢复到原始大小）\n    loop: -1                   // 无限循环（-1 表示永久循环）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '菱形缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '3秒缩放到80% → 3秒恢复 → 循环', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000642_v3", "prompt_id": "seed_000642", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色椭圆，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色椭圆，大小约为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为红色\n4. 使用 fillEllipse 在画布中央 (400, 300) 绘制椭圆，宽高均为 32 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  graphics.fillEllipse(400, 300, 32, 32);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000749_v3", "prompt_id": "seed_000749", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1.5秒内缩放到80%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建缩放动画，从 1 到 0.8 再到 1\n4. 设置 Tween 循环播放（loop: -1）和持续时间（1500ms）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = hexRadius + 10;\n  const centerY = hexRadius + 10;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  const textureSize = (hexRadius + 10) * 2;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 使用 yoyo 模式实现缩放到 0.8 后恢复到 1\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 750, // 1.5秒的一半，因为 yoyo 会来回\n    ease: 'Sine.easeInOut',\n    yoyo: true, // 自动反向播放\n    loop: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Hexagon scaling animation (1.0 → 0.8 → 1.0)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000403_v2", "prompt_id": "seed_000403", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到32%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.32\n4. 设置动画时长为 3000ms，yoyo 为 true 实现恢复效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150); // 200x150 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('rectTexture', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建使用该纹理的精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    scaleX: 0.32,           // X轴缩放到32%\n    scaleY: 0.32,           // Y轴缩放到32%\n    duration: 3000,         // 动画时长3秒\n    yoyo: true,             // 动画结束后反向播放（恢复原始大小）\n    loop: -1,               // 无限循环 (-1 表示永久循环)\n    ease: 'Linear'          // 线性缓动\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 50, 'Rectangle scaling to 32% and back\\nLooping forever', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000550_v2", "prompt_id": "seed_000550", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 800，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动与跳跃，重力800，速度200，与地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 800\n2. 使用 Graphics 创建玩家角色和地面平台的纹理\n3. 添加物理精灵，设置碰撞检测\n4. 监听键盘输入（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑，添加跳跃次数限制（仅在地面可跳）\n6. 添加状态变量记录跳跃次数和位置信息\n[/PLAN]\n\n```javascript\nclass PlatformerScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformerScene');\n    // 可验证的状态信号\n    this.jumpCount = 0;\n    this.playerX = 0;\n    this.playerY = 0;\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x3498db, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x27ae60, 1);\n    groundGraphics.fillRect(0, 0, 64, 32);\n    groundGraphics.generateTexture('ground', 64, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加主地面\n    this.platforms.create(400, 568, 'ground').setScale(12.5, 1).refreshBody();\n    \n    // 添加几个悬浮平台\n    this.platforms.create(200, 450, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(600, 400, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(400, 300, 'ground').setScale(2, 1).refreshBody();\n    this.platforms.create(100, 250, 'ground').setScale(2, 1).refreshBody();\n    this.platforms.create(700, 250, 'ground').setScale(2, 1).refreshBody();\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加控制说明\n    this.add.text(16, 60, 'Controls:\\n← → : Move\\nSPACE: Jump', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 检测是否在地面上\n    const touchingDown = this.player.body.touching.down;\n    \n    // 更新接地状态\n    if (touchingDown) {\n      this.isGrounded = true;\n    }\n\n    // 左右移动（速度 200）\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃逻辑（仅在地面可跳）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.isGrounded) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n      this.isGrounded = false;\n    }\n\n    // 更新状态变量\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Position: (${this.playerX}, ${this.playerY})`,\n      `Jump Count: ${this.jumpCount}`,\n      `Grounded: ${this.isGrounded}`,\n      `Velocity: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: PlatformerScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001035_v2", "prompt_id": "seed_001035", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 8 个蓝色敌人巡逻移动，在 160 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 8个蓝色敌人在场景中左右巡逻，玩家靠近时切换为追踪模式\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建玩家和敌人的纹理（使用Graphics绘制蓝色方块和绿色圆形）\n2. 初始化玩家精灵并设置键盘控制\n3. 创建8个敌人物理精灵组，随机分布在场景中\n4. 为每个敌人设置初始巡逻方向和速度（160）\n5. 在update中检测玩家与敌人距离，近距离时切换为追踪模式，远距离恢复巡逻\n6. 添加边界碰撞检测，敌人触碰边界时反向移动\n7. 维护enemiesPatrolling和enemiesChasing状态变量用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n    this.detectionRange = 150; // 检测范围\n    this.patrolSpeed = 160;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色圆形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 生成8个敌人，分布在场景不同位置\n    const positions = [\n      { x: 100, y: 100 },\n      { x: 700, y: 100 },\n      { x: 100, y: 500 },\n      { x: 700, y: 500 },\n      { x: 400, y: 150 },\n      { x: 200, y: 300 },\n      { x: 600, y: 300 },\n      { x: 400, y: 450 }\n    ];\n\n    positions.forEach((pos, index) => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 设置初始巡逻方向（随机左右）\n      enemy.patrolDirection = Math.random() > 0.5 ? 1 : -1;\n      enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n      \n      // 标记状态\n      enemy.isChasing = false;\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加说明文本\n    this.add.text(10, 10, 'Arrow keys to move\\nEnemies patrol and chase when near', {\n      fontSize: '16px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 状态显示\n    this.statusText = this.add.text(10, 70, '', {\n      fontSize: '14px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 初始化状态\n    this.enemiesPatrolling = 8;\n    this.enemiesChasing = 0;\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 重置状态计数\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, this.player.y,\n        enemy.x, enemy.y\n      );\n\n      // 判断是否应该追踪玩家\n      if (distance < this.detectionRange) {\n        // 追踪模式\n        if (!enemy.isChasing) {\n          enemy.isChasing = true;\n        }\n\n        // 计算追踪方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        this.physics.velocityFromRotation(angle, this.patrolSpeed, enemy.body.velocity);\n        this.enemiesChasing++;\n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          enemy.isChasing = false;\n          // 恢复巡逻速度\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        // 检测边界碰撞，反向移动\n        if (enemy.body.blocked.left || enemy.body.blocked.right) {\n          enemy.patrolDirection *= -1;\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        this.enemiesPatrolling++;\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText(\n      `Patrolling: ${this.enemiesPatrolling}\\n` +\n      `Chasing: ${this.enemiesChasing}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000974_v3", "prompt_id": "seed_000974", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色圆形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色圆形，直径24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为黄色（0xffff00）\n4. 使用 fillCircle 在画布中央（400, 300）绘制半径为 12 的圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 在画布中央绘制圆形\n  // 画布尺寸为 800x600，中心点为 (400, 300)\n  // 圆形大小为 24 像素，半径为 12\n  graphics.fillCircle(400, 300, 12);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000762_v3", "prompt_id": "seed_000762", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色三角形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色三角形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置蓝色填充\n5. 使用 fillTriangle 绘制等边三角形，顶点在中心点周围，边长约32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形大小（从中心点到顶点的距离）\n  const size = 32;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size * 0.6;\n  \n  // 顶点2：左下角\n  const x2 = centerX - size * 0.866;\n  const y2 = centerY + size * 0.5;\n  \n  // 顶点3：右下角\n  const x3 = centerX + size * 0.866;\n  const y3 = centerY + size * 0.5;\n  \n  // 设置蓝色填充 (0x0000ff)\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 绘制填充的三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加白色描边使三角形更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000616_v2", "prompt_id": "seed_000616", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 2.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让菱形在2.5秒内缩放到16%然后恢复，循环播放\nAPI: Graphics, Tween, TweenManager, BaseTween.loop, Tweens.add\nSTEPS:\n1. 使用 Graphics 绘制菱形形状\n2. 创建 Tween 动画，设置 scale 从 1 到 0.16 再回到 1\n3. 设置 Tween 的 duration 为 2500ms，yoyo 为 true 实现往返\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建菱形 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置菱形的位置（屏幕中心）\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（使用四个点构成的多边形）\n  const size = 100; // 菱形的半径\n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 顶点\n  graphics.lineTo(centerX + size, centerY);      // 右点\n  graphics.lineTo(centerX, centerY + size);      // 底点\n  graphics.lineTo(centerX - size, centerY);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 创建缩放动画\n  // 从原始大小（1）缩放到 16%（0.16），然后返回\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 2500,      // 2.5秒完成一次缩放\n    yoyo: true,          // 启用往返效果（缩小后再放大）\n    loop: -1,            // 无限循环\n    ease: 'Linear'       // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Diamond scaling to 16% and back (2.5s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000065_v2", "prompt_id": "seed_000065", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.95}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 2 秒内缩放到 24% 然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale 从 1 到 0.24 再到 1）\n4. 设置 Tween 循环播放（loop: -1）和 yoyo 效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 顶点\n  graphics.lineTo(100, 100);   // 右下\n  graphics.lineTo(0, 100);     // 左下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.24,        // 缩放到 24%\n    scaleY: 0.24,        // 缩放到 24%\n    duration: 2000,      // 2 秒\n    yoyo: true,          // 自动恢复到原始值\n    loop: -1,            // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 50, 'Triangle scaling to 24% and back (2s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000117_v3", "prompt_id": "seed_000117", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色方块以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色方块以80速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制红色方块并生成纹理\n3. 创建物理精灵并设置初始速度为 80\n4. 设置精灵与世界边界碰撞并反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nconst SPEED = 80;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('redSquare', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'redSquare');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const velocityX = Math.cos(angle) * SPEED;\n  const velocityY = Math.sin(angle) * SPEED;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（防止因碰撞导致速度衰减）\n  const velocity = square.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed !== 0) {\n    const scale = SPEED / currentSpeed;\n    square.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000470_v1", "prompt_id": "seed_000470", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色方块，使用补间动画实现左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建方块精灵，初始位置在左侧\n  const square = this.add.sprite(100, 300, 'whiteSquare');\n\n  // 创建补间动画：从左到右移动，1秒完成，往返循环\n  this.tweens.add({\n    targets: square,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 1000, // 动画时长 1 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000407_v1", "prompt_id": "seed_000407", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的橙色菱形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的橙色菱形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，使用 HEADLESS 或 AUTO 类型\n2. 在 create 方法中循环8次创建 Graphics 对象\n3. 使用 Graphics.fillPath 绘制菱形路径（4个顶点）\n4. 使用 setRandomPosition 设置每个菱形的随机位置\n5. 确保菱形大小为24像素（从中心点到边缘12像素）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建8个随机位置的橙色菱形\n  for (let i = 0; i < 8; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xFFA500, 1);\n    \n    // 创建菱形路径（24像素大小，从中心到边缘12像素）\n    const path = new Phaser.Geom.Polygon([\n      0, -12,    // 上顶点\n      12, 0,     // 右顶点\n      0, 12,     // 下顶点\n      -12, 0     // 左顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(path.points, true);\n    \n    // 设置随机位置（考虑边界，避免菱形超出画布）\n    const x = Phaser.Math.Between(20, 780);\n    const y = Phaser.Math.Between(20, 580);\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000315_v1", "prompt_id": "seed_000315", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色菱形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现蓝色菱形在2.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色菱形并生成纹理\n2. 创建 Sprite 对象并应用菱形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0066ff, 1);\n  \n  // 绘制菱形（四个顶点）\n  // 中心点在 (30, 30)，菱形大小为 60x60\n  graphics.beginPath();\n  graphics.moveTo(30, 0);      // 上顶点\n  graphics.lineTo(60, 30);     // 右顶点\n  graphics.lineTo(30, 60);     // 下顶点\n  graphics.lineTo(0, 30);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 60, 60);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 2500,             // 持续时间 2.5 秒\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 启用往返效果（到达终点后反向播放）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    loopDelay: 0                // 循环之间无延迟\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '蓝色菱形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '循环周期: 2.5秒 (单程)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000719_v3", "prompt_id": "seed_000719", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个星形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制星形以 240 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes, graphics.fillStar()\nSTEPS:\n1. 创建 Graphics 对象绘制星形\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态更新星形位置，速度为 240 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 星形对象和按键\nlet star;\nlet keyW, keyA, keyS, keyD;\nconst speed = 240; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制星形\n  star = this.add.graphics();\n  star.x = 400; // 初始位置 x\n  star.y = 300; // 初始位置 y\n  \n  // 绘制黄色星形\n  star.fillStyle(0xffff00, 1);\n  star.fillStar(0, 0, 5, 20, 40); // 中心点(0,0)，5个角，内半径20，外半径40\n  \n  // 添加 WASD 键监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the star', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离 = 速度 * 时间增量（转换为秒）\n  const distance = speed * (delta / 1000);\n  \n  // 根据按键状态移动星形\n  if (keyW.isDown) {\n    star.y -= distance; // 向上移动\n  }\n  if (keyS.isDown) {\n    star.y += distance; // 向下移动\n  }\n  if (keyA.isDown) {\n    star.x -= distance; // 向左移动\n  }\n  if (keyD.isDown) {\n    star.x += distance; // 向右移动\n  }\n  \n  // 边界限制（可选）\n  star.x = Phaser.Math.Clamp(star.x, 0, 800);\n  star.y = Phaser.Math.Clamp(star.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000120_v1", "prompt_id": "seed_000120", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的紫色矩形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的紫色矩形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机 x、y 坐标\n4. 设置紫色填充样式，绘制 24x24 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充（紫色的十六进制值为 0x800080 或类似）\n  graphics.fillStyle(0x9932cc, 1); // 使用深兰花紫色\n  \n  // 绘制10个随机位置的矩形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保矩形完全在画布内\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const randomX = Math.random() * (config.width - 24);\n    const randomY = Math.random() * (config.height - 24);\n    \n    // 绘制 24x24 的矩形\n    graphics.fillRect(randomX, randomY, 24, 24);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000650_v3", "prompt_id": "seed_000650", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让绿色矩形在 1.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建绿色矩形在 1.5 秒内完成旋转动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.DegToRad\nSTEPS:\n1. 使用 Graphics 绘制绿色矩形并生成纹理\n2. 创建 Sprite 对象并设置锚点为中心\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 1500ms，rotation 从 0 到 2π\n4. 设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillRect(0, 0, 100, 100); // 100x100 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('greenRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵并设置位置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'greenRect');\n  \n  // 设置锚点为中心（默认就是 0.5, 0.5，但明确设置更清晰）\n  rect.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    rotation: Math.PI * 2,   // 旋转角度：2π 弧度（360度）\n    duration: 1500,          // 动画持续时间：1.5 秒\n    ease: 'Linear',          // 线性缓动，匀速旋转\n    repeat: -1,              // 无限循环（-1 表示永远重复）\n    yoyo: false              // 不反向播放\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '绿色矩形旋转动画 (1.5秒/圈)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000074_v3", "prompt_id": "seed_000074", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：15 个橙色小球以 120 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 15个橙色小球以120速度在封闭空间内移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.group, Body.setBounce, Physics.add.collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制橙色圆形并生成纹理\n3. 创建物理组，添加15个小球精灵，设置随机位置和速度\n4. 设置小球的弹性系数为1（完全弹性碰撞）\n5. 添加边界碰撞和小球之间的碰撞检测\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n    this.ballCount = 15; // 小球数量\n  }\n\n  preload() {\n    // 使用 Graphics 程序化生成橙色小球纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xFF8800, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('orangeBall', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'orangeBall',\n      repeat: this.ballCount - 1, // 总共15个小球\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 设置每个小球的随机位置和速度\n    const ballsArray = this.balls.getChildren();\n    ballsArray.forEach((ball, index) => {\n      // 随机位置（避免太靠近边缘）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      ball.setPosition(x, y);\n\n      // 设置随机方向的速度，速度大小为120\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 120;\n      const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 120;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体\n      ball.setCircle(16);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 添加显示碰撞计数的文本\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加小球数量显示\n    this.ballCountText = this.add.text(10, 40, `Balls: ${this.ballCount}`, {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界显示（可选，便于观察）\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0xffffff, 1);\n    graphics.strokeRect(0, 0, 800, 600);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调函数，更新碰撞计数\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 可选：监控小球速度，确保保持恒定速度\n    const ballsArray = this.balls.getChildren();\n    ballsArray.forEach((ball) => {\n      const velocity = ball.body.velocity;\n      const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏离120太多，重新归一化（处理浮点误差）\n      if (Math.abs(speed - 120) > 1) {\n        const scale = 120 / speed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false // 设为 true 可查看碰撞体\n    }\n  },\n  scene: BallCollisionScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000941_v3", "prompt_id": "seed_000941", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2.5秒内缩放到64%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状并生成纹理\n2. 创建 Sprite 对象使用椭圆纹理\n3. 使用 Tween 创建缩放动画，从1缩放到0.64再回到1\n4. 设置 Tween 循环播放（loop: -1）和持续时间2500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillEllipse(100, 75, 200, 150); // 椭圆中心在(100, 75)，宽200，高150\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建使用椭圆纹理的 Sprite\n  const ellipseSprite = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 1250, // 2.5秒的一半，因为需要来回\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Ellipse Scale Animation\\n(64% and back, 2.5s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000531_v2", "prompt_id": "seed_000531", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色三角形并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制三角形（等边三角形，中心在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在左侧起始位置\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 500,             // 持续时间 0.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000523_v1", "prompt_id": "seed_000523", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形，并添加一个标记线以便观察旋转\n2. 将 Graphics 添加到 Container 中以便控制旋转\n3. 在 update 方法中根据 delta 时间计算旋转角度增量\n4. 每帧更新 Container 的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个圆形（蓝色填充）\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的红色线，用于观察旋转\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, 0);\n  graphics.lineTo(80, 0);\n  graphics.strokePath();\n  \n  // 在圆的边缘添加一个小圆点作为额外的旋转标记\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(80, 0, 10);\n  \n  // 将 Graphics 添加到 Container 中以便控制旋转\n  this.rotatingCircle = this.add.container(400, 300, [graphics]);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形以每秒 200° 的速度旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 显示当前旋转角度的文字\n  this.angleText = this.add.text(400, 550, '当前角度: 0°', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 200 度\n  const rotationSpeed = 200; // 度/秒\n  \n  // 将度转换为弧度（Phaser 使用弧度）\n  const rotationSpeedRadians = Phaser.Math.DegToRad(rotationSpeed);\n  \n  // 根据 delta 时间（毫秒）计算本帧应该旋转的角度\n  const rotationIncrement = rotationSpeedRadians * (delta / 1000);\n  \n  // 更新容器的旋转角度\n  this.rotatingCircle.rotation += rotationIncrement;\n  \n  // 更新角度显示文字（转换回度数并取模 360）\n  const currentDegrees = Phaser.Math.RadToDeg(this.rotatingCircle.rotation) % 360;\n  this.angleText.setText(`当前角度: ${Math.floor(currentDegrees)}°`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000301_v3", "prompt_id": "seed_000301", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置 duration 为 500 毫秒（0.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-25, 30);     // 左下角\n  graphics.lineTo(25, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右移动，往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 500,             // 持续时间 0.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果\n    repeat: -1                 // 无限循环 (-1 表示永远重复)\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000793_v3", "prompt_id": "seed_000793", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色三角形在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色三角形在3秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Triangle\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建 y 轴弹跳动画，配置 ease 为 'Bounce.easeOut'\n4. 设置动画循环播放，duration 为 3000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（顶点朝上）\n  const triangleSize = 60;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize / 2); // 顶点\n  graphics.lineTo(-triangleSize / 2, triangleSize / 2); // 左下角\n  graphics.lineTo(triangleSize / 2, triangleSize / 2); // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在屏幕中心偏上\n  const triangle = this.add.sprite(400, 200, 'triangle');\n  \n  // 创建弹跳动画\n  // 从当前位置（y=200）弹跳到底部（y=500），然后返回\n  this.tweens.add({\n    targets: triangle,\n    y: 500, // 目标 y 位置\n    duration: 1500, // 下落时间 1.5 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返动画\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '绿色三角形弹跳动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '3秒一个循环（1.5秒下落 + 1.5秒上升）', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000439_v2", "prompt_id": "seed_000439", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按鼠标左键向当前朝向发射子弹，子弹速度 360，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现玩家旋转朝向，鼠标左键向当前方向发射速度360的子弹\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Group, Phaser.Math.Angle.Between, Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\nSTEPS:\n1. 创建玩家精灵，使用Graphics生成三角形纹理表示朝向\n2. 监听键盘输入（WASD/方向键）控制玩家移动，鼠标移动控制旋转朝向\n3. 监听鼠标左键点击，创建子弹并使用velocityFromAngle设置速度360\n4. 使用Physics.Arcade.Group管理子弹池，子弹超出边界自动回收\n5. 添加bulletsFired计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 可验证状态信号\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（三角形表示方向）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(20, 0);  // 尖端指向右侧\n    playerGraphics.lineTo(-10, -10);\n    playerGraphics.lineTo(-10, 10);\n    playerGraphics.closePath();\n    playerGraphics.fillPath();\n    playerGraphics.generateTexture('player', 30, 20);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（小圆点）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDrag(500);\n    this.player.setMaxVelocity(300);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: true\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keys = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 鼠标输入\n    this.input.on('pointermove', (pointer) => {\n      // 计算玩家到鼠标的角度\n      const angle = Phaser.Math.Angle.Between(\n        this.player.x,\n        this.player.y,\n        pointer.x,\n        pointer.y\n      );\n      this.player.rotation = angle;\n    });\n\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        this.fireBullet();\n      }\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文字\n    this.add.text(10, 550, 'WASD/方向键移动 | 鼠标移动旋转 | 左键射击', {\n      fontSize: '14px',\n      fill: '#00ff00'\n    });\n  }\n\n  fireBullet() {\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹角度和速度\n      bullet.rotation = this.player.rotation;\n      \n      // 使用velocityFromAngle设置速度为360\n      const angle = Phaser.Math.RadToDeg(this.player.rotation);\n      this.physics.velocityFromAngle(angle, 360, bullet.body.velocity);\n      \n      // 设置子弹生命周期\n      bullet.lifespan = 2000; // 2秒后消失\n      bullet.birthTime = this.time.now;\n      \n      this.bulletsFired++;\n    }\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const acceleration = 400;\n    \n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setAccelerationX(-acceleration);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setAccelerationX(acceleration);\n    } else {\n      this.player.setAccelerationX(0);\n    }\n\n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setAccelerationY(-acceleration);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setAccelerationY(acceleration);\n    } else {\n      this.player.setAccelerationY(0);\n    }\n\n    // 更新子弹状态\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        // 检查子弹是否超时\n        if (time - bullet.birthTime > bullet.lifespan) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n        \n        // 检查子弹是否超出边界\n        if (bullet.x < -10 || bullet.x > 810 || \n            bullet.y < -10 || bullet.y > 610) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 更新状态显示\n    const activeBullets = this.bullets.countActive(true);\n    this.statusText.setText([\n      `子弹发射总数: ${this.bulletsFired}`,\n      `当前活跃子弹: ${activeBullets}`,\n      `玩家位置: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `玩家角度: ${Math.round(Phaser.Math.RadToDeg(this.player.rotation))}°`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000829_v1", "prompt_id": "seed_000829", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在1.5秒内缩放到16%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制一个圆形\n2. 创建 Tween 动画，设置 scale 从 1 到 0.16\n3. 配置 yoyo 为 true 实现恢复效果\n4. 设置 loop 为 -1 实现无限循环\n5. 设置 duration 为 1500ms（1.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制圆形（中心点在 0,0，半径 50）\n  graphics.fillCircle(0, 0, 50);\n  \n  // 将圆形放置在屏幕中央\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    scaleX: 0.16,               // X 轴缩放到 16%\n    scaleY: 0.16,               // Y 轴缩放到 16%\n    duration: 1500,             // 动画持续时间 1.5 秒\n    yoyo: true,                 // 启用悠悠球效果（动画结束后反向播放回到初始状态）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Circle scaling animation (1.5s to 16% and back, looping)', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000577_v3", "prompt_id": "seed_000577", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 24 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建基本的 Phaser Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字位置为屏幕右下角（考虑文字宽高偏移）\n4. 设置文字样式（字体大小 24px）\n5. 使用 setOrigin(1, 1) 将锚点设置为右下角，方便定位\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文字对象，位置设置在屏幕右下角\n  const text = this.add.text(\n    this.cameras.main.width - 20,  // X 坐标：屏幕宽度 - 右边距\n    this.cameras.main.height - 20, // Y 坐标：屏幕高度 - 下边距\n    'Hello Phaser',\n    {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }\n  );\n\n  // 设置锚点为右下角 (1, 1)，使文字从右下角开始定位\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000094_v2", "prompt_id": "seed_000094", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：20 个圆形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建收集游戏，玩家控制角色收集 20 个随机分布的圆形物品，收集完成后显示通关提示\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.GameObjects.Text\nSTEPS:\n1. 使用 Graphics 生成玩家和收集物的纹理\n2. 创建启用物理的玩家精灵，添加键盘控制\n3. 创建物理组，生成 20 个随机位置的收集物\n4. 添加碰撞检测，收集时移除物品并增加计数\n5. 当收集数达到 20 时显示通关文本\n[/PLAN]\n\n```javascript\nclass CollectionGame extends Phaser.Scene {\n  constructor() {\n    super('CollectionGame');\n    this.score = 0;\n    this.totalItems = 20;\n    this.gameCompleted = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（黄色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('item', 24, 24);\n    itemGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setVelocityDrag(500);\n    this.player.setMaxVelocity(300);\n\n    // 创建收集物组\n    this.items = this.physics.add.group();\n    \n    // 随机生成 20 个收集物\n    for (let i = 0; i < this.totalItems; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const item = this.items.create(x, y, 'item');\n      item.setCircle(12);\n      item.body.setOffset(0, 0);\n    }\n\n    // 添加碰撞检测\n    this.physics.add.overlap(this.player, this.items, this.collectItem, null, this);\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, `收集: ${this.score}/${this.totalItems}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加提示文本\n    this.add.text(16, 50, '使用方向键移动', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  collectItem(player, item) {\n    // 移除收集物\n    item.destroy();\n    \n    // 增加分数\n    this.score++;\n    this.scoreText.setText(`收集: ${this.score}/${this.totalItems}`);\n\n    // 检查是否完成\n    if (this.score >= this.totalItems && !this.gameCompleted) {\n      this.gameCompleted = true;\n      this.winText.setVisible(true);\n      \n      // 停止玩家移动\n      this.player.setVelocity(0, 0);\n      \n      // 添加闪烁效果\n      this.tweens.add({\n        targets: this.winText,\n        alpha: { from: 1, to: 0.3 },\n        duration: 500,\n        yoyo: true,\n        repeat: -1\n      });\n    }\n  }\n\n  update(time, delta) {\n    if (this.gameCompleted) {\n      return; // 游戏完成后停止更新\n    }\n\n    // 键盘控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectionGame\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001007_v2", "prompt_id": "seed_001007", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 0.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 0.5 秒内缩放到 80% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale 从 1 到 0.8 再回到 1）\n4. 设置 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（居中绘制，方便缩放）\n  graphics.beginPath();\n  graphics.moveTo(0, -50);      // 顶点\n  graphics.lineTo(-43, 25);     // 左下角\n  graphics.lineTo(43, 25);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 86, 75);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    scaleX: 0.8,                // X 轴缩放到 80%\n    scaleY: 0.8,                // Y 轴缩放到 80%\n    duration: 500,              // 持续时间 0.5 秒\n    yoyo: true,                 // 动画结束后反向播放（回到原始大小）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '三角形循环缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000352_v2", "prompt_id": "seed_000352", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#angle, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制矩形\n2. 设置矩形的原点为中心点以便围绕中心旋转\n3. 在 update 方法中根据 delta 时间累加角度（200度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制矩形，以中心为原点（-100, -75 到 100, 75，总尺寸 200x150）\n  graphics.fillRect(-100, -75, 200, 150);\n  \n  // 设置矩形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 数据中，以便在 update 中访问\n  this.rotatingRect = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 200 度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 每帧旋转的角度 = 200 * (delta / 1000)\n  const rotationSpeed = 200; // 度/秒\n  const deltaAngle = rotationSpeed * (delta / 1000);\n  \n  // 累加角度\n  this.rotatingRect.angle += deltaAngle;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000054_v2", "prompt_id": "seed_000054", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Tween 让方块在 1.5 秒内从透明到不透明循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 创建 Graphics 对象绘制方块\n2. 设置方块初始 alpha 为 0（完全透明）\n3. 使用 tweens.add 创建 alpha 补间动画，从 0 到 1，持续 1500ms\n4. 设置 yoyo: true 和 repeat: -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个方块 Graphics 对象\n  const square = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  square.fillStyle(0x00aaff, 1);\n  \n  // 绘制一个 100x100 的方块，位置在屏幕中心\n  const squareSize = 100;\n  const x = (this.cameras.main.width - squareSize) / 2;\n  const y = (this.cameras.main.height - squareSize) / 2;\n  square.fillRect(x, y, squareSize, squareSize);\n  \n  // 设置初始 alpha 为 0（完全透明）\n  square.alpha = 0;\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,\n    alpha: 1,              // 目标 alpha 值为 1（完全不透明）\n    duration: 1500,        // 持续时间 1.5 秒\n    yoyo: true,            // 来回播放（1->0->1）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加文本提示\n  this.add.text(\n    this.cameras.main.width / 2,\n    50,\n    'Square Fade Animation',\n    {\n      fontSize: '24px',\n      color: '#ffffff'\n    }\n  ).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000546_v1", "prompt_id": "seed_000546", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：15 个矩形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色移动收集15个随机分布的矩形，收集完成后显示通关文字\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家角色（使用Graphics绘制蓝色矩形）\n2. 创建15个可收集物品（使用Graphics绘制黄色矩形），随机分布在场景中\n3. 添加物理碰撞检测，当玩家碰到收集物时移除该物品并增加计数\n4. 使用键盘方向键控制玩家移动\n5. 当收集数量达到15时，显示\"恭喜通关\"文字并停止游戏\n[/PLAN]\n\n```javascript\nclass CollectGame extends Phaser.Scene {\n  constructor() {\n    super('CollectGame');\n    this.collectedCount = 0;\n    this.totalCollectibles = 15;\n    this.gameCompleted = false;\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，不需要外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffff00, 1);\n    collectibleGraphics.fillRect(0, 0, 20, 20);\n    collectibleGraphics.generateTexture('collectible', 20, 20);\n    collectibleGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成15个收集物\n    for (let i = 0; i < this.totalCollectibles; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCollideWorldBounds(true);\n      collectible.setBounce(0.5);\n      collectible.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n    }\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建计数文本\n    this.scoreText = this.add.text(16, 16, '收集: 0 / 15', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n  }\n\n  collectItem(player, collectible) {\n    // 移除收集物\n    collectible.destroy();\n\n    // 增加计数\n    this.collectedCount++;\n\n    // 更新文本\n    this.scoreText.setText(`收集: ${this.collectedCount} / ${this.totalCollectibles}`);\n\n    // 检查是否通关\n    if (this.collectedCount >= this.totalCollectibles) {\n      this.gameCompleted = true;\n      this.winText.setVisible(true);\n      this.player.setVelocity(0, 0);\n      // 禁用玩家输入\n      this.cursors = null;\n    }\n  }\n\n  update() {\n    if (this.gameCompleted || !this.cursors) {\n      return;\n    }\n\n    // 重置速度\n    this.player.setVelocity(0);\n\n    // 键盘控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectGame\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000951_v2", "prompt_id": "seed_000951", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 80 像素/秒的速度移动\nAPI: Scene.input.keyboard.addKeys, Graphics.fillRect, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制一个矩形作为玩家\n2. 在 create 中通过 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新矩形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象\nlet player;\n// 键盘输入\nlet keys;\n// 移动速度（像素/秒）\nconst SPEED = 80;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 40, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('playerRect', 40, 40);\n  graphics.destroy();\n  \n  // 创建玩家精灵并设置初始位置\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 添加 WASD 键盘监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the rectangle', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    player.x += distance; // 向右移动\n  }\n  \n  // 限制玩家在屏幕范围内\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000449_v3", "prompt_id": "seed_000449", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色圆形以300速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制紫色圆形并生成纹理\n3. 创建物理精灵并应用纹理\n4. 设置初始速度为300（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 半径25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'purpleCircle');\n  \n  // 设置圆形碰撞体为圆形（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置随机初始速度，速度大小为300\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  circle.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000554_v1", "prompt_id": "seed_000554", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的青色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的青色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环10次，每次创建一个 Graphics 对象\n3. 使用 Math.random() 生成随机 x, y 坐标\n4. 使用 Graphics API 绘制六边形路径（计算6个顶点坐标）\n5. 填充青色（0x00ffff）并渲染\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制10个随机位置的青色六边形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置（留出边界空间）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为青色\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, 16);\n  }\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心 x 坐标\n * @param {number} y - 中心 y 坐标\n * @param {number} size - 六边形大小（从中心到顶点的距离）\n */\nfunction drawHexagon(graphics, x, y, size) {\n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点（从顶部开始，顺时针）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每个角60度，起始角度-90度\n    const vx = x + size * Math.cos(angle);\n    const vy = y + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vx, vy);\n    } else {\n      graphics.lineTo(vx, vy);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000568_v3", "prompt_id": "seed_000568", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在4秒内从透明到不透明循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 设置初始透明度为0（完全透明）\n4. 使用 Tween 动画让 alpha 从0渐变到1，持续4秒\n5. 设置 Tween 循环播放（yoyo 或 repeat -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 程序化生成矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('rectangle', 200, 150);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建矩形精灵并放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'rectangle');\n  \n  // 设置初始透明度为0（完全透明）\n  rect.setAlpha(0);\n  \n  // 创建渐变动画：从透明(0)到不透明(1)，持续4秒，无限循环\n  this.tweens.add({\n    targets: rect,\n    alpha: 1,              // 目标透明度为1（完全不透明）\n    duration: 4000,        // 持续4秒\n    ease: 'Linear',        // 线性渐变\n    yoyo: true,            // 来回播放（1->0->1）\n    repeat: -1             // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '矩形透明度循环动画（4秒）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000296_v3", "prompt_id": "seed_000296", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 200。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 200\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), Graphics.fillRect(), Graphics.generateTexture()\nSTEPS:\n1. 创建灰色玩家精灵，使用 Graphics 绘制灰色方块纹理\n2. 设置 Arcade 物理系统，配置玩家速度为 200\n3. 添加键盘输入监听（方向键控制移动）\n4. 在 update 中检测玩家是否移出边界（左/右/上/下）\n5. 当移出边界时，将玩家传送到对侧边界位置\n6. 添加状态变量记录玩家穿越边界次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossBorderCount = 0; // 状态信号：记录穿越边界次数\n  }\n\n  preload() {\n    // 使用 Graphics 创建灰色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建玩家精灵（中心位置）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 允许移出边界\n    \n    // 设置移动速度\n    this.moveSpeed = 200;\n    \n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n    \n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.updateStatusText();\n    \n    // 添加边界线（可视化）\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0xffffff, 0.5);\n    borderGraphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n    \n    // 处理键盘输入\n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setVelocityX(-this.moveSpeed);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setVelocityX(this.moveSpeed);\n    }\n    \n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setVelocityY(-this.moveSpeed);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setVelocityY(this.moveSpeed);\n    }\n    \n    // 处理边界循环\n    this.handleWorldWrap();\n    \n    // 更新状态显示\n    this.updateStatusText();\n  }\n  \n  handleWorldWrap() {\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    const worldWidth = this.cameras.main.width;\n    const worldHeight = this.cameras.main.height;\n    \n    let wrapped = false;\n    \n    // 左边界检测\n    if (this.player.x < -playerWidth / 2) {\n      this.player.x = worldWidth + playerWidth / 2;\n      wrapped = true;\n    }\n    // 右边界检测\n    else if (this.player.x > worldWidth + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      wrapped = true;\n    }\n    \n    // 上边界检测\n    if (this.player.y < -playerHeight / 2) {\n      this.player.y = worldHeight + playerHeight / 2;\n      wrapped = true;\n    }\n    // 下边界检测\n    else if (this.player.y > worldHeight + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      wrapped = true;\n    }\n    \n    // 如果发生了边界穿越，增加计数\n    if (wrapped) {\n      this.crossBorderCount++;\n    }\n  }\n  \n  updateStatusText() {\n    const posX = Math.round(this.player.x);\n    const posY = Math.round(this.player.y);\n    this.statusText.setText(\n      `Position: (${posX}, ${posY})\\n` +\n      `Border Crosses: ${this.crossBorderCount}\\n` +\n      `Speed: ${this.moveSpeed}\\n` +\n      `Controls: Arrow Keys or WASD`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000842_v2", "prompt_id": "seed_000842", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色方块以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色方块以120速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制紫色方块纹理\n3. 创建物理精灵并设置初始速度为120\n4. 启用世界边界碰撞和反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet square;\nconst SPEED = 120;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建紫色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1);  // 紫色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('purpleSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'purpleSquare');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * SPEED;\n  const velocityY = Math.sin(angle * Math.PI / 180) * SPEED;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1，实现完美弹性碰撞\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为120\n  // 由于反弹可能导致速度变化，需要归一化速度向量\n  const currentVelocity = square.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  if (currentSpeed !== 0 && Math.abs(currentSpeed - SPEED) > 0.1) {\n    // 归一化并重新设置为目标速度\n    square.setVelocity(\n      (currentVelocity.x / currentSpeed) * SPEED,\n      (currentVelocity.y / currentSpeed) * SPEED\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000228_v1", "prompt_id": "seed_000228", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色三角形在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色三角形在3秒内完成弹跳动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 Tween 创建弹跳动画（y轴移动+缩放效果模拟弹跳）\n4. 设置 Tween 为循环模式，duration 为 3000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心点在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -40);      // 顶点\n  graphics.lineTo(-35, 30);     // 左下角\n  graphics.lineTo(35, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 70, 70);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建弹跳动画\n  // 使用 yoyo 和缩放效果模拟真实的弹跳\n  this.tweens.add({\n    targets: triangle,\n    y: 150,                    // 向上弹跳到 y=150\n    scaleY: 1.1,               // 垂直拉伸（起跳时的拉伸效果）\n    duration: 750,             // 上升阶段 0.75 秒\n    ease: 'Quad.easeOut',      // 减速上升\n    yoyo: true,                // 返回原位置\n    hold: 0,                   // 在顶点不停留\n    repeat: -1,                // 无限循环\n    repeatDelay: 0,            // 无延迟\n    onYoyo: function() {\n      // 下落阶段，三角形被压扁（模拟着地时的形变）\n      this.tweens.add({\n        targets: triangle,\n        scaleY: 0.8,           // 压扁效果\n        scaleX: 1.1,           // 横向拉伸\n        duration: 375,         // 0.375 秒\n        ease: 'Quad.easeIn',   // 加速下落\n        yoyo: true,            // 恢复形状\n        hold: 100              // 在压扁状态保持 0.1 秒\n      });\n    },\n    callbackScope: this\n  });\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '绿色三角形弹跳动画\\n循环周期：3秒', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000439_v1", "prompt_id": "seed_000439", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果，从 1.0 到 0.8 再回到 1.0\n4. 设置 Tween 的 loop 属性为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 在屏幕中心创建方块精灵\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 创建缩放动画\n  // yoyo: true 表示动画会反向播放（缩小后再放大）\n  // duration: 2000 表示单程 2 秒，来回共 4 秒\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 2000,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字提示\n  this.add.text(400, 500, 'Square scaling animation (loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000548_v2", "prompt_id": "seed_000548", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色圆形以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色圆形以120速度移动并在边界反弹\nAPI: Graphics, arcade.sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制橙色圆形并生成纹理\n2. 创建 arcade 物理精灵并应用纹理\n3. 设置精灵初始速度为120\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径为25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('orangeCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，释放内存\n  \n  // 创建物理精灵，位置在画布中心\n  const circle = this.physics.add.sprite(400, 300, 'orangeCircle');\n  \n  // 设置圆形为圆形碰撞体（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置初始速度（120像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 120);\n  circle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置完全反弹（弹性系数为1）\n  circle.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000662_v3", "prompt_id": "seed_000662", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 240 像素/秒的速度移动\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建 Scene 配置，设置画布尺寸\n2. 在 create 中使用 Graphics 绘制一个方块并生成纹理\n3. 创建 Sprite 或 Rectangle 对象作为可控制的方块\n4. 使用 this.input.keyboard.addKey 监听 WASD 键\n5. 在 update 中根据按键状态更新方块位置，速度为 240 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块，初始位置在画布中心\n  player = this.add.image(400, 300, 'playerBlock');\n\n  // 设置 WASD 键监听\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态移动方块\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n\n  // 限制方块在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000004_v2", "prompt_id": "seed_000004", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色椭圆并生成纹理\n3. 创建物理精灵并应用椭圆纹理\n4. 设置初始速度为 200（斜向移动）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制椭圆（中心在 50, 30，宽 100，高 60）\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 100, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（斜向移动，速度大小约为 200）\n  // 使用勾股定理：√(141² + 141²) ≈ 200\n  ellipse.setVelocity(141, 141);\n  \n  // 设置与世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000126_v1", "prompt_id": "seed_000126", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色菱形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色菱形在1.5秒内左右往返循环移动\nAPI: Graphics.fillStyle, Graphics.fillPath, Tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制灰色菱形形状\n2. 创建补间动画，设置从左到右的移动（x坐标变化）\n3. 配置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n5. 设置 duration 为 1500 毫秒（1.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制菱形（使用路径）\n  const diamondSize = 50;\n  graphics.beginPath();\n  graphics.moveTo(0, -diamondSize); // 上顶点\n  graphics.lineTo(diamondSize, 0);  // 右顶点\n  graphics.lineTo(0, diamondSize);  // 下顶点\n  graphics.lineTo(-diamondSize, 0); // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置初始位置（左侧）\n  const startX = 100;\n  const endX = 700;\n  const centerY = 300;\n  \n  graphics.setPosition(startX, centerY);\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: graphics,\n    x: endX,              // 目标 x 坐标（右侧）\n    duration: 1500,       // 持续时间 1.5 秒\n    ease: 'Linear',       // 线性缓动\n    yoyo: true,           // 启用往返效果（到达终点后反向播放）\n    repeat: -1            // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000744_v2", "prompt_id": "seed_000744", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让橙色菱形在 3 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色菱形在3秒内完成一次闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色菱形并生成纹理\n2. 创建 Sprite 使用生成的菱形纹理\n3. 使用 Tween 动画控制 alpha 属性实现闪烁效果（0->1->0，3秒循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFF8C00, 1);\n  \n  // 绘制菱形（中心点在 50, 50，边长约70像素）\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 上顶点\n  graphics.lineTo(100, 50);    // 右顶点\n  graphics.lineTo(50, 100);    // 下顶点\n  graphics.lineTo(0, 50);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中显示\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建闪烁动画\n  // 使用 Tween 控制 alpha 值：从1到0再到1，持续3秒，无限循环\n  this.tweens.add({\n    targets: diamond,\n    alpha: {\n      from: 1,\n      to: 0\n    },\n    duration: 1500,  // 1.5秒变暗\n    yoyo: true,      // 自动反向回到1（再1.5秒变亮）\n    repeat: -1,      // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '橙色菱形闪烁动画（3秒一次循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000211_v3", "prompt_id": "seed_000211", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色圆形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色圆形在0.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制青色圆形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(25, 25, 25); // 绘制半径为25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('cyanCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为纹理已生成\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'cyanCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧位置）\n    duration: 500,             // 持续时间 0.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '青色圆形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000563_v2", "prompt_id": "seed_000563", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的紫色三角形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的紫色三角形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景大小为 800x600\n2. 在 create 方法中使用循环创建5个 Graphics 对象\n3. 为每个 Graphics 对象设置紫色填充样式（0x800080）\n4. 使用 fillTriangle 方法绘制等边三角形，边长64像素\n5. 使用 setRandomPosition 方法将三角形随机放置在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建5个紫色三角形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充样式\n    graphics.fillStyle(0x800080, 1);\n    \n    // 绘制等边三角形\n    // 三角形的三个顶点坐标（相对于 graphics 对象的原点）\n    // 顶点：(0, -h), (-w/2, h/2), (w/2, h/2)\n    // 其中 h = 64 * sqrt(3) / 2 ≈ 55.4\n    const size = 64;\n    const height = size * Math.sqrt(3) / 2;\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶部顶点\n      -size / 2, height / 2,    // 左下顶点\n      size / 2, height / 2      // 右下顶点\n    );\n    \n    // 随机设置位置（确保三角形完全在画布内）\n    const margin = size / 2;\n    graphics.setPosition(\n      Phaser.Math.Between(margin, 800 - margin),\n      Phaser.Math.Between(margin, 600 - margin)\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000696_v3", "prompt_id": "seed_000696", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色星形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色星形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser 游戏配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的五个顶点和五个内凹点坐标（使用三角函数）\n4. 使用 Graphics API 绘制星形路径并填充橙色\n5. 将星形定位在画布中央（400, 300）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 40; // 外半径（星形尖端到中心的距离）\n  const innerRadius = 16; // 内半径（内凹点到中心的距离）\n  const points = 5; // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制星形的所有顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 计算角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000141_v3", "prompt_id": "seed_000141", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色圆形以300速度移动并在画布边界反弹\nAPI: Graphics.fillCircle, Physics.Arcade.Sprite, setVelocity, setBounce, setCollideWorldBounds\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制白色圆形并生成纹理\n3. 创建物理精灵并设置初始速度\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(25, 25, 25); // 中心点(25,25)，半径25\n  \n  // 生成纹理\n  graphics.generateTexture('whiteBall', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ball = this.physics.add.sprite(400, 300, 'whiteBall');\n  \n  // 设置初始速度（随机方向，速度300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 300;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 300;\n  ball.setVelocity(velocityX, velocityY);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ball.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  ball.setCollideWorldBounds(true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000253_v3", "prompt_id": "seed_000253", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色椭圆在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色椭圆4秒左右往返循环补间动画\nAPI: this.add.graphics, graphics.fillEllipse, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制紫色椭圆\n2. 创建补间动画，设置 x 坐标从左到右移动，持续 4 秒\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制紫色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillEllipse(0, 0, 80, 50); // 在中心点绘制椭圆，宽80高50\n  \n  // 将 graphics 转换为纹理以便用于精灵\n  graphics.generateTexture('ellipse', 80, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建椭圆精灵\n  const ellipse = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipse,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 4000, // 持续 4 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 往返效果\n    repeat: -1 // 无限循环（-1 表示永远重复）\n  });\n  \n  // 添加文字提示\n  this.add.text(300, 50, '紫色椭圆往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000709_v1", "prompt_id": "seed_000709", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让黄色六边形在 1 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色六边形淡入淡出循环动画\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制黄色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tweens 创建 alpha 透明度动画（0到1）\n4. 设置 yoyo 为 true 实现淡入淡出效果\n5. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制黄色六边形\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点坐标（中心在 64, 64，半径 50）\n  const radius = 50;\n  const centerX = 64;\n  const centerY = 64;\n  const hexagonPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    hexagonPoints.push(x, y);\n  }\n  \n  // 绘制黄色六边形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillPolygon(hexagonPoints);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 128, 128);\n  graphics.destroy(); // 销毁 graphics 对象，不再需要\n  \n  // 创建精灵对象\n  const hexagonSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果，duration 1000ms 表示淡入+淡出总共 2 秒\n  // 要实现 1 秒完成淡入淡出，每个方向需要 500ms\n  this.tweens.add({\n    targets: hexagonSprite,\n    alpha: 0,           // 从当前 alpha(1) 淡出到 0\n    duration: 500,      // 淡出持续 500ms\n    yoyo: true,         // 启用 yoyo 效果，淡出后自动淡入\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '黄色六边形淡入淡出循环动画', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000041_v2", "prompt_id": "seed_000041", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 600。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次后需落地，跳跃力度200，重力600\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理系统配置，设置重力为600\n2. 使用Graphics绘制玩家角色和地面平台\n3. 添加键盘输入监听，检测空格键跳跃\n4. 实现双跳逻辑：记录跳跃次数，最多允许2次跳跃\n5. 检测角色与地面碰撞，落地时重置跳跃次数\n6. 添加文本显示当前跳跃次数状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet jumpCount = 0; // 当前已跳跃次数\nlet maxJumps = 2; // 最大跳跃次数\nlet jumpPower = -200; // 跳跃力度\nlet statusText;\n\nfunction preload() {\n  // 使用Graphics创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建地面\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x4a4a4a, 1);\n  groundGraphics.fillRect(0, 550, 800, 50);\n  groundGraphics.generateTexture('groundTex', 800, 50);\n  groundGraphics.destroy();\n\n  ground = this.physics.add.staticSprite(400, 575, 'groundTex');\n  ground.setOrigin(0.5, 0.5);\n  ground.refreshBody();\n\n  // 创建玩家角色\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 50);\n  // 添加眼睛使角色更生动\n  playerGraphics.fillStyle(0x000000, 1);\n  playerGraphics.fillCircle(12, 15, 4);\n  playerGraphics.fillCircle(28, 15, 4);\n  playerGraphics.generateTexture('playerTex', 40, 50);\n  playerGraphics.destroy();\n\n  player = this.physics.add.sprite(400, 300, 'playerTex');\n  player.setCollideWorldBounds(true);\n\n  // 添加碰撞检测\n  this.physics.add.collider(player, ground, () => {\n    // 当玩家与地面接触时，重置跳跃次数\n    if (player.body.touching.down) {\n      jumpCount = 0;\n    }\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 添加状态文本显示\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(16, 50, '按空格键跳跃（最多2次）\\n方向键左右移动', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  updateStatusText();\n}\n\nfunction update() {\n  // 水平移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 双跳逻辑\n  if (Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    // 检查是否还能跳跃\n    if (jumpCount < maxJumps) {\n      player.setVelocityY(jumpPower);\n      jumpCount++;\n      updateStatusText();\n      \n      // 添加视觉反馈 - 跳跃时改变颜色\n      if (jumpCount === 1) {\n        player.setTint(0xffff00); // 第一次跳跃变黄色\n      } else if (jumpCount === 2) {\n        player.setTint(0xff8800); // 第二次跳跃变橙色\n      }\n    }\n  }\n\n  // 检测玩家是否在地面上，重置颜色\n  if (player.body.touching.down && jumpCount === 0) {\n    player.clearTint();\n  }\n\n  // 更新状态显示\n  updateStatusText();\n}\n\nfunction updateStatusText() {\n  const remainingJumps = maxJumps - jumpCount;\n  const onGround = player && player.body && player.body.touching.down;\n  \n  statusText.setText(\n    `跳跃次数: ${jumpCount}/${maxJumps}\\n` +\n    `剩余跳跃: ${remainingJumps}\\n` +\n    `是否在地面: ${onGround ? '是' : '否'}\\n` +\n    `速度Y: ${player ? Math.round(player.body.velocity.y) : 0}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000812_v2", "prompt_id": "seed_000812", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
