{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色菱形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建绿色菱形，使用 Tween 实现 1.5 秒弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制绿色菱形形状并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建 y 轴方向的弹跳动画，设置 ease 为 'Bounce.easeOut'\n4. 配置 duration 为 1500ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（四个点构成的多边形）\n  const size = 50;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中央偏上位置\n  const diamond = this.add.sprite(400, 200, 'diamond');\n  \n  // 创建弹跳动画\n  // 从当前位置向下弹跳 200 像素\n  this.tweens.add({\n    targets: diamond,\n    y: 400,                    // 目标 y 坐标（向下移动）\n    duration: 1500,            // 持续时间 1.5 秒\n    ease: 'Bounce.easeOut',    // 弹跳缓动效果\n    yoyo: true,                // 来回运动（下去再上来）\n    repeat: -1,                // 无限循环\n    hold: 0,                   // 到达目标点后立即返回\n    repeatDelay: 0             // 每次重复之间无延迟\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 550, '绿色菱形弹跳动画 (1.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000215_v3", "prompt_id": "seed_000215", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让紫色方块在 4 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建紫色方块淡入淡出动画，4秒循环一次\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 loop 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建紫色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('purpleSquare', 100, 100);\n  graphics.destroy();\n\n  // 创建紫色方块精灵，放置在屏幕中心\n  const square = this.add.sprite(400, 300, 'purpleSquare');\n\n  // 创建淡入淡出动画\n  // 4秒完成一次完整的淡入淡出循环\n  // yoyo: true 表示动画会反向播放（淡入后淡出）\n  // repeat: -1 表示无限循环\n  this.tweens.add({\n    targets: square,\n    alpha: 0,           // 目标透明度为0（完全透明）\n    duration: 2000,     // 单向动画持续2秒\n    yoyo: true,         // 启用往返效果（淡出后再淡入）\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut' // 使用正弦缓动函数，使动画更平滑\n  });\n\n  // 添加文字说明\n  this.add.text(400, 500, 'Purple Square Fade In/Out Animation', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000438_v2", "prompt_id": "seed_000438", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色椭圆以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色椭圆以120速度移动并在画布边界反弹\nAPI: Graphics, arcade.sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制绿色椭圆并生成纹理\n2. 启用 arcade 物理系统创建精灵\n3. 设置精灵速度为120，启用边界碰撞和反弹\n4. 配置世界边界以实现反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建绿色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆 (中心x, 中心y, 宽度, 高度)\n  graphics.generateTexture('greenEllipse', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'greenEllipse');\n  \n  // 设置初始速度 (使用勾股定理使合速度约为120)\n  // 120 = sqrt(vx^2 + vy^2)\n  // 设置为 (85, 85) 约等于 120\n  ellipse.setVelocity(85, 85);\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1，实现完美反弹\n  ellipse.setBounce(1, 1);\n  \n  // 确保世界边界已启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000275_v1", "prompt_id": "seed_000275", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 3 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在3秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建使用该纹理的 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 3 秒，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制菱形（四个点组成的多边形）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 上顶点\n  graphics.lineTo(centerX + size, centerY);      // 右顶点\n  graphics.lineTo(centerX, centerY + size);      // 下顶点\n  graphics.lineTo(centerX - size, centerY);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('diamond', 100, 100);\n  \n  // 销毁 Graphics 对象（已经生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建使用菱形纹理的精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，持续 3 秒，循环播放\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    alpha: 1,                   // 目标透明度值（完全不透明）\n    duration: 3000,             // 持续时间 3 秒（3000 毫秒）\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 来回播放（透明->不透明->透明）\n    repeat: -1                  // 无限循环（-1 表示永远重复）\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 550, '菱形透明度循环动画（3秒周期）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000252_v1", "prompt_id": "seed_000252", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让橙色菱形在 3 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色菱形在3秒内完成一次闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色菱形并生成纹理\n2. 创建 Sprite 使用生成的菱形纹理\n3. 使用 Tween 动画控制 alpha 属性实现闪烁效果（0->1->0，3秒循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFF8C00, 1);\n  \n  // 绘制菱形（中心点在 50, 50，边长约70像素）\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 上顶点\n  graphics.lineTo(100, 50);    // 右顶点\n  graphics.lineTo(50, 100);    // 下顶点\n  graphics.lineTo(0, 50);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中显示\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建闪烁动画\n  // 使用 Tween 控制 alpha 值：从1到0再到1，持续3秒，无限循环\n  this.tweens.add({\n    targets: diamond,\n    alpha: {\n      from: 1,\n      to: 0\n    },\n    duration: 1500,  // 1.5秒变暗\n    yoyo: true,      // 自动反向回到1（再1.5秒变亮）\n    repeat: -1,      // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '橙色菱形闪烁动画（3秒一次循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000211_v3", "prompt_id": "seed_000211", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 3 个金币，重力 600，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集3个金币，重力600，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建带 Arcade 物理系统的场景配置，设置重力为 600\n2. 使用 Graphics 绘制玩家（矩形）和平台（矩形），生成纹理\n3. 使用 Graphics 绘制金币（圆形），创建3个金币物理精灵并放置在空中\n4. 添加键盘输入监听（方向键），实现左右移动和跳跃\n5. 添加碰撞检测：玩家与平台、玩家与金币（overlap）\n6. 收集金币时增加分数并销毁金币，使用 Text 显示分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 400, 32);\n    platformGraphics.generateTexture('platform', 400, 32);\n    platformGraphics.destroy();\n\n    // 创建金币纹理\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffff00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n\n    // 创建玩家（物理精灵）\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 地面平台\n    this.platforms.create(200, 568, 'platform');\n    this.platforms.create(600, 568, 'platform');\n    \n    // 中层平台\n    this.platforms.create(400, 400, 'platform').setScale(0.6).refreshBody();\n    this.platforms.create(150, 300, 'platform').setScale(0.5).refreshBody();\n    this.platforms.create(650, 300, 'platform').setScale(0.5).refreshBody();\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 放置3个金币在空中\n    this.coins.create(400, 320, 'coin');\n    this.coins.create(150, 220, 'coin');\n    this.coins.create(650, 220, 'coin');\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 添加重叠检测（收集金币）\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加游戏说明\n    this.add.text(16, 56, 'Arrow Keys: Move & Jump', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      this.add.text(400, 300, 'YOU WIN!', {\n        fontSize: '64px',\n        fill: '#ffff00',\n        fontFamily: 'Arial'\n      }).setOrigin(0.5);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000970_v3", "prompt_id": "seed_000970", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按鼠标左键向当前朝向发射子弹，子弹速度 360，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现玩家旋转朝向，鼠标左键向当前方向发射速度360的子弹\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Group, Phaser.Math.Angle.Between, Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\nSTEPS:\n1. 创建玩家精灵，使用Graphics生成三角形纹理表示朝向\n2. 监听键盘输入（WASD/方向键）控制玩家移动，鼠标移动控制旋转朝向\n3. 监听鼠标左键点击，创建子弹并使用velocityFromAngle设置速度360\n4. 使用Physics.Arcade.Group管理子弹池，子弹超出边界自动回收\n5. 添加bulletsFired计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 可验证状态信号\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（三角形表示方向）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(20, 0);  // 尖端指向右侧\n    playerGraphics.lineTo(-10, -10);\n    playerGraphics.lineTo(-10, 10);\n    playerGraphics.closePath();\n    playerGraphics.fillPath();\n    playerGraphics.generateTexture('player', 30, 20);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（小圆点）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDrag(500);\n    this.player.setMaxVelocity(300);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: true\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keys = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 鼠标输入\n    this.input.on('pointermove', (pointer) => {\n      // 计算玩家到鼠标的角度\n      const angle = Phaser.Math.Angle.Between(\n        this.player.x,\n        this.player.y,\n        pointer.x,\n        pointer.y\n      );\n      this.player.rotation = angle;\n    });\n\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.leftButtonDown()) {\n        this.fireBullet();\n      }\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 添加说明文字\n    this.add.text(10, 550, 'WASD/方向键移动 | 鼠标移动旋转 | 左键射击', {\n      fontSize: '14px',\n      fill: '#00ff00'\n    });\n  }\n\n  fireBullet() {\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹角度和速度\n      bullet.rotation = this.player.rotation;\n      \n      // 使用velocityFromAngle设置速度为360\n      const angle = Phaser.Math.RadToDeg(this.player.rotation);\n      this.physics.velocityFromAngle(angle, 360, bullet.body.velocity);\n      \n      // 设置子弹生命周期\n      bullet.lifespan = 2000; // 2秒后消失\n      bullet.birthTime = this.time.now;\n      \n      this.bulletsFired++;\n    }\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const acceleration = 400;\n    \n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setAccelerationX(-acceleration);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setAccelerationX(acceleration);\n    } else {\n      this.player.setAccelerationX(0);\n    }\n\n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setAccelerationY(-acceleration);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setAccelerationY(acceleration);\n    } else {\n      this.player.setAccelerationY(0);\n    }\n\n    // 更新子弹状态\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        // 检查子弹是否超时\n        if (time - bullet.birthTime > bullet.lifespan) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n        \n        // 检查子弹是否超出边界\n        if (bullet.x < -10 || bullet.x > 810 || \n            bullet.y < -10 || bullet.y > 610) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 更新状态显示\n    const activeBullets = this.bullets.countActive(true);\n    this.statusText.setText([\n      `子弹发射总数: ${this.bulletsFired}`,\n      `当前活跃子弹: ${activeBullets}`,\n      `玩家位置: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `玩家角度: ${Math.round(Phaser.Math.RadToDeg(this.player.rotation))}°`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000829_v1", "prompt_id": "seed_000829", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 600，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现带重力的平台跳跃游戏，角色可左右移动和跳跃，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 600\n2. 使用 Graphics 创建玩家角色和地面平台\n3. 添加键盘输入监听（方向键），实现左右移动（速度 200）和跳跃\n4. 设置玩家与地面的碰撞检测，确保不穿透\n5. 添加状态变量（jumpCount）用于验证游戏状态\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家精灵（启用物理）\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setCollideWorldBounds(true); // 限制在世界边界内\n    this.player.setBounce(0); // 无弹性\n\n    // 创建地面组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加主地面\n    this.platforms.create(400, 575, 'ground');\n    \n    // 添加几个平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(500, 350, 'platform');\n    this.platforms.create(700, 250, 'platform');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, '方向键←→移动，↑或空格跳跃', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 检测是否在地面上（通过速度判断）\n    if (this.player.body.touching.down) {\n      this.isGrounded = true;\n    } else {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200); // 向左移动，速度 200\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200); // 向右移动，速度 200\n    } else {\n      this.player.setVelocityX(0); // 停止水平移动\n    }\n\n    // 跳跃控制（只有在地面上才能跳跃）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.isGrounded) {\n      this.player.setVelocityY(-400); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `跳跃次数: ${this.jumpCount}`,\n      `位置: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      `在地面: ${this.isGrounded ? '是' : '否'}`,\n      `速度: (${Math.floor(this.player.body.velocity.x)}, ${Math.floor(this.player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb', // 天空蓝背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 }, // 重力设置为 600\n      debug: false // 设为 true 可查看碰撞边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000945_v1", "prompt_id": "seed_000945", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9466666666666668}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 360，重力 400。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可在空中跳跃一次，跳跃力度360，重力400\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建带物理系统的场景，设置重力为400\n2. 使用Graphics绘制玩家角色和地面平台\n3. 添加键盘输入监听，检测空格键跳跃\n4. 维护跳跃计数器，允许最多2次跳跃\n5. 角色落地时重置跳跃计数器\n6. 显示跳跃状态文本用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.jumpCount = 0; // 跳跃计数器（可验证状态）\n    this.maxJumps = 2; // 最大跳跃次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（使用Graphics）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 60);\n    groundGraphics.generateTexture('ground', 800, 60);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵（带物理属性）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0);\n\n    // 创建地面平台\n    this.ground = this.physics.add.staticGroup();\n    this.ground.create(400, 580, 'ground');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.ground, () => {\n      // 玩家接触地面时重置跳跃计数\n      if (this.player.body.touching.down) {\n        this.jumpCount = 0;\n      }\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息（用于验证）\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 60, 'Press SPACE to jump (Max 2 jumps)', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 双跳逻辑\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      // 检查是否还有跳跃次数\n      if (this.jumpCount < this.maxJumps) {\n        this.player.setVelocityY(-360); // 跳跃力度360\n        this.jumpCount++;\n        this.updateStatus();\n      }\n    }\n\n    // 当玩家接触地面时重置跳跃计数\n    if (this.player.body.touching.down && this.jumpCount > 0) {\n      this.jumpCount = 0;\n      this.updateStatus();\n    }\n  }\n\n  updateStatus() {\n    // 更新状态文本显示\n    const remainingJumps = this.maxJumps - this.jumpCount;\n    const onGround = this.player.body.touching.down;\n    this.statusText.setText(\n      `Jumps Used: ${this.jumpCount}/${this.maxJumps} | ` +\n      `Remaining: ${remainingJumps} | ` +\n      `On Ground: ${onGround}`\n    );\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 }, // 重力设置为400\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000832_v3", "prompt_id": "seed_000832", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的粉色椭圆，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的粉色椭圆，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次\n3. 每次循环创建一个 Graphics 对象，设置粉色填充样式\n4. 使用 fillEllipse 绘制椭圆（中心点0,0，半径32x32，形成64像素大小）\n5. 使用 setRandomPosition 将每个椭圆放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建20个粉色椭圆\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式 (RGB: 255, 192, 203)\n    graphics.fillStyle(0xffc0cb, 1);\n    \n    // 绘制椭圆：中心点(0, 0)，水平半径32，垂直半径32\n    // 这样创建的椭圆总大小为 64x64 像素\n    graphics.fillEllipse(0, 0, 64, 64);\n    \n    // 设置随机位置\n    // x: 32 到 768 之间（确保椭圆完全在画布内）\n    // y: 32 到 568 之间\n    graphics.setRandomPosition(32, 32, 736, 536);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000727_v2", "prompt_id": "seed_000727", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左上显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左上角显示 \"Hello Phaser\" 文字，字体大小 80 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 80px，位置在左上角\n[/PLAN]\n\n```javascript\n// 创建场景类\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n  }\n\n  preload() {\n    // 本任务不需要预加载资源\n  }\n\n  create() {\n    // 在左上角 (10, 10) 位置创建文本\n    // 字体大小设置为 80px\n    const text = this.add.text(10, 10, 'Hello Phaser', {\n      fontSize: '80px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    });\n\n    // 设置文本原点为左上角（默认就是左上角，这里显式设置以确保）\n    text.setOrigin(0, 0);\n  }\n\n  update(time, delta) {\n    // 本任务不需要更新逻辑\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000328_v1", "prompt_id": "seed_000328", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Graphics 对象绘制矩形\n2. 设置矩形初始 alpha 为 0（完全透明）\n3. 使用 tweens 创建 alpha 从 0 到 1 的渐变动画\n4. 设置动画持续时间为 2000ms，循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制一个居中的矩形（200x150）\n  const rectX = 300;\n  const rectY = 225;\n  const rectWidth = 200;\n  const rectHeight = 150;\n  graphics.fillRect(rectX, rectY, rectWidth, rectHeight);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建渐变动画：从透明（alpha: 0）到不透明（alpha: 1）\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    alpha: 1,                    // 目标透明度值\n    duration: 2000,              // 持续时间 2 秒\n    ease: 'Linear',              // 线性缓动\n    loop: -1,                    // 无限循环\n    yoyo: true                   // 来回播放（透明->不透明->透明）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Rectangle Fade Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Alpha: 0 → 1 (2 seconds, looping)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000285_v3", "prompt_id": "seed_000285", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 200，移动速度 300，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色可左右移动和跳跃，具有重力和地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 200\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建物理精灵作为角色，设置碰撞体积\n4. 创建静态物理组作为地面平台\n5. 设置角色与地面的碰撞检测\n6. 监听键盘输入（方向键），实现左右移动（速度 300）和跳跃\n7. 添加状态变量记录跳跃次数和是否在地面\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号：跳跃次数\n    this.isGrounded = false; // 可验证的状态信号：是否在地面\n    this.moveDistance = 0; // 可验证的状态信号：移动距离\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0099ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 200, 40);\n    groundGraphics.generateTexture('ground', 200, 40);\n    groundGraphics.destroy();\n\n    // 创建角色精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true); // 角色不超出世界边界\n    this.player.body.setGravityY(200); // 设置重力为 200\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加多个平台\n    this.platforms.create(400, 568, 'ground').setScale(4, 1).refreshBody(); // 主地面\n    this.platforms.create(200, 450, 'ground').setScale(1.5, 1).refreshBody(); // 左侧平台\n    this.platforms.create(600, 400, 'ground').setScale(1.5, 1).refreshBody(); // 右侧平台\n    this.platforms.create(400, 250, 'ground').setScale(1, 1).refreshBody(); // 顶部平台\n\n    // 设置角色与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(16, 60, '← → 移动 | ↑ 或 空格 跳跃', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新状态信息\n    this.statusText.setText([\n      `跳跃次数: ${this.jumpCount}`,\n      `移动距离: ${Math.floor(this.moveDistance)}`,\n      `在地面: ${this.isGrounded ? '是' : '否'}`,\n      `速度Y: ${Math.floor(this.player.body.velocity.y)}`\n    ]);\n\n    // 检测是否在地面（通过垂直速度判断）\n    if (this.player.body.touching.down) {\n      this.isGrounded = true;\n    } else {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300); // 向左移动，速度 300\n      this.moveDistance += Math.abs(delta * 0.3); // 累计移动距离\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300); // 向右移动，速度 300\n      this.moveDistance += Math.abs(delta * 0.3);\n    } else {\n      this.player.setVelocityX(0); // 停止移动\n    }\n\n    // 跳跃控制（上方向键或空格键）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.isGrounded) {\n      this.player.setVelocityY(-400); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n      this.isGrounded = false; // 离开地面\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB', // 天蓝色背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 全局重力设为 0，由角色自身重力控制\n      debug: false // 设为 true 可查看碰撞边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000885_v2", "prompt_id": "seed_000885", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让圆形在2秒内缩放到48%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制一个圆形\n2. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.48\n3. 设置 yoyo 为 true 实现自动恢复，duration 为 2000ms\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个圆形图形对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制圆形（中心点在 0,0，半径为 50）\n  graphics.fillCircle(0, 0, 50);\n  \n  // 设置圆形位置到画布中心\n  graphics.setPosition(400, 300);\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    scaleX: 0.48,               // X 轴缩放到 48%\n    scaleY: 0.48,               // Y 轴缩放到 48%\n    duration: 2000,             // 动画持续时间 2 秒\n    yoyo: true,                 // 动画结束后反向播放（恢复到原始大小）\n    repeat: -1,                 // 无限循环（-1 表示永久重复）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 48% (2秒一个周期)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000606_v1", "prompt_id": "seed_000606", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形\n2. 使用 tweens.add 创建缩放补间动画\n3. 设置 scale 属性从 1 缩放到 0.8，duration 为 3000ms\n4. 设置 yoyo 为 true 实现往返效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个矩形 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制一个矩形（中心点在 0,0）\n  const rectWidth = 200;\n  const rectHeight = 150;\n  graphics.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);\n  \n  // 设置矩形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放补间动画\n  this.tweens.add({\n    targets: graphics,        // 动画目标对象\n    scaleX: 0.8,             // X 轴缩放到 80%\n    scaleY: 0.8,             // Y 轴缩放到 80%\n    duration: 3000,          // 持续时间 3 秒\n    yoyo: true,              // 启用往返效果（缩放后自动恢复）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'   // 缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '矩形将在 3 秒内缩放到 80% 并循环播放', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000646_v1", "prompt_id": "seed_000646", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Graphics 对象绘制椭圆形状\n2. 设置椭圆初始透明度为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 2 秒\n4. 设置 Tween 为循环播放（yoyo + repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制椭圆（中心位置，水平半径，垂直半径）\n  graphics.fillEllipse(400, 300, 150, 100);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.alpha = 0;\n  \n  // 创建 Tween 动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 2000,              // 持续时间 2 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 来回播放（1->0->1）\n    repeat: -1                   // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000436_v2", "prompt_id": "seed_000436", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让橙色菱形在 3 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建橙色菱形在3秒内完成闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setAlpha\nSTEPS:\n1. 使用 Graphics 绘制橙色菱形并生成纹理\n2. 创建 Sprite 使用生成的菱形纹理\n3. 使用 Tween 动画控制 alpha 透明度实现闪烁效果（0→1→0）\n4. 设置 duration 为 3000ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制橙色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 绘制菱形（中心点在 64, 64，宽高各 128）\n  graphics.beginPath();\n  graphics.moveTo(64, 0);      // 顶点\n  graphics.lineTo(128, 64);    // 右点\n  graphics.lineTo(64, 128);    // 底点\n  graphics.lineTo(0, 64);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  \n  // 销毁 Graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用菱形纹理的 Sprite\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建闪烁动画 Tween\n  this.tweens.add({\n    targets: diamond,\n    alpha: 0,              // 目标透明度为 0（完全透明）\n    duration: 1500,        // 单程 1.5 秒\n    yoyo: true,            // 启用往返效果（0→1→0）\n    repeat: -1,            // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 550, '橙色菱形闪烁动画（3秒一个循环）', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000211_v2", "prompt_id": "seed_000211", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 80 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Scene.input.keyboard.addKey\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建 Sprite 使用六边形纹理\n4. 添加 WASD 键盘输入监听\n5. 在 update 中根据按键状态移动六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet cursors;\nconst SPEED = 80;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制六边形（中心点在 32, 32）\n  const hexRadius = 30;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = 32 + hexRadius * Math.cos(angle);\n    const y = 32 + hexRadius * Math.sin(angle);\n    hexPoints.push(x, y);\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0], hexPoints[1]);\n  for (let i = 2; i < hexPoints.length; i += 2) {\n    graphics.lineTo(hexPoints[i], hexPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 64, 64);\n  graphics.destroy();\n  \n  // 创建六边形精灵，放置在屏幕中央\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 添加 WASD 键盘输入\n  cursors = {\n    w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检查 WASD 键状态并设置移动方向\n  if (cursors.w.isDown) {\n    velocityY = -1;\n  } else if (cursors.s.isDown) {\n    velocityY = 1;\n  }\n  \n  if (cursors.a.isDown) {\n    velocityX = -1;\n  } else if (cursors.d.isDown) {\n    velocityX = 1;\n  }\n  \n  // 归一化对角线移动速度（避免对角线移动过快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n  \n  // 应用移动\n  hexagon.x += velocityX * distance;\n  hexagon.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000343_v3", "prompt_id": "seed_000343", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 120 像素/秒的速度移动\nAPI: Scene.add.graphics, Scene.input.keyboard.addKeys, Scene.time.delta\nSTEPS:\n1. 创建 Graphics 对象绘制矩形作为玩家\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间计算位置偏移\n4. 更新矩形位置实现移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 玩家对象\nlet player;\n// 键盘控制\nlet keys;\n// 移动速度（像素/秒）\nconst SPEED = 120;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形（使用 Graphics）\n  player = this.add.graphics();\n  player.fillStyle(0x00ff00, 1); // 绿色矩形\n  player.fillRect(0, 0, 40, 40); // 40x40 的矩形\n  \n  // 设置初始位置（居中）\n  player.x = 400 - 20; // 减去矩形宽度的一半\n  player.y = 300 - 20; // 减去矩形高度的一半\n  \n  // 添加 WASD 键盘监听\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the rectangle', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置移动向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 WASD 按键状态\n  if (keys.W.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.S.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.A.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.D.isDown) {\n    velocityX = 1; // 向右\n  }\n  \n  // 处理斜向移动（归一化向量，保持恒定速度）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const factor = Math.sqrt(2) / 2; // 约 0.707\n    velocityX *= factor;\n    velocityY *= factor;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n  \n  // 边界限制（防止矩形移出屏幕）\n  player.x = Phaser.Math.Clamp(player.x, 0, 800 - 40);\n  player.y = Phaser.Math.Clamp(player.y, 0, 600 - 40);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000685_v1", "prompt_id": "seed_000685", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 0.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在 0.5 秒内缩放到 16% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制星形并生成纹理\n2. 创建星形精灵对象\n3. 使用 Tween 实现缩放动画（scale: 1 -> 0.16 -> 1）\n4. 设置 Tween 循环播放（loop: -1）\n5. 设置动画持续时间为 0.5 秒，使用 yoyo 实现往返效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = 64 + Math.cos(angle) * radius;\n    const y = 64 + Math.sin(angle) * radius;\n    points.push(x, y);\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 128, 128);\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中心\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  // 从 1 缩放到 0.16，然后返回到 1，每个方向 0.5 秒\n  this.tweens.add({\n    targets: star,\n    scale: 0.16,           // 目标缩放值 16%\n    duration: 500,         // 持续时间 0.5 秒\n    yoyo: true,            // 启用往返效果（缩小后再放大）\n    loop: -1,              // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 550, 'Star scaling animation (1.0 → 0.16 → 1.0)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 本示例不需要每帧更新逻辑\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000157_v3", "prompt_id": "seed_000157", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色星形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色星形以160速度移动并在边界反弹\nAPI: Graphics.fillStyle, Graphics.fillStar, Graphics.generateTexture, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制紫色星形并生成纹理\n2. 创建物理精灵并应用星形纹理\n3. 设置初始速度为 160（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色星形\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9933ff, 1);\n  \n  // 绘制星形（中心点, 5个角, 内半径, 外半径）\n  graphics.fillStar(50, 50, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置初始速度（160 速度，斜向移动）\n  // 使用勾股定理：速度分量 = 160 / √2 ≈ 113\n  star.setVelocity(113, 113);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  star.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 添加提示文本\n  this.add.text(10, 10, '紫色星形以160速度移动并反弹', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000062_v2", "prompt_id": "seed_000062", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制圆形，并添加一个标记线以便观察旋转\n2. 将 Graphics 添加到 Container 中以便控制旋转中心\n3. 在 update 方法中根据 delta 时间累加旋转角度（240度/秒 = 每毫秒 0.24 度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建一个容器，用于控制旋转中心\n  circle = this.add.container(400, 300);\n  \n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制圆形主体\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的线，用于观察旋转\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, 0);\n  graphics.lineTo(80, 0);\n  graphics.strokePath();\n  \n  // 在圆边缘添加一个小圆点作为旋转标记\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(80, 0, 10);\n  \n  // 将 graphics 添加到容器中\n  circle.add(graphics);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形以 240°/秒 的速度旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 将每秒 240 度转换为弧度：240° = 240 * (Math.PI / 180) ≈ 4.189 弧度/秒\n  // delta 是毫秒，所以需要除以 1000\n  const rotationSpeed = Phaser.Math.DegToRad(240); // 每秒的弧度\n  const rotationThisFrame = rotationSpeed * (delta / 1000); // 本帧的旋转量\n  \n  // 累加旋转角度\n  circle.rotation += rotationThisFrame;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000238_v3", "prompt_id": "seed_000238", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色椭圆以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Ellipse, Phaser.Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制黄色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度\n4. 设置世界边界碰撞和反弹系数\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet ellipse;\nlet velocity = { x: 200, y: 200 };\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillEllipse(50, 40, 100, 80); // 绘制椭圆（中心点，宽度，高度）\n  graphics.generateTexture('ellipseTex', 100, 80);\n  graphics.destroy();\n\n  // 创建物理精灵\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置初始速度\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 设置世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // Arcade 物理系统的 setCollideWorldBounds 和 setBounce \n  // 会自动处理边界碰撞和反弹，无需手动编写逻辑\n  \n  // 如果需要确保速度保持恒定（避免浮点误差累积）\n  const currentVelocity = ellipse.body.velocity;\n  const speed = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);\n  \n  // 如果速度有偏差，重新标准化\n  if (Math.abs(speed - 282.84) > 1) { // 200*sqrt(2) ≈ 282.84\n    const angle = Math.atan2(currentVelocity.y, currentVelocity.x);\n    ellipse.setVelocity(\n      Math.cos(angle) * 200 * Math.SQRT2,\n      Math.sin(angle) * 200 * Math.SQRT2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000079_v3", "prompt_id": "seed_000079", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色方块以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色方块以160速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带物理系统的游戏配置\n2. 使用Graphics绘制黄色方块并生成纹理\n3. 创建物理精灵并设置速度和边界碰撞\n4. 在update中检测边界并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet velocityX = 160;\nlet velocityY = 160;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用Graphics绘制黄色方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('yellowSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'yellowSquare');\n  \n  // 设置初始速度\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  square.setCollideWorldBounds(true);\n  square.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 物理引擎的bounce属性会自动处理反弹\n  // 但为了确保速度恒定为160，我们手动检测边界\n  const speed = 160;\n  \n  // 获取当前速度\n  const currentVelocity = square.body.velocity;\n  \n  // 归一化速度并乘以固定速度值，保持恒定速度\n  const magnitude = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.y * currentVelocity.y);\n  \n  if (magnitude > 0) {\n    square.setVelocity(\n      (currentVelocity.x / magnitude) * speed,\n      (currentVelocity.y / magnitude) * speed\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000631_v1", "prompt_id": "seed_000631", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色星形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色星形在2秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.generateTexture, Phaser.Tweens.TweenManager.add, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制白色星形并生成纹理\n2. 创建使用该纹理的 Sprite 对象，初始位置在左侧\n3. 使用 Tweens 创建补间动画，设置 x 坐标从左到右移动，持续 2 秒\n4. 启用 yoyo 模式实现往返效果，设置 loop(-1) 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const points = 5;\n  \n  // 计算星形的顶点坐标\n  const starPoints = [];\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push({\n      x: centerX + Math.cos(angle) * radius,\n      y: centerY + Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0].x, starPoints[0].y);\n  for (let i = 1; i < starPoints.length; i++) {\n    graphics.lineTo(starPoints[i].x, starPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: star,\n    x: 700,              // 目标 x 坐标（右侧）\n    duration: 2000,      // 持续时间 2 秒\n    yoyo: true,          // 启用往返效果\n    loop: -1,            // 无限循环\n    ease: 'Linear'       // 线性缓动\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '白色星形往返循环移动', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000147_v1", "prompt_id": "seed_000147", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 设置相机边界：创建一个 1600x1200 的大场景，限制相机只能在场景范围内移动。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera", "output": "[PLAN]\nREQ: 创建1600x1200大场景，设置相机边界限制相机移动范围\nAPI: setBounds, setBackgroundColor, fillRect, createCursorKeys, scrollX, scrollY\nSTEPS:\n1. 创建1600x1200的场景配置，视口设置为800x600\n2. 使用Graphics绘制场景背景网格，标识场景范围\n3. 使用camera.setBounds设置相机边界为场景大小\n4. 添加键盘控制实现相机移动，验证边界限制\n5. 添加相机位置显示文本，实时显示相机坐标\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建大场景背景 (1600x1200)\n  const graphics = this.add.graphics();\n  \n  // 绘制场景背景 - 使用网格表示整个场景\n  graphics.fillStyle(0x1a1a1a, 1);\n  graphics.fillRect(0, 0, 1600, 1200);\n  \n  // 绘制网格线，帮助识别场景范围\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 垂直线\n  for (let x = 0; x <= 1600; x += 100) {\n    graphics.lineBetween(x, 0, x, 1200);\n  }\n  \n  // 水平线\n  for (let y = 0; y <= 1200; y += 100) {\n    graphics.lineBetween(0, y, 1600, y);\n  }\n  \n  // 绘制场景边界标识\n  graphics.lineStyle(4, 0x00ff00, 1);\n  graphics.strokeRect(2, 2, 1596, 1196);\n  \n  // 在四个角添加标记\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(50, 50, 20);\n  graphics.fillCircle(1550, 50, 20);\n  graphics.fillCircle(50, 1150, 20);\n  graphics.fillCircle(1550, 1150, 20);\n  \n  // 添加坐标文本标识\n  const style = { fontSize: '16px', fill: '#00ff00', backgroundColor: '#000000' };\n  this.add.text(60, 40, '(0, 0)', style);\n  this.add.text(1460, 40, '(1600, 0)', style);\n  this.add.text(60, 1140, '(0, 1200)', style);\n  this.add.text(1410, 1140, '(1600, 1200)', style);\n  \n  // 在中心添加标识\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(800, 600, 30);\n  this.add.text(740, 590, 'CENTER\\n(800, 600)', {\n    fontSize: '18px',\n    fill: '#ff0000',\n    backgroundColor: '#000000',\n    align: 'center'\n  });\n  \n  // **关键：设置相机边界**\n  // 限制相机只能在 1600x1200 的场景范围内移动\n  this.cameras.main.setBounds(0, 0, 1600, 1200);\n  \n  // 设置世界边界（与相机边界一致）\n  this.physics.world.setBounds(0, 0, 1600, 1200);\n  \n  // 创建键盘控制\n  this.cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加WASD控制\n  this.keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 创建固定在屏幕上的UI文本（不随相机移动）\n  this.cameraInfo = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.cameraInfo.setScrollFactor(0); // 固定在屏幕上\n  this.cameraInfo.setDepth(1000); // 确保在最上层\n  \n  // 添加操作说明\n  this.instructions = this.add.text(10, 60, \n    'Controls:\\n' +\n    '← → ↑ ↓ or WASD: Move Camera\\n' +\n    'Camera is bounded to 1600x1200 scene',\n    {\n      fontSize: '14px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }\n  );\n  this.instructions.setScrollFactor(0);\n  this.instructions.setDepth(1000);\n  \n  // 相机移动速度\n  this.cameraSpeed = 5;\n}\n\nfunction update(time, delta) {\n  const camera = this.cameras.main;\n  \n  // 使用方向键或WASD控制相机移动\n  if (this.cursors.left.isDown || this.keys.a.isDown) {\n    camera.scrollX -= this.cameraSpeed;\n  }\n  if (this.cursors.right.isDown || this.keys.d.isDown) {\n    camera.scrollX += this.cameraSpeed;\n  }\n  if (this.cursors.up.isDown || this.keys.w.isDown) {\n    camera.scrollY -= this.cameraSpeed;\n  }\n  if (this.cursors.down.isDown || this.keys.s.isDown) {\n    camera.scrollY += this.cameraSpeed;\n  }\n  \n  // 更新相机信息显示\n  const bounds = camera.getBounds();\n  this.cameraInfo.setText(\n    `Camera Position: (${Math.round(camera.scrollX)}, ${Math.round(camera.scrollY)})\\n` +\n    `Camera View: ${Math.round(bounds.x)}, ${Math.round(bounds.y)} to ` +\n    `${Math.round(bounds.right)}, ${Math.round(bounds.bottom)}\\n` +\n    `World Bounds: 0, 0 to 1600, 1200`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000014_v2", "prompt_id": "seed_000014", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9006060606060605}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Game, Phaser.Scene\nSTEPS:\n1. 创建 Graphics 对象绘制菱形形状\n2. 将 Graphics 添加到 Container 中以便于旋转控制\n3. 在 update 方法中根据 delta 时间累加旋转角度（160度/秒 = 160 * delta/1000）\n4. 使用 Container.setRotation 或 angle 属性应用旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst ROTATION_SPEED = 160; // 每秒旋转160度\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建容器用于旋转\n  diamond = this.add.container(400, 300);\n  \n  // 创建 Graphics 对象绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形样式\n  graphics.fillStyle(0x00ffff, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  // 绘制菱形（四个顶点）\n  const size = 80;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  \n  // 填充和描边\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 将 graphics 添加到容器中\n  diamond.add(graphics);\n  \n  // 添加提示文本\n  this.add.text(400, 50, '菱形旋转速度: 160°/秒', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 根据 delta 时间计算旋转增量\n  // delta 单位是毫秒，需要转换为秒\n  const rotationDelta = ROTATION_SPEED * (delta / 1000);\n  \n  // 累加旋转角度（angle 属性使用度数）\n  diamond.angle += rotationDelta;\n  \n  // 可选：防止角度值无限增长\n  if (diamond.angle >= 360) {\n    diamond.angle -= 360;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000679_v2", "prompt_id": "seed_000679", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的黄色三角形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的黄色三角形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布大小\n2. 在 create 方法中循环20次\n3. 每次循环创建一个 Graphics 对象，填充黄色\n4. 使用 fillTriangle 绘制等边三角形（边长24像素）\n5. 使用 setRandomPosition 设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建20个黄色三角形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为黄色\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制等边三角形\n    // 三角形顶点坐标（以中心为原点，边长24像素）\n    const size = 24;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    // 三个顶点坐标（相对于中心）\n    const x1 = 0;\n    const y1 = -height * 2 / 3; // 顶点\n    const x2 = -size / 2;\n    const y2 = height / 3; // 左下角\n    const x3 = size / 2;\n    const y3 = height / 3; // 右下角\n    \n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 设置随机位置（考虑三角形大小，避免超出边界）\n    const margin = 20;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000519_v1", "prompt_id": "seed_000519", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 3 个金币，重力 1000，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集3个金币，重力1000，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 配置物理系统，设置重力为1000\n2. 使用Graphics创建玩家角色、平台和金币的纹理\n3. 添加键盘输入控制（左右移动和跳跃）\n4. 实现碰撞检测：玩家与平台、玩家与金币\n5. 收集金币时增加分数并销毁金币\n6. 在屏幕上显示分数文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.2);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 地面平台\n    this.platforms.create(400, 568, 'platform').setScale(4, 1).refreshBody();\n    \n    // 中间平台\n    this.platforms.create(200, 400, 'platform');\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(400, 250, 'platform');\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在平台上方放置3个金币\n    this.coins.create(200, 350, 'coin');\n    this.coins.create(600, 350, 'coin');\n    this.coins.create(400, 200, 'coin');\n\n    // 设置金币属性\n    this.coins.children.iterate((coin) => {\n      coin.setBounceY(Phaser.Math.FloatBetween(0.4, 0.6));\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n    \n    // 添加金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontStyle: 'bold'\n    });\n\n    // 添加游戏说明\n    this.add.text(400, 50, 'Use Arrow Keys to Move and Jump\\nCollect all 3 coins!', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      align: 'center'\n    }).setOrigin(0.5);\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      this.add.text(400, 300, 'You Win!\\nScore: ' + this.score, {\n        fontSize: '48px',\n        fill: '#00ff00',\n        fontStyle: 'bold',\n        align: 'center'\n      }).setOrigin(0.5);\n      \n      // 暂停游戏\n      this.physics.pause();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000872_v2", "prompt_id": "seed_000872", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的六边形\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Graphics#generateTexture\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并应用六边形纹理\n3. 在 update 中让六边形持续向左下移动\n4. 使用 Camera.startFollow 让相机跟随六边形\n5. 设置世界边界以便观察跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst MOVE_SPEED = 100; // 每秒移动的像素数\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，让场景足够大以便观察跟随效果\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n\n  // 绘制六边形（中心点为原点）\n  const hexRadius = 30;\n  const hexPath = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = hexRadius * Math.cos(angle);\n    const y = hexRadius * Math.sin(angle);\n    hexPath.push(new Phaser.Math.Vector2(x, y));\n  }\n\n  graphics.beginPath();\n  graphics.moveTo(hexPath[0].x, hexPath[0].y);\n  for (let i = 1; i < hexPath.length; i++) {\n    graphics.lineTo(hexPath[i].x, hexPath[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n\n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2 + 10, hexRadius * 2 + 10);\n  graphics.destroy();\n\n  // 创建六边形精灵，初始位置在场景中心偏右上\n  hexagon = this.add.sprite(1000, 500, 'hexagon');\n\n  // 添加一些参考网格线以便观察移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  for (let x = 0; x <= 2000; x += 100) {\n    gridGraphics.lineTo(x, 0);\n    gridGraphics.lineTo(x, 2000);\n    gridGraphics.moveTo(x + 100, 0);\n  }\n  for (let y = 0; y <= 2000; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(2000, y);\n  }\n  gridGraphics.strokePath();\n\n  // 添加坐标文本提示\n  const infoText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机视图上\n\n  // 存储文本对象以便在 update 中更新\n  this.infoText = infoText;\n\n  // 相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 可选：设置跟随偏移，让六边形不完全居中\n  // this.cameras.main.setFollowOffset(0, 0);\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（基于帧时间）\n  const moveDistance = (MOVE_SPEED * delta) / 1000;\n\n  // 向左下移动（左：x减小，下：y增大）\n  // 45度角移动\n  const moveX = -moveDistance * Math.cos(Math.PI / 4);\n  const moveY = moveDistance * Math.sin(Math.PI / 4);\n\n  hexagon.x += moveX;\n  hexagon.y += moveY;\n\n  // 更新信息文本\n  this.infoText.setText([\n    `六边形位置: (${Math.round(hexagon.x)}, ${Math.round(hexagon.y)})`,\n    `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`,\n    '相机正在跟随六边形移动'\n  ]);\n\n  // 可选：当六边形移出世界边界时重置位置\n  if (hexagon.x < 0 || hexagon.y > 2000) {\n    hexagon.x = 1000;\n    hexagon.y = 500;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000445_v3", "prompt_id": "seed_000445", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8920833333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让青色椭圆在 2 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色椭圆在2秒内完成闪烁并循环的动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆并生成纹理\n2. 创建使用该纹理的 Sprite 对象\n3. 使用 Tween 动画控制 alpha 属性实现闪烁效果（0->1->0）\n4. 设置 duration 为 2000ms，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillEllipse(50, 40, 100, 80); // 绘制椭圆（中心点，宽度，高度）\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTexture', 100, 80);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建使用该纹理的 Sprite\n  const ellipse = this.add.sprite(400, 300, 'ellipseTexture');\n  \n  // 创建闪烁动画\n  // 闪烁效果：透明度从 1 -> 0 -> 1，持续 2 秒，无限循环\n  this.tweens.add({\n    targets: ellipse,\n    alpha: 0, // 目标透明度\n    duration: 1000, // 1 秒变为透明\n    yoyo: true, // 反向播放（0 -> 1）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Blinking Cyan Ellipse (2s cycle)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000512_v1", "prompt_id": "seed_000512", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 300，移动速度 160，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动与跳跃，具有重力和地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 300\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建物理精灵作为角色和静态地面平台\n4. 设置键盘输入监听（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑（速度 160）和跳跃逻辑\n6. 配置角色与地面的碰撞检测\n7. 添加状态变量记录跳跃次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色方块）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 64, 32);\n    groundGraphics.generateTexture('ground', 64, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加主地面\n    this.platforms.create(400, 568, 'ground').setScale(12.5, 1).refreshBody();\n    \n    // 添加几个悬浮平台\n    this.platforms.create(600, 450, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(200, 450, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(400, 350, 'ground').setScale(2, 1).refreshBody();\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, 'Controls: Arrow Keys to Move, Space to Jump', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置接地状态（将在碰撞时更新）\n    const wasGrounded = this.isGrounded;\n    this.isGrounded = this.player.body.touching.down;\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只在接地时可以跳跃）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.isGrounded) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n      this.updateStatusText();\n    }\n\n    // 更新状态文本\n    if (wasGrounded !== this.isGrounded) {\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Jump Count: ${this.jumpCount} | Grounded: ${this.isGrounded ? 'Yes' : 'No'} | ` +\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    );\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001085_v2", "prompt_id": "seed_001085", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色矩形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色矩形在2.5秒内左右往返循环移动\nAPI: this.add.graphics, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制青色矩形并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 实现往返效果，loop 设置为 -1 实现无限循环\n5. 设置 duration 为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillRect(0, 0, 60, 60); // 60x60 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('cyanRect', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'cyanRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（右侧位置）\n    duration: 2500,          // 持续时间 2.5 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向播放）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动，匀速运动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '青色矩形往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000122_v3", "prompt_id": "seed_000122", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色六边形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制8个黄色六边形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPoints, Graphics.beginPath, Graphics.closePath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布尺寸\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形顶点计算函数，根据中心点和半径计算6个顶点坐标\n4. 循环8次，每次生成随机位置，绘制黄色填充的六边形\n5. 使用 Graphics API 绘制路径并填充\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xFFD700, 1);\n  \n  // 六边形半径（从中心到顶点的距离）\n  const hexRadius = 40; // 80像素大小对应半径40\n  \n  // 绘制8个随机位置的六边形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机位置，确保六边形不会超出边界\n    const x = Phaser.Math.Between(hexRadius + 10, 800 - hexRadius - 10);\n    const y = Phaser.Math.Between(hexRadius + 10, 600 - hexRadius - 10);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, hexRadius);\n  }\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} centerX - 中心点 X 坐标\n * @param {number} centerY - 中心点 Y 坐标\n * @param {number} radius - 半径\n */\nfunction drawHexagon(graphics, centerX, centerY, radius) {\n  // 计算六边形的6个顶点\n  const points = [];\n  \n  for (let i = 0; i < 6; i++) {\n    // 六边形每个角度间隔60度，从顶部开始（-90度）\n    const angle = (Math.PI / 180) * (60 * i - 90);\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push(x, y);\n  }\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  \n  // 连接所有顶点\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  \n  // 闭合路径并填充\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000068_v1", "prompt_id": "seed_000068", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 20 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成20个白色可收集物体，玩家碰撞后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, this.physics.add.overlap, this.add.text\nSTEPS:\n1. 配置物理系统（Arcade Physics）\n2. 使用 Graphics 生成玩家和收集物的纹理（玩家用蓝色圆形，收集物用白色圆形）\n3. 创建玩家精灵并添加物理属性，设置键盘控制\n4. 创建物理组并随机生成20个收集物\n5. 设置玩家与收集物的碰撞检测（overlap）\n6. 碰撞时销毁收集物并增加分数\n7. 显示分数文本并实时更新\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色圆形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（白色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffffff, 1);\n    collectibleGraphics.fillCircle(10, 10, 10);\n    collectibleGraphics.generateTexture('collectible', 20, 20);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setVelocity(0, 0);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成20个收集物\n    for (let i = 0; i < 20; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCircle(10); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.scoreText.setDepth(100);\n\n    // 添加提示文本\n    this.add.text(400, 550, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0 && this.score > 0) {\n      this.showVictoryMessage();\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁收集物\n    collectible.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 添加收集特效（简单的闪烁文字）\n    const bonusText = this.add.text(collectible.x, collectible.y, '+10', {\n      fontSize: '24px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 文字上浮并消失\n    this.tweens.add({\n      targets: bonusText,\n      y: bonusText.y - 50,\n      alpha: 0,\n      duration: 800,\n      ease: 'Power2',\n      onComplete: () => {\n        bonusText.destroy();\n      }\n    });\n  }\n\n  showVictoryMessage() {\n    if (this.victoryShown) return;\n    this.victoryShown = true;\n\n    const victoryText = this.add.text(400, 300, 'All Collected!\\nFinal Score: ' + this.score, {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      align: 'center'\n    }).setOrigin(0.5);\n\n    // 胜利文字闪烁效果\n    this.tweens.add({\n      targets: victoryText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000889_v1", "prompt_id": "seed_000889", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色六边形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色六边形以240速度移动并在画布边界反弹\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Graphics.generateTexture, Physics.Arcade.Sprite, Physics.World.setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制灰色六边形并生成纹理\n2. 创建带物理引擎的精灵对象，设置初始速度为240\n3. 设置世界边界碰撞和精灵反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 计算六边形顶点坐标（中心在原点，半径40）\n  const radius = 40;\n  const hexagonPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    hexagonPoints.push({\n      x: radius + radius * Math.cos(angle),\n      y: radius + radius * Math.sin(angle)\n    });\n  }\n  \n  // 绘制六边形\n  graphics.fillPoints(hexagonPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', radius * 2, radius * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（240像素/秒，随机方向）\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const velocityX = Math.cos(angle) * 240;\n  const velocityY = Math.sin(angle) * 240;\n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞边界\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 确保世界边界碰撞已启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000740_v1", "prompt_id": "seed_000740", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 300 像素/秒的速度移动\nAPI: this.input.keyboard.addKey(), this.add.graphics(), graphics.fillRect(), key.isDown\nSTEPS:\n1. 创建 Scene 并初始化游戏配置\n2. 在 create 中使用 Graphics 绘制一个矩形作为玩家\n3. 使用 addKey 注册 WASD 四个按键\n4. 在 update 中检测按键状态，根据 delta 时间计算位移并更新矩形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象\nlet player;\n// 按键对象\nlet keyW, keyA, keyS, keyD;\n// 移动速度（像素/秒）\nconst SPEED = 300;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形（使用 Graphics）\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的矩形\n  \n  // 将 graphics 转换为纹理以便后续使用\n  graphics.generateTexture('playerRect', 50, 50);\n  graphics.destroy(); // 销毁临时 graphics 对象\n  \n  // 创建玩家精灵并设置初始位置\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 注册 WASD 按键\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧应该移动的距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 检测按键并移动玩家\n  if (keyW.isDown) {\n    player.y -= moveDistance; // 向上移动\n  }\n  if (keyS.isDown) {\n    player.y += moveDistance; // 向下移动\n  }\n  if (keyA.isDown) {\n    player.x -= moveDistance; // 向左移动\n  }\n  if (keyD.isDown) {\n    player.x += moveDistance; // 向右移动\n  }\n  \n  // 边界限制（可选，防止矩形移出屏幕）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000142_v3", "prompt_id": "seed_000142", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的绿色矩形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的绿色矩形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用循环15次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置绿色，fillRect 绘制 48x48 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 矩形大小\n  const rectSize = 48;\n  \n  // 绘制15个随机位置的绿色矩形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机位置，确保矩形完全在画布内\n    const x = Phaser.Math.Between(0, config.width - rectSize);\n    const y = Phaser.Math.Between(0, config.height - rectSize);\n    \n    // 绘制矩形\n    graphics.fillRect(x, y, rectSize, rectSize);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000225_v3", "prompt_id": "seed_000225", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的绿色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的绿色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用循环创建8个 Graphics 对象\n3. 对每个 Graphics 对象使用 fillTriangle 绘制绿色三角形（大小16像素）\n4. 使用 setRandomPosition 将三角形随机分布在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建8个绿色三角形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制等边三角形，大小为16像素\n    // 三角形顶点坐标（以中心为原点）\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height * 2/3,           // 顶点（上）\n      -size / 2, height * 1/3,    // 左下顶点\n      size / 2, height * 1/3      // 右下顶点\n    );\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const padding = size;\n    const randomX = Phaser.Math.Between(padding, 800 - padding);\n    const randomY = Phaser.Math.Between(padding, 600 - padding);\n    \n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000764_v2", "prompt_id": "seed_000764", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色方块在 1 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色方块在1秒内完成抖动动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制灰色方块并生成纹理\n2. 创建 Sprite 对象并应用纹理\n3. 使用 Tween 动画实现抖动效果（快速左右/上下移动）\n4. 设置动画循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('grayBox', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵并居中\n  const box = this.add.sprite(400, 300, 'grayBox');\n\n  // 创建抖动动画效果\n  // 使用快速的左右抖动来模拟震动效果\n  this.tweens.add({\n    targets: box,\n    x: '+=10', // 向右移动10像素\n    duration: 50, // 50毫秒\n    yoyo: true, // 返回原位\n    repeat: 9, // 重复9次（加上第一次共10次，总计1秒）\n    ease: 'Linear',\n    onComplete: () => {\n      // 第一组抖动完成后，立即开始反向抖动\n      this.tweens.add({\n        targets: box,\n        x: '-=10', // 向左移动10像素\n        duration: 50,\n        yoyo: true,\n        repeat: 9,\n        ease: 'Linear',\n        loop: -1, // 无限循环\n        loopDelay: 0\n      });\n    }\n  });\n\n  // 或者使用更简单的方式：同时在 x 和 y 轴上抖动\n  // 注释掉上面的代码，使用下面的代码可以实现更自然的抖动效果\n  /*\n  this.tweens.add({\n    targets: box,\n    x: box.x + Phaser.Math.Between(-8, 8),\n    y: box.y + Phaser.Math.Between(-8, 8),\n    duration: 50,\n    ease: 'Power2',\n    yoyo: true,\n    repeat: 9, // 总共1秒（50ms * 2 * 10 = 1000ms）\n    loop: -1, // 无限循环\n    onRepeat: () => {\n      // 每次重复时随机设置新的抖动位置\n      const tween = this.tweens.getTweensOf(box)[0];\n      if (tween) {\n        tween.updateTo('x', box.x + Phaser.Math.Between(-8, 8), true);\n        tween.updateTo('y', box.y + Phaser.Math.Between(-8, 8), true);\n      }\n    }\n  });\n  */\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000711_v3", "prompt_id": "seed_000711", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让灰色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, Collider\nSTEPS:\n1. 创建 Phaser.Game 配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制灰色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为 200\n4. 在 update 中检测边界碰撞并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 使用 Graphics 创建灰色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆（中心x, 中心y, 宽度, 高度）\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 200);\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  ellipse.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 物理系统自动处理边界反弹，无需额外逻辑\n  // 但如果不使用 setCollideWorldBounds，可以手动检测：\n  /*\n  if (ellipse.x <= ellipse.width / 2 || ellipse.x >= 800 - ellipse.width / 2) {\n    ellipse.body.velocity.x *= -1;\n  }\n  if (ellipse.y <= ellipse.height / 2 || ellipse.y >= 600 - ellipse.height / 2) {\n    ellipse.body.velocity.y *= -1;\n  }\n  */\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000126_v2", "prompt_id": "seed_000126", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9649999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让橙色圆形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色圆形，使用 Tween 动画在 1 秒内旋转 360 度并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setRotation\nSTEPS:\n1. 使用 Graphics 绘制橙色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 rotation 属性从 0 到 2π\n4. 设置 duration 为 1000ms，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建橙色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillCircle(50, 50, 50); // 半径 50 的圆形\n  \n  // 添加一个标记点，用于观察旋转效果\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(50, 20, 8); // 在圆形顶部添加白色小圆点作为标记\n  \n  graphics.generateTexture('orangeCircle', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建橙色圆形精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'orangeCircle');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: circle,\n    rotation: Math.PI * 2, // 旋转 360 度（2π 弧度）\n    duration: 1000, // 1 秒完成一次旋转\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动，保持匀速旋转\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '橙色圆形旋转动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000571_v1", "prompt_id": "seed_000571", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置 duration 为 500 毫秒（0.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-25, 30);     // 左下角\n  graphics.lineTo(25, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右移动，往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 500,             // 持续时间 0.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果\n    repeat: -1                 // 无限循环 (-1 表示永远重复)\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000793_v3", "prompt_id": "seed_000793", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 3 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形，使用 Tween 动画在 3 秒内缩放到 24%，然后恢复原始大小，并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象\n3. 使用 tweens 创建缩放动画，从 scale=1 到 scale=0.24，持续 3 秒\n4. 设置 yoyo=true 使动画反向播放（恢复原始大小）\n5. 设置 loop=-1 使动画无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制星形的顶点坐标\n  const points = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: Math.cos(angle) * radius + 60,\n      y: Math.sin(angle) * radius + 60\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 120, 120);\n  graphics.destroy();\n  \n  // 创建星形精灵并居中显示\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  // 从原始大小 (scale=1) 缩放到 24% (scale=0.24)\n  // 持续时间 3000 毫秒（3 秒）\n  // yoyo=true 使动画反向播放，恢复到原始大小\n  // loop=-1 表示无限循环\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 3000,\n    yoyo: true,\n    loop: -1,\n    ease: 'Linear'\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '星形缩放动画 (3秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% → 24% → 100%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000277_v3", "prompt_id": "seed_000277", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Arcade 物理精灵并应用三角形纹理\n3. 设置初始速度为 160（斜向移动）\n4. 启用世界边界碰撞和反弹系数为 1\n5. 在 update 中保持恒定速度（可选优化）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nconst SPEED = 160;\n\nfunction preload() {\n  // 使用 Graphics 创建白色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制白色三角形\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillTriangle(\n    32, 8,   // 顶点（上）\n    8, 56,   // 左下角\n    56, 56   // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置初始速度（斜向移动，速度大小为160）\n  // 使用勾股定理：vx² + vy² = 160²\n  // 设置45度角移动：vx = vy = 160/√2 ≈ 113.137\n  const velocity = SPEED / Math.sqrt(2);\n  triangle.setVelocity(velocity, velocity);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置完全弹性碰撞（反弹系数为1）\n  triangle.setBounce(1, 1);\n  \n  // 确保物理体大小合适\n  triangle.setCircle(28); // 使用圆形碰撞体，更适合三角形\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（防止因精度问题速度衰减）\n  const currentSpeed = Math.sqrt(\n    triangle.body.velocity.x ** 2 + \n    triangle.body.velocity.y ** 2\n  );\n  \n  // 如果速度有偏差，重新归一化到 SPEED\n  if (Math.abs(currentSpeed - SPEED) > 0.1) {\n    const scale = SPEED / currentSpeed;\n    triangle.setVelocity(\n      triangle.body.velocity.x * scale,\n      triangle.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000589_v2", "prompt_id": "seed_000589", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色菱形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色菱形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环12次\n3. 每次循环创建一个 Graphics 对象\n4. 使用 beginPath 和 moveTo/lineTo 绘制菱形路径（4个顶点）\n5. 使用 Phaser.Math.Between 生成随机 x、y 坐标\n6. 填充绿色并完成绘制\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const diamondSize = 80; // 菱形大小\n  const halfSize = diamondSize / 2; // 半径\n  \n  // 绘制12个随机位置的绿色菱形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置，确保菱形完全在画布内\n    const x = Phaser.Math.Between(halfSize, 800 - halfSize);\n    const y = Phaser.Math.Between(halfSize, 600 - halfSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 开始绘制菱形路径\n    graphics.beginPath();\n    \n    // 菱形的四个顶点（上、右、下、左）\n    graphics.moveTo(x, y - halfSize);           // 上顶点\n    graphics.lineTo(x + halfSize, y);           // 右顶点\n    graphics.lineTo(x, y + halfSize);           // 下顶点\n    graphics.lineTo(x - halfSize, y);           // 左顶点\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000052_v2", "prompt_id": "seed_000052", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让青色椭圆在 2 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色椭圆在2秒内完成闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆并生成纹理\n2. 创建 Sprite 使用生成的椭圆纹理\n3. 使用 Tween 动画控制 alpha 透明度实现闪烁效果（0->1->0）\n4. 设置 duration 为 2000ms，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制椭圆（中心点在 80, 60，宽度 160，高度 120）\n  graphics.fillEllipse(80, 60, 160, 120);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTexture', 160, 120);\n  \n  // 清除 graphics 对象（已经生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建使用椭圆纹理的精灵，放置在屏幕中央\n  const ellipseSprite = this.add.sprite(400, 300, 'ellipseTexture');\n  \n  // 创建闪烁动画（通过改变 alpha 透明度）\n  this.tweens.add({\n    targets: ellipseSprite,\n    alpha: {\n      from: 1,    // 从完全不透明\n      to: 0       // 到完全透明\n    },\n    duration: 1000,  // 1秒变透明\n    yoyo: true,      // 反向播放（透明后再变回不透明）\n    repeat: -1,      // 无限循环\n    ease: 'Sine.easeInOut'  // 使用正弦缓动，让闪烁更平滑\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 500, '青色椭圆闪烁动画 (2秒一个循环)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000512_v2", "prompt_id": "seed_000512", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 80 像素/秒的速度移动\nAPI: this.input.keyboard.addKey, this.add.graphics, this.time.delta\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中使用 Graphics 绘制矩形作为玩家\n3. 使用 addKey 监听 WASD 四个按键\n4. 在 update 中根据按键状态和 delta 时间计算位置增量\n5. 更新矩形位置实现移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建玩家矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 40, 40);\n  \n  // 将 graphics 转换为纹理\n  graphics.generateTexture('playerRect', 40, 40);\n  graphics.destroy();\n  \n  // 创建玩家精灵并居中\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 设置 WASD 键位\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the rectangle', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧应移动的距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    player.y -= distance;\n  }\n  if (keyS.isDown) {\n    player.y += distance;\n  }\n  if (keyA.isDown) {\n    player.x -= distance;\n  }\n  if (keyD.isDown) {\n    player.x += distance;\n  }\n  \n  // 边界限制（可选，防止矩形移出屏幕）\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000449_v2", "prompt_id": "seed_000449", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2秒内缩放到48%再恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状\n2. 创建 Tween 动画，设置 scaleX 和 scaleY 从 1 到 0.48\n3. 配置 yoyo 为 true 实现往返效果，duration 为 2000ms\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建椭圆图形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制椭圆（中心点在 0,0，半径 100x60）\n  graphics.fillEllipse(0, 0, 200, 120);\n  \n  // 将椭圆定位到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.48,      // 缩放到 48%\n    scaleY: 0.48,      // 缩放到 48%\n    duration: 2000,    // 持续 2 秒\n    yoyo: true,        // 往返播放（缩小后再恢复）\n    loop: -1,          // 无限循环\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆缩放动画 (48% ↔ 100%)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000466_v2", "prompt_id": "seed_000466", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色矩形，大小约为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个 64x64 的红色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为红色 (0xff0000)\n4. 在画布中央 (400-32, 300-32) 位置绘制 64x64 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色，透明度为 1\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 计算矩形左上角位置（画布中央 - 矩形尺寸的一半）\n  const rectSize = 64;\n  const x = (config.width - rectSize) / 2;  // 400 - 32 = 368\n  const y = (config.height - rectSize) / 2; // 300 - 32 = 268\n  \n  // 绘制矩形\n  graphics.fillRect(x, y, rectSize, rectSize);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000399_v3", "prompt_id": "seed_000399", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色椭圆，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色椭圆，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置黄色填充样式（0xffff00）\n4. 使用 fillEllipse 方法在画布中央（400, 300）绘制椭圆，宽高均为 48 像素\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 在画布中央绘制黄色椭圆\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充样式\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  const centerX = config.width / 2;  // 400\n  const centerY = config.height / 2; // 300\n  const ellipseWidth = 48;\n  const ellipseHeight = 48;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000575_v3", "prompt_id": "seed_000575", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色圆形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色圆形以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制青色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 设置世界边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(25, 25, 25); // 半径25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，节省资源\n  \n  // 创建物理精灵\n  const ball = this.physics.add.sprite(400, 300, 'circle');\n  \n  // 设置初始速度（200速度，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 200);\n  ball.setVelocity(velocity.x, velocity.y);\n  \n  // 设置碰撞世界边界\n  ball.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ball.setBounce(1, 1);\n  \n  // 可选：添加文字提示\n  this.add.text(10, 10, 'Cyan ball bouncing at 200 speed', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000623_v1", "prompt_id": "seed_000623", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Graphics 对象用于绘制\n2. 设置紫色填充样式\n3. 计算菱形四个顶点坐标（中心点为画布中心，边长48像素）\n4. 使用 fillPath 绘制菱形多边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充样式 (紫色 RGB: 128, 0, 128)\n  graphics.fillStyle(0x800080, 1);\n  \n  // 计算菱形四个顶点坐标\n  // 菱形是一个旋转45度的正方形，对角线长度为48像素\n  const halfSize = 24; // 从中心到顶点的距离\n  \n  // 菱形顶点：上、右、下、左\n  const points = [\n    centerX, centerY - halfSize,  // 上顶点\n    centerX + halfSize, centerY,  // 右顶点\n    centerX, centerY + halfSize,  // 下顶点\n    centerX - halfSize, centerY   // 左顶点\n  ];\n  \n  // 创建多边形并填充\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000112_v2", "prompt_id": "seed_000112", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的紫色矩形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的紫色矩形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机 x、y 坐标\n4. 设置紫色填充样式，绘制 24x24 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充（紫色的十六进制值为 0x800080 或类似）\n  graphics.fillStyle(0x9932cc, 1); // 使用深兰花紫色\n  \n  // 绘制10个随机位置的矩形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保矩形完全在画布内\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const randomX = Math.random() * (config.width - 24);\n    const randomY = Math.random() * (config.height - 24);\n    \n    // 绘制 24x24 的矩形\n    graphics.fillRect(randomX, randomY, 24, 24);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000650_v3", "prompt_id": "seed_000650", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的粉色三角形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的粉色三角形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.generateTexture, this.add.image\nSTEPS:\n1. 创建 Graphics 对象并设置粉色填充样式\n2. 使用 fillTriangle 绘制一个等边三角形（边长64像素）\n3. 使用 generateTexture 将三角形转换为可复用的纹理\n4. 循环12次，在随机位置创建三角形图像\n5. 确保随机位置在画布范围内（考虑三角形大小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充样式 (0xFFC0CB 是粉色的十六进制值)\n  graphics.fillStyle(0xFFC0CB, 1);\n  \n  // 绘制等边三角形（边长64像素）\n  // 计算三角形的三个顶点坐标\n  const size = 64;\n  const height = (Math.sqrt(3) / 2) * size; // 等边三角形的高\n  \n  // 以中心为原点绘制三角形\n  const x1 = 0;           // 顶点（顶部中心）\n  const y1 = -height / 2;\n  const x2 = -size / 2;   // 左下角\n  const y2 = height / 2;\n  const x3 = size / 2;    // 右下角\n  const y3 = height / 2;\n  \n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 将绘制的三角形生成为纹理\n  graphics.generateTexture('pinkTriangle', size, size);\n  \n  // 清除 graphics 对象（已经生成纹理，不再需要显示）\n  graphics.destroy();\n  \n  // 创建12个随机位置的三角形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置（考虑三角形大小，避免超出边界）\n    const randomX = Phaser.Math.Between(size / 2, config.width - size / 2);\n    const randomY = Phaser.Math.Between(size / 2, config.height - size / 2);\n    \n    // 在随机位置创建三角形图像\n    this.add.image(randomX, randomY, 'pinkTriangle');\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000330_v3", "prompt_id": "seed_000330", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个椭圆形状并生成纹理\n2. 创建一个 Sprite 使用该椭圆纹理\n3. 使用 Tween 动画实现缩放效果，从 1 到 0.8 再回到 1\n4. 设置 Tween 的 yoyo 和 loop 属性实现往复循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制椭圆（中心点在 100, 60，半径 100x60）\n  graphics.fillEllipse(100, 60, 200, 120);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 200, 120);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建椭圆精灵，放置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    scaleX: 0.8,                // X 轴缩放到 80%\n    scaleY: 0.8,                // Y 轴缩放到 80%\n    duration: 2000,             // 持续时间 2 秒（2000 毫秒）\n    yoyo: true,                 // 启用往复效果（缩小后自动恢复）\n    repeat: -1,                 // 无限循环（-1 表示永久重复）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆缩放动画 (80% ↔ 100%)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000511_v1", "prompt_id": "seed_000511", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色星形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央使用 Graphics 绘制一个蓝色星形，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的顶点坐标（5 个外顶点和 5 个内顶点）\n4. 使用 Graphics API 绘制星形路径并填充蓝色\n5. 将星形定位到画布中央\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 星形参数\n  const centerX = 400; // 画布中央 X\n  const centerY = 300; // 画布中央 Y\n  const outerRadius = 16; // 外半径 16 像素\n  const innerRadius = 8; // 内半径约为外半径的一半\n  const points = 5; // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制星形的顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算角度（从顶部开始，顺时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000289_v3", "prompt_id": "seed_000289", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让白色三角形在 2 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色三角形，使用 Tween 实现 2 秒淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Sprite 对象应用该纹理\n3. 使用 tweens.add 创建 alpha 从 0 到 1 再到 0 的补间动画\n4. 设置动画持续时间 2 秒，yoyo 模式，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制三角形（等边三角形，边长约 100 像素）\n  graphics.beginPath();\n  graphics.moveTo(0, -50);      // 顶点\n  graphics.lineTo(-43, 25);     // 左下角\n  graphics.lineTo(43, 25);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中央\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 初始设置为完全透明\n  triangle.setAlpha(0);\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: triangle,\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 1000,              // 淡入持续 1 秒\n    yoyo: true,                  // 启用 yoyo 模式，动画会反向播放（淡出）\n    repeat: -1,                  // -1 表示无限循环\n    ease: 'Sine.easeInOut'       // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 550, '白色三角形淡入淡出动画（2秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000724_v2", "prompt_id": "seed_000724", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色方块，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个 80x80 像素的绿色方块\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用 fillStyle 设置绿色填充色\n4. 使用 fillRect 在中心位置 (360, 260) 绘制 80x80 的方块\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 绘制绿色方块\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色 (0x00ff00)，透明度为 1\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算中心位置\n  // 画布宽度 800，方块宽度 80，中心 x = (800 - 80) / 2 = 360\n  // 画布高度 600，方块高度 80，中心 y = (600 - 80) / 2 = 260\n  const squareSize = 80;\n  const centerX = (config.width - squareSize) / 2;\n  const centerY = (config.height - squareSize) / 2;\n  \n  // 在中心位置绘制方块\n  graphics.fillRect(centerX, centerY, squareSize, squareSize);\n}\n\n// 创建并启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000308_v3", "prompt_id": "seed_000308", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让黄色方块在 3 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个黄色方块，使用 Tween 动画实现 3 秒循环抖动效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene\nSTEPS:\n1. 使用 Graphics 创建黄色方块纹理\n2. 创建 Sprite 对象并应用纹理\n3. 使用 Tween 动画实现抖动效果（通过快速改变 x/y 位置）\n4. 设置 Tween 为循环模式，持续时间 3 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成黄色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  graphics.generateTexture('yellowBox', 80, 80);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建黄色方块精灵\n  const box = this.add.sprite(400, 300, 'yellowBox');\n  \n  // 创建抖动动画\n  // 使用多个关键帧在 3 秒内快速改变位置，形成抖动效果\n  this.tweens.add({\n    targets: box,\n    duration: 3000,\n    ease: 'Linear',\n    repeat: -1, // 无限循环\n    yoyo: false,\n    // 使用 x 和 y 的随机偏移来创建抖动效果\n    props: {\n      x: {\n        value: '+=0', // 基准位置\n        duration: 3000,\n        ease: (t) => {\n          // 自定义缓动函数：在 0-1 之间产生随机抖动\n          // 使用正弦波叠加随机值创建抖动效果\n          const shake = Math.sin(t * 50) * 5 + (Math.random() - 0.5) * 10;\n          return shake / 400; // 归一化偏移量\n        }\n      },\n      y: {\n        value: '+=0',\n        duration: 3000,\n        ease: (t) => {\n          const shake = Math.cos(t * 50) * 5 + (Math.random() - 0.5) * 10;\n          return shake / 300;\n        }\n      }\n    }\n  });\n  \n  // 另一种更简单的实现方式：使用时间轴快速切换位置\n  // 注释掉上面的 tween，使用下面这种方式也可以\n  /*\n  const timeline = this.tweens.timeline({\n    loop: -1,\n    targets: box\n  });\n  \n  // 在 3 秒内添加多个快速抖动关键帧\n  const shakeCount = 30; // 抖动次数\n  const duration = 3000 / shakeCount; // 每次抖动持续时间\n  \n  for (let i = 0; i < shakeCount; i++) {\n    const offsetX = (Math.random() - 0.5) * 20;\n    const offsetY = (Math.random() - 0.5) * 20;\n    \n    timeline.add({\n      x: 400 + offsetX,\n      y: 300 + offsetY,\n      duration: duration,\n      ease: 'Linear'\n    });\n  }\n  \n  // 最后回到原始位置\n  timeline.add({\n    x: 400,\n    y: 300,\n    duration: duration,\n    ease: 'Linear'\n  });\n  \n  timeline.play();\n  */\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '黄色方块抖动动画（3秒循环）', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000598_v2", "prompt_id": "seed_000598", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色方块以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色方块以160速度移动并在边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.generateTexture, Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.World.setBoundsCollision\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制黄色方块并生成纹理\n3. 创建物理精灵并设置初始速度为160\n4. 启用世界边界碰撞和反弹属性\n5. 设置精灵与世界边界碰撞时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的方块\n  \n  // 生成纹理\n  graphics.generateTexture('yellowSquare', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const square = this.physics.add.sprite(400, 300, 'yellowSquare');\n  \n  // 设置初始速度（随机方向，速度为160）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 160);\n  square.setVelocity(velocity.x, velocity.y);\n  \n  // 启用世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000631_v3", "prompt_id": "seed_000631", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个菱形并生成纹理\n2. 创建一个 Sprite 使用该菱形纹理\n3. 使用 Tween 动画实现缩放效果：从 1 缩放到 0.8，yoyo 模式自动恢复，设置循环播放\n4. 设置动画时长为 3000ms（3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  // 绘制菱形（中心点在 64, 64）\n  const centerX = 64;\n  const centerY = 64;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  graphics.closePath();\n  \n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建使用菱形纹理的精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    scaleX: 0.8,               // X轴缩放到 80%\n    scaleY: 0.8,               // Y轴缩放到 80%\n    duration: 3000,            // 动画时长 3 秒\n    yoyo: true,                // 启用 yoyo 模式，动画结束后反向播放回到原始状态\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'     // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '菱形缩放动画（循环播放）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000642_v2", "prompt_id": "seed_000642", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 20 个金币，重力 800，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集20个金币，重力800，显示分数\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.StaticGroup, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Physics.Arcade.World.gravity\nSTEPS:\n1. 创建游戏配置，启用 Arcade 物理引擎，设置重力为 800\n2. 使用 Graphics 创建玩家、平台和金币的纹理\n3. 创建玩家精灵，添加物理属性和碰撞边界\n4. 创建静态平台组，包含地面和若干空中平台\n5. 创建金币组（20个），随机分布在平台上方\n6. 添加键盘输入控制（左右移动和跳跃）\n7. 实现玩家与平台的碰撞检测\n8. 实现玩家与金币的重叠检测，收集时增加分数并销毁金币\n9. 创建分数文本显示，实时更新\n[/PLAN]\n\n```javascript\nclass PlatformGame extends Phaser.Scene {\n  constructor() {\n    super('PlatformGame');\n    this.score = 0;\n    this.collectedCoins = 0;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8B4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 创建金币纹理\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xFFD700, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.lineStyle(2, 0xFFA500);\n    coinGraphics.strokeCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0 / 20', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.scoreText.setScrollFactor(0);\n    this.scoreText.setDepth(10);\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 地面平台\n    this.platforms.create(400, 580, 'platform').setScale(4, 1).refreshBody();\n\n    // 空中平台\n    this.platforms.create(150, 480, 'platform');\n    this.platforms.create(350, 420, 'platform');\n    this.platforms.create(550, 360, 'platform');\n    this.platforms.create(700, 300, 'platform');\n    this.platforms.create(250, 280, 'platform');\n    this.platforms.create(500, 220, 'platform');\n    this.platforms.create(650, 160, 'platform');\n    this.platforms.create(100, 180, 'platform');\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n\n    // 在平台上方生成金币\n    const coinPositions = [\n      { x: 150, y: 440 },\n      { x: 200, y: 440 },\n      { x: 350, y: 380 },\n      { x: 400, y: 380 },\n      { x: 550, y: 320 },\n      { x: 600, y: 320 },\n      { x: 700, y: 260 },\n      { x: 750, y: 260 },\n      { x: 250, y: 240 },\n      { x: 300, y: 240 },\n      { x: 500, y: 180 },\n      { x: 550, y: 180 },\n      { x: 650, y: 120 },\n      { x: 700, y: 120 },\n      { x: 100, y: 140 },\n      { x: 150, y: 140 },\n      { x: 400, y: 500 },\n      { x: 450, y: 500 },\n      { x: 200, y: 350 },\n      { x: 600, y: 450 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 设置金币收集\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加完成提示文本（初始隐藏）\n    this.completeText = this.add.text(400, 300, 'All Coins Collected!\\nScore: 20/20', {\n      fontSize: '32px',\n      fill: '#FFD700',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 },\n      align: 'center'\n    });\n    this.completeText.setOrigin(0.5);\n    this.completeText.setVisible(false);\n    this.completeText.setDepth(20);\n  }\n\n  collectCoin(player, coin) {\n    coin.disableBody(true, true);\n    this.score += 1;\n    this.collectedCoins += 1;\n    this.scoreText.setText(`Score: ${this.score} / 20`);\n\n    // 检查是否收集完所有金币\n    if (this.collectedCoins >= 20) {\n      this.completeText.setVisible(true);\n    }\n  }\n\n  update() {\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃（只能在地面或平台上跳跃）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: PlatformGame\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001175_v2", "prompt_id": "seed_001175", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个青色物体以 200 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个青色物体以200速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Body#setBounce, Phaser.Physics.Arcade.Body#setCollideWorldBounds, Phaser.Physics.Arcade.Body#setVelocity\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 生成青色圆形纹理\n3. 创建物理组，添加 15 个青色物体\n4. 为每个物体设置随机速度（200 像素/秒）和反弹属性\n5. 设置物体间的碰撞检测和世界边界碰撞\n6. 添加状态变量记录活跃物体数量\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeObjects = 0; // 状态信号：活跃物体数量\n    this.totalCollisions = 0; // 状态信号：总碰撞次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00FFFF, 1); // 青色\n    graphics.fillCircle(20, 20, 20); // 半径为 20 的圆\n    graphics.generateTexture('cyanBall', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.objectGroup = this.physics.add.group({\n      key: 'cyanBall',\n      repeat: 14, // 创建 15 个物体（1 + 14）\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 设置每个物体的随机位置和速度\n    const objects = this.objectGroup.getChildren();\n    this.activeObjects = objects.length;\n\n    objects.forEach((obj, index) => {\n      // 随机位置（避免重叠）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      obj.setPosition(x, y);\n\n      // 随机方向，速度为 200\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(angle * Math.PI / 180) * 200;\n      const velocityY = Math.sin(angle * Math.PI / 180) * 200;\n      obj.setVelocity(velocityX, velocityY);\n\n      // 设置反弹\n      obj.setBounce(1, 1);\n      obj.setCollideWorldBounds(true);\n    });\n\n    // 设置物体之间的碰撞\n    this.physics.add.collider(this.objectGroup, this.objectGroup, this.onCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  onCollision(obj1, obj2) {\n    // 碰撞回调\n    this.totalCollisions++;\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Active Objects: ${this.activeObjects}\\n` +\n      `Total Collisions: ${this.totalCollisions}\\n` +\n      `Speed: 200 px/s`\n    );\n  }\n\n  update(time, delta) {\n    // 验证速度保持在 200 左右（由于碰撞可能有轻微偏差）\n    const objects = this.objectGroup.getChildren();\n    objects.forEach(obj => {\n      const body = obj.body;\n      const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n      \n      // 如果速度偏差超过 5%，重新归一化到 200\n      if (Math.abs(currentSpeed - 200) > 10) {\n        const normalizedVelX = (body.velocity.x / currentSpeed) * 200;\n        const normalizedVelY = (body.velocity.y / currentSpeed) * 200;\n        body.setVelocity(normalizedVelX, normalizedVelY);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000844_v2", "prompt_id": "seed_000844", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色菱形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色菱形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中使用循环创建12个 Graphics 对象\n3. 每个 Graphics 对象使用 fillPath 绘制菱形（4个顶点坐标）\n4. 使用 setRandomPosition 将每个菱形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 菱形大小\n  const size = 80;\n  const halfSize = size / 2;\n  \n  // 创建12个绿色菱形\n  for (let i = 0; i < 12; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 创建菱形路径（中心点在原点）\n    const path = new Phaser.Geom.Polygon([\n      0, -halfSize,      // 上顶点\n      halfSize, 0,       // 右顶点\n      0, halfSize,       // 下顶点\n      -halfSize, 0       // 左顶点\n    ]);\n    \n    // 填充菱形\n    graphics.fillPoints(path.points, true);\n    \n    // 设置随机位置（考虑边界，避免菱形超出画布）\n    const x = Phaser.Math.Between(halfSize, config.width - halfSize);\n    const y = Phaser.Math.Between(halfSize, config.height - halfSize);\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000052_v3", "prompt_id": "seed_000052", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的矩形对象\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建 Scene 并配置游戏窗口大小\n2. 在 create 中使用 Graphics 或 Rectangle 创建可移动的矩形对象\n3. 设置相机跟随该矩形对象，使用 camera.startFollow() 方法\n4. 在 update 中让矩形持续向右上方移动（x++, y--）\n5. 添加背景网格或参考物体以便观察相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet moveSpeed = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个大的世界边界，让相机有足够的空间跟随\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  \n  // 绘制背景网格作为参考，帮助观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制网格\n  for (let x = 0; x <= 2000; x += 100) {\n    graphics.lineBetween(x, 0, x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 100) {\n    graphics.lineBetween(0, y, 2000, y);\n  }\n  \n  // 添加坐标标记\n  const textStyle = { \n    fontSize: '14px', \n    color: '#00ff00',\n    backgroundColor: '#000000'\n  };\n  \n  for (let x = 0; x <= 2000; x += 200) {\n    for (let y = 0; y <= 2000; y += 200) {\n      this.add.text(x + 5, y + 5, `${x},${y}`, textStyle);\n    }\n  }\n  \n  // 创建玩家矩形（使用 Rectangle 游戏对象）\n  player = this.add.rectangle(400, 1500, 40, 40, 0xff0000);\n  \n  // 设置相机跟随玩家，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（这里不设置，保持默认居中）\n  // this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加提示文本（固定在相机视图上）\n  const infoText = this.add.text(10, 10, '相机跟随矩形移动中...', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 设置文本固定在相机上，不随世界移动\n  infoText.setScrollFactor(0);\n  \n  // 添加实时坐标显示\n  this.positionText = this.add.text(10, 40, '', {\n    fontSize: '16px',\n    color: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让矩形向右上方移动\n  player.x += moveSpeed;\n  player.y -= moveSpeed;\n  \n  // 更新位置显示\n  this.positionText.setText(\n    `位置: (${Math.round(player.x)}, ${Math.round(player.y)})`\n  );\n  \n  // 可选：当矩形到达边界时重置位置\n  if (player.x > 1900 || player.y < 100) {\n    player.x = 400;\n    player.y = 1500;\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000287_v3", "prompt_id": "seed_000287", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8733333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 15 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，15个白色物体碰撞后消失加分并显示分数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理引擎场景，配置 arcade 物理系统\n2. 使用 Graphics 生成玩家和可收集物体的纹理\n3. 创建物理组存储15个随机分布的白色收集物\n4. 添加键盘控制让玩家移动\n5. 使用 overlap 检测玩家与收集物碰撞，碰撞后销毁物体并加分\n6. 创建文本显示当前分数\n[/PLAN]\n\n```javascript\nclass CollectGame extends Phaser.Scene {\n  constructor() {\n    super('CollectGame');\n    this.score = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（白色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffffff, 1);\n    collectibleGraphics.fillCircle(12, 12, 12);\n    collectibleGraphics.generateTexture('collectible', 24, 24);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 生成15个随机位置的收集物\n    for (let i = 0; i < 15; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCircle(12); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加提示文本\n    this.add.text(400, 16, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5, 0);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁收集物\n    collectible.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0) {\n      this.add.text(400, 300, 'YOU WIN!\\nAll Items Collected!', {\n        fontSize: '48px',\n        fill: '#00ff00',\n        fontFamily: 'Arial',\n        align: 'center'\n      }).setOrigin(0.5);\n\n      // 停止玩家移动\n      this.player.setVelocity(0, 0);\n      this.physics.pause();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectGame\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000851_v1", "prompt_id": "seed_000851", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左上显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左上角显示 \"Hello Phaser\" 文字，字体大小 80 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和 Scene\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字位置为左上角 (0, 0)，字体大小为 80px\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本任务无需预加载资源\n}\n\nfunction create() {\n  // 在左上角创建文字对象\n  // 参数: x坐标, y坐标, 文字内容, 样式配置\n  this.add.text(0, 0, 'Hello Phaser', {\n    fontSize: '80px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000328_v2", "prompt_id": "seed_000328", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 创建 Graphics 对象并绘制三角形\n2. 设置三角形初始透明度为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 4 秒\n4. 设置 Tween 循环播放（repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制三角形（使用 beginPath 和 fillPath）\n  graphics.beginPath();\n  graphics.moveTo(400, 200); // 顶点\n  graphics.lineTo(300, 400); // 左下角\n  graphics.lineTo(500, 400); // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1, // 目标透明度：完全不透明\n    duration: 4000, // 持续时间 4 秒\n    ease: 'Linear', // 线性渐变\n    repeat: -1, // 无限循环\n    yoyo: false // 不反向播放，只是从 0 到 1 循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Triangle fading in (4s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000473_v1", "prompt_id": "seed_000473", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让青色椭圆在 2.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色椭圆，使用 Tween 动画在 2.5 秒内完成一次旋转并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.generateTexture, Phaser.GameObjects.Sprite, Phaser.Tweens.TweenManager.add\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画让椭圆旋转 360 度（2π 弧度）\n4. 设置 Tween 为循环模式（loop: -1）和持续时间 2500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制椭圆（中心点在 0,0，宽度 120，高度 80）\n  graphics.fillEllipse(0, 0, 120, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 在屏幕中心创建椭圆精灵\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    angle: 360,                 // 旋转到 360 度\n    duration: 2500,             // 持续时间 2.5 秒\n    ease: 'Linear',             // 线性缓动，保持匀速旋转\n    repeat: -1,                 // 无限循环 (-1 表示永久循环)\n    onRepeat: function() {\n      // 每次循环重置角度，避免数值累积\n      ellipse.angle = 0;\n    }\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '青色椭圆旋转动画\\n2.5秒一圈，无限循环', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000739_v2", "prompt_id": "seed_000739", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的三角形\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建精灵对象并设置初始位置\n3. 使用 camera.startFollow 让相机跟随精灵\n4. 在 update 中更新精灵位置（向左下移动）\n5. 扩大世界边界以容纳移动范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet triangle;\nconst moveSpeed = 100; // 每秒移动的像素\n\nfunction preload() {\n  // 使用 Graphics 创建三角形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 顶点\n  graphics.lineTo(0, 64);      // 左下\n  graphics.lineTo(64, 64);     // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加边框使三角形更明显\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 扩大世界边界，允许三角形移动更远\n  this.cameras.main.setBounds(0, 0, 3000, 3000);\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 创建三角形精灵，初始位置在世界中心\n  triangle = this.add.sprite(1500, 1500, 'triangle');\n  \n  // 设置相机跟随三角形\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 添加网格背景以便观察移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(3000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加文本提示\n  const text = this.add.text(16, 16, '相机跟随三角形移动', {\n    fontSize: '24px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 向左下方移动：x 减少，y 增加\n  // 使用 45 度角移动（左下方向）\n  const moveDistance = moveSpeed * deltaSeconds;\n  triangle.x -= moveDistance * Math.cos(Math.PI / 4); // 向左\n  triangle.y += moveDistance * Math.sin(Math.PI / 4); // 向下\n  \n  // 可选：当三角形移动到边界时重置位置\n  if (triangle.x < 0 || triangle.y > 3000) {\n    triangle.setPosition(1500, 1500);\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000239_v2", "prompt_id": "seed_000239", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8820833333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形以360速度移动并在画布边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建带有 Arcade 物理引擎的 Phaser 游戏配置\n2. 使用 Graphics 绘制橙色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为 360（斜向移动以体现反弹效果）\n5. 启用世界边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1);  // 橙色\n  \n  // 绘制星形（中心点在 50, 50，半径 50）\n  graphics.fillStar(50, 50, 5, 20, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();  // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（斜向移动，速度分量使用勾股定理计算）\n  // 总速度 360，分解为 x 和 y 方向\n  const angle = Phaser.Math.DegToRad(45);  // 45度角\n  const velocityX = Math.cos(angle) * 360;\n  const velocityY = Math.sin(angle) * 360;\n  star.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞，不损失速度）\n  star.setBounce(1, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000798_v1", "prompt_id": "seed_000798", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite, Graphics#generateTexture\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 在 update 中让菱形自动向右上方移动\n4. 使用 Camera.startFollow 让相机跟随菱形并居中\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet diamond;\nconst moveSpeed = 2; // 移动速度（像素/帧）\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  createGrid.call(this);\n  \n  // 使用 Graphics 绘制菱形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（四个点连接成菱形）\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 上顶点\n  graphics.lineTo(64, 32);     // 右顶点\n  graphics.lineTo(32, 64);     // 下顶点\n  graphics.lineTo(0, 32);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使菱形更明显\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamondTexture', 64, 64);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建菱形精灵，初始位置在场景中心\n  diamond = this.add.sprite(400, 300, 'diamondTexture');\n  \n  // 设置相机跟随菱形\n  // 第二个参数为 true 表示圆形插值跟随（平滑跟随）\n  // 第三和第四个参数控制跟随的平滑度（0-1之间，值越小越平滑）\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 设置相机边界，让相机可以在更大的世界中移动\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随菱形移动\\n菱形向右上方移动', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让菱形向右上方移动（45度角）\n  diamond.x += moveSpeed;\n  diamond.y -= moveSpeed;\n  \n  // 让菱形旋转，增加视觉效果\n  diamond.rotation += 0.02;\n  \n  // 可选：当菱形移动到边界外时重置位置（演示用）\n  if (diamond.x > 1900 || diamond.y < 100) {\n    diamond.x = 400;\n    diamond.y = 300;\n  }\n}\n\n// 辅助函数：创建背景网格\nfunction createGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制更大的网格区域\n  const gridSize = 100;\n  const worldWidth = 2000;\n  const worldHeight = 2000;\n  \n  // 绘制垂直线\n  for (let x = 0; x <= worldWidth; x += gridSize) {\n    graphics.lineBetween(x, 0, x, worldHeight);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= worldHeight; y += gridSize) {\n    graphics.lineBetween(0, y, worldWidth, y);\n  }\n  \n  // 添加坐标标记\n  const style = { fontSize: '14px', fill: '#666666' };\n  for (let x = 0; x <= worldWidth; x += 200) {\n    for (let y = 0; y <= worldHeight; y += 200) {\n      this.add.text(x + 5, y + 5, `${x},${y}`, style);\n    }\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000412_v1", "prompt_id": "seed_000412", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8733333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形以160速度移动并在边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色三角形并生成纹理\n3. 创建物理精灵并设置初始速度为160\n4. 设置精灵与世界边界碰撞并反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#ffffff'\n};\n\nlet triangle;\nconst SPEED = 160;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制三角形（等边三角形，边长约60）\n  graphics.beginPath();\n  graphics.moveTo(30, 0);      // 顶点\n  graphics.lineTo(0, 52);      // 左下\n  graphics.lineTo(60, 52);     // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 60, 52);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * SPEED;\n  const velocityY = Math.sin(angle * Math.PI / 180) * SPEED;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置与世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  triangle.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 确保物理体大小匹配纹理\n  triangle.body.setSize(60, 52);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（修正因碰撞可能产生的速度变化）\n  const currentVelocity = triangle.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  // 如果速度发生变化，归一化到目标速度\n  if (Math.abs(currentSpeed - SPEED) > 0.1) {\n    const scale = SPEED / currentSpeed;\n    triangle.setVelocity(\n      currentVelocity.x * scale,\n      currentVelocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000434_v1", "prompt_id": "seed_000434", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.alpha\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续时间 4 秒\n4. 设置 Tween 为循环播放模式（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -60);      // 顶点\n  graphics.lineTo(-52, 30);     // 左下角\n  graphics.lineTo(52, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 将 Graphics 生成为纹理\n  graphics.generateTexture('triangle', 104, 90);\n  \n  // 销毁 Graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的 Sprite\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始透明度为 0（完全透明）\n  triangle.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    alpha: 1,                    // 目标透明度值（完全不透明）\n    duration: 4000,              // 持续时间 4 秒（4000 毫秒）\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 反向播放（不透明回到透明）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '三角形透明度循环动画（4秒周期）', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000473_v2", "prompt_id": "seed_000473", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 800。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可在空中跳跃一次，跳跃力度200，重力800\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 创建物理系统配置，设置重力为800\n2. 使用Graphics绘制玩家角色和地面平台\n3. 添加键盘输入监听（空格键或上箭头键）\n4. 实现跳跃计数器，限制最多跳跃2次\n5. 玩家接触地面时重置跳跃计数\n6. 添加状态显示文本，显示剩余跳跃次数\n[/PLAN]\n\n```javascript\n// 双跳功能实现\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet jumpCount = 0; // 当前已跳跃次数\nlet maxJumps = 2; // 最大跳跃次数\nlet statusText;\nlet jumpForce = -200; // 跳跃力度（负值向上）\n\nfunction preload() {\n  // 使用Graphics创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建地面\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x228B22, 1);\n  groundGraphics.fillRect(0, 550, 800, 50);\n  groundGraphics.generateTexture('groundTex', 800, 50);\n  groundGraphics.destroy();\n\n  ground = this.physics.add.staticImage(400, 575, 'groundTex');\n\n  // 创建玩家\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0xFF6347, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('playerTex', 40, 40);\n  playerGraphics.destroy();\n\n  player = this.physics.add.sprite(100, 450, 'playerTex');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 设置碰撞\n  this.physics.add.collider(player, ground, () => {\n    // 玩家着地时重置跳跃次数\n    if (player.body.touching.down) {\n      jumpCount = 0;\n      updateStatusText();\n    }\n  });\n\n  // 键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 状态文本显示\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '24px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n  updateStatusText();\n\n  // 添加说明文本\n  this.add.text(16, 60, '按 SPACE 或 UP 跳跃\\n可在空中再跳一次', {\n    fontSize: '18px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加左右移动平台用于测试\n  const platformGraphics = this.add.graphics();\n  platformGraphics.fillStyle(0x8B4513, 1);\n  platformGraphics.fillRect(0, 0, 150, 20);\n  platformGraphics.generateTexture('platformTex', 150, 20);\n  platformGraphics.destroy();\n\n  const platform1 = this.physics.add.staticImage(300, 400, 'platformTex');\n  const platform2 = this.physics.add.staticImage(500, 300, 'platformTex');\n  \n  this.physics.add.collider(player, platform1, () => {\n    if (player.body.touching.down) {\n      jumpCount = 0;\n      updateStatusText();\n    }\n  });\n  \n  this.physics.add.collider(player, platform2, () => {\n    if (player.body.touching.down) {\n      jumpCount = 0;\n      updateStatusText();\n    }\n  });\n}\n\nfunction update() {\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃逻辑\n  if (Phaser.Input.Keyboard.JustDown(cursors.up) || Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    if (jumpCount < maxJumps) {\n      player.setVelocityY(jumpForce);\n      jumpCount++;\n      updateStatusText();\n    }\n  }\n}\n\nfunction updateStatusText() {\n  const remainingJumps = maxJumps - jumpCount;\n  statusText.setText(`剩余跳跃次数: ${remainingJumps}/${maxJumps}`);\n  \n  // 改变文本颜色提示\n  if (remainingJumps === 0) {\n    statusText.setStyle({ fill: '#ff0000' });\n  } else if (remainingJumps === 1) {\n    statusText.setStyle({ fill: '#ff8800' });\n  } else {\n    statusText.setStyle({ fill: '#000' });\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000881_v2", "prompt_id": "seed_000881", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色圆形以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色圆形以120速度移动并在边界反弹\nAPI: Graphics.fillCircle, Graphics.generateTexture, Physics.Arcade.Sprite, Physics.World.setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制橙色圆形并生成纹理\n2. 创建 Arcade Physics 精灵并设置速度为120\n3. 启用世界边界碰撞和精灵边界反弹\n4. 设置精灵在边界碰撞时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillCircle(25, 25, 25); // 半径25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('orangeCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵，位置在画布中心\n  const circle = this.physics.add.sprite(400, 300, 'orangeCircle');\n  \n  // 设置初始速度为120（斜向移动）\n  circle.setVelocity(120, 120);\n  \n  // 设置碰撞边界\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1，实现完美反弹\n  circle.setBounce(1, 1);\n  \n  // 确保世界边界启用碰撞\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000662_v1", "prompt_id": "seed_000662", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并使用 fillTriangle 绘制三角形\n2. 在 create 中将 Graphics 对象保存为场景属性\n3. 在 update 中根据 delta 时间累加旋转角度（120度/秒 = 2.094弧度/秒）\n4. 将计算出的旋转值应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  this.triangle = this.add.graphics();\n  \n  // 设置三角形的位置到屏幕中心\n  this.triangle.x = 400;\n  this.triangle.y = 300;\n  \n  // 设置填充颜色\n  this.triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心点在原点）\n  // 三角形的顶点相对于 Graphics 对象的原点\n  const size = 80;\n  const height = size * Math.sqrt(3) / 2;\n  \n  this.triangle.fillTriangle(\n    0, -height * 2 / 3,           // 顶点（上）\n    -size / 2, height / 3,        // 左下顶点\n    size / 2, height / 3          // 右下顶点\n  );\n  \n  // 初始化旋转角度\n  this.currentRotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 120 度\n  // 120 度 = 120 * (Math.PI / 180) = 2.0944 弧度\n  const rotationSpeed = (120 * Math.PI / 180); // 弧度/秒\n  \n  // 根据 delta（毫秒）计算本帧应旋转的角度\n  this.currentRotation += rotationSpeed * (delta / 1000);\n  \n  // 应用旋转\n  this.triangle.rotation = this.currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000441_v3", "prompt_id": "seed_000441", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 160 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版，敌人速度随时间从160逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Time.TimerEvent, Phaser.Physics.Arcade.Group, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家精灵和敌人组，使用Graphics生成纹理\n2. 实现键盘控制玩家移动（方向键）\n3. 设置定时器生成敌人，初始速度160，每秒递增速度\n4. 添加碰撞检测，碰撞后游戏结束\n5. 显示生存时间文本，每帧更新\n6. 暴露survivalTime和enemySpeed状态变量用于验证\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.survivalTime = 0;\n    this.enemySpeed = 160;\n    this.gameOver = false;\n    this.speedIncrement = 10; // 每秒增加的速度\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 24, 24);\n    enemyGraphics.generateTexture('enemy', 24, 24);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(width / 2, height - 50, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0.0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 速度文本\n    this.speedText = this.add.text(16, 50, 'Speed: 160', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏结束文本（隐藏）\n    this.gameOverText = this.add.text(width / 2, height / 2, 'GAME OVER', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      fontFamily: 'Arial'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本（隐藏）\n    this.restartText = this.add.text(width / 2, height / 2 + 60, 'Click to Restart', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 定时生成敌人\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 定时增加敌人速度\n    this.speedTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.increaseSpeed,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 点击重启\n    this.input.on('pointerdown', () => {\n      if (this.gameOver) {\n        this.scene.restart();\n      }\n    });\n\n    // 记录游戏开始时间\n    this.startTime = this.time.now;\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 更新生存时间\n    this.survivalTime = (time - this.startTime) / 1000;\n    this.timeText.setText(`Time: ${this.survivalTime.toFixed(1)}s`);\n\n    // 玩家移动\n    const speed = 300;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 移除超出屏幕的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > this.cameras.main.height + 50) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    const x = Phaser.Math.Between(20, this.cameras.main.width - 20);\n    const enemy = this.enemies.create(x, -20, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  increaseSpeed() {\n    if (this.gameOver) {\n      return;\n    }\n\n    this.enemySpeed += this.speedIncrement;\n    this.speedText.setText(`Speed: ${this.enemySpeed}`);\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) {\n      return;\n    }\n\n    this.gameOver = true;\n\n    // 停止所有定时器\n    this.enemyTimer.remove();\n    this.speedTimer.remove();\n\n    // 停止玩家\n    this.player.setVelocity(0);\n    this.player.setTint(0xff0000);\n\n    // 停止所有敌人\n    this.enemies.children.entries.forEach((e) => {\n      e.setVelocity(0);\n    });\n\n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 更新最终时间\n    this.timeText.setText(`Final Time: ${this.survivalTime.toFixed(1)}s`);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000908_v1", "prompt_id": "seed_000908", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.855}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算菱形四个顶点坐标（中心点在画布中央，菱形对角线长度为 48 像素）\n4. 使用 Graphics API 绘制菱形路径并填充灰色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 菱形大小（对角线长度的一半）\n  const size = 24; // 48 / 2 = 24\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000100_v3", "prompt_id": "seed_000100", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 120 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKeys(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制方块并生成纹理\n2. 使用 this.add.sprite() 创建可移动的方块精灵\n3. 使用 addKeys 绑定 WASD 键盘输入\n4. 在 update 中根据按键状态更新方块位置，速度为 120 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('playerBox', 40, 40);\n  graphics.destroy();\n\n  // 创建玩家方块精灵，放置在屏幕中央\n  player = this.add.sprite(400, 300, 'playerBox');\n\n  // 绑定 WASD 键\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧应移动的距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 根据按键状态设置移动方向\n  if (keys.w.isDown) {\n    velocityY = -1;\n  } else if (keys.s.isDown) {\n    velocityY = 1;\n  }\n\n  if (keys.a.isDown) {\n    velocityX = -1;\n  } else if (keys.d.isDown) {\n    velocityX = 1;\n  }\n\n  // 归一化对角线移动速度（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n\n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n\n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000493_v2", "prompt_id": "seed_000493", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让圆形在2秒内从透明渐变到完全不透明并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 2 秒\n4. 设置 Tween 为循环播放（yoyo 或 repeat -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circle', 100, 100); // 生成 100x100 的纹理\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建圆形精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circle');\n  \n  // 设置初始透明度为 0（完全透明）\n  circle.setAlpha(0);\n\n  // 创建 Tween 动画：从透明到不透明，持续 2 秒，循环播放\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    alpha: 1,                  // 目标透明度为 1（完全不透明）\n    duration: 2000,            // 持续时间 2 秒（2000 毫秒）\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 来回播放（透明->不透明->透明）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Circle Fade Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000553_v3", "prompt_id": "seed_000553", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个圆形，使用 Tween 动画在 4 秒内缩放到 24%，然后恢复原始大小，并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，从 1 缩放到 0.24\n4. 设置 yoyo 为 true 使动画往返播放\n5. 设置 loop 为 -1 实现无限循环\n6. 设置 duration 为 2000ms（单程 2 秒，往返共 4 秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n\n  // 创建圆形精灵并居中显示\n  const circle = this.add.sprite(400, 300, 'circle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: circle,\n    scaleX: 0.24, // 缩放到 24%\n    scaleY: 0.24, // 缩放到 24%\n    duration: 2000, // 单程 2 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 往返播放（缩小后再放大）\n    loop: -1 // 无限循环\n  });\n\n  // 添加提示文字\n  this.add.text(400, 550, 'Circle scaling: 100% ↔ 24% (4s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000111_v3", "prompt_id": "seed_000111", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让黄色六边形在 1 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色六边形淡入淡出循环动画\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制黄色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tweens 创建 alpha 透明度动画（0到1）\n4. 设置 yoyo 为 true 实现淡入淡出效果\n5. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制黄色六边形\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点坐标（中心在 64, 64，半径 50）\n  const radius = 50;\n  const centerX = 64;\n  const centerY = 64;\n  const hexagonPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    hexagonPoints.push(x, y);\n  }\n  \n  // 绘制黄色六边形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillPolygon(hexagonPoints);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 128, 128);\n  graphics.destroy(); // 销毁 graphics 对象，不再需要\n  \n  // 创建精灵对象\n  const hexagonSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果，duration 1000ms 表示淡入+淡出总共 2 秒\n  // 要实现 1 秒完成淡入淡出，每个方向需要 500ms\n  this.tweens.add({\n    targets: hexagonSprite,\n    alpha: 0,           // 从当前 alpha(1) 淡出到 0\n    duration: 500,      // 淡出持续 500ms\n    yoyo: true,         // 启用 yoyo 效果，淡出后自动淡入\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '黄色六边形淡入淡出循环动画', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000041_v2", "prompt_id": "seed_000041", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆形状\n2. 在 create 中初始化椭圆的位置和样式\n3. 在 update 中根据 delta 时间增量计算旋转角度（240度/秒 = 240 * Math.PI/180 弧度/秒）\n4. 每帧更新 Graphics 对象的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  ellipse = this.add.graphics();\n  \n  // 设置椭圆样式和绘制\n  ellipse.fillStyle(0x00ff00, 1);\n  ellipse.fillEllipse(0, 0, 150, 80); // 中心点在(0,0)，宽150，高80\n  \n  // 设置椭圆位置到屏幕中心\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '椭圆以每秒 240° 旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 计算每帧旋转的角度（弧度）\n  // 240度/秒 = 240 * (Math.PI / 180) 弧度/秒\n  // delta 是毫秒，需要转换为秒：delta / 1000\n  const rotationSpeed = 240 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 更新椭圆的旋转角度\n  ellipse.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000446_v3", "prompt_id": "seed_000446", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色矩形在3秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Game 配置和 Scene，设置舞台尺寸\n2. 在 create 中使用 Graphics 绘制白色矩形\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置 duration 为 3000 毫秒（3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建白色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 80, 60);\n  \n  // 将 graphics 转换为纹理以便于补间动画控制\n  graphics.generateTexture('whiteRect', 80, 60);\n  graphics.destroy();\n  \n  // 创建精灵对象用于动画\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（从左到右）\n    duration: 3000,          // 持续时间 3 秒\n    yoyo: true,              // 启用往返效果（到达目标后反向播放）\n    repeat: -1,              // 无限循环（-1 表示永久重复）\n    ease: 'Linear'           // 线性缓动函数，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000720_v2", "prompt_id": "seed_000720", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右上显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右上角显示 \"Hello Phaser\" 文字，字体大小 16 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字位置为屏幕右上角（canvas 宽度减去偏移，y 为偏移值）\n4. 设置文字原点为右上角 (1, 0)，使文字从右上角定位\n5. 配置文字样式：字体大小 16px，颜色为白色\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕右上角创建文字\n  // 位置：x = 画布宽度 - 20（右边距），y = 20（上边距）\n  const text = this.add.text(780, 20, 'Hello Phaser', {\n    fontSize: '16px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字原点为右上角 (1, 0)\n  // 这样文字会从右上角开始对齐，而不是默认的左上角\n  text.setOrigin(1, 0);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000490_v3", "prompt_id": "seed_000490", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的青色矩形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的青色矩形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中使用循环创建3个 Graphics 对象\n3. 为每个 Graphics 对象设置青色填充样式（0x00ffff）\n4. 绘制 16x16 的矩形，并使用 setRandomPosition 设置随机位置\n5. 确保矩形在画布范围内显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建3个随机位置的青色矩形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置青色填充样式（cyan: 0x00ffff）\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 绘制 16x16 的矩形（以原点为基准）\n    graphics.fillRect(0, 0, 16, 16);\n    \n    // 设置随机位置（确保矩形完全在画布内）\n    graphics.setRandomPosition(0, 0, 800 - 16, 600 - 16);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000245_v2", "prompt_id": "seed_000245", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在4秒内从透明渐变到完全不透明，循环播放\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Graphics.generateTexture, Tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性从 0 到 1\n4. 设置 yoyo 和 repeat(-1) 实现循环渐变效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 计算六边形的顶点坐标\n  const hexRadius = 80;\n  const centerX = 0;\n  const centerY = 0;\n  const hexPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    hexPoints.push(x, y);\n  }\n  \n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff88, 1); // 青绿色\n  graphics.fillPolygon(hexPoints);\n  \n  // 生成纹理\n  const textureSize = hexRadius * 2 + 20;\n  graphics.x = textureSize / 2;\n  graphics.y = textureSize / 2;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建六边形精灵\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  hexagon.setAlpha(0); // 初始透明度为 0\n  \n  // 创建渐变动画\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 4000, // 4秒\n    yoyo: true, // 来回播放（透明->不透明->透明）\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性渐变\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Hexagon fading in/out (4s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000375_v3", "prompt_id": "seed_000375", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现黄色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现黄色角色通过按键切换 idle/run 状态，使用 tween 或帧动画体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Tweens.TweenManager, Phaser.Animations.AnimationManager\nSTEPS:\n1. 使用 Graphics 创建黄色角色纹理（多帧）\n2. 创建 idle 和 run 两种帧动画\n3. 监听键盘输入（1键切换到idle，2键切换到run）\n4. 根据状态播放对应动画，并添加 tween 效果增强表现\n5. 显示当前状态文本作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle'; // 可验证的状态变量\n  }\n\n  preload() {\n    // 创建黄色角色的多帧纹理\n    this.createCharacterFrames();\n  }\n\n  createCharacterFrames() {\n    const graphics = this.add.graphics();\n    \n    // 创建 idle 状态的3帧（黄色方块，轻微变化）\n    for (let i = 0; i < 3; i++) {\n      graphics.clear();\n      graphics.fillStyle(0xffff00, 1); // 黄色\n      \n      // 轻微的大小变化模拟呼吸效果\n      const size = 50 + i * 2;\n      const offset = (50 - size) / 2;\n      graphics.fillRect(offset, offset, size, size);\n      \n      // 添加眼睛\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(15, 20, 3);\n      graphics.fillCircle(35, 20, 3);\n      \n      graphics.generateTexture(`idle_${i}`, 50, 50);\n    }\n    \n    // 创建 run 状态的4帧（黄色方块，倾斜和拉伸）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      graphics.fillStyle(0xffff00, 1);\n      \n      // 跑步时的形变效果\n      const skew = i % 2 === 0 ? 5 : -5;\n      graphics.fillRect(skew, 0, 50, 50);\n      \n      // 添加眼睛（跑步时眼睛更有动感）\n      graphics.fillStyle(0x000000, 1);\n      const eyeOffset = i % 2 === 0 ? 2 : -2;\n      graphics.fillCircle(15 + eyeOffset, 20, 3);\n      graphics.fillCircle(35 + eyeOffset, 20, 3);\n      \n      // 添加运动线条\n      graphics.lineStyle(2, 0xffff00, 0.5);\n      graphics.lineBetween(-10, 15 + i * 5, 0, 15 + i * 5);\n      graphics.lineBetween(-10, 35 + i * 5, 0, 35 + i * 5);\n      \n      graphics.generateTexture(`run_${i}`, 50, 50);\n    }\n    \n    graphics.destroy();\n  }\n\n  create() {\n    // 添加背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x87ceeb, 1);\n    bg.fillRect(0, 0, 800, 600);\n    \n    // 创建角色精灵\n    this.player = this.add.sprite(400, 300, 'idle_0');\n    this.player.setScale(2);\n    \n    // 创建 idle 动画\n    this.anims.create({\n      key: 'idle',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' },\n        { key: 'idle_2' },\n        { key: 'idle_1' }\n      ],\n      frameRate: 4,\n      repeat: -1\n    });\n    \n    // 创建 run 动画\n    this.anims.create({\n      key: 'run',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 10,\n      repeat: -1\n    });\n    \n    // 默认播放 idle 动画\n    this.player.play('idle');\n    \n    // 添加状态文本显示\n    this.stateText = this.add.text(400, 100, 'State: IDLE', {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.stateText.setOrigin(0.5);\n    \n    // 添加提示文本\n    this.add.text(400, 500, 'Press [1] for IDLE  |  Press [2] for RUN', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 3\n    }).setOrigin(0.5);\n    \n    // 键盘输入监听\n    this.key1 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ONE);\n    this.key2 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.TWO);\n    \n    // 监听按键按下事件\n    this.key1.on('down', () => this.switchState('idle'));\n    this.key2.on('down', () => this.switchState('run'));\n    \n    // 添加粒子效果容器\n    this.particleGraphics = this.add.graphics();\n  }\n\n  switchState(newState) {\n    if (this.currentState === newState) return;\n    \n    this.currentState = newState;\n    \n    // 停止所有正在进行的 tween\n    this.tweens.killTweensOf(this.player);\n    \n    if (newState === 'idle') {\n      // 切换到 idle 状态\n      this.player.play('idle');\n      this.stateText.setText('State: IDLE');\n      \n      // idle 状态的 tween：轻微上下浮动\n      this.tweens.add({\n        targets: this.player,\n        y: 300 - 10,\n        duration: 1000,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n      \n      // 缩放回正常\n      this.tweens.add({\n        targets: this.player,\n        scaleX: 2,\n        scaleY: 2,\n        duration: 300,\n        ease: 'Back.easeOut'\n      });\n      \n    } else if (newState === 'run') {\n      // 切换到 run 状态\n      this.player.play('run');\n      this.stateText.setText('State: RUN');\n      \n      // run 状态的 tween：左右快速移动\n      this.tweens.add({\n        targets: this.player,\n        x: 600,\n        duration: 1500,\n        ease: 'Linear',\n        yoyo: true,\n        repeat: -1\n      });\n      \n      // 轻微倾斜效果\n      this.tweens.add({\n        targets: this.player,\n        angle: -5,\n        duration: 150,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n      \n      // 轻微拉伸效果\n      this.tweens.add({\n        targets: this.player,\n        scaleX: 2.2,\n        scaleY: 1.9,\n        duration: 300,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n    }\n    \n    // 状态切换时的闪烁效果\n    this.tweens.add({\n      targets: this.stateText,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 2\n    });\n  }\n\n  update(time, delta) {\n    // 在 run 状态下添加拖尾粒子效果\n    if (this.currentState === 'run' && Math.random() > 0.7) {\n      this.particleGraphics.clear();\n      this.particleGraphics.fillStyle(0xffff00, 0.3);\n      \n      for (let i = 0; i < 3; i++) {\n        const offsetX = (Math.random() - 0.5) * 20;\n        const offsetY = (Math.random() - 0.5) * 20;\n        this.particleGraphics.fillCircle(\n          this.player.x + offsetX - 30,\n          this.player.y + offsetY,\n          5\n        );\n      }\n      \n      // 粒子淡出\n      this.tweens.add({\n        targets: this.particleGraphics,\n        alpha: 0,\n        duration: 300,\n        onComplete: () => {\n          this.particleGraphics.clear();\n          this.particleGraphics.alpha = 1;\n        }\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene,\n  pixelArt: false,\n  parent: 'game-container'\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000898_v1", "prompt_id": "seed_000898", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.9649999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的蓝色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的蓝色星形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillStar, Graphics.setRandomPosition, Scene.add.graphics\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置蓝色填充，使用 fillStar 绘制星形（5个点，外半径32，内半径16）\n4. 使用 setRandomPosition 将每个星形随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载资源\n}\n\nfunction create() {\n  // 创建20个蓝色星形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置蓝色填充\n    graphics.fillStyle(0x0000ff, 1);\n    \n    // 绘制星形\n    // fillStar(x, y, points, innerRadius, outerRadius)\n    // 星形中心在 (0, 0)，外半径32像素（总大小64像素），内半径16像素\n    graphics.fillStar(0, 0, 5, 16, 32);\n    \n    // 随机位置放置星形\n    // 确保星形完全在画布内（留出32像素边距）\n    graphics.setRandomPosition(32, 32, 800 - 64, 600 - 64);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000150_v3", "prompt_id": "seed_000150", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 300 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版，敌人速度随时间从300逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade.Group, Phaser.Time.TimerEvent, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统场景，生成玩家和敌人的纹理\n2. 使用键盘控制玩家移动，限制在屏幕范围内\n3. 创建敌人组，初始速度300，定时生成敌人\n4. 添加碰撞检测，碰到敌人游戏结束\n5. 使用定时器记录生存时间，每秒增加敌人速度\n6. 显示生存时间文本，游戏结束显示最终成绩\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.survivalTime = 0;\n    this.enemySpeed = 300;\n    this.isGameOver = false;\n    this.speedIncreaseRate = 20; // 每秒增加的速度\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 24, 24);\n    enemyGraphics.generateTexture('enemy', 24, 24);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 速度显示文本\n    this.speedText = this.add.text(16, 50, 'Speed: 300', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      fontFamily: 'Arial'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 定时生成敌人（每0.8秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 800,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 每秒更新计时器和速度\n    this.survivalTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.updateTime,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 重置提示\n    this.restartText = this.add.text(400, 360, '', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 空格键重启\n    this.input.keyboard.on('keydown-SPACE', () => {\n      if (this.isGameOver) {\n        this.scene.restart();\n      }\n    });\n  }\n\n  update() {\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 玩家移动\n    const speed = 350;\n    \n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.isGameOver) {\n      return;\n    }\n\n    // 随机X位置\n    const x = Phaser.Math.Between(20, 780);\n    const enemy = this.enemies.create(x, -20, 'enemy');\n    \n    // 设置当前速度\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  updateTime() {\n    if (this.isGameOver) {\n      return;\n    }\n\n    this.survivalTime++;\n    this.timeText.setText('Time: ' + this.survivalTime + 's');\n\n    // 增加敌人速度\n    this.enemySpeed += this.speedIncreaseRate;\n    this.speedText.setText('Speed: ' + Math.floor(this.enemySpeed));\n\n    // 更新现有敌人的速度\n    this.enemies.children.entries.forEach(enemy => {\n      enemy.setVelocityY(this.enemySpeed);\n    });\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.isGameOver) {\n      return;\n    }\n\n    this.isGameOver = true;\n\n    // 停止所有定时器\n    this.enemyTimer.remove();\n    this.survivalTimer.remove();\n\n    // 停止所有物理对象\n    this.physics.pause();\n\n    // 显示游戏结束信息\n    this.gameOverText.setText('GAME OVER!\\nSurvived: ' + this.survivalTime + 's');\n    this.gameOverText.setVisible(true);\n\n    this.restartText.setText('Press SPACE to restart');\n    this.restartText.setVisible(true);\n\n    // 玩家变灰\n    this.player.setTint(0x888888);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000894_v2", "prompt_id": "seed_000894", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.865}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在1.5秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 使用 Tween 实现缩放动画，从1到0.48再回到1\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy();\n\n  // 在屏幕中心创建方块精灵\n  const square = this.add.sprite(400, 300, 'square');\n\n  // 创建缩放动画\n  // yoyo: true 使动画在到达目标后反向播放回到起始值\n  // duration: 1500 表示单向动画时长1.5秒（往返共3秒）\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 1500,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut'\n  });\n\n  // 添加文字说明\n  this.add.text(400, 500, 'Square scaling to 48% and back (looping)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000607_v3", "prompt_id": "seed_000607", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在1.5秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制星形纹理并生成可复用纹理\n2. 创建 Star 游戏对象放置在屏幕中心\n3. 使用 Tweens 创建缩放动画，从 scale:1 到 scale:0.48，持续1.5秒\n4. 设置 yoyo:true 实现来回动画，loop:-1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制星形路径\n  const points = [];\n  const radius1 = 50; // 外半径\n  const radius2 = 20; // 内半径\n  const spikes = 5;\n  const centerX = 60;\n  const centerY = 60;\n  \n  for (let i = 0; i < spikes * 2; i++) {\n    const radius = i % 2 === 0 ? radius1 : radius2;\n    const angle = (i * Math.PI) / spikes - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    points.push(new Phaser.Math.Vector2(x, y));\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 120, 120);\n  graphics.destroy();\n  \n  // 创建星形精灵并放置在屏幕中心\n  const star = this.add.image(400, 300, 'star');\n  \n  // 创建缩放补间动画\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 1500, // 1.5秒\n    ease: 'Sine.easeInOut', // 使用正弦缓动使动画更平滑\n    yoyo: true, // 来回播放（缩小后再放大）\n    loop: -1, // 无限循环\n    repeat: 0 // yoyo模式下不需要额外repeat\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 550, '星形缩放动画 (1.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000286_v3", "prompt_id": "seed_000286", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让灰色矩形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色矩形，使用 Tween 动画实现 1 秒内旋转 360 度并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.GameObject.generateTexture, Phaser.Tweens.TweenManager.add\nSTEPS:\n1. 使用 Graphics 绘制灰色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 设置动画持续时间为 1000ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('grayRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象并设置位置到屏幕中心\n  const rectangle = this.add.sprite(400, 300, 'grayRect');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rectangle,\n    angle: 360, // 旋转到 360 度\n    duration: 1000, // 持续 1 秒\n    ease: 'Linear', // 线性缓动\n    repeat: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000732_v3", "prompt_id": "seed_000732", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser 游戏配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算菱形的四个顶点坐标（中心点为画布中央，菱形对角线长度为 48 像素）\n4. 使用 Graphics API 绘制菱形路径并填充灰色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  \n  // 计算菱形的中心点（画布中央）\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 菱形的半对角线长度（48 像素菱形，对角线为 48，半对角线为 24）\n  const halfSize = 24;\n  \n  // 绘制菱形路径\n  graphics.beginPath();\n  \n  // 上顶点\n  graphics.moveTo(centerX, centerY - halfSize);\n  \n  // 右顶点\n  graphics.lineTo(centerX + halfSize, centerY);\n  \n  // 下顶点\n  graphics.lineTo(centerX, centerY + halfSize);\n  \n  // 左顶点\n  graphics.lineTo(centerX - halfSize, centerY);\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000100_v2", "prompt_id": "seed_000100", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色椭圆，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色椭圆，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置绿色填充样式 (0x00ff00)\n4. 使用 fillEllipse 方法在画布中央 (400, 300) 绘制椭圆，半径约 48 像素\n5. 完成绘制并初始化游戏\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 绘制绿色椭圆\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  const centerX = config.width / 2;  // 400\n  const centerY = config.height / 2; // 300\n  const ellipseWidth = 48;\n  const ellipseHeight = 48;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000656_v2", "prompt_id": "seed_000656", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个白色敌人巡逻移动，在 120 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 10个白色敌人在场景中巡逻，玩家靠近时追踪玩家\nAPI: Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Phaser.Physics.Arcade.Body, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统和场景配置\n2. 使用 Graphics 生成玩家和敌人的纯色纹理\n3. 创建物理组管理10个敌人，设置初始巡逻速度和方向\n4. 在 update 中检测每个敌人与玩家的距离，小于阈值时追踪\n5. 处理敌人边界碰撞实现左右往返巡逻\n6. 添加键盘控制玩家移动\n7. 添加状态信号变量记录敌人追踪状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemyTrackingCount = 0; // 状态信号：正在追踪的敌人数量\n    this.totalEnemies = 10; // 状态信号：敌人总数\n    this.detectionRange = 150; // 检测范围\n    this.patrolSpeed = 120; // 巡逻速度\n    this.chaseSpeed = 180; // 追踪速度\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0099ff, 1);\n    playerGraphics.fillRect(0, 0, 30, 30);\n    playerGraphics.generateTexture('player', 30, 30);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（白色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xffffff, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      key: 'enemy',\n      repeat: this.totalEnemies - 1,\n      setXY: { \n        x: 100, \n        y: 100, \n        stepX: 70,\n        stepY: 60\n      }\n    });\n\n    // 初始化每个敌人的巡逻状态\n    this.enemies.children.entries.forEach((enemy, index) => {\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 设置初始巡逻方向（随机左右）\n      const direction = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;\n      enemy.setVelocityX(this.patrolSpeed * direction);\n      \n      // 存储敌人状态\n      enemy.setData('isTracking', false);\n      enemy.setData('patrolDirection', direction);\n      enemy.setData('initialY', enemy.y);\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界线以便观察\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0x00ff00, 0.3);\n    graphics.strokeRect(0, 0, width, height);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 重置追踪计数\n    this.enemyTrackingCount = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach((enemy) => {\n      const distance = Phaser.Math.Distance.Between(\n        enemy.x, enemy.y,\n        this.player.x, this.player.y\n      );\n\n      // 检测是否在追踪范围内\n      if (distance < this.detectionRange) {\n        // 进入追踪模式\n        enemy.setData('isTracking', true);\n        this.enemyTrackingCount++;\n\n        // 计算追踪方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        // 设置追踪速度\n        this.physics.velocityFromRotation(\n          angle,\n          this.chaseSpeed,\n          enemy.body.velocity\n        );\n\n        // 改变颜色表示追踪状态（红色）\n        enemy.setTint(0xff0000);\n      } else {\n        // 退出追踪模式，恢复巡逻\n        if (enemy.getData('isTracking')) {\n          enemy.setData('isTracking', false);\n          enemy.clearTint();\n          \n          // 恢复巡逻速度\n          const direction = enemy.getData('patrolDirection');\n          enemy.setVelocityX(this.patrolSpeed * direction);\n          enemy.setVelocityY(0);\n        }\n\n        // 巡逻模式：检测左右边界碰撞\n        if (!enemy.getData('isTracking')) {\n          const bounds = this.physics.world.bounds;\n          \n          // 碰到左边界或右边界时反转方向\n          if (enemy.x <= enemy.width / 2 && enemy.body.velocity.x < 0) {\n            enemy.setData('patrolDirection', 1);\n            enemy.setVelocityX(this.patrolSpeed);\n          } else if (enemy.x >= bounds.width - enemy.width / 2 && enemy.body.velocity.x > 0) {\n            enemy.setData('patrolDirection', -1);\n            enemy.setVelocityX(-this.patrolSpeed);\n          }\n\n          // 保持在初始Y轴附近巡逻\n          const initialY = enemy.getData('initialY');\n          if (Math.abs(enemy.y - initialY) > 5) {\n            const yDirection = enemy.y > initialY ? -1 : 1;\n            enemy.setVelocityY(yDirection * 50);\n          } else {\n            enemy.setVelocityY(0);\n          }\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Total Enemies: ${this.totalEnemies}`,\n      `Tracking: ${this.enemyTrackingCount}`,\n      `Patrolling: ${this.totalEnemies - this.enemyTrackingCount}`,\n      `Player: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      '',\n      'Use Arrow Keys to Move'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001003_v2", "prompt_id": "seed_001003", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色三角形在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色三角形在3秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Triangle\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建 y 轴弹跳动画，配置 ease 为 'Bounce.easeOut'\n4. 设置动画循环播放，duration 为 3000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（顶点朝上）\n  const triangleSize = 60;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize / 2); // 顶点\n  graphics.lineTo(-triangleSize / 2, triangleSize / 2); // 左下角\n  graphics.lineTo(triangleSize / 2, triangleSize / 2); // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在屏幕中心偏上\n  const triangle = this.add.sprite(400, 200, 'triangle');\n  \n  // 创建弹跳动画\n  // 从当前位置（y=200）弹跳到底部（y=500），然后返回\n  this.tweens.add({\n    targets: triangle,\n    y: 500, // 目标 y 位置\n    duration: 1500, // 下落时间 1.5 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返动画\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '绿色三角形弹跳动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '3秒一个循环（1.5秒下落 + 1.5秒上升）', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000439_v2", "prompt_id": "seed_000439", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色星形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个灰色星形在2秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色星形并生成纹理\n2. 创建使用该纹理的 Sprite 对象并放置在左侧起始位置\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动，duration 为 2000ms\n4. 设置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色星形\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制五角星\n  const centerX = 32;\n  const centerY = 32;\n  const outerRadius = 30;\n  const innerRadius = 12;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右移动，2秒完成，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 2000, // 2秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环\n    ease: 'Linear' // 线性运动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000118_v1", "prompt_id": "seed_000118", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色三角形在 2.5 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色三角形在 2.5 秒内完成抖动动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建 Sprite 对象承载三角形纹理\n3. 使用 Tween 创建抖动效果（x/y 位置随机偏移）\n4. 设置 Tween 持续时间为 2.5 秒并循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制三角形（等边三角形）\n  const triangleSize = 60;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize / 2);\n  graphics.lineTo(-triangleSize / 2, triangleSize / 2);\n  graphics.lineTo(triangleSize / 2, triangleSize / 2);\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 记录初始位置\n  const originalX = triangle.x;\n  const originalY = triangle.y;\n  \n  // 创建抖动动画\n  // 使用 timeline 来创建复杂的抖动效果\n  const shakeIntensity = 10; // 抖动强度\n  \n  this.tweens.add({\n    targets: triangle,\n    duration: 2500, // 2.5 秒\n    ease: 'Linear',\n    repeat: -1, // 无限循环\n    onUpdate: (tween) => {\n      // 在动画更新时随机偏移位置\n      const progress = tween.progress;\n      \n      // 使用正弦波模拟抖动衰减效果\n      const intensity = Math.sin(progress * Math.PI * 20) * shakeIntensity;\n      \n      triangle.x = originalX + Phaser.Math.Between(-intensity, intensity);\n      triangle.y = originalY + Phaser.Math.Between(-intensity, intensity);\n    },\n    onRepeat: () => {\n      // 每次循环重置位置\n      triangle.x = originalX;\n      triangle.y = originalY;\n    }\n  });\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '灰色三角形抖动动画 (2.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000469_v1", "prompt_id": "seed_000469", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Tween 让方块在 1.5 秒内从透明到不透明循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 创建 Graphics 对象绘制方块\n2. 设置方块初始 alpha 为 0（完全透明）\n3. 使用 tweens.add 创建 alpha 补间动画，从 0 到 1，持续 1500ms\n4. 设置 yoyo: true 和 repeat: -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个方块 Graphics 对象\n  const square = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  square.fillStyle(0x00aaff, 1);\n  \n  // 绘制一个 100x100 的方块，位置在屏幕中心\n  const squareSize = 100;\n  const x = (this.cameras.main.width - squareSize) / 2;\n  const y = (this.cameras.main.height - squareSize) / 2;\n  square.fillRect(x, y, squareSize, squareSize);\n  \n  // 设置初始 alpha 为 0（完全透明）\n  square.alpha = 0;\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,\n    alpha: 1,              // 目标 alpha 值为 1（完全不透明）\n    duration: 1500,        // 持续时间 1.5 秒\n    yoyo: true,            // 来回播放（1->0->1）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加文本提示\n  this.add.text(\n    this.cameras.main.width / 2,\n    50,\n    'Square Fade Animation',\n    {\n      fontSize: '24px',\n      color: '#ffffff'\n    }\n  ).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000546_v1", "prompt_id": "seed_000546", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色星形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个灰色星形在1秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色星形并生成纹理\n2. 创建 Sprite 对象使用该星形纹理\n3. 使用 tweens 创建 x 坐标补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x888888, 1); // 灰色\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push({\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0].x, starPoints[0].y);\n  for (let i = 1; i < starPoints.length; i++) {\n    graphics.lineTo(starPoints[i].x, starPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右，1秒完成，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 1000, // 1秒\n    yoyo: true, // 往返\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000760_v1", "prompt_id": "seed_000760", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中循环12次创建 Graphics 对象\n3. 使用 fillStyle 设置绿色，用 fillTriangle 绘制三角形\n4. 使用 setRandomPosition 随机放置每个三角形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 循环创建12个绿色三角形\n  for (let i = 0; i < 12; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置绿色填充\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制等边三角形，大小为16像素\n    // 计算三角形顶点坐标（中心对齐）\n    const height = 16;\n    const halfBase = height * Math.tan(Math.PI / 6); // 等边三角形底边的一半\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶点（上）\n      -halfBase, height / 2,    // 左下顶点\n      halfBase, height / 2      // 右下顶点\n    );\n    \n    // 随机设置位置\n    graphics.setRandomPosition(\n      0, \n      0, \n      config.width, \n      config.height\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000050_v3", "prompt_id": "seed_000050", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让粉色星形在 1.5 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色星形并使用 Tween 实现 1.5 秒循环缩放动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 tweens.add 创建缩放动画，设置 duration 为 1500ms，yoyo 和 repeat -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  function drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillStyle(color, 1);\n    graphics.fillPath();\n  }\n\n  // 绘制粉色星形\n  graphics.clear();\n  drawStar(graphics, 60, 60, 5, 50, 25, 0xff69b4);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkStar', 120, 120);\n  graphics.destroy();\n\n  // 创建星形精灵并居中\n  const star = this.add.sprite(400, 300, 'pinkStar');\n\n  // 创建缩放动画\n  // 从原始大小缩放到 1.5 倍，然后返回，持续 1.5 秒，无限循环\n  this.tweens.add({\n    targets: star,\n    scaleX: 1.5,\n    scaleY: 1.5,\n    duration: 1500,\n    yoyo: true,        // 动画结束后反向播放\n    repeat: -1,        // 无限循环 (-1 表示永远重复)\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000282_v2", "prompt_id": "seed_000282", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左上显示一段文字 \"Hello Phaser\"，字体大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左上显示 \"Hello Phaser\" 文字，字体大小 24 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左上角（10, 10），字体大小为 24px\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 此任务不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕左上角（10, 10）位置创建文本\n  // 字体大小为 24 像素，颜色为白色\n  this.add.text(10, 10, 'Hello Phaser', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000226_v1", "prompt_id": "seed_000226", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setAlpha\nSTEPS:\n1. 创建 Graphics 对象绘制圆形\n2. 设置圆形初始透明度为 0（完全透明）\n3. 使用 Tween 动画让透明度从 0 渐变到 1\n4. 配置 Tween 为循环播放（yoyo 或 loop）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 在中心位置绘制一个半径为 80 的圆形\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 80;\n  graphics.fillCircle(centerX, centerY, radius);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，持续 1 秒，循环播放\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 1000,              // 持续时间 1 秒\n    ease: 'Linear',              // 线性渐变\n    yoyo: true,                  // 反向播放（不透明再回到透明）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '圆形透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000136_v3", "prompt_id": "seed_000136", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让圆形在1.5秒内缩放到64%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象\n3. 使用 Tween 系统创建缩放动画，设置 scale 从 1 到 0.64 再回到 1\n4. 设置 Tween 的 yoyo 为 true 实现往返效果，duration 为 1500ms\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circleTexture', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建使用该纹理的精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circleTexture');\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: circle,\n    scaleX: 0.64, // 缩放到 64%\n    scaleY: 0.64,\n    duration: 1500, // 1.5 秒\n    yoyo: true, // 往返效果（缩小后再放大）\n    loop: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Circle scaling to 64% and back (looping)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000666_v1", "prompt_id": "seed_000666", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色星形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色星形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个外顶点和 5 个内顶点坐标（基于中心点和半径）\n4. 使用 beginPath/moveTo/lineTo 绘制星形路径\n5. 使用橙色填充星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 40; // 外半径 40px，总大小约 80px\n  const innerRadius = 16; // 内半径（约为外半径的 40%）\n  const points = 5; // 五角星\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算星形的顶点并绘制\n  for (let i = 0; i < points * 2; i++) {\n    // 每个点的角度（交替使用外半径和内半径）\n    const angle = (i * Math.PI) / points - Math.PI / 2; // 从顶部开始\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充星形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000141_v2", "prompt_id": "seed_000141", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的白色星形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的白色星形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 使用数学计算绘制五角星路径（外半径40px，内半径16px）\n4. 为每个星形设置随机位置（确保在画布范围内）\n5. 填充白色并渲染星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个随机位置的白色星形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置随机位置（留出边距以确保星形完全显示）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 绘制白色星形\n    drawStar(graphics, x, y, 5, 40, 16, 0xffffff);\n  }\n}\n\n/**\n * 绘制星形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心点 x 坐标\n * @param {number} cy - 中心点 y 坐标\n * @param {number} spikes - 星形的尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n * @param {number} color - 填充颜色\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n  // 设置填充样式为白色\n  graphics.fillStyle(color, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  let rot = Math.PI / 2 * 3; // 起始角度（从顶部开始）\n  let step = Math.PI / spikes; // 每个点之间的角度步长\n  \n  // 移动到第一个外部点\n  graphics.moveTo(cx, cy - outerRadius);\n  \n  // 绘制星形的所有点\n  for (let i = 0; i < spikes; i++) {\n    // 外部点\n    let x = cx + Math.cos(rot) * outerRadius;\n    let y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n    \n    // 内部点\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n  \n  // 闭合路径\n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000674_v2", "prompt_id": "seed_000674", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让粉色方块在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色方块在0.5秒内完成淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色方块并生成纹理\n2. 创建 Sprite 对象承载纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 loop 参数实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkSquare', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象\n  const pinkSquare = this.add.sprite(400, 300, 'pinkSquare');\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: pinkSquare,\n    alpha: 0, // 目标透明度为0（完全透明）\n    duration: 500, // 持续时间0.5秒\n    yoyo: true, // 启用yoyo效果（淡出后再淡入）\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Pink Square Fade In/Out Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000627_v2", "prompt_id": "seed_000627", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的椭圆在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的椭圆对象并保持居中\nAPI: Graphics.fillEllipse, Camera.startFollow, Sprite.setVelocity, Physics.add.sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制椭圆并生成纹理\n3. 创建物理精灵对象并设置向右上方移动的速度\n4. 使用相机的 startFollow 方法跟随椭圆对象\n5. 设置世界边界使对象可以移动到更大范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成椭圆纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制椭圆\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(30, 30, 60, 40); // 中心点(30,30)，宽60，高40\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 60, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，使对象可以移动到更大的范围\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 创建椭圆精灵对象，初始位置在场景中心\n  this.ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置椭圆向右上方移动（右上方向：x正，y负）\n  this.ellipse.setVelocity(150, -100);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3000, 3000);\n  \n  // 相机跟随椭圆对象\n  this.cameras.main.startFollow(this.ellipse);\n  \n  // 添加背景网格以便观察相机移动效果\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x333333, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.lineBetween(x, 0, x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加文字提示\n  const text = this.add.text(10, 10, '相机跟随椭圆移动', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 让文字固定在相机视图上\n  text.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 可选：如果椭圆移出世界边界，可以重置位置\n  if (this.ellipse.x > 2900 || this.ellipse.y < 100) {\n    this.ellipse.setPosition(400, 300);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000115_v2", "prompt_id": "seed_000115", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形并让它以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon, Scene.update\nSTEPS:\n1. 使用 Graphics 对象绘制一个菱形\n2. 在 create 中创建菱形并设置初始位置在画布中心\n3. 在 update 中根据 delta 时间计算旋转角度增量（80度/秒）\n4. 使用 setRotation 方法更新菱形的旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置菱形的位置在画布中心\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 设置填充颜色\n  diamond.fillStyle(0x00ff00, 1);\n  \n  // 定义菱形的四个顶点（相对于中心点）\n  const points = [\n    0, -80,    // 上顶点\n    60, 0,     // 右顶点\n    0, 80,     // 下顶点\n    -60, 0     // 左顶点\n  ];\n  \n  // 创建多边形并填充\n  const polygon = new Phaser.Geom.Polygon(points);\n  diamond.fillPoints(polygon.points, true);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 80 度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 角度转弧度：Phaser.Math.DegToRad(80)\n  const rotationSpeed = Phaser.Math.DegToRad(80); // 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000);\n  \n  // 更新菱形的旋转角度\n  diamond.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000796_v2", "prompt_id": "seed_000796", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色方块，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的黄色方块，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环8次\n3. 每次循环使用 Phaser.Math.Between 生成随机 x, y 坐标\n4. 使用 Graphics 对象绘制黄色方块（fillStyle 设置为黄色，fillRect 绘制 24x24 方块）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制方块\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制8个随机位置的方块\n  for (let i = 0; i < 8; i++) {\n    // 生成随机位置，确保方块完全在画布内\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const x = Phaser.Math.Between(0, 776);\n    const y = Phaser.Math.Between(0, 576);\n    \n    // 绘制 24x24 的方块\n    graphics.fillRect(x, y, 24, 24);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000278_v1", "prompt_id": "seed_000278", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形移动，速度 360 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Container\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中使用 Graphics 绘制菱形（四个三角形或路径）\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态和 delta 时间计算位移，更新菱形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 360; // 像素/秒\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建菱形图形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制菱形（使用路径）\n  // 菱形中心在 (0, 0)，大小为 40x40\n  graphics.beginPath();\n  graphics.moveTo(0, -20);    // 上顶点\n  graphics.lineTo(20, 0);     // 右顶点\n  graphics.lineTo(0, 20);     // 下顶点\n  graphics.lineTo(-20, 0);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置描边\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 将菱形放置在屏幕中央\n  diamond = graphics;\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 设置 WASD 键盘监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文字\n  this.add.text(10, 10, 'Use WASD to move the diamond', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离（速度 * 时间）\n  // delta 是毫秒，需要转换为秒\n  const distance = SPEED * (delta / 1000);\n  \n  // 初始化速度向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 W 键（向上）\n  if (keys.w.isDown) {\n    velocityY = -1;\n  }\n  \n  // 检测 S 键（向下）\n  if (keys.s.isDown) {\n    velocityY = 1;\n  }\n  \n  // 检测 A 键（向左）\n  if (keys.a.isDown) {\n    velocityX = -1;\n  }\n  \n  // 检测 D 键（向右）\n  if (keys.d.isDown) {\n    velocityX = 1;\n  }\n  \n  // 如果同时按下多个方向键，需要归一化速度向量\n  // 避免斜向移动速度过快\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新菱形位置\n  diamond.x += velocityX * distance;\n  diamond.y += velocityY * distance;\n  \n  // 可选：限制菱形在屏幕范围内\n  diamond.x = Phaser.Math.Clamp(diamond.x, 20, 780);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000735_v3", "prompt_id": "seed_000735", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色三角形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色三角形，大小约为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 计算画布中心点坐标和三角形三个顶点坐标（等边三角形）\n4. 使用 fillStyle 设置绿色填充，使用 fillTriangle 绘制三角形\n5. 可选：添加描边使三角形更清晰\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形大小（从中心到顶点的距离）\n  const size = 48;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点朝上的等边三角形\n  const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n  \n  const x1 = centerX;                    // 顶部顶点\n  const y1 = centerY - height * 2 / 3;\n  \n  const x2 = centerX - size / 2;         // 左下顶点\n  const y2 = centerY + height / 3;\n  \n  const x3 = centerX + size / 2;         // 右下顶点\n  const y3 = centerY + height / 3;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 添加深绿色描边使三角形轮廓更清晰\n  graphics.lineStyle(2, 0x008800, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000471_v3", "prompt_id": "seed_000471", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 1.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个菱形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 1.5 秒\n4. 设置 Tween 为循环模式（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色菱形\n  \n  // 绘制菱形（四个顶点）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size); // 上顶点\n  graphics.lineTo(centerX + size, centerY); // 右顶点\n  graphics.lineTo(centerX, centerY + size); // 下顶点\n  graphics.lineTo(centerX - size, centerY); // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建菱形精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  diamond.alpha = 0; // 初始设置为完全透明\n  \n  // 创建渐变动画：从透明(0)到不透明(1)，持续 1.5 秒，循环播放\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 1500, // 持续时间 1.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（从 0 到 1，再从 1 到 0）\n    repeat: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000138_v2", "prompt_id": "seed_000138", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 8 个蓝色物体以 300 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 8个蓝色物体以300速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.World.collide\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成蓝色圆形纹理\n3. 创建物理组，添加8个物体并设置随机速度\n4. 设置物体反弹系数为1，确保完全弹性碰撞\n5. 在 update 中检测物体间碰撞和边界碰撞\n6. 添加碰撞计数器作为可验证状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证状态：碰撞次数\n    this.activeObjects = 8; // 可验证状态：活动物体数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建蓝色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0066ff, 1);\n    graphics.fillCircle(20, 20, 20);\n    graphics.generateTexture('blueCircle', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.objects = this.physics.add.group({\n      defaultKey: 'blueCircle',\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 创建8个物体并设置随机速度\n    for (let i = 0; i < 8; i++) {\n      // 随机位置（避免边缘）\n      const x = Phaser.Math.Between(100, 700);\n      const y = Phaser.Math.Between(100, 500);\n      \n      const obj = this.objects.create(x, y, 'blueCircle');\n      \n      // 设置随机方向的速度，速度大小为300\n      const angle = Phaser.Math.Between(0, 360);\n      const velocity = this.physics.velocityFromAngle(angle, 300);\n      obj.setVelocity(velocity.x, velocity.y);\n      \n      // 设置圆形碰撞体\n      obj.setCircle(20);\n      obj.setBounce(1);\n    }\n\n    // 设置物体间的碰撞检测\n    this.physics.add.collider(this.objects, this.objects, this.onCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  onCollision(obj1, obj2) {\n    // 碰撞回调，增加计数器\n    this.collisionCount++;\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Active Objects: ${this.activeObjects}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 300 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 确保速度保持在300\n    this.objects.children.entries.forEach(obj => {\n      const body = obj.body;\n      const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n      \n      // 如果速度偏差过大，重新标准化到300\n      if (Math.abs(currentSpeed - 300) > 1) {\n        const scale = 300 / currentSpeed;\n        body.setVelocity(body.velocity.x * scale, body.velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000989_v3", "prompt_id": "seed_000989", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Graphics 对象用于绘制\n2. 计算画布中心点坐标 (400, 300)\n3. 计算菱形四个顶点坐标（上下左右各距中心 24 像素）\n4. 使用 fillStyle 设置紫色填充\n5. 使用 fillPath 绘制菱形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 菱形半径（从中心到顶点的距离）\n  const size = 24;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充 (0x800080 是标准紫色)\n  graphics.fillStyle(0x800080, 1);\n  \n  // 定义菱形的四个顶点坐标\n  // 顶点：上、右、下、左\n  const points = [\n    centerX, centerY - size,  // 上顶点\n    centerX + size, centerY,  // 右顶点\n    centerX, centerY + size,  // 下顶点\n    centerX - size, centerY   // 左顶点\n  ];\n  \n  // 创建多边形并填充\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000112_v1", "prompt_id": "seed_000112", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 5 个金币，重力 600，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集5个金币，重力600，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建带 Arcade 物理系统的游戏配置，设置重力为 600\n2. 使用 Graphics 绘制玩家（矩形）和金币（圆形），生成纹理\n3. 创建地面平台和空中平台，设置为静态物理体\n4. 在空中随机位置创建 5 个金币物理体\n5. 添加键盘控制（方向键），实现左右移动和跳跃\n6. 添加玩家与金币的碰撞检测，收集时增加分数并销毁金币\n7. 创建文本显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色矩形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 400, 32);\n    platformGraphics.generateTexture('platform', 400, 32);\n    platformGraphics.destroy();\n\n    // 创建小平台纹理\n    const smallPlatformGraphics = this.add.graphics();\n    smallPlatformGraphics.fillStyle(0x888888, 1);\n    smallPlatformGraphics.fillRect(0, 0, 200, 24);\n    smallPlatformGraphics.generateTexture('smallPlatform', 200, 24);\n    smallPlatformGraphics.destroy();\n\n    // 创建地面平台\n    this.platforms = this.physics.add.staticGroup();\n    this.platforms.create(400, 584, 'platform').setScale(2, 1).refreshBody();\n    \n    // 创建空中平台\n    this.platforms.create(600, 450, 'smallPlatform');\n    this.platforms.create(200, 380, 'smallPlatform');\n    this.platforms.create(700, 300, 'smallPlatform');\n    this.platforms.create(150, 250, 'smallPlatform');\n    this.platforms.create(500, 200, 'smallPlatform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 添加玩家与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在空中平台上方创建5个金币\n    const coinPositions = [\n      { x: 600, y: 400 },\n      { x: 200, y: 330 },\n      { x: 700, y: 250 },\n      { x: 150, y: 200 },\n      { x: 500, y: 150 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.3);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 金币与平台碰撞\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 玩家与金币碰撞检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontStyle: 'bold',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.scoreText.setScrollFactor(0);\n\n    // 创建提示文本\n    this.hintText = this.add.text(400, 50, 'Use Arrow Keys to Move and Jump!\\nCollect all 5 coins!', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      align: 'center',\n      stroke: '#000000',\n      strokeThickness: 3\n    });\n    this.hintText.setOrigin(0.5);\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 检查是否收集完所有金币\n    if (this.score >= 5 && this.coins.countActive(true) === 0) {\n      if (!this.winText) {\n        this.winText = this.add.text(400, 300, 'YOU WIN!\\nAll coins collected!', {\n          fontSize: '48px',\n          fill: '#00ff00',\n          align: 'center',\n          fontStyle: 'bold',\n          stroke: '#000000',\n          strokeThickness: 6\n        });\n        this.winText.setOrigin(0.5);\n      }\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 1;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 添加收集音效的视觉反馈（闪烁效果）\n    this.cameras.main.flash(100, 255, 255, 0);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000820_v1", "prompt_id": "seed_000820", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆形状\n2. 在 create 中初始化椭圆的位置和初始旋转角度\n3. 在 update 中根据 delta 时间增量计算旋转角度（160度/秒 = 160 * delta/1000 度/帧）\n4. 将角度转换为弧度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipseGraphics;\nlet currentRotation = 0; // 当前旋转角度（弧度）\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置椭圆样式和绘制\n  ellipseGraphics.fillStyle(0x00ff00, 1); // 绿色填充\n  ellipseGraphics.fillEllipse(0, 0, 200, 100); // 在局部坐标 (0,0) 绘制椭圆，宽200高100\n  \n  // 设置椭圆位置到屏幕中心\n  ellipseGraphics.x = 400;\n  ellipseGraphics.y = 300;\n  \n  // 添加边框以便更清楚地看到旋转效果\n  ellipseGraphics.lineStyle(3, 0xffffff, 1);\n  ellipseGraphics.strokeEllipse(0, 0, 200, 100);\n  \n  // 添加一个标记点，方便观察旋转\n  ellipseGraphics.fillStyle(0xff0000, 1);\n  ellipseGraphics.fillCircle(100, 0, 8); // 在椭圆右侧添加红色圆点\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 160 度\n  // delta 是毫秒，需要转换为秒：delta / 1000\n  // 角度转弧度：度 * Math.PI / 180\n  const rotationSpeed = 160; // 度/秒\n  const rotationIncrement = (rotationSpeed * delta / 1000) * (Math.PI / 180);\n  \n  // 累加旋转角度\n  currentRotation += rotationIncrement;\n  \n  // 应用旋转到椭圆\n  ellipseGraphics.rotation = currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000281_v2", "prompt_id": "seed_000281", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的青色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的青色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，根据中心点和半径计算6个顶点坐标\n4. 循环10次，每次生成随机位置并绘制青色六边形\n5. 使用 fillStyle 设置青色，使用 beginPath/lineTo/closePath/fillPath 绘制填充六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充颜色 (cyan: #00FFFF)\n  graphics.fillStyle(0x00FFFF, 1);\n  \n  /**\n   * 绘制六边形\n   * @param {number} x - 中心点 x 坐标\n   * @param {number} y - 中心点 y 坐标\n   * @param {number} radius - 六边形半径（从中心到顶点的距离）\n   */\n  function drawHexagon(x, y, radius) {\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点坐标\n    // 从顶部开始，顺时针绘制\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // 每个角60度，起始角度-90度使顶点朝上\n      const px = x + radius * Math.cos(angle);\n      const py = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        graphics.moveTo(px, py);\n      } else {\n        graphics.lineTo(px, py);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  }\n  \n  // 绘制10个随机位置的六边形\n  const hexagonRadius = 16; // 六边形大小为16像素\n  const margin = hexagonRadius + 10; // 边距，确保六边形不会超出画布\n  \n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    \n    drawHexagon(randomX, randomY, hexagonRadius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000568_v2", "prompt_id": "seed_000568", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 120 像素/秒的速度移动\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建 Game 配置，设置场景和画布尺寸\n2. 在 create 中使用 Graphics 生成方块纹理\n3. 创建方块 Sprite 并设置初始位置\n4. 使用 this.input.keyboard.addKeys 监听 WASD 键\n5. 在 update 中根据按键状态更新方块位置，速度为 120 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块，放置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n\n  // 设置 WASD 键盘输入\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the block', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间差（秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 检测 WASD 键状态并更新速度\n  if (keys.W.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.S.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.A.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.D.isDown) {\n    velocityX = 1; // 向右\n  }\n\n  // 归一化对角线移动速度（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n\n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n\n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000493_v3", "prompt_id": "seed_000493", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让橙色三角形在 3 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建橙色三角形，使用 Tween 实现 3 秒缩放循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制橙色三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 tweens.add 创建缩放动画，设置 duration 为 3000ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (50, 50)，边长约 80\n  graphics.beginPath();\n  graphics.moveTo(50, 10);      // 顶点\n  graphics.lineTo(10, 90);      // 左下\n  graphics.lineTo(90, 90);      // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('orangeTriangle', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的 Sprite，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'orangeTriangle');\n  \n  // 设置初始缩放\n  triangle.setScale(1);\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标\n    scaleX: 2,                   // X 轴缩放到 2 倍\n    scaleY: 2,                   // Y 轴缩放到 2 倍\n    duration: 1500,              // 单程 1.5 秒\n    yoyo: true,                  // 往返动画（放大后缩小）\n    repeat: -1,                  // 无限循环\n    ease: 'Sine.easeInOut'       // 平滑的缓动效果\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 550, 'Orange Triangle Scaling Animation (3s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000547_v3", "prompt_id": "seed_000547", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：20 个圆形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 收集游戏：20个圆形随机分布，收集完成后显示\"恭喜通关\"\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Factory#overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家角色（使用Graphics绘制正方形）和物理系统\n2. 使用Physics.Arcade.Group创建20个可收集的圆形物体，随机分布在场景中\n3. 添加键盘控制让玩家可以移动\n4. 使用overlap检测玩家与圆形的碰撞，碰撞时销毁圆形并增加计数\n5. 当收集计数达到20时显示\"恭喜通关\"文本\n[/PLAN]\n\n```javascript\nclass CollectionGame extends Phaser.Scene {\n  constructor() {\n    super('CollectionGame');\n    this.collectedCount = 0;\n    this.totalItems = 20;\n  }\n\n  preload() {\n    // 使用Graphics程序化生成纹理\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建收集品纹理（黄色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffdd00, 1);\n    itemGraphics.fillCircle(15, 15, 15);\n    itemGraphics.generateTexture('item', 30, 30);\n    itemGraphics.destroy();\n  }\n\n  create() {\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#2d2d2d');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集品组\n    this.items = this.physics.add.group();\n\n    // 随机生成20个收集品\n    for (let i = 0; i < this.totalItems; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const item = this.items.create(x, y, 'item');\n      item.setCircle(15); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.items,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建UI文本\n    this.scoreText = this.add.text(16, 16, `收集: ${this.collectedCount}/${this.totalItems}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '64px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 6\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n\n    // 添加重置提示文本（初始隐藏）\n    this.resetText = this.add.text(400, 380, '按 R 键重新开始', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.resetText.setOrigin(0.5);\n    this.resetText.setVisible(false);\n\n    // 游戏完成标志\n    this.gameCompleted = false;\n\n    // 添加R键重置功能\n    this.input.keyboard.on('keydown-R', () => {\n      if (this.gameCompleted) {\n        this.scene.restart();\n      }\n    });\n  }\n\n  collectItem(player, item) {\n    // 销毁收集品\n    item.destroy();\n\n    // 增加计数\n    this.collectedCount++;\n\n    // 更新文本\n    this.scoreText.setText(`收集: ${this.collectedCount}/${this.totalItems}`);\n\n    // 检查是否收集完成\n    if (this.collectedCount >= this.totalItems) {\n      this.gameCompleted = true;\n      this.winText.setVisible(true);\n      this.resetText.setVisible(true);\n      this.player.setVelocity(0, 0); // 停止玩家移动\n    }\n  }\n\n  update() {\n    // 如果游戏已完成，不处理移动\n    if (this.gameCompleted) {\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectionGame\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001007_v3", "prompt_id": "seed_001007", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.88}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 8 个金币，重力 400，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集8个金币，重力400，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力为 400\n2. 使用 Graphics 生成玩家（蓝色方块）和金币（黄色圆形）纹理\n3. 创建地面平台和空中平台（使用 StaticGroup）\n4. 生成 8 个金币分布在平台上方\n5. 添加键盘输入控制（左右移动+跳跃）\n6. 实现碰撞检测：玩家与平台、玩家与金币\n7. 收集金币时增加分数并销毁金币\n8. 显示分数文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x4a90e2, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffd700, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n\n    // 生成平台纹理（绿色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x2ecc71, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 生成地面纹理（深绿色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x27ae60, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n\n    // 创建地面\n    this.platforms = this.physics.add.staticGroup();\n    this.platforms.create(400, 580, 'ground');\n\n    // 创建空中平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(400, 300, 'platform');\n    this.platforms.create(150, 250, 'platform');\n    this.platforms.create(650, 200, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在平台上方生成 8 个金币\n    const coinPositions = [\n      { x: 200, y: 400 },\n      { x: 250, y: 400 },\n      { x: 600, y: 350 },\n      { x: 650, y: 350 },\n      { x: 400, y: 250 },\n      { x: 150, y: 200 },\n      { x: 650, y: 150 },\n      { x: 700, y: 150 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.3);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n    \n    // 设置玩家与金币的重叠检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 添加游戏说明\n    this.add.text(16, 56, 'Arrow Keys: Move & Jump', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 2\n    });\n\n    // 胜利文本（初始隐藏）\n    this.winText = this.add.text(400, 300, 'You Win!', {\n      fontSize: '64px',\n      fill: '#ffd700',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 6\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n  }\n\n  update() {\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃（只有在地面或平台上才能跳）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.score === 80) {\n      this.winText.setVisible(true);\n      \n      // 2秒后重新开始游戏\n      this.time.delayedCall(2000, () => {\n        this.scene.restart();\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001047_v2", "prompt_id": "seed_001047", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.905}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个矩形\n2. 将矩形的原点设置为中心点，便于旋转\n3. 在 update 方法中根据 delta 时间增量计算旋转角度\n4. 每帧更新矩形的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制一个 100x100 的矩形，原点在中心\n  // 需要将矩形绘制在 (-50, -50) 位置，使其中心在 (0, 0)\n  graphics.fillRect(-50, -50, 100, 100);\n  \n  // 将 Graphics 对象定位到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 的 data 中，以便在 update 中访问\n  this.rotatingRect = graphics;\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，需要转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 每秒旋转 200 度，转换为弧度\n  const rotationSpeed = Phaser.Math.DegToRad(200);\n  \n  // 更新旋转角度\n  this.rotatingRect.rotation += rotationSpeed * deltaInSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000054_v3", "prompt_id": "seed_000054", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 300 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制椭圆形状\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位移\n4. 更新椭圆位置实现移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 椭圆对象和按键变量\nlet ellipse;\nlet keyW, keyA, keyS, keyD;\nlet ellipseX = 400;\nlet ellipseY = 300;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制椭圆\n  ellipse = this.add.graphics();\n  ellipse.fillStyle(0x00ff00, 1); // 绿色椭圆\n  ellipse.fillEllipse(0, 0, 60, 40); // 以中心点绘制，宽60高40\n  \n  // 设置初始位置\n  ellipse.x = ellipseX;\n  ellipse.y = ellipseY;\n  \n  // 添加 WASD 按键监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    ellipseY -= distance; // 向上移动\n  }\n  if (keyS.isDown) {\n    ellipseY += distance; // 向下移动\n  }\n  if (keyA.isDown) {\n    ellipseX -= distance; // 向左移动\n  }\n  if (keyD.isDown) {\n    ellipseX += distance; // 向右移动\n  }\n  \n  // 边界限制（可选，防止椭圆移出屏幕）\n  ellipseX = Phaser.Math.Clamp(ellipseX, 30, 770);\n  ellipseY = Phaser.Math.Clamp(ellipseY, 20, 580);\n  \n  // 更新椭圆显示位置\n  ellipse.x = ellipseX;\n  ellipse.y = ellipseY;\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000507_v2", "prompt_id": "seed_000507", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的椭圆在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的椭圆对象并保持居中\nAPI: Graphics#fillEllipse, Camera#startFollow, Sprite#setVelocity, Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置较大的世界边界以便对象移动\n2. 使用 Graphics 绘制椭圆形状并生成纹理\n3. 创建物理精灵对象并设置向右上的速度\n4. 使用相机的 startFollow 方法跟随该对象\n5. 设置相机边界与世界边界一致\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界为更大的范围，允许对象移动\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点、宽度、高度\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵对象，初始位置在场景中心\n  this.player = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置椭圆向右上方移动（正x轴，负y轴）\n  this.player.setVelocity(150, -100);\n  \n  // 设置对象在世界边界内碰撞反弹\n  this.player.setCollideWorldBounds(true);\n  this.player.setBounce(1, 1);\n  \n  // 获取主相机并设置跟随对象\n  const camera = this.cameras.main;\n  \n  // 相机跟随椭圆对象，保持居中\n  camera.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  camera.setBounds(0, 0, 3000, 3000);\n  \n  // 添加一些参考网格线，便于观察相机跟随效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    gridGraphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加文本提示\n  const text = this.add.text(16, 16, 'Camera following the green ellipse', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 将文本固定在相机上，不随相机移动\n  text.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 每帧更新逻辑（本例中物理系统自动处理移动）\n  // 可以在这里添加额外的逻辑，如检测边界等\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000115_v1", "prompt_id": "seed_000115", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 300 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes, graphics.fillStyle(), graphics.beginPath(), graphics.moveTo(), graphics.lineTo(), graphics.closePath(), graphics.fillPath()\nSTEPS:\n1. 创建 Graphics 对象绘制菱形形状\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位移\n4. 更新菱形的位置坐标\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet diamond;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建菱形 Graphics 对象\n  diamond = this.add.graphics();\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 绘制菱形\n  drawDiamond(diamond);\n  \n  // 添加 WASD 键盘监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    diamond.y -= distance;\n  }\n  if (keyS.isDown) {\n    diamond.y += distance;\n  }\n  if (keyA.isDown) {\n    diamond.x -= distance;\n  }\n  if (keyD.isDown) {\n    diamond.x += distance;\n  }\n  \n  // 边界限制（可选）\n  diamond.x = Phaser.Math.Clamp(diamond.x, 0, 800);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 0, 600);\n}\n\n// 辅助函数：绘制菱形\nfunction drawDiamond(graphics) {\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 上顶点\n  graphics.lineTo(25, 0);     // 右顶点\n  graphics.lineTo(0, 30);     // 下顶点\n  graphics.lineTo(-25, 0);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000269_v2", "prompt_id": "seed_000269", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.901111111111111}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 360 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillCircle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形，并在圆形上添加一个标记（如小圆点）以便观察旋转\n2. 在 create 中初始化 Graphics 对象并设置位置\n3. 在 update 中根据 delta 时间增量更新 rotation 属性，每秒增加 2π 弧度（360度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  this.rotatingCircle = this.add.graphics();\n  \n  // 设置圆形位置到画布中心\n  this.rotatingCircle.x = 400;\n  this.rotatingCircle.y = 300;\n  \n  // 绘制主圆形（蓝色）\n  this.rotatingCircle.fillStyle(0x4a90e2, 1);\n  this.rotatingCircle.fillCircle(0, 0, 80);\n  \n  // 绘制一个小圆点标记（红色），用于观察旋转\n  this.rotatingCircle.fillStyle(0xff0000, 1);\n  this.rotatingCircle.fillCircle(60, 0, 10);\n  \n  // 绘制一条从圆心到边缘的线（白色），更清晰地显示旋转\n  this.rotatingCircle.lineStyle(3, 0xffffff, 1);\n  this.rotatingCircle.beginPath();\n  this.rotatingCircle.moveTo(0, 0);\n  this.rotatingCircle.lineTo(80, 0);\n  this.rotatingCircle.strokePath();\n  \n  // 添加说明文字\n  this.add.text(400, 50, '圆形以每秒 360° 旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 每秒 360 度 = 2π 弧度/秒\n  // rotation 增量 = (2 * Math.PI) * (delta / 1000)\n  const rotationSpeed = 2 * Math.PI; // 每秒 2π 弧度（360度）\n  this.rotatingCircle.rotation += rotationSpeed * (delta / 1000);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000681_v1", "prompt_id": "seed_000681", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色六边形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色六边形以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制白色六边形并生成纹理\n2. 创建带物理属性的 Sprite 使用该纹理\n3. 设置初始速度为 200，设置边界碰撞反弹\n4. 在 update 中检测边界并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const size = 30;\n  const centerX = size;\n  const centerY = size;\n  \n  // 绘制六边形（6个顶点）\n  graphics.fillStyle(0xffffff, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + size * Math.cos(angle);\n    const y = centerY + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建带物理属性的六边形精灵\n  hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 200;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 200;\n  \n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞边界\n  hexagon.setCollideWorldBounds(true);\n  hexagon.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 检测边界碰撞并反弹（物理引擎的 bounce 已处理，但这里添加额外检测以确保）\n  const bounds = hexagon.getBounds();\n  \n  // 左右边界检测\n  if (bounds.left <= 0 && hexagon.body.velocity.x < 0) {\n    hexagon.body.velocity.x *= -1;\n  } else if (bounds.right >= config.width && hexagon.body.velocity.x > 0) {\n    hexagon.body.velocity.x *= -1;\n  }\n  \n  // 上下边界检测\n  if (bounds.top <= 0 && hexagon.body.velocity.y < 0) {\n    hexagon.body.velocity.y *= -1;\n  } else if (bounds.bottom >= config.height && hexagon.body.velocity.y > 0) {\n    hexagon.body.velocity.y *= -1;\n  }\n  \n  // 保持速度恒定为200\n  const currentSpeed = Math.sqrt(\n    hexagon.body.velocity.x ** 2 + hexagon.body.velocity.y ** 2\n  );\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - 200) > 1) {\n    hexagon.body.velocity.x = (hexagon.body.velocity.x / currentSpeed) * 200;\n    hexagon.body.velocity.y = (hexagon.body.velocity.y / currentSpeed) * 200;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000385_v3", "prompt_id": "seed_000385", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的三角形，保持居中显示\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制一个三角形作为可视化对象\n2. 将 Graphics 转换为纹理并创建 Sprite 对象用于移动\n3. 在 update 中让三角形持续向右上方移动\n4. 使用 Camera.startFollow 让相机跟随三角形并保持居中\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nconst moveSpeed = 100; // 每秒移动像素\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让三角形有足够的移动空间\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向右上方的三角形\n  graphics.beginPath();\n  graphics.moveTo(0, -20);      // 顶点（上）\n  graphics.lineTo(15, 20);      // 右下\n  graphics.lineTo(-15, 20);     // 左下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加边框使三角形更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n\n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('triangleTexture', 40, 50);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成纹理\n\n  // 创建三角形精灵，初始位置在世界中心\n  triangle = this.add.sprite(1000, 1000, 'triangleTexture');\n\n  // 设置相机跟随三角形\n  // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n  // lerpX 和 lerpY 设置为 0.1 使相机平滑跟随\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1, 0, 0);\n\n  // 添加一些参考网格线帮助观察移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 2000);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 2000; y += 100) {\n    gridGraphics.lineBetween(0, y, 2000, y);\n  }\n\n  // 添加文本说明（固定在相机上）\n  const infoText = this.add.text(10, 10, '三角形自动向右上移动\\n相机跟随中...', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机视图上，不随世界移动\n\n  // 添加位置信息文本\n  this.positionText = this.add.text(10, 70, '', {\n    fontSize: '14px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 计算移动增量（向右上方移动，45度角）\n  const moveX = moveSpeed * (delta / 1000); // 向右\n  const moveY = -moveSpeed * (delta / 1000); // 向上（Y轴负方向）\n\n  // 更新三角形位置\n  triangle.x += moveX;\n  triangle.y += moveY;\n\n  // 更新位置信息显示\n  this.positionText.setText(\n    `三角形位置: (${Math.round(triangle.x)}, ${Math.round(triangle.y)})\\n` +\n    `相机中心: (${Math.round(this.cameras.main.scrollX + 400)}, ${Math.round(this.cameras.main.scrollY + 300)})`\n  );\n\n  // 如果三角形超出世界边界，重置到起始位置\n  if (triangle.x > 1900 || triangle.y < 100) {\n    triangle.setPosition(100, 1900);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000193_v2", "prompt_id": "seed_000193", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.Scene#update, Phaser.GameObjects.Graphics#setRotation\nSTEPS:\n1. 创建 Phaser Game 配置，设置 Scene 生命周期方法\n2. 在 create 方法中使用 Graphics 绘制一个方块\n3. 在 update 方法中根据 delta 时间累加旋转角度（每秒 80 度），并应用到方块上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块\n  square = this.add.graphics();\n  square.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在 (0, 0)\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 设置方块位置到屏幕中心\n  square.x = 400;\n  square.y = 300;\n  \n  // 添加边框以便更清楚地看到旋转效果\n  square.lineStyle(3, 0xffffff, 1);\n  square.strokeRect(-50, -50, 100, 100);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 80 度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 角度转弧度：Phaser.Math.DegToRad(80)\n  const rotationSpeed = Phaser.Math.DegToRad(80); // 每秒 80 度（弧度制）\n  \n  // 累加旋转角度\n  currentRotation += rotationSpeed * (delta / 1000);\n  \n  // 应用旋转\n  square.setRotation(currentRotation);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000404_v3", "prompt_id": "seed_000404", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 3 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在3秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 Tween 动画将 scale 从 1 缩放到 0.24，持续 3 秒\n4. 设置 yoyo 为 true 实现恢复效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制三角形（等边三角形）\n  const triangleSize = 100;\n  graphics.beginPath();\n  graphics.moveTo(triangleSize, 0); // 顶点\n  graphics.lineTo(0, triangleSize * Math.sqrt(3) / 2); // 左下角\n  graphics.lineTo(triangleSize * 2, triangleSize * Math.sqrt(3) / 2); // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize * 2, triangleSize * Math.sqrt(3) / 2);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建三角形精灵并居中显示\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置三角形的锚点为中心\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.24, // 缩放到 24%\n    scaleY: 0.24, // 缩放到 24%\n    duration: 3000, // 持续 3 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 动画结束后反向播放（恢复原始大小）\n    loop: -1 // 无限循环 (-1 表示永久循环)\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '三角形缩放动画\\n3秒缩放到24%后恢复', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000098_v3", "prompt_id": "seed_000098", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色星形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色星形，大小约为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的5个外顶点和5个内顶点坐标（基于中心点和半径）\n4. 使用 Graphics API 绘制星形路径并填充橙色\n5. 将星形定位到画布中央\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 16; // 外半径\n  const innerRadius = 8;  // 内半径（约为外半径的一半）\n  const points = 5;       // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制星形的顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000116_v1", "prompt_id": "seed_000116", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让红色星形在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色星形，使用 Tween 实现 0.5 秒淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制红色星形并生成纹理\n2. 创建 Sprite 对象使用生成的星形纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  \n  // 绘制星形的路径\n  const points = 5; // 五角星\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const centerX = 50;\n  const centerY = 50;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('redStar', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'redStar');\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    alpha: 0,                // 目标透明度（从1淡出到0）\n    duration: 500,           // 持续时间 0.5 秒\n    yoyo: true,              // 反向播放（淡出后再淡入）\n    repeat: -1,              // 无限循环 (-1 表示永久重复)\n    ease: 'Linear'           // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000521_v1", "prompt_id": "seed_000521", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 360 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建 Game 配置，设置 800x600 画布和 Scene\n2. 在 create 中使用 Graphics 绘制椭圆形状并生成纹理\n3. 创建精灵对象并应用椭圆纹理，放置在画布中心\n4. 使用 input.keyboard.addKeys 监听 WASD 键\n5. 在 update 中根据按键状态更新椭圆位置，速度为 360 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 360; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色椭圆\n  graphics.fillEllipse(40, 30, 80, 60); // 在 (40, 30) 处绘制 80x60 的椭圆\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n\n  // 创建椭圆精灵，放置在画布中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n\n  // 设置 WASD 键监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离（速度 * 时间差，delta 单位是毫秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态更新椭圆位置\n  if (keys.w.isDown) {\n    ellipse.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    ellipse.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    ellipse.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    ellipse.x += distance; // 向右移动\n  }\n\n  // 可选：限制椭圆在画布范围内\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 0, 800);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000200_v2", "prompt_id": "seed_000200", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Game 配置，使用 HEADLESS 或 AUTO 类型\n2. 在 create 中使用 Graphics 绘制一个矩形\n3. 在 update 中根据 delta 时间累加旋转角度（300度/秒 = 300 * Math.PI / 180 弧度/秒）\n4. 将计算的旋转角度应用到矩形的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet rectangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  rectangle = this.add.graphics();\n  rectangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制矩形，中心点在 (0, 0)，这样旋转时会围绕中心旋转\n  rectangle.fillRect(-100, -50, 200, 100);\n  \n  // 设置矩形位置到屏幕中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒 300 度 = 300 * Math.PI / 180 弧度/秒\n  // delta 是毫秒，需要转换为秒：delta / 1000\n  const rotationSpeed = (300 * Math.PI / 180); // 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  rectangle.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000310_v2", "prompt_id": "seed_000310", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色矩形在0.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Game\nSTEPS:\n1. 创建 Scene 并配置 Game 实例\n2. 在 create 中使用 Graphics 绘制白色矩形\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 500 毫秒（0.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 60, 40);\n  \n  // 将 Graphics 转换为纹理以便于补间动画控制\n  graphics.generateTexture('whiteRect', 60, 40);\n  graphics.destroy();\n  \n  // 创建使用该纹理的精灵对象\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（从初始 100 移动到 700）\n    duration: 500,           // 持续时间 0.5 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向回到起点）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动函数，保持匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000658_v3", "prompt_id": "seed_000658", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 5 个紫色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，5个紫色物体，碰撞消失加分，显示分数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建带物理系统的游戏配置\n2. 使用 Graphics 生成玩家和可收集物体的纹理\n3. 创建物理组添加5个紫色收集物\n4. 添加分数文本显示\n5. 使用 overlap 检测碰撞，触发收集逻辑\n6. 键盘控制玩家移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（紫色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x9966ff, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 在场景中随机位置生成5个收集物\n  const positions = [\n    { x: 150, y: 150 },\n    { x: 650, y: 150 },\n    { x: 150, y: 450 },\n    { x: 650, y: 450 },\n    { x: 400, y: 100 }\n  ];\n\n  positions.forEach(pos => {\n    const collectible = collectibles.create(pos.x, pos.y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    // 添加轻微的浮动效果\n    this.tweens.add({\n      targets: collectible,\n      y: collectible.y - 10,\n      duration: 1000,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  });\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 添加说明文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move', {\n    fontSize: '20px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 收集物消失\n  collectible.disableBody(true, true);\n\n  // 增加分数\n  score += 10;\n  scoreText.setText('Score: ' + score);\n\n  // 检查是否收集完所有物品\n  if (collectibles.countActive(true) === 0) {\n    // 显示胜利信息\n    const winText = this.add.text(400, 300, 'All Collected!\\nYou Win!', {\n      fontSize: '48px',\n      fill: '#ffff00',\n      fontFamily: 'Arial',\n      align: 'center'\n    }).setOrigin(0.5);\n\n    // 停止玩家移动\n    player.setVelocity(0, 0);\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000849_v3", "prompt_id": "seed_000849", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8700000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个自动向左下移动的菱形，相机跟随并保持居中\nAPI: Graphics#fillStyle, Graphics#fillPath, Graphics#generateTexture, Camera#startFollow, Sprite#setVelocity\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建精灵对象并设置物理属性\n3. 设置精灵向左下方向移动（负X和正Y速度）\n4. 配置主相机跟随该精灵对象\n5. 添加边界和背景以便观察相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet diamond;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个大的世界边界，让菱形有足够的移动空间\n  this.physics.world.setBounds(0, 0, 3200, 2400);\n  \n  // 绘制网格背景以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 3200; x += 100) {\n    graphics.lineBetween(x, 0, x, 2400);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 2400; y += 100) {\n    graphics.lineBetween(0, y, 3200, y);\n  }\n  \n  // 创建菱形纹理\n  const diamondGraphics = this.add.graphics();\n  diamondGraphics.fillStyle(0xff6b6b, 1);\n  \n  // 绘制菱形路径\n  const diamondPath = new Phaser.Geom.Polygon([\n    0, -30,    // 上顶点\n    30, 0,     // 右顶点\n    0, 30,     // 下顶点\n    -30, 0     // 左顶点\n  ]);\n  \n  diamondGraphics.fillPoints(diamondPath.points, true);\n  \n  // 生成纹理\n  diamondGraphics.generateTexture('diamond', 60, 60);\n  diamondGraphics.destroy();\n  \n  // 创建菱形精灵，初始位置在世界中心\n  diamond = this.physics.add.sprite(1600, 1200, 'diamond');\n  \n  // 设置菱形向左下移动\n  // 负X速度表示向左，正Y速度表示向下\n  diamond.setVelocity(-150, 150);\n  \n  // 设置碰撞边界\n  diamond.setCollideWorldBounds(true);\n  diamond.setBounce(1, 1); // 碰到边界反弹\n  \n  // 配置相机\n  const camera = this.cameras.main;\n  \n  // 设置相机边界与世界边界一致\n  camera.setBounds(0, 0, 3200, 2400);\n  \n  // 相机跟随菱形，保持居中\n  camera.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 添加说明文字（固定在相机上）\n  const text = this.add.text(10, 10, '菱形自动向左下移动\\n相机跟随并保持居中', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图上\n  \n  // 显示当前位置信息\n  this.positionText = this.add.text(10, 80, '', {\n    fontSize: '14px',\n    fill: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 更新位置显示\n  if (this.positionText && diamond) {\n    this.positionText.setText(\n      `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})\\n` +\n      `速度: (${Math.round(diamond.body.velocity.x)}, ${Math.round(diamond.body.velocity.y)})`\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000734_v2", "prompt_id": "seed_000734", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象作为可移动的菱形\n3. 在 update 中让菱形自动向右下移动\n4. 使用 camera.startFollow 让相机跟随菱形对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst MOVE_SPEED = 2; // 移动速度\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制菱形\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，初始位置在场景中心\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置相机跟随菱形对象\n  // 第二个参数 true 表示圆形跟随（平滑），false 表示锁定跟随\n  // 第三个参数是水平跟随的平滑度 (0-1)，第四个参数是垂直跟随的平滑度\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 可选：设置相机边界，让场景更大\n  // 这样可以看到相机跟随的效果\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  \n  // 添加一些参考网格，方便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 2000; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(2000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加说明文字（固定在相机上）\n  const text = this.add.text(10, 10, '菱形自动向右下移动\\n相机跟随并保持居中', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让菱形自动向右下移动\n  diamond.x += MOVE_SPEED;\n  diamond.y += MOVE_SPEED;\n  \n  // 可选：添加旋转效果，让移动更明显\n  diamond.rotation += 0.02;\n  \n  // 可选：限制移动范围，避免超出场景边界\n  if (diamond.x > 1900 || diamond.y > 1900) {\n    // 重置到起始位置\n    diamond.setPosition(100, 100);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000574_v2", "prompt_id": "seed_000574", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒360度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation\nSTEPS:\n1. 创建 Graphics 对象并绘制三角形\n2. 在 update 方法中根据 delta 时间累加旋转角度\n3. 每秒旋转 360 度，即每毫秒旋转 360/1000 度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  triangle = this.add.graphics();\n  \n  // 设置填充颜色\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（以原点为中心）\n  // 三个顶点坐标相对于原点\n  triangle.fillTriangle(\n    0, -50,    // 顶部顶点\n    -43, 25,   // 左下顶点\n    43, 25     // 右下顶点\n  );\n  \n  // 设置三角形位置到屏幕中心\n  triangle.x = 400;\n  triangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 360 度 = 2π 弧度\n  // delta 是毫秒，转换为秒需要除以 1000\n  // 每帧旋转的弧度 = (2 * Math.PI) * (delta / 1000)\n  const rotationSpeed = (2 * Math.PI) * (delta / 1000);\n  \n  // 累加旋转角度\n  triangle.rotation += rotationSpeed;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000276_v3", "prompt_id": "seed_000276", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制一个六边形移动，速度为 300 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Phaser.GameObjects.Sprite\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建精灵对象并设置六边形纹理\n4. 监听 WASD 键盘输入\n5. 在 update 中根据按键状态移动六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 300;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制六边形（中心点在 40, 40）\n  const hexRadius = 30;\n  const centerX = 40;\n  const centerY = 40;\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 80, 80);\n  graphics.destroy();\n  \n  // 创建六边形精灵\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置键盘输入\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键并设置速度方向\n  if (keys.W.isDown) {\n    velocityY = -1;\n  }\n  if (keys.S.isDown) {\n    velocityY = 1;\n  }\n  if (keys.A.isDown) {\n    velocityX = -1;\n  }\n  if (keys.D.isDown) {\n    velocityX = 1;\n  }\n  \n  // 归一化对角线移动（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n  \n  // 更新六边形位置\n  hexagon.x += velocityX * distance;\n  hexagon.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000748_v2", "prompt_id": "seed_000748", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色六边形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色六边形以240速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 创建带物理属性的精灵对象，设置初始速度为240\n3. 在 update 中检测边界碰撞，反转速度实现反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet hexagon;\nconst SPEED = 240;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  \n  // 绘制六边形（中心点为原点）\n  const size = 30;\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = size + Math.cos(angle) * size;\n    const y = size + Math.sin(angle) * size;\n    points.push(new Phaser.Math.Vector2(x, y));\n  }\n  \n  graphics.fillPoints(points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建带物理属性的六边形精灵\n  hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * SPEED;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * SPEED;\n  \n  hexagon.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞边界\n  hexagon.setCollideWorldBounds(true);\n  hexagon.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 检查边界并反转速度（额外保险，因为 setBounce 和 setCollideWorldBounds 已处理）\n  // 但为了确保速度恒定为 240，我们手动处理\n  const body = hexagon.body;\n  \n  // 左右边界\n  if (hexagon.x <= hexagon.width / 2 && body.velocity.x < 0) {\n    body.velocity.x = Math.abs(body.velocity.x);\n  } else if (hexagon.x >= config.width - hexagon.width / 2 && body.velocity.x > 0) {\n    body.velocity.x = -Math.abs(body.velocity.x);\n  }\n  \n  // 上下边界\n  if (hexagon.y <= hexagon.height / 2 && body.velocity.y < 0) {\n    body.velocity.y = Math.abs(body.velocity.y);\n  } else if (hexagon.y >= config.height - hexagon.height / 2 && body.velocity.y > 0) {\n    body.velocity.y = -Math.abs(body.velocity.y);\n  }\n  \n  // 保持速度恒定为 240\n  const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n  if (currentSpeed > 0 && Math.abs(currentSpeed - SPEED) > 1) {\n    body.velocity.normalize().scale(SPEED);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000037_v2", "prompt_id": "seed_000037", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的红色矩形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的红色矩形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布大小\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环8次，每次生成随机坐标（x, y）\n4. 使用 fillStyle 设置红色，fillRect 绘制 32x32 的矩形\n5. 确保矩形在画布范围内（考虑矩形大小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 矩形大小\n  const rectSize = 32;\n  \n  // 绘制8个随机位置的红色矩形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机坐标，确保矩形完全在画布内\n    // x 范围: 0 到 (width - rectSize)\n    // y 范围: 0 到 (height - rectSize)\n    const x = Math.random() * (config.width - rectSize);\n    const y = Math.random() * (config.height - rectSize);\n    \n    // 绘制矩形\n    graphics.fillRect(x, y, rectSize, rectSize);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000175_v2", "prompt_id": "seed_000175", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现粉色血条 UI，显示 10 格生命值，空格键扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化 10 点生命值变量\n2. 使用 Graphics 绘制 10 个粉色矩形作为血条格子\n3. 监听空格键输入事件，每次按下扣除 1 点生命值\n4. 更新血条显示，隐藏已损失的生命值格子\n5. 当生命值为 0 时显示 Game Over 文本并停止游戏\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 可验证的状态信号\n    this.maxHealth = 10;\n    this.healthBars = [];\n    this.gameOver = false;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, '粉色血条演示', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, '按空格键扣血', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 创建生命值文本显示\n    this.healthText = this.add.text(400, 450, `生命值: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ff69b4',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.spaceKey.on('down', this.takeDamage, this);\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold',\n      stroke: '#000000',\n      strokeThickness: 6\n    }).setOrigin(0.5).setVisible(false);\n  }\n\n  createHealthBar() {\n    const barWidth = 50;\n    const barHeight = 30;\n    const barSpacing = 10;\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing)) / 2 + barWidth / 2;\n    const startY = 200;\n\n    // 创建 10 个血条格子\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + barSpacing);\n      \n      // 创建背景（深色边框）\n      const background = this.add.graphics();\n      background.fillStyle(0x8b4789, 1); // 深粉色边框\n      background.fillRect(x - barWidth / 2 - 2, startY - barHeight / 2 - 2, barWidth + 4, barHeight + 4);\n\n      // 创建血条本体（粉色）\n      const bar = this.add.graphics();\n      bar.fillStyle(0xff69b4, 1); // 粉色\n      bar.fillRect(x - barWidth / 2, startY - barHeight / 2, barWidth, barHeight);\n\n      // 添加高光效果\n      const highlight = this.add.graphics();\n      highlight.fillStyle(0xffb6d9, 0.6); // 浅粉色高光\n      highlight.fillRect(x - barWidth / 2 + 2, startY - barHeight / 2 + 2, barWidth - 4, barHeight / 3);\n\n      this.healthBars.push({\n        background: background,\n        bar: bar,\n        highlight: highlight\n      });\n    }\n  }\n\n  takeDamage() {\n    if (this.gameOver) {\n      return;\n    }\n\n    if (this.health > 0) {\n      this.health--;\n      this.updateHealthBar();\n      this.healthText.setText(`生命值: ${this.health}/${this.maxHealth}`);\n\n      // 添加扣血动画效果\n      const index = this.health;\n      if (index >= 0 && index < this.healthBars.length) {\n        const bar = this.healthBars[index];\n        \n        // 闪烁效果\n        this.tweens.add({\n          targets: [bar.bar, bar.highlight],\n          alpha: 0,\n          duration: 200,\n          yoyo: true,\n          repeat: 1,\n          onComplete: () => {\n            bar.bar.setVisible(false);\n            bar.highlight.setVisible(false);\n          }\n        });\n      }\n\n      // 检查是否死亡\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  updateHealthBar() {\n    // 隐藏已损失的生命值格子\n    for (let i = this.health; i < this.maxHealth; i++) {\n      this.healthBars[i].bar.setVisible(false);\n      this.healthBars[i].highlight.setVisible(false);\n    }\n  }\n\n  triggerGameOver() {\n    this.gameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    \n    // Game Over 文本动画\n    this.gameOverText.setScale(0);\n    this.tweens.add({\n      targets: this.gameOverText,\n      scale: 1,\n      duration: 500,\n      ease: 'Bounce.easeOut'\n    });\n\n    // 禁用输入\n    this.spaceKey.off('down', this.takeDamage, this);\n\n    // 添加重启提示\n    this.time.delayedCall(1000, () => {\n      this.add.text(400, 380, '按 R 键重新开始', {\n        fontSize: '20px',\n        color: '#ffffff'\n      }).setOrigin(0.5);\n\n      // 监听 R 键重启游戏\n      const rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n      rKey.on('down', () => {\n        this.scene.restart();\n      });\n    });\n  }\n\n  update(time, delta) {\n    // 血条呼吸效果（当生命值较低时）\n    if (this.health > 0 && this.health <= 3 && !this.gameOver) {\n      const pulse = Math.sin(time / 200) * 0.2 + 0.8;\n      for (let i = 0; i < this.health; i++) {\n        this.healthBars[i].bar.setAlpha(pulse);\n        this.healthBars[i].highlight.setAlpha(pulse * 0.6);\n      }\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: HealthBarScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000887_v2", "prompt_id": "seed_000887", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8837499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让灰色矩形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色矩形，使用 Tween 动画在 1 秒内旋转 360 度并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setRotation\nSTEPS:\n1. 使用 Graphics 绘制灰色矩形并生成纹理\n2. 创建 Sprite 对象应用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 rotation 属性从 0 到 2π\n4. 配置动画循环（loop: -1）和持续时间（duration: 1000）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建灰色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('grayRect', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建灰色矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'grayRect');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    rotation: Math.PI * 2,   // 旋转到 360 度（2π 弧度）\n    duration: 1000,          // 持续时间 1 秒\n    ease: 'Linear',          // 线性缓动，匀速旋转\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    repeat: 0                // 每次循环之间不重复\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Gray rectangle rotating in 1 second loop', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000732_v2", "prompt_id": "seed_000732", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 240 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版，敌人速度随时间从240逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建玩家（绿色方块）和敌人组（红色方块），使用Graphics生成纹理\n2. 设置键盘控制（方向键）让玩家移动\n3. 使用定时器每秒生成随机位置的敌人，初始速度240\n4. 在update中根据经过时间逐渐增加敌人速度\n5. 检测碰撞，碰撞后显示游戏结束和生存时间\n6. 显示实时生存时间文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.survivalTime = 0;\n    this.isGameOver = false;\n    this.baseEnemySpeed = 240;\n    this.currentEnemySpeed = 240;\n    this.speedIncreaseRate = 20; // 每秒增加的速度\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0.0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 速度显示文本\n    this.speedText = this.add.text(16, 50, 'Speed: 240', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, '', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      fontFamily: 'Arial',\n      align: 'center'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 360, '', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      align: 'center'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 定时生成敌人（每秒一个）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 游戏开始时间\n    this.startTime = this.time.now;\n\n    // 重启键\n    this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n  }\n\n  update(time, delta) {\n    if (this.isGameOver) {\n      // 检测重启\n      if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {\n        this.restartGame();\n      }\n      return;\n    }\n\n    // 更新生存时间\n    this.survivalTime = (time - this.startTime) / 1000;\n    this.timeText.setText(`Time: ${this.survivalTime.toFixed(1)}s`);\n\n    // 根据时间增加敌人速度\n    this.currentEnemySpeed = this.baseEnemySpeed + (this.survivalTime * this.speedIncreaseRate);\n    this.speedText.setText(`Speed: ${Math.floor(this.currentEnemySpeed)}`);\n\n    // 玩家移动控制\n    const playerSpeed = 300;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 更新所有敌人的速度\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.active) {\n        // 保持方向，更新速度\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x,\n          enemy.y,\n          this.player.x,\n          this.player.y\n        );\n        this.physics.velocityFromRotation(\n          angle,\n          this.currentEnemySpeed,\n          enemy.body.velocity\n        );\n      }\n    });\n\n    // 清理超出边界的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (\n        enemy.x < -50 ||\n        enemy.x > 850 ||\n        enemy.y < -50 ||\n        enemy.y > 650\n      ) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.isGameOver) return;\n\n    // 随机从屏幕边缘生成敌人\n    const side = Phaser.Math.Between(0, 3);\n    let x, y;\n\n    switch (side) {\n      case 0: // 上\n        x = Phaser.Math.Between(0, 800);\n        y = -30;\n        break;\n      case 1: // 右\n        x = 830;\n        y = Phaser.Math.Between(0, 600);\n        break;\n      case 2: // 下\n        x = Phaser.Math.Between(0, 800);\n        y = 630;\n        break;\n      case 3: // 左\n        x = -30;\n        y = Phaser.Math.Between(0, 600);\n        break;\n    }\n\n    const enemy = this.enemies.create(x, y, 'enemy');\n\n    // 计算朝向玩家的角度\n    const angle = Phaser.Math.Angle.Between(\n      x,\n      y,\n      this.player.x,\n      this.player.y\n    );\n\n    // 设置敌人速度（使用当前速度）\n    this.physics.velocityFromRotation(angle, this.currentEnemySpeed, enemy.body.velocity);\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.isGameOver) return;\n\n    this.isGameOver = true;\n\n    // 停止游戏\n    this.physics.pause();\n    this.enemyTimer.remove();\n\n    // 玩家变色\n    player.setTint(0xff0000);\n\n    // 显示游戏结束信息\n    this.gameOverText.setText(`GAME OVER\\nSurvival Time: ${this.survivalTime.toFixed(1)}s`);\n    this.gameOverText.setVisible(true);\n\n    this.restartText.setText('Press R to Restart');\n    this.restartText.setVisible(true);\n  }\n\n  restartGame() {\n    this.scene.restart();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000890_v2", "prompt_id": "seed_000890", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9107692307692308}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 在随机位置绘制5个粉色星形，每个大小64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布大小\n2. 在 create 方法中创建一个绘制星形的函数\n3. 使用 Graphics 对象绘制星形路径（5个顶点）\n4. 循环5次，每次在随机位置创建一个粉色星形\n5. 使用 setPosition 将星形放置在随机坐标\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制星形的函数\n  const drawStar = (graphics, size) => {\n    const outerRadius = size / 2;\n    const innerRadius = outerRadius * 0.4;\n    const points = 5;\n    \n    graphics.beginPath();\n    \n    for (let i = 0; i < points * 2; i++) {\n      const angle = (i * Math.PI) / points - Math.PI / 2;\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      \n      if (i === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  };\n  \n  // 创建5个随机位置的粉色星形\n  for (let i = 0; i < 5; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充 (0xFFC0CB 是粉色的十六进制值)\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 绘制星形\n    drawStar(graphics, 64);\n    \n    // 设置随机位置（考虑星形大小，避免超出边界）\n    const randomX = Phaser.Math.Between(32, 768);\n    const randomY = Phaser.Math.Between(32, 568);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000248_v3", "prompt_id": "seed_000248", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 8 个蓝色物体以 300 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 8个蓝色物体以300速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World#setBoundsCollision, Phaser.Physics.Arcade.Body#setVelocity, Phaser.Physics.Arcade.Body#setBounce, Phaser.Physics.Arcade.World#collide\nSTEPS:\n1. 创建物理系统配置，启用 Arcade Physics\n2. 使用 Graphics 生成蓝色圆形纹理\n3. 创建物理组，添加 8 个蓝色物体\n4. 为每个物体设置随机速度（总速度为 300）和完全反弹\n5. 启用世界边界碰撞和物体间碰撞检测\n6. 添加状态信号变量记录碰撞次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet collisionCount = 0;\nlet activeObjects = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1);\n  graphics.fillCircle(20, 20, 20);\n  graphics.generateTexture('blueCircle', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 启用世界边界碰撞\n  this.physics.world.setBoundsCollision(true, true, true, true);\n  \n  // 创建物理组\n  const blueObjects = this.physics.add.group({\n    key: 'blueCircle',\n    repeat: 7, // 创建 8 个物体（1 + 7）\n    setXY: {\n      x: 100,\n      y: 100,\n      stepX: 80,\n      stepY: 60\n    }\n  });\n  \n  // 设置每个物体的属性\n  blueObjects.children.iterate((child) => {\n    // 设置随机方向的速度，总速度为 300\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const velocityX = Math.cos(angle) * 300;\n    const velocityY = Math.sin(angle) * 300;\n    \n    child.setVelocity(velocityX, velocityY);\n    \n    // 设置完全反弹\n    child.setBounce(1, 1);\n    \n    // 启用世界边界碰撞\n    child.setCollideWorldBounds(true);\n    \n    // 设置圆形碰撞体\n    child.body.setCircle(20);\n  });\n  \n  // 更新活跃物体数量\n  activeObjects = blueObjects.children.size;\n  \n  // 启用物体间碰撞\n  this.physics.add.collider(blueObjects, blueObjects, () => {\n    collisionCount++;\n  });\n  \n  // 显示状态信息\n  const statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 更新状态显示\n  this.events.on('update', () => {\n    statusText.setText([\n      `Active Objects: ${activeObjects}`,\n      `Collisions: ${collisionCount}`,\n      `Speed: 300 px/s`\n    ]);\n  });\n  \n  // 添加说明文本\n  this.add.text(400, 580, 'Blue objects moving at 300 speed with bounce', {\n    fontSize: '14px',\n    fill: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 游戏循环更新（物理系统自动处理移动和碰撞）\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000989_v1", "prompt_id": "seed_000989", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9066666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆\n2. 在 update 方法中根据 delta 时间增量计算旋转角度\n3. 将角度转换为弧度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet rotationSpeed = 80; // 每秒旋转 80 度\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象并绘制椭圆\n  ellipse = this.add.graphics();\n  \n  // 设置椭圆位置到屏幕中心\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 设置填充样式并绘制椭圆\n  ellipse.fillStyle(0x00ff00, 1);\n  // 椭圆中心在 (0, 0)，长轴 120，短轴 60\n  ellipse.fillEllipse(0, 0, 120, 60);\n  \n  // 添加一个标记点，便于观察旋转效果\n  ellipse.fillStyle(0xff0000, 1);\n  ellipse.fillCircle(60, 0, 8);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 计算本帧应该旋转的角度（度）\n  const rotationDegrees = rotationSpeed * (delta / 1000);\n  \n  // 将角度转换为弧度并累加到当前旋转值\n  ellipse.rotation += Phaser.Math.DegToRad(rotationDegrees);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000190_v3", "prompt_id": "seed_000190", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个青色星形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个青色星形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个外顶点和 5 个内顶点坐标（基于中心点和半径）\n4. 使用 beginPath/moveTo/lineTo 绘制星形路径\n5. 使用青色填充星形并渲染\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 40;  // 外半径 40px，直径约 80px\n  const innerRadius = 16;  // 内半径约为外半径的 40%\n  const points = 5;        // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制星形的顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 每个点的角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点用 moveTo，其余用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充星形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000651_v3", "prompt_id": "seed_000651", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让红色矩形在 2 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个红色矩形，使用 Tween 动画实现 2 秒缩放循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Image\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Image 对象使用生成的纹理\n3. 使用 tweens.add 创建缩放动画，设置 scale 属性从 1 到 1.5 再回到 1\n4. 配置动画循环播放，持续时间 2 秒，使用 yoyo 实现往返效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建红色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('redRect', 100, 100);\n  graphics.destroy();\n  \n  // 在屏幕中央创建红色矩形图像\n  const rect = this.add.image(400, 300, 'redRect');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    scale: 1.5,              // 缩放到 1.5 倍\n    duration: 1000,          // 单程持续 1 秒\n    yoyo: true,              // 启用往返效果（放大后缩小）\n    repeat: -1,              // 无限循环 (-1 表示永久重复)\n    ease: 'Sine.easeInOut'   // 使用正弦缓动函数使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '红色矩形缩放动画 (2秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000355_v3", "prompt_id": "seed_000355", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 1.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 设置初始 alpha 为 0（完全透明）\n4. 使用 Tween 动画让 alpha 从 0 到 1，持续 1.5 秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点为 50, 50，尺寸 100x100）\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 顶点\n  graphics.lineTo(100, 50);    // 右点\n  graphics.lineTo(50, 100);    // 底点\n  graphics.lineTo(0, 50);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中显示\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1,              // 目标透明度为 1（完全不透明）\n    duration: 1500,        // 持续时间 1.5 秒\n    ease: 'Linear',        // 线性缓动\n    yoyo: true,            // 来回播放（透明->不透明->透明）\n    repeat: -1             // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000138_v1", "prompt_id": "seed_000138", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 Tween 系统创建缩放动画，从1到0.48再回到1\n4. 设置 yoyo 为 true 实现往返效果，设置 loop 为 -1 实现无限循环\n5. 设置 duration 为 2000ms（单程2秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建使用该纹理的 Sprite，并居中显示\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    scaleX: 0.48,           // X 轴缩放到 48%\n    scaleY: 0.48,           // Y 轴缩放到 48%\n    duration: 2000,         // 单程持续时间 2 秒\n    yoyo: true,             // 启用往返效果（缩放到 48% 后再恢复到 100%）\n    loop: -1,               // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'  // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Rectangle scaling to 48% and back\\nLooping animation', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000581_v1", "prompt_id": "seed_000581", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在2.5秒内缩放到16%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果：从 scale=1 到 scale=0.16，yoyo 模式自动恢复\n4. 设置 duration 为 2500ms（2.5秒），loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (0, 0)，方便缩放\n  const triangleSize = 100;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize * 0.577); // 顶点\n  graphics.lineTo(-triangleSize / 2, triangleSize * 0.289); // 左下\n  graphics.lineTo(triangleSize / 2, triangleSize * 0.289); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.16, // 缩放到 16%\n    scaleY: 0.16,\n    duration: 2500, // 2.5 秒\n    yoyo: true, // 自动恢复到原始大小\n    loop: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Triangle scaling animation (16% - 100% loop)', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000066_v2", "prompt_id": "seed_000066", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 300 像素/秒的速度移动\nAPI: Graphics.fillTriangle, Input.Keyboard.addKeys, Scene.update\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象应用三角形纹理\n3. 在 create 中使用 addKeys 监听 WASD 键\n4. 在 update 中根据按键状态计算速度并更新三角形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向上方的三角形\n  graphics.fillTriangle(\n    0, -20,    // 顶点（上）\n    -15, 20,   // 左下角\n    15, 20     // 右下角\n  );\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('triangleTex', 30, 40);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成纹理\n  \n  // 创建三角形精灵，放置在屏幕中心\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置键盘输入监听 WASD\n  keys = this.input.keyboard.addKeys({\n    up: Phaser.Input.Keyboard.KeyCodes.W,\n    down: Phaser.Input.Keyboard.KeyCodes.S,\n    left: Phaser.Input.Keyboard.KeyCodes.A,\n    right: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算速度增量（像素/帧）\n  const velocity = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 根据按键状态计算移动方向\n  if (keys.left.isDown) {\n    velocityX -= velocity;\n  }\n  if (keys.right.isDown) {\n    velocityX += velocity;\n  }\n  if (keys.up.isDown) {\n    velocityY -= velocity;\n  }\n  if (keys.down.isDown) {\n    velocityY += velocity;\n  }\n  \n  // 更新三角形位置\n  triangle.x += velocityX;\n  triangle.y += velocityY;\n  \n  // 边界限制（可选，防止三角形移出屏幕）\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000756_v3", "prompt_id": "seed_000756", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的六边形并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制六边形\n2. 将六边形图形生成为纹理并创建 Sprite 对象\n3. 在 update 中让六边形持续向上移动\n4. 使用 Camera.startFollow 让相机跟随六边形并保持居中\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.hexagon = null;\n    this.moveSpeed = 100; // 每秒移动像素数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 绘制六边形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.lineStyle(3, 0xffffff, 1);\n    \n    // 绘制六边形（中心点在 0,0）\n    const size = 30;\n    const points = [];\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i;\n      const x = size * Math.cos(angle);\n      const y = size * Math.sin(angle);\n      points.push(new Phaser.Math.Vector2(x, y));\n    }\n    \n    graphics.beginPath();\n    graphics.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      graphics.lineTo(points[i].x, points[i].y);\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 将 Graphics 生成为纹理\n    graphics.generateTexture('hexagonTex', size * 2, size * 2);\n    graphics.destroy();\n    \n    // 创建六边形精灵，初始位置在场景中心偏下\n    this.hexagon = this.add.sprite(400, 500, 'hexagonTex');\n    \n    // 设置相机跟随六边形\n    // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n    // roundPixels: 是否将相机位置四舍五入到整数像素\n    // lerpX, lerpY: 平滑跟随的插值系数 (0-1)，1 表示立即跟随\n    this.cameras.main.startFollow(this.hexagon, true, 0.1, 0.1);\n    \n    // 添加一些参考背景网格，方便观察移动效果\n    this.createBackgroundGrid();\n    \n    // 添加提示文本（固定在相机上）\n    const text = this.add.text(10, 10, '六边形自动向上移动\\n相机跟随并保持居中', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n  }\n\n  update(time, delta) {\n    // 让六边形持续向上移动\n    // delta 是毫秒数，需要转换为秒\n    if (this.hexagon) {\n      this.hexagon.y -= this.moveSpeed * (delta / 1000);\n      \n      // 可选：当六边形移动到很远时重置位置（演示循环效果）\n      if (this.hexagon.y < -1000) {\n        this.hexagon.y = 500;\n      }\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建网格背景，方便观察相机移动\n    const gridGraphics = this.add.graphics();\n    gridGraphics.lineStyle(1, 0x333333, 0.5);\n    \n    const gridSize = 100;\n    const worldWidth = 800;\n    const worldHeight = 2000;\n    \n    // 绘制垂直线\n    for (let x = 0; x <= worldWidth; x += gridSize) {\n      gridGraphics.lineBetween(x, -worldHeight, x, worldHeight);\n    }\n    \n    // 绘制水平线\n    for (let y = -worldHeight; y <= worldHeight; y += gridSize) {\n      gridGraphics.lineBetween(0, y, worldWidth, y);\n    }\n    \n    // 添加坐标标记\n    const style = { fontSize: '12px', color: '#666666' };\n    for (let y = 0; y >= -worldHeight; y -= 200) {\n      this.add.text(10, y, `Y: ${y}`, style);\n    }\n    for (let y = 200; y <= worldHeight; y += 200) {\n      this.add.text(10, y, `Y: ${y}`, style);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene,\n  // 扩展世界边界以允许相机跟随对象移动\n  physics: {\n    default: 'arcade',\n    arcade: {\n      debug: false\n    }\n  }\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000686_v1", "prompt_id": "seed_000686", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 0.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 0.5 秒内缩放到 80% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale 从 1 到 0.8 再回到 1）\n4. 设置 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（居中绘制，方便缩放）\n  graphics.beginPath();\n  graphics.moveTo(0, -50);      // 顶点\n  graphics.lineTo(-43, 25);     // 左下角\n  graphics.lineTo(43, 25);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 86, 75);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    scaleX: 0.8,                // X 轴缩放到 80%\n    scaleY: 0.8,                // Y 轴缩放到 80%\n    duration: 500,              // 持续时间 0.5 秒\n    yoyo: true,                 // 动画结束后反向播放（回到原始大小）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '三角形循环缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000352_v2", "prompt_id": "seed_000352", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色矩形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色矩形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为红色（0xff0000）\n4. 计算画布中心位置，绘制 48x48 的矩形，使其中心对齐画布中心\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 在画布中央绘制红色矩形\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色，不透明度为 1\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 计算矩形的左上角位置，使其中心在画布中央\n  // 画布中心：(400, 300)\n  // 矩形大小：48x48\n  // 左上角位置：(400 - 24, 300 - 24) = (376, 276)\n  const rectSize = 48;\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000370_v3", "prompt_id": "seed_000370", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：橙色敌人从上方以 240 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，玩家左右移动躲避从上方落下的橙色敌人，碰撞则游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.overlap\nSTEPS:\n1. 创建物理系统配置，设置重力为0（手动控制敌人下落速度）\n2. 使用 Graphics 创建玩家（绿色方块）和敌人（橙色圆形）的纹理\n3. 设置键盘输入监听（左右方向键或 A/D 键）\n4. 在 create 中创建玩家精灵并启用物理，创建敌人组\n5. 定时器每隔一段时间生成新的敌人，设置其速度为 240 向下\n6. 在 update 中处理玩家移动和边界限制\n7. 使用碰撞检测监听玩家与敌人的重叠，触发游戏结束\n8. 显示游戏状态文本（存活时间/分数）和游戏结束提示\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.survivalTime = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（橙色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff8800, 1);\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 定时生成敌人（每1-2秒随机生成）\n    this.enemyTimer = this.time.addEvent({\n      delay: Phaser.Math.Between(1000, 2000),\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Time: 0s', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER\\nPress SPACE to Restart', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      align: 'center'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启键\n    this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 计时器\n    this.timeEvent = this.time.addEvent({\n      delay: 100,\n      callback: this.updateTime,\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) return;\n\n    // 随机X位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -40, 'enemy');\n    \n    // 设置敌人速度为240向下\n    enemy.setVelocityY(240);\n    enemy.body.setSize(40, 40);\n\n    // 敌人离开屏幕后销毁并增加分数\n    enemy.setData('scored', false);\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) return;\n\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.player.setTint(0xff0000);\n    this.gameOverText.setVisible(true);\n    \n    // 停止生成敌人\n    this.enemyTimer.remove();\n    this.timeEvent.remove();\n  }\n\n  updateTime() {\n    if (!this.gameOver) {\n      this.survivalTime += 0.1;\n      this.score = Math.floor(this.survivalTime * 10);\n      this.scoreText.setText(`Time: ${this.survivalTime.toFixed(1)}s | Score: ${this.score}`);\n    }\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      // 检测重启\n      if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {\n        this.scene.restart();\n        this.score = 0;\n        this.gameOver = false;\n        this.survivalTime = 0;\n      }\n      return;\n    }\n\n    // 玩家移动\n    const speed = 300;\n    \n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理离开屏幕的敌人并增加分数\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 650) {\n        if (!enemy.getData('scored')) {\n          enemy.setData('scored', true);\n          this.score += 10;\n        }\n        enemy.destroy();\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000877_v3", "prompt_id": "seed_000877", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9121428571428571}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色六边形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色六边形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Image\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 创建 Image 对象使用生成的六边形纹理\n3. 使用 Tween 实现从左到右的移动动画，持续4秒\n4. 设置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1); // 粉色 (HotPink)\n  \n  // 绘制六边形\n  const hexagonRadius = 40;\n  const hexagonPath = [];\n  \n  // 计算六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角60度\n    const x = hexagonRadius + hexagonRadius * Math.cos(angle);\n    const y = hexagonRadius + hexagonRadius * Math.sin(angle);\n    hexagonPath.push(x, y);\n  }\n  \n  // 绘制多边形\n  graphics.fillPoints(hexagonPath, true);\n  \n  // 生成纹理\n  const textureSize = hexagonRadius * 2 + 10; // 留一些边距\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  \n  // 清除 graphics 对象（已经生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建六边形图像对象\n  const hexagon = this.add.image(100, 300, 'hexagon');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: hexagon,           // 动画目标\n    x: 700,                     // 目标 x 坐标（从左到右）\n    duration: 4000,             // 持续时间 4 秒\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 往返效果（到达终点后返回起点）\n    loop: -1                    // 无限循环（-1 表示永久循环）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '粉色六边形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '动画持续4秒，自动往返循环', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000704_v1", "prompt_id": "seed_000704", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 设置相机边界：创建一个 1600x1200 的大场景，限制相机只能在场景范围内移动。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera", "output": "[PLAN]\nREQ: 创建1600x1200大场景，设置相机边界限制相机移动范围\nAPI: setBounds, setBackgroundColor, fillRect, createCursorKeys, scrollX, scrollY\nSTEPS:\n1. 创建1600x1200的大场景，使用Graphics绘制背景网格便于观察\n2. 使用camera.setBounds设置相机边界为场景大小\n3. 添加键盘控制让相机可以移动，验证边界限制\n4. 在场景四周绘制边界标记，方便观察相机是否被正确限制\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 获取主相机\n  const camera = this.cameras.main;\n  \n  // 设置相机边界为 1600x1200 的场景大小\n  camera.setBounds(0, 0, 1600, 1200);\n  \n  // 绘制场景背景 - 使用网格便于观察\n  const graphics = this.add.graphics();\n  \n  // 绘制浅色背景\n  graphics.fillStyle(0x404040, 1);\n  graphics.fillRect(0, 0, 1600, 1200);\n  \n  // 绘制网格线\n  graphics.lineStyle(1, 0x606060, 0.5);\n  \n  // 垂直网格线\n  for (let x = 0; x <= 1600; x += 100) {\n    graphics.beginPath();\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 1200);\n    graphics.strokePath();\n  }\n  \n  // 水平网格线\n  for (let y = 0; y <= 1200; y += 100) {\n    graphics.beginPath();\n    graphics.moveTo(0, y);\n    graphics.lineTo(1600, y);\n    graphics.strokePath();\n  }\n  \n  // 绘制场景边界标记\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.strokeRect(2, 2, 1596, 1196);\n  \n  // 在四个角落添加标记文字\n  const textStyle = {\n    fontSize: '24px',\n    fill: '#ffffff',\n    backgroundColor: '#000000'\n  };\n  \n  this.add.text(20, 20, 'TOP-LEFT (0, 0)', textStyle);\n  this.add.text(1600 - 220, 20, 'TOP-RIGHT (1600, 0)', textStyle);\n  this.add.text(20, 1200 - 50, 'BOTTOM-LEFT (0, 1200)', textStyle);\n  this.add.text(1600 - 280, 1200 - 50, 'BOTTOM-RIGHT (1600, 1200)', textStyle);\n  \n  // 在场景中心添加标记\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(800, 600, 20);\n  this.add.text(800 - 80, 600 - 50, 'CENTER\\n(800, 600)', {\n    fontSize: '20px',\n    fill: '#00ff00',\n    align: 'center'\n  });\n  \n  // 添加控制说明\n  this.add.text(10, 10, 'Use Arrow Keys to Move Camera\\nCamera is bounded to 1600x1200', {\n    fontSize: '16px',\n    fill: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setScrollFactor(0); // 固定在屏幕上，不随相机移动\n  \n  // 创建键盘控制\n  this.cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加相机位置显示（固定在屏幕上）\n  this.cameraInfo = this.add.text(10, 560, '', {\n    fontSize: '14px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 5, y: 3 }\n  }).setScrollFactor(0);\n  \n  // 相机移动速度\n  this.cameraSpeed = 5;\n}\n\nfunction update(time, delta) {\n  const camera = this.cameras.main;\n  \n  // 使用方向键控制相机移动\n  if (this.cursors.left.isDown) {\n    camera.scrollX -= this.cameraSpeed;\n  } else if (this.cursors.right.isDown) {\n    camera.scrollX += this.cameraSpeed;\n  }\n  \n  if (this.cursors.up.isDown) {\n    camera.scrollY -= this.cameraSpeed;\n  } else if (this.cursors.down.isDown) {\n    camera.scrollY += this.cameraSpeed;\n  }\n  \n  // 更新相机位置信息显示\n  this.cameraInfo.setText(\n    `Camera Position: (${Math.round(camera.scrollX)}, ${Math.round(camera.scrollY)})\\n` +\n    `Camera Bounds: 0-${camera.bounds.width}, 0-${camera.bounds.height}`\n  );\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000014_v3", "prompt_id": "seed_000014", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9066666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的橙色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的橙色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillTriangle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环5次创建 Graphics 对象\n3. 每个 Graphics 对象使用 fillStyle 设置橙色（0xff8800）\n4. 使用 fillTriangle 绘制等边三角形，边长16像素\n5. 使用 setRandomPosition 将三角形随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建5个橙色三角形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xff8800, 1);\n    \n    // 绘制等边三角形\n    // 三角形顶点坐标（以中心为原点，边长16像素）\n    const size = 16;\n    const height = (Math.sqrt(3) / 2) * size; // 等边三角形高度\n    \n    // 三个顶点坐标（相对于图形中心）\n    const x1 = 0;           // 顶部顶点\n    const y1 = -height * 2/3;\n    \n    const x2 = -size / 2;   // 左下顶点\n    const y2 = height * 1/3;\n    \n    const x3 = size / 2;    // 右下顶点\n    const y3 = height * 1/3;\n    \n    // 填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 随机设置位置（确保三角形完全在画布内）\n    const margin = 20; // 边距\n    graphics.setRandomPosition(\n      margin,\n      margin,\n      config.width - margin * 2,\n      config.height - margin * 2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000348_v1", "prompt_id": "seed_000348", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的菱形对象并保持居中\nAPI: Graphics, Camera.startFollow, Sprite, Scene\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 在 update 中让菱形自动向右移动\n4. 使用 Camera.startFollow 让相机跟随菱形对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst MOVE_SPEED = 100; // 每秒移动像素数\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制菱形（四个顶点）\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使菱形更明显\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让菱形有足够的移动空间\n  this.cameras.main.setBounds(0, 0, 3200, 600);\n  this.physics.world.setBounds(0, 0, 3200, 600);\n  \n  // 在场景左侧创建菱形精灵\n  diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 设置相机跟随菱形，保持居中\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 添加一些参考网格，方便观察相机移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 3200; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 600);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 600; y += 100) {\n    gridGraphics.lineBetween(0, y, 3200, y);\n  }\n  \n  // 添加文本提示\n  const text = this.add.text(16, 16, '菱形自动向右移动，相机跟随', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 将文本固定在相机上，不随场景滚动\n  text.setScrollFactor(0);\n  \n  // 添加位置信息文本\n  this.positionText = this.add.text(16, 50, '', {\n    fontSize: '16px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让菱形向右移动\n  // delta 是毫秒，需要转换为秒\n  diamond.x += MOVE_SPEED * (delta / 1000);\n  \n  // 更新位置信息\n  this.positionText.setText(\n    `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})\\n` +\n    `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n  );\n  \n  // 可选：当菱形到达世界边界时重置位置\n  if (diamond.x > 3200) {\n    diamond.x = 100;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000672_v2", "prompt_id": "seed_000672", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9337499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的三角形并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#x\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制三角形\n2. 将 Graphics 生成为可复用的纹理\n3. 创建 Sprite 对象作为移动目标\n4. 在 update 中让 Sprite 自动向右移动\n5. 使用 Camera.startFollow 让相机跟随 Sprite 并保持居中\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.triangle = null;\n    this.speed = 100; // 移动速度（像素/秒）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 绘制三角形\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1); // 绿色三角形\n    \n    // 绘制等边三角形（中心点在原点）\n    graphics.beginPath();\n    graphics.moveTo(0, -20);      // 顶点\n    graphics.lineTo(-17.32, 10);  // 左下角\n    graphics.lineTo(17.32, 10);   // 右下角\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 生成纹理\n    graphics.generateTexture('triangleTex', 40, 40);\n    graphics.destroy(); // 销毁 graphics 对象，纹理已保存\n    \n    // 创建三角形 Sprite（起始位置在场景左侧）\n    this.triangle = this.add.sprite(100, 300, 'triangleTex');\n    \n    // 设置相机跟随三角形\n    // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n    // roundPixels: 是否四舍五入像素，避免抖动\n    // lerpX/lerpY: 相机跟随的平滑度（0-1，1为立即跟随）\n    this.cameras.main.startFollow(this.triangle, true, 0.1, 0.1);\n    \n    // 扩展世界边界，让三角形可以移动更远\n    this.cameras.main.setBounds(0, 0, 3000, 600);\n    \n    // 添加提示文本（固定在相机视图）\n    const text = this.add.text(10, 10, '三角形自动向右移动\\n相机跟随并保持居中', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机视图，不随相机移动\n    \n    // 添加场景参考点（帮助观察移动）\n    for (let i = 0; i < 3000; i += 200) {\n      const marker = this.add.graphics();\n      marker.fillStyle(0x666666, 0.5);\n      marker.fillCircle(i, 300, 5);\n      \n      const label = this.add.text(i, 320, `${i}px`, {\n        fontSize: '12px',\n        fill: '#999999'\n      });\n      label.setOrigin(0.5, 0);\n    }\n  }\n\n  update(time, delta) {\n    // 让三角形持续向右移动\n    // delta 是毫秒，转换为秒\n    this.triangle.x += this.speed * (delta / 1000);\n    \n    // 可选：当三角形移动到边界时重置位置\n    if (this.triangle.x > 2900) {\n      this.triangle.x = 100;\n    }\n  }\n}\n\n// Phaser Game 配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene,\n  // 可选：如果需要在 Node.js 环境运行，使用 Phaser.HEADLESS\n  // type: Phaser.HEADLESS,\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000480_v2", "prompt_id": "seed_000480", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让紫色矩形在 2 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色矩形，使用 Tween 动画实现 2 秒旋转一圈的循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制紫色矩形并生成纹理\n2. 创建 Sprite 或 Container 作为旋转对象\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 配置动画参数：duration 为 2000ms，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('purpleRect', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象并设置位置和锚点\n  const rect = this.add.sprite(400, 300, 'purpleRect');\n  rect.setOrigin(0.5, 0.5); // 设置中心点为旋转中心\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rect,\n    angle: 360, // 旋转 360 度\n    duration: 2000, // 持续 2 秒\n    ease: 'Linear', // 线性缓动，保持匀速旋转\n    repeat: -1, // 无限循环\n    onRepeat: function() {\n      // 每次循环重置角度，避免数值累积\n      rect.angle = 0;\n    }\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '紫色矩形旋转动画 (2秒/圈)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000591_v3", "prompt_id": "seed_000591", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个使用该纹理的精灵对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 4 秒\n4. 设置 Tween 为循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径 50 的圆\n  graphics.generateTexture('circleTexture', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n  \n  // 创建精灵对象，使用生成的圆形纹理\n  const circle = this.add.sprite(400, 300, 'circleTexture');\n  circle.setAlpha(0); // 初始设置为完全透明\n  \n  // 创建 Tween 动画：从透明（alpha: 0）到不透明（alpha: 1）\n  this.tweens.add({\n    targets: circle,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 4000, // 持续时间 4 秒\n    ease: 'Linear', // 线性渐变\n    yoyo: true, // 来回循环（0->1->0）\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '圆形从透明到不透明循环渐变（4秒周期）', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000011_v3", "prompt_id": "seed_000011", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现红色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现红色角色按键切换 idle/run 状态，使用 tween 和帧动画体现状态差异\nAPI: this.add.graphics(), this.tweens.add(), this.anims.create(), this.input.keyboard.addKey(), this.add.sprite()\nSTEPS:\n1. 使用 Graphics 创建红色方块纹理作为角色，生成多帧纹理用于帧动画\n2. 创建 idle 和 run 两种动画，idle 使用缓慢的上下浮动 tween，run 使用快速的帧动画\n3. 监听 I 键切换到 idle 状态，R 键切换到 run 状态\n4. 添加状态文本显示当前状态，用于验证状态切换\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 游戏状态变量（用于验证）\nlet currentState = 'idle';\nlet stateChangeCount = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建红色角色的多帧纹理\n  const graphics = this.add.graphics();\n  \n  // 创建 idle 状态的纹理（单帧，纯红色方块）\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 64, 64);\n  graphics.generateTexture('player_idle', 64, 64);\n  graphics.clear();\n  \n  // 创建 run 状态的纹理帧（4帧，不同亮度的红色表示动画）\n  const runColors = [0xff0000, 0xcc0000, 0xff3333, 0xee0000];\n  for (let i = 0; i < 4; i++) {\n    graphics.fillStyle(runColors[i], 1);\n    graphics.fillRect(0, 0, 64, 64);\n    // 添加简单的腿部动画效果\n    graphics.fillStyle(0x880000, 1);\n    if (i % 2 === 0) {\n      graphics.fillRect(10, 50, 15, 14);\n      graphics.fillRect(40, 50, 15, 14);\n    } else {\n      graphics.fillRect(15, 50, 15, 14);\n      graphics.fillRect(35, 50, 15, 14);\n    }\n    graphics.generateTexture(`player_run_${i}`, 64, 64);\n    graphics.clear();\n  }\n  \n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵\n  this.player = this.add.sprite(400, 300, 'player_idle');\n  this.player.setOrigin(0.5);\n  \n  // 创建 run 动画（帧动画）\n  this.anims.create({\n    key: 'run',\n    frames: [\n      { key: 'player_run_0' },\n      { key: 'player_run_1' },\n      { key: 'player_run_2' },\n      { key: 'player_run_3' }\n    ],\n    frameRate: 8,\n    repeat: -1\n  });\n  \n  // 状态显示文本\n  this.stateText = this.add.text(400, 100, 'State: IDLE', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#ffffff'\n  });\n  this.stateText.setOrigin(0.5);\n  \n  // 指令文本\n  this.add.text(400, 150, 'Press [I] for IDLE | Press [R] for RUN', {\n    fontSize: '20px',\n    fontFamily: 'Arial',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n  \n  // 状态计数器文本（用于验证）\n  this.counterText = this.add.text(400, 500, 'State Changes: 0', {\n    fontSize: '18px',\n    fontFamily: 'Arial',\n    color: '#ffff00'\n  });\n  this.counterText.setOrigin(0.5);\n  \n  // 添加按键监听\n  this.keyI = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);\n  this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n  \n  // 初始化为 idle 状态\n  this.currentTween = null;\n  this.switchToIdle();\n}\n\nfunction update() {\n  // 检测按键切换状态\n  if (Phaser.Input.Keyboard.JustDown(this.keyI)) {\n    this.switchToIdle();\n  }\n  \n  if (Phaser.Input.Keyboard.JustDown(this.keyR)) {\n    this.switchToRun();\n  }\n}\n\n// 切换到 idle 状态\nPhaser.Scene.prototype.switchToIdle = function() {\n  if (currentState === 'idle') return;\n  \n  currentState = 'idle';\n  stateChangeCount++;\n  \n  // 停止 run 动画\n  this.player.stop();\n  this.player.setTexture('player_idle');\n  \n  // 停止之前的 tween\n  if (this.currentTween) {\n    this.currentTween.stop();\n  }\n  \n  // 创建 idle 状态的上下浮动 tween\n  this.currentTween = this.tweens.add({\n    targets: this.player,\n    y: 280,\n    duration: 1500,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1\n  });\n  \n  // 更新显示\n  this.stateText.setText('State: IDLE');\n  this.stateText.setColor('#00ff00');\n  this.counterText.setText(`State Changes: ${stateChangeCount}`);\n};\n\n// 切换到 run 状态\nPhaser.Scene.prototype.switchToRun = function() {\n  if (currentState === 'run') return;\n  \n  currentState = 'run';\n  stateChangeCount++;\n  \n  // 停止 idle tween\n  if (this.currentTween) {\n    this.currentTween.stop();\n  }\n  \n  // 重置位置\n  this.player.y = 300;\n  \n  // 播放 run 帧动画\n  this.player.play('run');\n  \n  // 添加水平移动 tween（跑步效果）\n  this.currentTween = this.tweens.add({\n    targets: this.player,\n    x: 600,\n    duration: 2000,\n    ease: 'Linear',\n    yoyo: true,\n    repeat: -1\n  });\n  \n  // 更新显示\n  this.stateText.setText('State: RUN');\n  this.stateText.setColor('#ff6600');\n  this.counterText.setText(`State Changes: ${stateChangeCount}`);\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000868_v2", "prompt_id": "seed_000868", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 300 像素/秒的速度移动\nAPI: Phaser.Game, Phaser.Scene, Graphics.fillRect, Input.Keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Scene 类，配置游戏画布大小\n2. 在 create 中使用 Graphics 绘制方块并生成纹理\n3. 创建 Sprite 对象作为可控制的方块\n4. 使用 addKey 监听 WASD 四个按键\n5. 在 update 中根据按键状态计算移动方向并更新方块位置\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.keys = {};\n    this.speed = 300; // 像素/秒\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 绘制方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1); // 绿色方块\n    graphics.fillRect(0, 0, 50, 50);\n    graphics.generateTexture('playerBox', 50, 50);\n    graphics.destroy();\n\n    // 创建玩家方块（居中位置）\n    this.player = this.add.sprite(400, 300, 'playerBox');\n\n    // 设置 WASD 键盘输入\n    this.keys.W = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keys.A = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keys.S = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keys.D = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 添加提示文本\n    this.add.text(10, 10, 'Use WASD to move the square', {\n      fontSize: '18px',\n      color: '#ffffff'\n    });\n  }\n\n  update(time, delta) {\n    // 计算移动向量\n    let velocityX = 0;\n    let velocityY = 0;\n\n    // 检测按键状态并设置移动方向\n    if (this.keys.W.isDown) {\n      velocityY = -1; // 向上\n    } else if (this.keys.S.isDown) {\n      velocityY = 1; // 向下\n    }\n\n    if (this.keys.A.isDown) {\n      velocityX = -1; // 向左\n    } else if (this.keys.D.isDown) {\n      velocityX = 1; // 向右\n    }\n\n    // 归一化对角线移动速度（避免斜向移动过快）\n    if (velocityX !== 0 && velocityY !== 0) {\n      const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n      velocityX /= length;\n      velocityY /= length;\n    }\n\n    // 根据 delta 时间更新位置（确保帧率独立）\n    this.player.x += velocityX * this.speed * (delta / 1000);\n    this.player.y += velocityY * this.speed * (delta / 1000);\n\n    // 限制方块在画布范围内\n    this.player.x = Phaser.Math.Clamp(this.player.x, 25, 775);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 25, 575);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000688_v1", "prompt_id": "seed_000688", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9066666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左上移动的矩形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个矩形作为可移动对象\n2. 在 create 中设置相机跟随该矩形对象\n3. 在 update 中让矩形持续向左上方移动（x减小，y减小）\n4. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nconst MOVE_SPEED = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制网格范围更大，以便看到相机跟随效果\n  for (let x = -2000; x <= 2000; x += 100) {\n    graphics.moveTo(x, -2000);\n    graphics.lineTo(x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += 100) {\n    graphics.moveTo(-2000, y);\n    graphics.lineTo(2000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加网格坐标标签\n  const style = { fontSize: '12px', fill: '#00ff00' };\n  for (let x = -2000; x <= 2000; x += 200) {\n    for (let y = -2000; y <= 2000; y += 200) {\n      this.add.text(x + 5, y + 5, `${x},${y}`, style);\n    }\n  }\n  \n  // 创建玩家矩形（使用 Rectangle 游戏对象）\n  player = this.add.rectangle(400, 300, 40, 40, 0xff0000);\n  \n  // 添加一个白色边框使其更明显\n  const border = this.add.graphics();\n  border.lineStyle(2, 0xffffff, 1);\n  border.strokeRect(-20, -20, 40, 40);\n  \n  // 将边框附加到玩家对象上\n  this.add.container(0, 0, [player, border]);\n  \n  // 设置相机跟随玩家矩形\n  this.cameras.main.startFollow(player);\n  \n  // 可选：设置相机边界（让相机可以无限跟随）\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 添加提示文本（固定在相机上）\n  const instructionText = this.add.text(10, 10, \n    '红色矩形自动向左上移动\\n相机跟随并保持居中', \n    { \n      fontSize: '16px', \n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }\n  );\n  instructionText.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让矩形向左上方移动\n  // 左上方：x 减小（向左），y 减小（向上）\n  player.x -= MOVE_SPEED;\n  player.y -= MOVE_SPEED;\n  \n  // 可选：显示当前位置（用于调试）\n  // console.log(`Player position: (${player.x.toFixed(0)}, ${player.y.toFixed(0)})`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000338_v2", "prompt_id": "seed_000338", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形从透明到不透明循环渐变动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, this.add.graphics, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制六边形路径并填充颜色\n2. 设置初始 alpha 为 0（完全透明）\n3. 使用 tweens 创建 alpha 从 0 到 1 的补间动画\n4. 设置动画持续时间 1000ms，循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 计算六边形的顶点坐标\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 100;\n  const sides = 6;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 * i) / sides - Math.PI / 2; // 从顶部开始\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径并填充\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置初始透明度为 0\n  graphics.setAlpha(0);\n  \n  // 创建渐变动画：从透明（alpha=0）到不透明（alpha=1）\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1,\n    duration: 1000,        // 1秒\n    ease: 'Linear',        // 线性渐变\n    yoyo: true,            // 反向播放（从1回到0）\n    loop: -1,              // 无限循环\n    repeat: 0              // yoyo 模式下不需要额外 repeat\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 500, '六边形循环渐变动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000073_v1", "prompt_id": "seed_000073", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在1.5秒内缩放到16%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制星形并生成纹理\n2. 创建星形精灵对象放置在画布中心\n3. 使用 Tween 动画实现缩放效果（scale: 1 -> 0.16 -> 1）\n4. 设置 loop: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.sprite(400, 300, 'star');\n  star.setOrigin(0.5, 0.5);\n  \n  // 创建缩放动画\n  // 使用 yoyo 实现缩放到16%后恢复\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 1500, // 1.5秒\n    ease: 'Sine.easeInOut',\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    loop: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 550, 'Star scaling animation: 100% → 16% → 100% (loop)', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000406_v3", "prompt_id": "seed_000406", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到32%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.32\n4. 设置动画时长为 3000ms，yoyo 为 true 实现恢复效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150); // 200x150 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('rectTexture', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建使用该纹理的精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    scaleX: 0.32,           // X轴缩放到32%\n    scaleY: 0.32,           // Y轴缩放到32%\n    duration: 3000,         // 动画时长3秒\n    yoyo: true,             // 动画结束后反向播放（恢复原始大小）\n    loop: -1,               // 无限循环 (-1 表示永久循环)\n    ease: 'Linear'          // 线性缓动\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 50, 'Rectangle scaling to 32% and back\\nLooping forever', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000550_v2", "prompt_id": "seed_000550", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色圆形在2.5秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制红色圆形\n2. 创建补间动画，设置 x 坐标从左到右移动，持续2.5秒\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制红色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色，不透明\n  graphics.fillCircle(0, 0, 30); // 在原点绘制半径为30的圆形\n  \n  // 将 graphics 转换为纹理，方便后续操作\n  graphics.generateTexture('redCircle', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建使用该纹理的精灵，初始位置在左侧\n  const circle = this.add.sprite(100, 300, 'redCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,        // 动画目标对象\n    x: 700,                 // 目标 x 坐标（右侧）\n    duration: 2500,         // 持续时间 2.5 秒（2500 毫秒）\n    ease: 'Linear',         // 线性缓动\n    yoyo: true,             // 启用往返效果（到达终点后反向播放）\n    repeat: -1              // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000076_v2", "prompt_id": "seed_000076", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色三角形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色三角形以200速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 使用 Graphics 绘制黄色三角形并生成纹理\n2. 创建物理精灵并应用三角形纹理\n3. 设置初始速度为200（x和y方向）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  // 绘制等边三角形（中心点在纹理中心）\n  const size = 40;\n  const centerX = size / 2;\n  const centerY = size / 2;\n  const height = size * Math.sqrt(3) / 2;\n  \n  graphics.fillTriangle(\n    centerX, centerY - height * 2/3,           // 顶点\n    centerX - size / 2, centerY + height / 3,  // 左下角\n    centerX + size / 2, centerY + height / 3   // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', size, size);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（200像素/秒）\n  triangle.setVelocity(200, 200);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 可选：让三角形旋转以增加视觉效果\n  this.physics.world.on('worldbounds', () => {\n    // 可以在这里添加碰撞音效或其他效果\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000545_v3", "prompt_id": "seed_000545", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 64px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字位置为屏幕右下角（考虑文字尺寸偏移）\n4. 设置字体大小为 64px，并设置原点为右下角对齐\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建文字对象，位置设置在屏幕右下角\n  const text = this.add.text(\n    this.scale.width - 20,  // x 坐标：画布宽度 - 右边距\n    this.scale.height - 20, // y 坐标：画布高度 - 下边距\n    'Hello Phaser',\n    {\n      fontSize: '64px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }\n  );\n  \n  // 设置文字原点为右下角 (1, 1)，使文字从右下角对齐\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000572_v2", "prompt_id": "seed_000572", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色菱形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色菱形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 beginPath 开始路径绘制\n5. 通过 moveTo 和 lineTo 绘制菱形的四个顶点（上下左右各距中心 40 像素）\n6. 使用 closePath 闭合路径\n7. 设置蓝色填充样式并使用 fillPath 填充菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  \n  // 菱形大小（从中心到顶点的距离）\n  const size = 40;\n  \n  // 设置蓝色填充样式\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充菱形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000169_v1", "prompt_id": "seed_000169", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 200 像素/秒速度移动\nAPI: Graphics.fillStyle, Graphics.fillPath, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象使用生成的菱形纹理\n3. 通过 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新菱形位置，速度为 200 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 创建菱形路径（中心点为原点）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中央\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 添加 WASD 键监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧移动距离（速度 * 时间差，delta 单位是毫秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动菱形\n  if (keys.w.isDown) {\n    diamond.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    diamond.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    diamond.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    diamond.x += distance; // 向右移动\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000464_v2", "prompt_id": "seed_000464", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色圆形以300速度移动，碰到画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制红色圆形纹理\n3. 创建物理精灵并应用纹理\n4. 设置精灵速度为300，启用边界碰撞和反弹\n5. 设置世界边界碰撞检测\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径25的圆\n  graphics.generateTexture('redCircle', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'redCircle');\n  \n  // 设置初始速度（300像素/秒，45度角方向）\n  const speed = 300;\n  const angle = Phaser.Math.DegToRad(45);\n  circle.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置边界碰撞和反弹\n  circle.setCollideWorldBounds(true);\n  circle.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 确保世界边界启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000104_v2", "prompt_id": "seed_000104", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 16 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为右下角（画布宽度减去边距，画布高度减去边距）\n4. 设置文本原点为右下角 (1, 1)，使文本从右下角对齐\n5. 配置文本样式，字体大小为 16px\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右下角创建文本\n  // 位置：右边距 20px，下边距 20px\n  const text = this.add.text(\n    this.cameras.main.width - 20,  // x: 画布宽度 - 右边距\n    this.cameras.main.height - 20, // y: 画布高度 - 下边距\n    'Hello Phaser',\n    {\n      fontSize: '16px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    }\n  );\n  \n  // 设置原点为右下角 (1, 1)，使文本从右下角对齐\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000509_v2", "prompt_id": "seed_000509", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色菱形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色菱形，大小约为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 beginPath 开始路径绘制，通过 moveTo 和 lineTo 绘制菱形的四个顶点\n5. 设置绿色填充样式，调用 fillPath 填充菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 菱形大小（从中心到顶点的距离）\n  const size = 24;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);           // 上顶点\n  graphics.lineTo(centerX + size, centerY);           // 右顶点\n  graphics.lineTo(centerX, centerY + size);           // 下顶点\n  graphics.lineTo(centerX - size, centerY);           // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000091_v1", "prompt_id": "seed_000091", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让粉色星形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个粉色星形，使用 Tween 动画实现 1.5 秒闪烁循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Star\nSTEPS:\n1. 使用 Graphics 绘制粉色星形纹理\n2. 创建 Star 游戏对象并应用纹理\n3. 使用 Tween 控制 alpha 透明度实现闪烁效果（0→1→0）\n4. 设置 Tween 循环播放，duration 为 1500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建粉色星形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制粉色星形\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.lineStyle(2, 0xff1493, 1); // 深粉色描边\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 18;\n  const points = 5;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵对象\n  const star = this.add.image(400, 300, 'star');\n  star.setScale(2); // 放大2倍使其更明显\n  \n  // 创建闪烁动画（使用 Tween 控制透明度）\n  this.tweens.add({\n    targets: star,\n    alpha: { from: 1, to: 0 }, // 从完全不透明到完全透明\n    duration: 750, // 0.75秒变暗\n    yoyo: true, // 往返动画（变暗后再变亮）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '粉色星形闪烁动画\\n1.5秒循环', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000680_v1", "prompt_id": "seed_000680", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 200 像素/秒的速度移动\nAPI: Graphics.fillTriangle, Input.Keyboard.addKeys, GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象并应用三角形纹理\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新三角形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向上方的三角形（中心在原点）\n  graphics.fillTriangle(\n    0, -20,    // 顶点\n    -15, 20,   // 左下角\n    15, 20     // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 30, 40);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中心\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置 WASD 键\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动三角形\n  if (keys.W.isDown) {\n    triangle.y -= distance;\n  }\n  if (keys.S.isDown) {\n    triangle.y += distance;\n  }\n  if (keys.A.isDown) {\n    triangle.x -= distance;\n  }\n  if (keys.D.isDown) {\n    triangle.x += distance;\n  }\n  \n  // 边界限制（可选，防止移出屏幕）\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000109_v2", "prompt_id": "seed_000109", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让紫色菱形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色菱形，使用 Tween 动画实现 1.5 秒闪烁循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制紫色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 值在 0-1 之间变化，持续 1.5 秒\n4. 设置 yoyo 和 repeat: -1 实现循环闪烁效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建紫色菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（使用四个点连接）\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵并放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建闪烁动画\n  // 使用 Tween 控制 alpha 值实现闪烁效果\n  this.tweens.add({\n    targets: diamond,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 750,      // 单程持续 750ms\n    yoyo: true,         // 往返动画（0->1->0）\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '紫色菱形闪烁动画 (1.5秒/次)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000106_v2", "prompt_id": "seed_000106", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环3次，每次创建一个 Graphics 对象\n3. 使用三角函数计算六边形的6个顶点坐标（半径32像素）\n4. 使用 Phaser.Math.Between 生成随机位置（考虑边界避免超出画布）\n5. 使用 Graphics API 绘制填充的紫色六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制3个随机位置的紫色六边形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充\n    graphics.fillStyle(0x9932cc, 1);\n    \n    // 六边形参数\n    const radius = 32; // 半径32像素，直径64像素\n    const sides = 6;\n    \n    // 生成随机位置（考虑边界，留出半径空间）\n    const x = Phaser.Math.Between(radius + 10, 800 - radius - 10);\n    const y = Phaser.Math.Between(radius + 10, 600 - radius - 10);\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的顶点并绘制\n    for (let j = 0; j < sides; j++) {\n      // 计算每个顶点的角度（从顶部开始，所以减去90度）\n      const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(vx, vy);\n      } else {\n        graphics.lineTo(vx, vy);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000647_v3", "prompt_id": "seed_000647", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建场景并使用 Graphics 绘制菱形形状，生成纹理\n2. 创建精灵对象使用生成的菱形纹理\n3. 在 create 中设置相机跟随该精灵对象\n4. 在 update 中让精灵持续向右上方移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst MOVE_SPEED = 2;\n\nfunction preload() {\n  // 使用 Graphics 程序化生成菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 顶点\n  graphics.lineTo(64, 32);   // 右点\n  graphics.lineTo(32, 64);   // 底点\n  graphics.lineTo(0, 32);    // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，初始位置在场景中心\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置相机跟随菱形对象\n  // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n  // roundPixels: false - 不进行像素取整\n  // lerpX/lerpY: 0.1 - 平滑跟随系数，值越小越平滑\n  this.cameras.main.startFollow(diamond, false, 0.1, 0.1);\n  \n  // 设置相机边界，让相机可以无限跟随\n  // 这里设置一个较大的世界边界\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 添加提示文字（固定在相机视图中）\n  const text = this.add.text(10, 10, '相机跟随菱形移动', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图中，不随相机移动\n  \n  // 添加位置信息文字\n  this.positionText = this.add.text(10, 50, '', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让菱形向右上方移动\n  // 向右移动（x 增加）\n  diamond.x += MOVE_SPEED;\n  // 向上移动（y 减少）\n  diamond.y -= MOVE_SPEED;\n  \n  // 更新位置信息显示\n  this.positionText.setText(\n    `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})\\n` +\n    `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n  );\n  \n  // 可选：添加旋转效果让菱形更生动\n  diamond.rotation += 0.02;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000412_v2", "prompt_id": "seed_000412", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色三角形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色三角形在1.5秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillTriangle, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制红色三角形\n2. 创建补间动画，设置起始位置在左侧，目标位置在右侧\n3. 设置动画时长为1.5秒，启用 yoyo 实现往返，repeat 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制三角形（等腰三角形）\n  // 参数：x1, y1, x2, y2, x3, y3\n  graphics.fillTriangle(\n    0, -30,    // 顶点（上）\n    -25, 30,   // 左下角\n    25, 30     // 右下角\n  );\n  \n  // 设置初始位置在左侧\n  graphics.setPosition(100, 300);\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 1500,              // 动画时长 1.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000220_v1", "prompt_id": "seed_000220", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色三角形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色三角形，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置灰色填充\n5. 使用 fillTriangle 绘制等边三角形，三个顶点相对中心点分布\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#ffffff',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充样式 (RGB: 128, 128, 128)\n  graphics.fillStyle(0x808080, 1);\n  \n  // 计算画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 三角形大小约为 16 像素\n  const size = 16;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1: 顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size / 2;\n  \n  // 顶点2: 左下角\n  const x2 = centerX - size / 2;\n  const y2 = centerY + size / 2;\n  \n  // 顶点3: 右下角\n  const x3 = centerX + size / 2;\n  const y3 = centerY + size / 2;\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加描边使三角形更清晰\n  graphics.lineStyle(1, 0x404040, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000604_v2", "prompt_id": "seed_000604", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 白色玩家移出边界时从对侧出现（循环地图效果），移动速度 80。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 白色玩家移出边界时从对侧出现（循环地图效果），移动速度 80\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard.createCursorKeys, Graphics.fillRect, Graphics.generateTexture\nSTEPS:\n1. 创建白色玩家精灵，使用 Graphics 绘制白色方块作为纹理\n2. 设置 Arcade 物理系统，配置玩家速度为 80\n3. 在 create 中绑定键盘输入（方向键）\n4. 在 update 中处理玩家移动逻辑（WASD 或方向键）\n5. 在 update 中检测边界，当玩家移出边界时从对侧重新出现\n6. 添加状态信号变量（position、wrapCount）用于验证循环效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.wrapCount = 0; // 状态信号：记录循环次数\n    this.playerSpeed = 80;\n  }\n\n  preload() {\n    // 使用 Graphics 创建白色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建玩家精灵，初始位置在画布中心\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 允许移出边界\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 绘制边界参考线\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0x00ff00, 0.5);\n    borderGraphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n\n    // 处理键盘输入 - 方向键或 WASD\n    if (this.cursors.left.isDown || this.keys.a.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown || this.keys.d.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    }\n\n    if (this.cursors.up.isDown || this.keys.w.isDown) {\n      this.player.setVelocityY(-this.playerSpeed);\n    } else if (this.cursors.down.isDown || this.keys.s.isDown) {\n      this.player.setVelocityY(this.playerSpeed);\n    }\n\n    // 处理边界循环（wrap around）\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    const gameWidth = this.cameras.main.width;\n    const gameHeight = this.cameras.main.height;\n\n    let wrapped = false;\n\n    // 左右边界检测\n    if (this.player.x > gameWidth + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      wrapped = true;\n    } else if (this.player.x < -playerWidth / 2) {\n      this.player.x = gameWidth + playerWidth / 2;\n      wrapped = true;\n    }\n\n    // 上下边界检测\n    if (this.player.y > gameHeight + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      wrapped = true;\n    } else if (this.player.y < -playerHeight / 2) {\n      this.player.y = gameHeight + playerHeight / 2;\n      wrapped = true;\n    }\n\n    // 如果发生了循环，增加计数\n    if (wrapped) {\n      this.wrapCount++;\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `Wrap Count: ${this.wrapCount}`,\n      `Speed: ${this.playerSpeed}`,\n      `Use Arrow Keys or WASD to move`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000897_v3", "prompt_id": "seed_000897", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 360 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes, this.time.delta\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个方块并生成纹理\n2. 创建 sprite 对象作为可移动的玩家方块\n3. 使用 addKey 绑定 WASD 四个按键\n4. 在 update 中检测按键状态，根据 delta 时间计算位移量\n5. 根据按键方向更新方块位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet player;\nlet keys;\nconst SPEED = 360; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块，初始位置在屏幕中央\n  player = this.add.sprite(400, 300, 'playerBlock');\n\n  // 绑定 WASD 键\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 检测按键状态并设置移动方向\n  if (keys.W.isDown) {\n    velocityY = -1; // 向上\n  } else if (keys.S.isDown) {\n    velocityY = 1; // 向下\n  }\n\n  if (keys.A.isDown) {\n    velocityX = -1; // 向左\n  } else if (keys.D.isDown) {\n    velocityX = 1; // 向右\n  }\n\n  // 如果同时按下两个方向键，需要归一化速度向量\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n\n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n\n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000016_v1", "prompt_id": "seed_000016", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色方块以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds, Phaser.Physics.Arcade.Body.setVelocity\nSTEPS:\n1. 创建带有 Arcade 物理引擎的游戏配置\n2. 使用 Graphics 生成红色方块纹理\n3. 创建物理精灵并设置初始速度为200\n4. 设置物理体的反弹属性和世界边界碰撞\n5. 确保方块在碰到边界时能够反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 不需要重力\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建红色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的方块\n  graphics.generateTexture('redSquare', 50, 50);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n  \n  // 创建物理精灵，位置在画布中心\n  const square = this.physics.add.sprite(400, 300, 'redSquare');\n  \n  // 设置初始速度（200像素/秒，方向为右下45度）\n  square.setVelocity(200, 200);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 可选：保存引用以便在 update 中使用\n  this.square = square;\n}\n\nfunction update(time, delta) {\n  // 方块会自动由物理引擎处理移动和反弹\n  // 如果需要额外逻辑可以在这里添加\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000396_v2", "prompt_id": "seed_000396", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个蓝色敌人巡逻移动，在 120 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 创建15个蓝色敌人在场景中左右巡逻，检测玩家距离并在接近时追踪玩家\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.Sprite, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建玩家和敌人的纹理（使用Graphics绘制蓝色和绿色方块）\n2. 初始化玩家精灵，添加键盘控制\n3. 创建物理组，生成15个敌人并随机分布在场景中\n4. 为每个敌人设置初始巡逻方向和速度\n5. 在update中检测玩家与敌人距离，近距离时切换为追踪模式，远距离恢复巡逻模式\n6. 添加边界检测，敌人碰到边界时反向移动\n7. 显示状态信息（敌人数量、追踪数量）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemyCount = 15;\n    this.trackingCount = 0;\n    this.patrolSpeed = 120;\n    this.trackingDistance = 150;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 30, 30);\n    playerGraphics.generateTexture('player', 30, 30);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0066ff, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 生成15个敌人\n    for (let i = 0; i < this.enemyCount; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const enemy = this.enemies.create(x, y, 'enemy');\n      \n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 随机初始巡逻方向（左或右）\n      enemy.patrolDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;\n      enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n      \n      // 状态标记\n      enemy.isTracking = false;\n    }\n\n    // 创建状态文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 570, 'Use Arrow Keys to Move', {\n      fontSize: '14px',\n      fill: '#ffffff'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 重置追踪计数\n    this.trackingCount = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.getChildren().forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, \n        this.player.y, \n        enemy.x, \n        enemy.y\n      );\n\n      // 检测是否应该追踪玩家\n      if (distance < this.trackingDistance) {\n        // 追踪模式\n        if (!enemy.isTracking) {\n          enemy.isTracking = true;\n        }\n        \n        this.trackingCount++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, \n          enemy.y, \n          this.player.x, \n          this.player.y\n        );\n\n        // 设置追踪速度（稍快于巡逻速度）\n        const trackSpeed = this.patrolSpeed * 1.2;\n        enemy.setVelocity(\n          Math.cos(angle) * trackSpeed,\n          Math.sin(angle) * trackSpeed\n        );\n\n        // 改变颜色表示追踪状态（红色）\n        enemy.setTint(0xff0000);\n      } else {\n        // 巡逻模式\n        if (enemy.isTracking) {\n          enemy.isTracking = false;\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        // 恢复蓝色\n        enemy.clearTint();\n\n        // 边界检测 - 碰到左右边界时反向\n        if (enemy.x <= 15 && enemy.body.velocity.x < 0) {\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(this.patrolSpeed);\n        } else if (enemy.x >= 785 && enemy.body.velocity.x > 0) {\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(-this.patrolSpeed);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText([\n      `Total Enemies: ${this.enemyCount}`,\n      `Tracking Player: ${this.trackingCount}`,\n      `Patrolling: ${this.enemyCount - this.trackingCount}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000900_v3", "prompt_id": "seed_000900", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 2.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让菱形在2.5秒内缩放到16%然后恢复，循环播放\nAPI: Graphics, Tween, TweenManager, BaseTween.loop, Tweens.add\nSTEPS:\n1. 使用 Graphics 绘制菱形形状\n2. 创建 Tween 动画，设置 scale 从 1 到 0.16 再回到 1\n3. 设置 Tween 的 duration 为 2500ms，yoyo 为 true 实现往返\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建菱形 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置菱形的位置（屏幕中心）\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（使用四个点构成的多边形）\n  const size = 100; // 菱形的半径\n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 顶点\n  graphics.lineTo(centerX + size, centerY);      // 右点\n  graphics.lineTo(centerX, centerY + size);      // 底点\n  graphics.lineTo(centerX - size, centerY);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 创建缩放动画\n  // 从原始大小（1）缩放到 16%（0.16），然后返回\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 2500,      // 2.5秒完成一次缩放\n    yoyo: true,          // 启用往返效果（缩小后再放大）\n    loop: -1,            // 无限循环\n    ease: 'Linear'       // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Diamond scaling to 16% and back (2.5s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000065_v2", "prompt_id": "seed_000065", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.95}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个橙色物体以 200 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 10个橙色物体以200速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World#collide, setBounce, setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎，设置世界边界反弹\n2. 使用 Graphics 生成橙色圆形纹理\n3. 创建物理组，添加 10 个橙色物体\n4. 为每个物体设置随机速度（200 像素/秒）和完全反弹\n5. 在 update 中检测物体之间的碰撞，实现相互反弹\n6. 添加状态信号：记录碰撞次数作为验证指标\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff8800, 1); // 橙色\n    graphics.fillCircle(20, 20, 20); // 半径20的圆\n    graphics.generateTexture('orangeCircle', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.orangeGroup = this.physics.add.group({\n      defaultKey: 'orangeCircle',\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 创建 10 个橙色物体\n    for (let i = 0; i < 10; i++) {\n      // 随机位置\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      const orange = this.orangeGroup.create(x, y, 'orangeCircle');\n      \n      // 设置随机方向的速度，速度大小为 200\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 200;\n      const velocityY = Math.sin(angle) * 200;\n      \n      orange.setVelocity(velocityX, velocityY);\n      orange.setCircle(20); // 设置碰撞体为圆形\n    }\n\n    // 设置物体之间的碰撞检测\n    this.physics.add.collider(\n      this.orangeGroup,\n      this.orangeGroup,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 显示碰撞计数（调试用）\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n  }\n\n  handleCollision(obj1, obj2) {\n    // 碰撞回调，增加计数\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    // 更新碰撞计数显示\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n    \n    // 确保物体速度保持在 200 左右（可选的速度修正）\n    this.orangeGroup.getChildren().forEach(orange => {\n      const velocity = orange.body.velocity;\n      const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏离太多，重新归一化到 200\n      if (speed > 0 && Math.abs(speed - 200) > 10) {\n        const scale = 200 / speed;\n        orange.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000937_v1", "prompt_id": "seed_000937", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形移动，速度 240 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.Math.Vector2\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制菱形并生成纹理\n3. 创建 Sprite 对象作为可移动的菱形\n4. 在 create 中绑定 WASD 键盘输入\n5. 在 update 中根据按键状态更新菱形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（四个顶点）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形 Sprite\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置 WASD 键盘输入\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文字\n  this.add.text(10, 10, 'Use WASD to move the diamond', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 创建移动向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 WASD 按键状态\n  if (keys.w.isDown) {\n    velocityY = -1;\n  }\n  if (keys.s.isDown) {\n    velocityY = 1;\n  }\n  if (keys.a.isDown) {\n    velocityX = -1;\n  }\n  if (keys.d.isDown) {\n    velocityX = 1;\n  }\n  \n  // 如果有移动，归一化向量并应用速度\n  if (velocityX !== 0 || velocityY !== 0) {\n    const velocity = new Phaser.Math.Vector2(velocityX, velocityY);\n    velocity.normalize();\n    \n    diamond.x += velocity.x * distance;\n    diamond.y += velocity.y * distance;\n  }\n  \n  // 限制菱形在屏幕范围内\n  diamond.x = Phaser.Math.Clamp(diamond.x, 32, 768);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 32, 568);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000236_v3", "prompt_id": "seed_000236", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让红色三角形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个红色三角形，使用 Tween 动画在 4 秒内完成 360 度旋转并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制红色三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 配置动画持续时间 4000ms，设置 repeat: -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (60, 60)，半径约 50\n  graphics.beginPath();\n  graphics.moveTo(60, 10);  // 顶点\n  graphics.lineTo(110, 100); // 右下角\n  graphics.lineTo(10, 100);  // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 120, 120);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置精灵的原点为中心（默认已经是 0.5, 0.5）\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    angle: 360,                  // 旋转到 360 度\n    duration: 4000,              // 持续时间 4 秒\n    ease: 'Linear',              // 线性缓动，匀速旋转\n    repeat: -1,                  // 无限循环 (-1 表示永远重复)\n    yoyo: false                  // 不需要来回播放\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '红色三角形旋转动画 (4秒/圈)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000221_v1", "prompt_id": "seed_000221", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Scene.physics, Arcade.Body.setBounce, Arcade.Body.setCollideWorldBounds, Arcade.Body.setVelocity\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建物理精灵并应用三角形纹理\n3. 设置初始速度为160（x和y方向各约113，使合速度为160）\n4. 启用世界边界碰撞和反弹系数为1\n5. 在 update 中保持速度恒定为160\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#ffffff'\n};\n\nlet triangle;\nconst SPEED = 160;\n\nfunction preload() {\n  // 预加载阶段（无需外部资源）\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制一个等边三角形（中心在32,32）\n  graphics.fillTriangle(\n    32, 10,   // 顶点\n    10, 54,   // 左下\n    54, 54    // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  triangle = this.physics.add.sprite(400, 300, 'triangleTexture');\n  \n  // 设置世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 设置初始速度（45度角方向，速度大小为160）\n  const angle = Math.PI / 4; // 45度\n  const vx = Math.cos(angle) * SPEED;\n  const vy = Math.sin(angle) * SPEED;\n  triangle.setVelocity(vx, vy);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为160\n  const body = triangle.body;\n  const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - SPEED) > 0.1) {\n    // 归一化速度并乘以目标速度\n    const scale = SPEED / currentSpeed;\n    body.velocity.x *= scale;\n    body.velocity.y *= scale;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000434_v3", "prompt_id": "seed_000434", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色圆形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色圆形以360速度移动并在画布边界反弹\nAPI: Graphics.fillCircle, Physics.Arcade, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色圆形并生成纹理\n3. 创建物理精灵并应用圆形纹理\n4. 设置初始速度为 360（斜向移动）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  \n  // 生成纹理\n  graphics.generateTexture('grayCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'grayCircle');\n  \n  // 设置速度 - 使用勾股定理使合速度约为 360\n  // 360 / sqrt(2) ≈ 254.56，这样 x 和 y 方向速度合成后约为 360\n  const speed = 360 / Math.sqrt(2);\n  circle.setVelocity(speed, speed);\n  \n  // 设置圆形碰撞体（更精确的碰撞检测）\n  circle.body.setCircle(25);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 本例中无需额外更新逻辑，物理系统自动处理\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000114_v1", "prompt_id": "seed_000114", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个橙色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 20 个橙色可复用对象，对象离开屏幕后自动回收并重新使用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 使用 Graphics 生成橙色圆形纹理\n2. 创建 Physics.Arcade.Group 作为对象池，设置 maxSize 为 20\n3. 配置对象池的 createCallback 和 removeCallback 实现对象的初始化和回收\n4. 在 create 中批量生成 20 个对象，设置随机位置和速度\n5. 在 update 中检测对象是否离开屏幕，离开则 kill 回收到对象池\n6. 定时从对象池中获取对象并重新激活，实现复用\n7. 添加状态变量追踪活跃对象数和回收次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;  // 当前活跃对象数\n    this.recycleCount = 0;  // 回收次数\n    this.spawnCount = 0;    // 生成次数\n  }\n\n  preload() {\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8C00, 1);  // 橙色\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('orangeCircle', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'orangeCircle',\n      maxSize: 20,\n      createCallback: (obj) => {\n        // 对象创建时的回调\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 初始化 20 个对象\n    for (let i = 0; i < 20; i++) {\n      this.spawnObject();\n    }\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 定时器：每 2 秒尝试重新激活一个对象\n    this.time.addEvent({\n      delay: 2000,\n      callback: this.respawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  spawnObject() {\n    // 从对象池获取或创建对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 随机位置（屏幕内）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      // 激活对象\n      obj.setPosition(x, y);\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 设置随机速度\n      const velocityX = Phaser.Math.Between(-200, 200);\n      const velocityY = Phaser.Math.Between(-200, 200);\n      obj.setVelocity(velocityX, velocityY);\n      \n      // 设置边界反弹\n      obj.setBounce(1, 1);\n      obj.setCollideWorldBounds(false);  // 不反弹，离开屏幕后回收\n      \n      this.spawnCount++;\n      this.updateActiveCount();\n    }\n  }\n\n  respawnObject() {\n    // 尝试从对象池中获取一个未激活的对象并重新激活\n    const inactiveObjects = this.objectPool.getChildren().filter(obj => !obj.active);\n    \n    if (inactiveObjects.length > 0) {\n      const obj = inactiveObjects[0];\n      \n      // 随机新位置\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      obj.setPosition(x, y);\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 新的随机速度\n      const velocityX = Phaser.Math.Between(-200, 200);\n      const velocityY = Phaser.Math.Between(-200, 200);\n      obj.setVelocity(velocityX, velocityY);\n      \n      this.spawnCount++;\n      this.updateActiveCount();\n    }\n  }\n\n  recycleObject(obj) {\n    // 回收对象到对象池\n    obj.setActive(false);\n    obj.setVisible(false);\n    obj.setVelocity(0, 0);\n    \n    this.recycleCount++;\n    this.updateActiveCount();\n  }\n\n  updateActiveCount() {\n    // 更新活跃对象计数\n    this.activeCount = this.objectPool.getChildren().filter(obj => obj.active).length;\n  }\n\n  updateStatus() {\n    // 更新状态文本\n    const poolSize = this.objectPool.getLength();\n    const text = [\n      `Pool Size: ${poolSize}/20`,\n      `Active Objects: ${this.activeCount}`,\n      `Recycled: ${this.recycleCount}`,\n      `Total Spawned: ${this.spawnCount}`\n    ].join('\\n');\n    \n    this.statusText.setText(text);\n  }\n\n  update(time, delta) {\n    // 检查所有活跃对象是否离开屏幕\n    this.objectPool.getChildren().forEach(obj => {\n      if (obj.active) {\n        // 检查是否完全离开屏幕（包含对象大小）\n        const margin = 50;\n        if (obj.x < -margin || obj.x > 800 + margin || \n            obj.y < -margin || obj.y > 600 + margin) {\n          this.recycleObject(obj);\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000939_v1", "prompt_id": "seed_000939", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 5 个紫色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，玩家碰撞紫色物体后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，使用 arcade 物理引擎\n2. 使用 Graphics 生成玩家和收集物纹理（玩家绿色方块，收集物紫色圆形）\n3. 创建玩家精灵和收集物物理组，随机分布 5 个收集物\n4. 添加键盘控制让玩家可以移动（方向键）\n5. 使用 overlap 检测玩家与收集物碰撞，碰撞后移除收集物并增加分数\n6. 创建文本对象显示当前分数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建玩家纹理（绿色方块）\n  const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 使用 Graphics 创建收集物纹理（紫色圆形）\n  const collectibleGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  collectibleGraphics.fillStyle(0x9d4edd, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物物理组\n  collectibles = this.physics.add.group();\n\n  // 随机生成 5 个收集物\n  for (let i = 0; i < 5; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    // 添加轻微的随机速度让收集物移动\n    collectible.setVelocity(\n      Phaser.Math.Between(-50, 50),\n      Phaser.Math.Between(-50, 50)\n    );\n    collectible.setBounce(1); // 碰到边界反弹\n  }\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加玩家与收集物的重叠检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\n// 收集物品回调函数\nfunction collectItem(player, collectible) {\n  // 移除收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 如果所有收集物都被收集，显示胜利信息\n  if (collectibles.countActive(true) === 0) {\n    const winText = this.add.text(400, 300, 'YOU WIN!', {\n      fontSize: '64px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n    winText.setOrigin(0.5);\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000849_v1", "prompt_id": "seed_000849", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个自动向右下移动的菱形，相机跟随并保持居中\nAPI: Graphics, Camera.startFollow, Camera.setZoom, Sprite, Physics\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建物理精灵对象并设置速度向右下移动\n3. 设置相机跟随该精灵对象\n4. 在 update 中保持物体持续移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet diamond;\nlet camera;\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（四个三角形组成）\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使菱形更明显\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个大的世界边界，让物体有足够的移动空间\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 创建菱形精灵，初始位置在世界中心\n  diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置菱形向右下方移动的速度\n  diamond.setVelocity(150, 150);\n  \n  // 设置菱形在世界边界内碰撞反弹\n  diamond.setCollideWorldBounds(true);\n  diamond.setBounce(1, 1);\n  \n  // 获取主相机\n  camera = this.cameras.main;\n  \n  // 设置相机边界与世界边界一致\n  camera.setBounds(0, 0, 3000, 3000);\n  \n  // 相机跟随菱形，保持居中\n  // 参数：目标对象, 是否圆滑跟随（默认false表示紧密跟随）, 跟随速度（1表示立即跟随）\n  camera.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 可选：设置相机缩放以获得更好的视野\n  // camera.setZoom(1);\n  \n  // 添加网格背景以更好地观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.lineTo(x, 0);\n    graphics.lineTo(x, 3000);\n    graphics.moveTo(x + 100, 0);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(3000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加中心参考点（在菱形初始位置）\n  const centerDot = this.add.graphics();\n  centerDot.fillStyle(0x00ff00, 1);\n  centerDot.fillCircle(400, 300, 5);\n  \n  // 添加说明文字（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随菱形移动\\n菱形会在世界边界反弹', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 可选：在这里添加额外的更新逻辑\n  // 例如：根据输入改变菱形速度等\n  \n  // 显示当前菱形位置（用于调试）\n  // console.log(`Diamond position: (${diamond.x.toFixed(0)}, ${diamond.y.toFixed(0)})`);\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000574_v1", "prompt_id": "seed_000574", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9400000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按WASD键发射白色子弹的例子，子弹速度 300，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现按WASD键发射白色子弹，速度300，离开边界自动回收到对象池\nAPI: this.input.keyboard.addKey(), this.physics.add.group(), Graphics.generateTexture(), Physics.Arcade.Group\nSTEPS:\n1. 创建物理引擎配置，启用 arcade 物理系统\n2. 使用 Graphics 生成白色子弹纹理\n3. 创建物理对象池 Group，配置子弹回收逻辑\n4. 监听 WASD 键盘输入事件\n5. 根据按键方向从对象池获取子弹并设置速度\n6. 在 update 中检测子弹是否离开边界并回收\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用 Graphics 生成白色子弹纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(8, 8, 8);\n    graphics.generateTexture('bullet', 16, 16);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池（Group）\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50, // 对象池最大容量\n      runChildUpdate: false\n    });\n\n    // 创建玩家（用于发射子弹的中心点）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    this.player = this.add.sprite(400, 300, 'player');\n\n    // 设置 WASD 键盘输入\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 添加按键按下事件监听\n    this.keyW.on('down', () => this.fireBullet(0, -1)); // 向上\n    this.keyA.on('down', () => this.fireBullet(-1, 0)); // 向左\n    this.keyS.on('down', () => this.fireBullet(0, 1));  // 向下\n    this.keyD.on('down', () => this.fireBullet(1, 0));  // 向右\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, 'Bullets Fired: 0', {\n      fontSize: '18px',\n      fill: '#ffffff'\n    });\n  }\n\n  fireBullet(dirX, dirY) {\n    // 从对象池获取子弹（如果池中没有可用对象，会自动创建）\n    const bullet = this.bullets.get(this.player.x, this.player.y);\n\n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n\n      // 设置子弹速度（速度 300）\n      bullet.body.setVelocity(dirX * 300, dirY * 300);\n\n      // 更新发射计数\n      this.bulletsFired++;\n      this.statusText.setText(`Bullets Fired: ${this.bulletsFired}`);\n    }\n  }\n\n  update(time, delta) {\n    // 检查所有活跃的子弹\n    this.bullets.getChildren().forEach((bullet) => {\n      if (bullet.active) {\n        // 检测子弹是否离开边界\n        if (\n          bullet.x < -20 ||\n          bullet.x > 820 ||\n          bullet.y < -20 ||\n          bullet.y > 620\n        ) {\n          // 回收子弹到对象池\n          this.bullets.killAndHide(bullet);\n          bullet.body.setVelocity(0, 0);\n        }\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000921_v3", "prompt_id": "seed_000921", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的椭圆在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的椭圆对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 创建 Graphics 绘制椭圆并生成纹理\n2. 创建 Sprite 对象使用椭圆纹理，启用物理引擎\n3. 设置椭圆向上移动的速度\n4. 使用相机的 startFollow 方法跟随椭圆对象\n5. 扩大世界边界以允许椭圆持续向上移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 扩大世界边界，允许对象向上移动\n  this.physics.world.setBounds(0, -5000, 800, 6000);\n  \n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(30, 30, 60, 40); // 中心点(30,30)，宽60，高40\n  graphics.generateTexture('ellipseTex', 60, 60);\n  graphics.destroy();\n  \n  // 创建椭圆精灵对象，启用物理引擎\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  ellipse.setCollideWorldBounds(false); // 不与世界边界碰撞\n  \n  // 设置椭圆向上移动的速度（负Y方向）\n  ellipse.setVelocity(0, -150);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, -5000, 800, 6000);\n  \n  // 相机跟随椭圆对象，保持居中\n  this.cameras.main.startFollow(ellipse, true, 0.1, 0.1);\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '椭圆自动向上移动\\n相机跟随并保持居中', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图上\n  \n  // 添加参考网格（用于观察移动效果）\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 800; x += 100) {\n    gridGraphics.moveTo(x, -5000);\n    gridGraphics.lineTo(x, 1000);\n  }\n  \n  // 绘制水平线\n  for (let y = -5000; y <= 1000; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(800, y);\n  }\n  \n  gridGraphics.strokePath();\n}\n\nfunction update(time, delta) {\n  // 椭圆已经通过物理引擎自动移动，无需额外更新\n  // 相机自动跟随，无需手动调整\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000569_v2", "prompt_id": "seed_000569", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色方块以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带物理引擎的游戏配置，启用 arcade 物理系统\n2. 使用 Graphics 生成粉色方块纹理\n3. 创建物理精灵并设置速度为200\n4. 设置精灵与世界边界碰撞并反弹\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet velocity = { x: 200, y: 200 };\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 生成粉色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('pinkSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'pinkSquare');\n  \n  // 设置初始速度\n  square.setVelocity(velocity.x, velocity.y);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // arcade 物理引擎的 collideWorldBounds 和 bounce 会自动处理反弹\n  // 无需手动编写边界检测代码\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000721_v1", "prompt_id": "seed_000721", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的圆形对象\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 使用 Graphics 绘制圆形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 使用物理系统让圆形自动向右下移动\n4. 调用 camera.startFollow 让相机跟随圆形对象\n5. 扩大世界边界以容纳移动范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\n\nfunction preload() {\n  // 使用 Graphics 创建圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 扩大世界边界，允许对象移动到更大的范围\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 创建玩家对象（圆形）\n  player = this.physics.add.sprite(400, 300, 'circle');\n  \n  // 设置圆形向右下方移动的速度\n  player.setVelocity(150, 150);\n  \n  // 设置对象在世界边界内碰撞反弹\n  player.setCollideWorldBounds(true);\n  player.setBounce(1, 1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3000, 3000);\n  \n  // 相机跟随玩家对象，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 添加背景网格以便观察相机移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    gridGraphics.moveTo(x, 0);\n    gridGraphics.lineTo(x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(3000, y);\n  }\n  gridGraphics.strokePath();\n  \n  // 添加文字提示\n  const text = this.add.text(16, 16, '相机跟随圆形移动', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 固定文字在相机视图中\n  text.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 当前物理系统会自动处理圆形的移动和碰撞\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000437_v3", "prompt_id": "seed_000437", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右侧显示 \"Hello Phaser\" 文字，字体大小 16 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字内容为 \"Hello Phaser\"，字体大小 16px\n4. 将文字定位到屏幕右侧（x 坐标接近画布宽度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建文字对象，位置在屏幕右侧\n  const text = this.add.text(650, 300, 'Hello Phaser', {\n    fontSize: '16px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字的原点为中心，使其垂直居中\n  text.setOrigin(0, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000039_v2", "prompt_id": "seed_000039", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在2.5秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用生成的六边形纹理\n3. 使用 Tween 实现缩放动画（scale 从 1 到 0.48 再到 1）\n4. 设置 Tween 循环播放（loop: -1）和持续时间（2500ms）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // yoyo: true 表示动画会反向播放（缩小后再放大）\n  // duration: 2500 表示单程2.5秒，完整循环5秒\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 2500,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '六边形缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '循环播放：1.0 → 0.48 → 1.0', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000166_v1", "prompt_id": "seed_000166", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色圆形以300速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制蓝色圆形纹理\n3. 创建物理精灵并设置初始速度为300\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillCircle(25, 25, 25); // 半径25的圆形\n  graphics.generateTexture('blueCircle', 50, 50);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 创建物理精灵，位置在画布中心\n  const ball = this.physics.add.sprite(400, 300, 'blueCircle');\n\n  // 设置初始速度（斜向移动，速度大小约为300）\n  // 使用勾股定理：sqrt(x^2 + y^2) ≈ 300\n  // 取 x=212, y=212，则 sqrt(212^2 + 212^2) ≈ 300\n  ball.setVelocity(212, 212);\n\n  // 启用世界边界碰撞\n  ball.setCollideWorldBounds(true);\n\n  // 设置反弹系数为1，实现完美反弹\n  ball.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000184_v1", "prompt_id": "seed_000184", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setAlpha\nSTEPS:\n1. 使用 Graphics 绘制六边形路径并填充颜色\n2. 将 Graphics 转换为纹理以便应用 alpha 动画\n3. 创建 Sprite 使用生成的六边形纹理\n4. 使用 Tween 动画控制 Sprite 的 alpha 属性从 0 到 1\n5. 设置 Tween 为循环模式，持续时间 2 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100; // 临时中心点用于绘制\n  const centerY = 100;\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制六边形路径\n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('hexagon', hexRadius * 2 + 20, hexRadius * 2 + 20);\n  \n  // 销毁 Graphics 对象（已生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 在场景中心创建六边形 Sprite\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 初始设置为完全透明\n  hexSprite.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: hexSprite,\n    alpha: 1, // 目标 alpha 值\n    duration: 2000, // 持续时间 2 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（透明->不透明->透明）\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Hexagon fading animation (2s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000180_v1", "prompt_id": "seed_000180", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (30, 30)，三角形顶点向上\n  graphics.beginPath();\n  graphics.moveTo(30, 10);  // 顶点\n  graphics.lineTo(10, 50);  // 左下角\n  graphics.lineTo(50, 50);  // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 60);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 500,               // 持续时间 0.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    repeat: -1                   // 无限循环（-1 表示永远重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000416_v2", "prompt_id": "seed_000416", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 启用世界边界碰撞和反弹\n5. 设置精灵与世界边界碰撞\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制椭圆（中心点在 40, 30，半径为 40x30）\n  graphics.fillEllipse(40, 30, 80, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（速度为200，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 200;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 200;\n  ellipse.setVelocity(velocityX, velocityY);\n  \n  // 启用与世界边界的碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 确保世界边界碰撞已启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000081_v3", "prompt_id": "seed_000081", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 160，重力 500。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次，跳跃力度160，重力500\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 创建带物理系统的场景配置，设置重力为500\n2. 使用Graphics生成角色和地面的纹理\n3. 创建物理精灵角色，添加键盘输入监听\n4. 实现双跳逻辑：记录跳跃次数，空中可跳第二次，落地重置\n5. 添加状态信号变量显示当前跳跃次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#87CEEB'\n};\n\nlet player;\nlet ground;\nlet cursors;\nlet jumpKey;\nlet jumpCount = 0; // 当前跳跃次数\nconst MAX_JUMPS = 2; // 最大跳跃次数\nconst JUMP_VELOCITY = -160; // 跳跃速度（负值向上）\nlet statusText;\n\nfunction preload() {\n  // 创建角色纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x0066FF, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建地面纹理（绿色长方形）\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x228B22, 1);\n  groundGraphics.fillRect(0, 0, 800, 100);\n  groundGraphics.generateTexture('ground', 800, 100);\n  groundGraphics.destroy();\n\n  // 创建平台纹理（棕色）\n  const platformGraphics = this.add.graphics();\n  platformGraphics.fillStyle(0x8B4513, 1);\n  platformGraphics.fillRect(0, 0, 200, 20);\n  platformGraphics.generateTexture('platform', 200, 20);\n  platformGraphics.destroy();\n}\n\nfunction create() {\n  // 创建地面\n  ground = this.physics.add.staticSprite(400, 575, 'ground');\n  ground.setOrigin(0.5, 0.5);\n  ground.refreshBody();\n\n  // 创建几个平台用于测试双跳\n  const platform1 = this.physics.add.staticSprite(200, 400, 'platform');\n  const platform2 = this.physics.add.staticSprite(600, 300, 'platform');\n  \n  // 创建平台组\n  const platforms = this.physics.add.staticGroup();\n  platforms.add(ground);\n  platforms.add(platform1);\n  platforms.add(platform2);\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 450, 'player');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 添加玩家与平台的碰撞\n  this.physics.add.collider(player, platforms, () => {\n    // 当玩家接触地面时，重置跳跃次数\n    if (player.body.touching.down) {\n      jumpCount = 0;\n    }\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 创建状态显示文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(16, 50, '控制说明:\\n← → 移动\\n↑ 或 空格 跳跃\\n可以在空中跳第二次', {\n    fontSize: '16px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 初始化跳跃次数\n  jumpCount = 0;\n}\n\nfunction update() {\n  // 左右移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-200);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(200);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 双跳逻辑\n  if (Phaser.Input.Keyboard.JustDown(cursors.up) || Phaser.Input.Keyboard.JustDown(jumpKey)) {\n    // 检查是否可以跳跃（跳跃次数未达上限）\n    if (jumpCount < MAX_JUMPS) {\n      player.setVelocityY(JUMP_VELOCITY);\n      jumpCount++;\n    }\n  }\n\n  // 检测玩家是否在地面上，如果在地面且之前跳过，重置跳跃次数\n  if (player.body.touching.down && player.body.velocity.y === 0) {\n    if (jumpCount > 0) {\n      jumpCount = 0;\n    }\n  }\n\n  // 更新状态显示\n  const onGround = player.body.touching.down ? '是' : '否';\n  const canJump = jumpCount < MAX_JUMPS ? '是' : '否';\n  statusText.setText(\n    `跳跃次数: ${jumpCount}/${MAX_JUMPS}\\n` +\n    `在地面: ${onGround}\\n` +\n    `可跳跃: ${canJump}\\n` +\n    `Y速度: ${Math.round(player.body.velocity.y)}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000957_v3", "prompt_id": "seed_000957", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色星形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色星形并生成纹理\n2. 创建星形精灵并定位到左侧起点\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  const drawStar = (graphics, cx, cy, spikes, outerRadius, innerRadius, color) => {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.fillStyle(color, 1);\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillPath();\n  };\n\n  // 绘制橙色星形（中心在 50, 50，用于生成纹理）\n  drawStar(graphics, 50, 50, 5, 40, 20, 0xFF8C00);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n\n  // 创建星形精灵\n  const star = this.add.sprite(100, 300, 'star');\n\n  // 创建补间动画：从左到右，然后往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5秒\n    ease: 'Linear',\n    yoyo: true, // 启用往返效果\n    repeat: -1 // 无限循环\n  });\n\n  // 添加说明文字\n  this.add.text(400, 50, '橙色星形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000566_v3", "prompt_id": "seed_000566", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色星形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色星形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的五个外顶点和五个内顶点坐标（使用三角函数）\n4. 使用 Graphics API 绘制星形路径并填充白色\n5. 将星形定位在画布中央（400, 300）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 星形参数\n  const centerX = 400;  // 画布中央 X 坐标\n  const centerY = 300;  // 画布中央 Y 坐标\n  const outerRadius = 24;  // 外半径（星形尖端到中心的距离）\n  const innerRadius = 12;  // 内半径（星形凹陷点到中心的距离）\n  const points = 5;  // 五角星\n  \n  // 设置填充颜色为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算星形的顶点坐标\n  for (let i = 0; i < points * 2; i++) {\n    // 每个点的角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000155_v3", "prompt_id": "seed_000155", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的圆形对象并保持居中\nAPI: Graphics#fillCircle, Graphics#generateTexture, Physics.add.sprite, Camera#startFollow, Sprite#setVelocityX\nSTEPS:\n1. 使用 Graphics 绘制圆形并生成纹理\n2. 创建物理精灵对象并设置向右移动的速度\n3. 配置相机跟随该精灵对象并保持居中\n4. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 1. 使用 Graphics 创建圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();\n\n  // 2. 创建背景网格以便观察相机移动\n  createGrid.call(this);\n\n  // 3. 创建可移动的圆形精灵\n  this.player = this.physics.add.sprite(400, 300, 'circle');\n  this.player.setCollideWorldBounds(false); // 允许移出世界边界\n\n  // 4. 设置自动向右移动\n  this.player.setVelocityX(150);\n\n  // 5. 设置相机跟随\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 可选：设置相机边界（如果需要限制相机移动范围）\n  // this.cameras.main.setBounds(0, 0, 2000, 600);\n\n  // 6. 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随圆形移动', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 例如：当圆形移动到一定距离后改变方向\n}\n\n// 辅助函数：创建背景网格\nfunction createGrid() {\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n\n  // 绘制垂直线\n  for (let x = 0; x < 3000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 600);\n  }\n\n  // 绘制水平线\n  for (let y = 0; y < 600; y += 100) {\n    gridGraphics.lineBetween(0, y, 3000, y);\n  }\n\n  // 添加位置标记\n  const style = { fontSize: '14px', color: '#666666' };\n  for (let x = 0; x < 3000; x += 200) {\n    this.add.text(x + 5, 5, `x:${x}`, style);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000010_v2", "prompt_id": "seed_000010", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个橙色物体以 200 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 10个橙色物体以200速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity, setCollideWorldBounds\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成橙色圆形纹理\n3. 创建物理组，添加 10 个橙色物体\n4. 为每个物体设置随机速度（200）和完全反弹\n5. 设置物体间碰撞检测和世界边界碰撞\n6. 添加状态变量记录碰撞次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff8800, 1); // 橙色\n    graphics.fillCircle(20, 20, 20); // 半径20的圆\n    graphics.generateTexture('orangeCircle', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.orangeGroup = this.physics.add.group({\n      defaultKey: 'orangeCircle',\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 创建10个橙色物体\n    for (let i = 0; i < 10; i++) {\n      // 随机位置（避免边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      const orangeObj = this.orangeGroup.create(x, y, 'orangeCircle');\n      \n      // 设置随机方向的速度，总速度为200\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 200;\n      const velocityY = Math.sin(angle) * 200;\n      \n      orangeObj.setVelocity(velocityX, velocityY);\n      orangeObj.setBounce(1, 1); // 完全反弹\n      orangeObj.setCollideWorldBounds(true);\n      orangeObj.setCircle(20); // 设置圆形碰撞体\n    }\n\n    // 设置物体间的碰撞检测\n    this.physics.add.collider(\n      this.orangeGroup,\n      this.orangeGroup,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 显示碰撞计数（用于验证）\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n  }\n\n  handleCollision(obj1, obj2) {\n    // 记录碰撞次数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保物体速度保持在200左右（由于浮点误差可能会有微小变化）\n    this.orangeGroup.children.entries.forEach(obj => {\n      const currentSpeed = Math.sqrt(obj.body.velocity.x ** 2 + obj.body.velocity.y ** 2);\n      \n      // 如果速度偏离200太多，重新标准化\n      if (Math.abs(currentSpeed - 200) > 5) {\n        const angle = Math.atan2(obj.body.velocity.y, obj.body.velocity.x);\n        obj.setVelocity(Math.cos(angle) * 200, Math.sin(angle) * 200);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000937_v3", "prompt_id": "seed_000937", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的三角形并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象并应用三角形纹理\n3. 设置 Sprite 向右移动的速度\n4. 使用相机的 startFollow 方法跟随 Sprite 对象\n5. 在 update 中持续更新 Sprite 位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet triangle;\nlet speed = 2; // 每帧移动的像素\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向右侧的三角形\n  graphics.beginPath();\n  graphics.moveTo(0, -20);    // 顶点\n  graphics.lineTo(-15, 20);   // 左下角\n  graphics.lineTo(15, 20);    // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 30, 40);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建三角形 Sprite，初始位置在场景中央\n  triangle = this.add.sprite(400, 300, 'triangleTexture');\n  \n  // 设置相机跟随三角形\n  // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n  // roundPixels: 是否四舍五入像素以避免抖动\n  // lerpX/lerpY: 插值系数（0-1），值越小跟随越平滑\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 设置相机边界，使其可以跟随到更远的地方\n  this.cameras.main.setBounds(0, 0, 5000, 600);\n  \n  // 添加一些参考物体来显示移动效果\n  for (let i = 0; i < 50; i++) {\n    const x = i * 100;\n    const rect = this.add.graphics();\n    rect.lineStyle(2, 0xffffff, 0.3);\n    rect.strokeRect(x, 250, 50, 100);\n  }\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '三角形自动向右移动，相机跟随', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让三角形持续向右移动\n  triangle.x += speed;\n  \n  // 可选：当三角形移动到很远时重置位置（演示用）\n  if (triangle.x > 4500) {\n    triangle.x = 400;\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000480_v1", "prompt_id": "seed_000480", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色矩形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色矩形在4秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制蓝色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add() 创建补间动画，设置目标 x 坐标为右侧\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n5. 设置 duration: 4000 控制单程时间为4秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillRect(0, 0, 80, 60); // 绘制矩形\n  \n  // 生成纹理\n  graphics.generateTexture('blueRect', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建精灵对象\n  const rect = this.add.sprite(100, 300, 'blueRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（右侧位置）\n    duration: 4000,          // 单程持续时间 4 秒\n    yoyo: true,              // 启用往返效果（到达目标后反向返回）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, '蓝色矩形往返循环移动（4秒/单程）', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000186_v2", "prompt_id": "seed_000186", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个六边形并以每秒200度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Graphics.generateTexture, Scene.add.sprite, GameObject.rotation\nSTEPS:\n1. 使用 Graphics 绘制六边形路径并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 在 update 方法中根据 delta 时间累加旋转角度（200度/秒 = 200 * Math.PI / 180 弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形\n  const hexRadius = 60; // 六边形半径\n  const centerX = 64; // 纹理中心X\n  const centerY = 64; // 纹理中心Y\n  \n  // 开始路径\n  graphics.beginPath();\n  \n  // 绘制六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每60度一个顶点，从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径并填充\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使六边形更明显\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 128, 128);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建六边形精灵并放置在屏幕中心\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始旋转角度为0\n  hexagon.rotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转200度\n  // delta 是毫秒，需要转换为秒\n  // 200度 = 200 * (Math.PI / 180) 弧度\n  const rotationSpeed = 200 * (Math.PI / 180); // 弧度/秒\n  const deltaSeconds = delta / 1000; // 转换为秒\n  \n  // 累加旋转角度\n  hexagon.rotation += rotationSpeed * deltaSeconds;\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000210_v3", "prompt_id": "seed_000210", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色矩形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色矩形以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成橙色矩形纹理\n3. 创建物理精灵并设置速度\n4. 设置世界边界碰撞和反弹系数\n5. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet rectangle;\nlet velocityX = 200;\nlet velocityY = 200;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建橙色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillRect(0, 0, 60, 40);\n  graphics.generateTexture('orangeRect', 60, 40);\n  graphics.destroy();\n\n  // 创建物理精灵\n  rectangle = this.physics.add.sprite(400, 300, 'orangeRect');\n  \n  // 设置初始速度\n  rectangle.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  rectangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数\n  rectangle.setBounce(1, 1);\n  \n  // 确保物理体大小与纹理匹配\n  rectangle.body.setSize(60, 40);\n}\n\nfunction update(time, delta) {\n  // Arcade 物理系统的 bounce 和 collideWorldBounds 会自动处理反弹\n  // 不需要手动检测边界\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000311_v2", "prompt_id": "seed_000311", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 8 个蓝色敌人巡逻移动，在 160 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 8个蓝色敌人在场景中左右巡逻，玩家靠近时切换为追踪模式\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建玩家和敌人的纹理（使用Graphics绘制蓝色方块和绿色圆形）\n2. 初始化玩家精灵并设置键盘控制\n3. 创建8个敌人物理精灵组，随机分布在场景中\n4. 为每个敌人设置初始巡逻方向和速度（160）\n5. 在update中检测玩家与敌人距离，近距离时切换为追踪模式，远距离恢复巡逻\n6. 添加边界碰撞检测，敌人触碰边界时反向移动\n7. 维护enemiesPatrolling和enemiesChasing状态变量用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n    this.detectionRange = 150; // 检测范围\n    this.patrolSpeed = 160;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色圆形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 生成8个敌人，分布在场景不同位置\n    const positions = [\n      { x: 100, y: 100 },\n      { x: 700, y: 100 },\n      { x: 100, y: 500 },\n      { x: 700, y: 500 },\n      { x: 400, y: 150 },\n      { x: 200, y: 300 },\n      { x: 600, y: 300 },\n      { x: 400, y: 450 }\n    ];\n\n    positions.forEach((pos, index) => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 设置初始巡逻方向（随机左右）\n      enemy.patrolDirection = Math.random() > 0.5 ? 1 : -1;\n      enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n      \n      // 标记状态\n      enemy.isChasing = false;\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加说明文本\n    this.add.text(10, 10, 'Arrow keys to move\\nEnemies patrol and chase when near', {\n      fontSize: '16px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 状态显示\n    this.statusText = this.add.text(10, 70, '', {\n      fontSize: '14px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 初始化状态\n    this.enemiesPatrolling = 8;\n    this.enemiesChasing = 0;\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 重置状态计数\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, this.player.y,\n        enemy.x, enemy.y\n      );\n\n      // 判断是否应该追踪玩家\n      if (distance < this.detectionRange) {\n        // 追踪模式\n        if (!enemy.isChasing) {\n          enemy.isChasing = true;\n        }\n\n        // 计算追踪方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        this.physics.velocityFromRotation(angle, this.patrolSpeed, enemy.body.velocity);\n        this.enemiesChasing++;\n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          enemy.isChasing = false;\n          // 恢复巡逻速度\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        // 检测边界碰撞，反向移动\n        if (enemy.body.blocked.left || enemy.body.blocked.right) {\n          enemy.patrolDirection *= -1;\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        this.enemiesPatrolling++;\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText(\n      `Patrolling: ${this.enemiesPatrolling}\\n` +\n      `Chasing: ${this.enemiesChasing}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000974_v3", "prompt_id": "seed_000974", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 0.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形，使用 Tween 动画在 0.5 秒内缩放到 64%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 创建 Game 配置和 Scene\n2. 在 create 中使用 Graphics 绘制星形或使用 Star GameObject\n3. 创建 Tween 动画，设置 scale 从 1 到 0.64，duration 为 500ms\n4. 设置 yoyo 为 true 实现来回缩放效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 方法1: 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色星形\n  graphics.lineStyle(2, 0xffa500, 1); // 橙色描边\n  \n  // 绘制五角星\n  const centerX = 400;\n  const centerY = 300;\n  const outerRadius = 60;\n  const innerRadius = 25;\n  const points = 5;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 方法2: 使用 Phaser 内置的 Star GameObject（更简洁）\n  const star = this.add.star(400, 300, 5, 25, 60, 0xffff00);\n  star.setStrokeStyle(2, 0xffa500);\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.64,  // 缩放到 64%\n    scaleY: 0.64,\n    duration: 500,  // 0.5 秒\n    yoyo: true,     // 来回播放（缩小后再放大）\n    loop: -1,       // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Star scaling animation (64% - 100% loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000364_v1", "prompt_id": "seed_000364", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块移动，速度为 80 像素/秒\nAPI: this.add.graphics(), this.input.keyboard.addKeys(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制方块并生成纹理\n2. 创建精灵对象并应用纹理\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态和 delta 时间计算移动距离\n5. 更新方块位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家精灵，放置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n\n  // 设置 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算每帧移动的距离\n  const moveDistance = SPEED * deltaSeconds;\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 检查 WASD 键状态并设置速度\n  if (keys.w.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.s.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.a.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.d.isDown) {\n    velocityX = 1; // 向右\n  }\n\n  // 归一化对角线移动速度（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n\n  // 更新玩家位置\n  player.x += velocityX * moveDistance;\n  player.y += velocityY * moveDistance;\n\n  // 限制在屏幕范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000035_v3", "prompt_id": "seed_000035", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色方块以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色方块以80速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制红色方块并生成纹理\n3. 创建物理精灵并设置初始速度为 80\n4. 设置精灵与世界边界碰撞并反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nconst SPEED = 80;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('redSquare', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'redSquare');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const velocityX = Math.cos(angle) * SPEED;\n  const velocityY = Math.sin(angle) * SPEED;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（防止因碰撞导致速度衰减）\n  const velocity = square.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed !== 0) {\n    const scale = SPEED / currentSpeed;\n    square.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000470_v1", "prompt_id": "seed_000470", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色椭圆在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色椭圆4秒左右往返循环补间动画\nAPI: this.add.graphics, graphics.fillEllipse, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制紫色椭圆\n2. 创建补间动画，设置 x 坐标从左到右移动，持续 4 秒\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制紫色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillEllipse(0, 0, 80, 50); // 在中心点绘制椭圆，宽80高50\n  \n  // 将 graphics 转换为纹理以便用于精灵\n  graphics.generateTexture('ellipse', 80, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建椭圆精灵\n  const ellipse = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipse,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 4000, // 持续 4 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 往返效果\n    repeat: -1 // 无限循环（-1 表示永远重复）\n  });\n  \n  // 添加文字提示\n  this.add.text(300, 50, '紫色椭圆往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000709_v1", "prompt_id": "seed_000709", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建场景并使用 Graphics 绘制菱形形状生成纹理\n2. 创建菱形精灵对象并设置初始位置\n3. 在 update 中让菱形持续向上移动\n4. 使用主相机的 startFollow 方法让相机跟随菱形对象\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst MOVE_SPEED = 100; // 每秒向上移动的像素数\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  createBackgroundGrid.call(this);\n  \n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形精灵对象，初始位置在场景中心下方\n  diamond = this.add.sprite(400, 1000, 'diamond');\n  \n  // 设置相机跟随菱形对象\n  // 第二个参数为 roundPixels，设置为 true 可以避免抖动\n  // 第三个参数为 lerpX，第四个参数为 lerpY，控制跟随的平滑度（0-1之间，1为立即跟随）\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 设置相机边界（可选，让相机在更大的世界中移动）\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n  \n  // 添加提示文本（固定在相机上）\n  const instructionText = this.add.text(10, 10, 'Camera follows the diamond\\nDiamond moves upward automatically', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  instructionText.setScrollFactor(0); // 固定在相机上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让菱形向上移动（y 坐标减小）\n  diamond.y -= MOVE_SPEED * (delta / 1000);\n  \n  // 可选：当菱形移动到顶部时重置位置\n  if (diamond.y < -100) {\n    diamond.y = 3000;\n  }\n}\n\n// 辅助函数：创建背景网格\nfunction createBackgroundGrid() {\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 800; x += 100) {\n    gridGraphics.lineTo(x, 0);\n    gridGraphics.lineTo(x, 3000);\n    gridGraphics.moveTo(x + 100, 0);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 3000; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(800, y);\n  }\n  \n  gridGraphics.strokePath();\n  \n  // 添加坐标标记\n  for (let y = 0; y <= 3000; y += 200) {\n    const label = this.add.text(10, y, `Y: ${y}`, {\n      fontSize: '14px',\n      fill: '#888888'\n    });\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000197_v2", "prompt_id": "seed_000197", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8716666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色三角形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色三角形在3秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Sprite 对象应用三角形纹理\n3. 使用 tweens.add 创建 x 轴移动补间动画\n4. 设置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右，3秒完成，往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 3000,            // 持续时间 3 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永远重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000590_v2", "prompt_id": "seed_000590", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个青色物体以 80 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 10个青色物体以80速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Graphics.fillCircle, Physics.add.collider, setVelocity, setBounce\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 生成青色圆形纹理\n3. 创建物理组并添加 10 个物体\n4. 为每个物体设置随机速度（80）和反弹属性\n5. 添加物体间的碰撞检测\n6. 设置世界边界碰撞\n7. 添加碰撞计数器作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 碰撞计数器（验证信号）\n    this.activeObjects = 0; // 活跃物体数量（验证信号）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00FFFF, 1); // 青色\n    graphics.fillCircle(20, 20, 20); // 半径20的圆\n    graphics.generateTexture('cyanBall', 40, 40);\n    graphics.destroy();\n\n    // 创建物理组\n    this.objectGroup = this.physics.add.group({\n      key: 'cyanBall',\n      repeat: 9, // 创建10个物体（0-9）\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 设置每个物体的随机位置和速度\n    const objects = this.objectGroup.getChildren();\n    this.activeObjects = objects.length;\n\n    objects.forEach((obj, index) => {\n      // 随机位置\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      obj.setPosition(x, y);\n\n      // 随机方向，速度为80\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 80;\n      const velocityY = Math.sin(angle) * 80;\n      obj.setVelocity(velocityX, velocityY);\n\n      // 设置反弹系数\n      obj.setBounce(1, 1);\n    });\n\n    // 添加物体间的碰撞检测\n    this.physics.add.collider(\n      this.objectGroup,\n      this.objectGroup,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  handleCollision(obj1, obj2) {\n    // 碰撞回调，增加计数器\n    this.collisionCount++;\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Active Objects: ${this.activeObjects}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 80 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 更新状态显示\n    this.updateStatusText();\n\n    // 验证速度保持在80左右（考虑浮点误差）\n    const objects = this.objectGroup.getChildren();\n    objects.forEach(obj => {\n      const speed = Math.sqrt(obj.body.velocity.x ** 2 + obj.body.velocity.y ** 2);\n      \n      // 如果速度偏差过大，重新归一化到80\n      if (Math.abs(speed - 80) > 1) {\n        const normalizedVx = (obj.body.velocity.x / speed) * 80;\n        const normalizedVy = (obj.body.velocity.y / speed) * 80;\n        obj.setVelocity(normalizedVx, normalizedVy);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000983_v1", "prompt_id": "seed_000983", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色三角形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色三角形以240速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Scene\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建物理精灵并设置速度为240\n3. 启用世界边界碰撞和反弹\n4. 在 update 中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet velocity = { x: 240, y: 240 };\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形 (等边三角形)\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 顶点\n  graphics.lineTo(-26, 15);   // 左下\n  graphics.lineTo(26, 15);    // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 52, 45);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置初始速度 (使用勾股定理确保总速度为240)\n  // 240 / sqrt(2) ≈ 169.7\n  const speed = 240 / Math.sqrt(2);\n  triangle.setVelocity(speed, speed);\n  \n  // 启用世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  triangle.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // Arcade Physics 的 bounce 和 collideWorldBounds 会自动处理反弹\n  // 但为了确保速度恒定为240，我们需要手动处理\n  \n  const body = triangle.body;\n  \n  // 检测边界碰撞并反转速度\n  if (body.blocked.left || body.blocked.right) {\n    body.velocity.x *= -1;\n  }\n  \n  if (body.blocked.up || body.blocked.down) {\n    body.velocity.y *= -1;\n  }\n  \n  // 确保速度保持在240\n  const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n  if (currentSpeed > 0 && Math.abs(currentSpeed - 240) > 1) {\n    const scale = 240 / currentSpeed;\n    body.velocity.x *= scale;\n    body.velocity.y *= scale;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000256_v1", "prompt_id": "seed_000256", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9466666666666668}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的圆形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建 Graphics 对象绘制圆形作为玩家\n2. 使用 Graphics.generateTexture 生成可复用的纹理\n3. 创建 Sprite 对象使用生成的纹理\n4. 设置相机跟随该 Sprite 对象\n5. 在 update 中让对象持续向右下移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nconst MOVE_SPEED = 2; // 移动速度\n\nfunction preload() {\n  // 使用 Graphics 创建圆形纹理，无需外部资源\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.fillCircle(25, 25, 25); // 圆心在 (25, 25)，半径 25\n  graphics.generateTexture('playerCircle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个大的背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制网格线\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.lineBetween(x, 0, x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加坐标标记\n  const style = { fontSize: '16px', color: '#00ff00' };\n  for (let x = 0; x <= 3000; x += 500) {\n    for (let y = 0; y <= 3000; y += 500) {\n      this.add.text(x + 10, y + 10, `(${x},${y})`, style);\n    }\n  }\n  \n  // 创建玩家对象，初始位置在 (400, 300)\n  player = this.add.sprite(400, 300, 'playerCircle');\n  \n  // 设置世界边界，让场景足够大\n  this.cameras.main.setBounds(0, 0, 3000, 3000);\n  \n  // 相机跟随玩家对象，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 添加提示文字（固定在相机视图中）\n  const hint = this.add.text(10, 10, '圆形自动向右下移动\\n相机跟随并保持居中', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  hint.setScrollFactor(0); // 固定在相机视图中，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让玩家对象持续向右下移动\n  player.x += MOVE_SPEED;\n  player.y += MOVE_SPEED;\n  \n  // 限制在世界边界内\n  if (player.x > 3000) {\n    player.x = 3000;\n  }\n  if (player.y > 3000) {\n    player.y = 3000;\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000437_v2", "prompt_id": "seed_000437", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色星形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现橙色星形4秒左右往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 tweens.add 创建 x 轴移动补间动画，设置 duration 为 4000ms\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  function drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.fillStyle(color, 1);\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillPath();\n  }\n\n  // 绘制橙色星形（中心在 50, 50，外半径 40，内半径 20）\n  drawStar(graphics, 50, 50, 5, 40, 20, 0xFFA500);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n\n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n\n  // 创建补间动画：从左到右，4秒，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 4000, // 4秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环\n    ease: 'Linear' // 线性运动\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Orange Star Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000618_v1", "prompt_id": "seed_000618", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在0.5秒内从透明到不透明循环渐变\nAPI: this.add.graphics, this.tweens.add, Phaser.Game\nSTEPS:\n1. 创建 Graphics 对象绘制方块\n2. 使用 tweens 创建 alpha 属性动画，从0到1，持续500ms\n3. 设置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100); // 绘制 100x100 的方块\n  \n  // 设置方块位置到屏幕中心\n  graphics.x = 350;\n  graphics.y = 250;\n  \n  // 初始设置为完全透明\n  graphics.alpha = 0;\n  \n  // 创建渐变动画\n  this.tweens.add({\n    targets: graphics,        // 动画目标对象\n    alpha: 1,                 // 目标透明度值（完全不透明）\n    duration: 500,            // 持续时间 0.5 秒\n    ease: 'Linear',           // 线性缓动\n    yoyo: true,               // 启用往返效果（到达目标后反向播放）\n    repeat: -1                // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 100, 'Alpha Fade Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 500, 'The square fades in/out every 0.5 seconds', {\n    fontSize: '16px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000349_v3", "prompt_id": "seed_000349", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 20 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成20个白色可收集物体，玩家碰到后消失并加分，显示score\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 配置物理系统和场景\n2. 使用 Graphics 生成玩家和可收集物体的纹理\n3. 创建玩家精灵和物理组，随机生成20个可收集物体\n4. 添加键盘控制让玩家移动\n5. 使用 overlap 检测碰撞，碰到后销毁物体并增加分数\n6. 创建 Text 显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.scoreText = null;\n    this.player = null;\n    this.collectibles = null;\n    this.cursors = null;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建可收集物体纹理（白色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffffff, 1);\n    collectibleGraphics.fillCircle(10, 10, 10);\n    collectibleGraphics.generateTexture('collectible', 20, 20);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建可收集物体组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成20个可收集物体\n    for (let i = 0; i < 20; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setCircle(10); // 设置圆形碰撞体\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加边界\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0x00ff00, 1);\n    graphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁可收集物体\n    collectible.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有物体\n    if (this.collectibles.countActive(true) === 0) {\n      this.scoreText.setText('Score: ' + this.score + ' - YOU WIN!');\n      this.physics.pause();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000889_v2", "prompt_id": "seed_000889", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个方块\n2. 在 create 中将方块放置在画布中心\n3. 在 update 中根据 delta 时间增量更新方块的 rotation 属性，实现每秒 300 度的旋转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制方块\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在 (0, 0)\n  // 这样旋转时会围绕中心旋转\n  graphics.fillRect(-50, -50, 100, 100);\n  \n  // 将方块放置在画布中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 中，方便 update 访问\n  this.rotatingSquare = graphics;\n  \n  // 添加文字说明\n  this.add.text(10, 10, '方块旋转速度: 300度/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的帧间隔时间\n  // 将每秒 300 度转换为每毫秒的弧度增量\n  // 300 度 = 300 * (Math.PI / 180) 弧度\n  // 每毫秒旋转角度 = (300 * Math.PI / 180) / 1000 * delta\n  \n  const rotationSpeed = 300; // 度/秒\n  const radiansPerSecond = Phaser.Math.DegToRad(rotationSpeed);\n  const radiansThisFrame = radiansPerSecond * (delta / 1000);\n  \n  // 更新方块的旋转角度\n  this.rotatingSquare.rotation += radiansThisFrame;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000405_v2", "prompt_id": "seed_000405", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色六边形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的黄色六边形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算六边形6个顶点坐标（基于中心点和半径）\n4. 使用循环绘制8个六边形，每个位置使用 Math.random 生成随机坐标\n5. 设置黄色填充样式（0xffff00），绘制并填充六边形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xffff00, 1);\n  \n  /**\n   * 绘制六边形\n   * @param {number} x - 中心点 x 坐标\n   * @param {number} y - 中心点 y 坐标\n   * @param {number} radius - 六边形半径（中心到顶点距离）\n   */\n  function drawHexagon(x, y, radius) {\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    // 从顶部开始，顺时针绘制\n    for (let i = 0; i < 6; i++) {\n      // 每个角度为 60 度（Math.PI / 3）\n      // 起始角度为 -90 度，使第一个顶点在正上方\n      const angle = (Math.PI / 3) * i - Math.PI / 2;\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        graphics.moveTo(vx, vy);\n      } else {\n        graphics.lineTo(vx, vy);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  }\n  \n  // 六边形大小为 80 像素（直径），半径为 40\n  const hexRadius = 40;\n  \n  // 绘制8个随机位置的六边形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const randomX = hexRadius + Math.random() * (800 - 2 * hexRadius);\n    const randomY = hexRadius + Math.random() * (600 - 2 * hexRadius);\n    \n    drawHexagon(randomX, randomY, hexRadius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000068_v2", "prompt_id": "seed_000068", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的灰色方块，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制10个24像素的灰色方块\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置灰色，fillRect 绘制 24x24 的方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#ffffff',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色 (0x808080)\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制10个随机位置的方块\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保方块完全在画布内\n    // x: 0 到 (800 - 24)，y: 0 到 (600 - 24)\n    const x = Phaser.Math.Between(0, 776);\n    const y = Phaser.Math.Between(0, 576);\n    \n    // 绘制 24x24 的方块\n    graphics.fillRect(x, y, 24, 24);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000373_v3", "prompt_id": "seed_000373", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色星形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Star\nSTEPS:\n1. 创建橙色星形图形对象\n2. 使用 tweens 创建从左到右的移动动画\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8C00, 1); // 橙色\n  \n  // 绘制星形的路径\n  const starPoints = [];\n  const outerRadius = 40;\n  const innerRadius = 20;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    starPoints.push(\n      Math.cos(angle) * radius,\n      Math.sin(angle) * radius\n    );\n  }\n  \n  // 绘制星形\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0], starPoints[1]);\n  for (let i = 2; i < starPoints.length; i += 2) {\n    graphics.lineTo(starPoints[i], starPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5秒\n    ease: 'Linear',\n    yoyo: true, // 往返效果\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Orange Star Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Moving left to right and back (2.5s each way)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000566_v1", "prompt_id": "seed_000566", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 300 像素/秒速度移动\nAPI: this.input.keyboard.addKey(), this.add.graphics(), graphics.fillRect(), key.isDown\nSTEPS:\n1. 创建 Graphics 对象绘制矩形作为玩家\n2. 使用 addKey() 绑定 WASD 四个按键\n3. 在 update 中检测按键状态，根据 delta 计算位移量\n4. 更新矩形位置实现移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象\nlet player;\n// 按键对象\nlet keys;\n// 移动速度（像素/秒）\nconst SPEED = 300;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的矩形\n  \n  // 将 graphics 转换为纹理\n  graphics.generateTexture('playerRect', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建玩家精灵，位置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 绑定 WASD 按键\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the rectangle', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧的移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键状态并设置速度\n  if (keys.W.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.S.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.A.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.D.isDown) {\n    velocityX = 1; // 向右\n  }\n  \n  // 处理斜向移动时的速度归一化\n  if (velocityX !== 0 && velocityY !== 0) {\n    // 斜向移动时，使用勾股定理归一化速度\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX * moveDistance;\n  player.y += velocityY * moveDistance;\n  \n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000142_v1", "prompt_id": "seed_000142", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在2.5秒内缩放到16%再恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 scale 属性从 1 到 0.16 再到 1\n4. 设置 Tween 循环播放（loop: -1）和持续时间 2500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (50, 50)，边长约 80\n  graphics.beginPath();\n  graphics.moveTo(50, 10);      // 顶点\n  graphics.lineTo(10, 90);      // 左下角\n  graphics.lineTo(90, 90);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中央\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  // 从原始大小(1) -> 缩放到16%(0.16) -> 恢复到原始大小(1)\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 1250,  // 2.5秒的一半，缩小阶段\n    yoyo: true,      // 自动反向播放（恢复阶段）\n    repeat: -1,      // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '三角形缩放动画 (2.5秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 16%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000066_v1", "prompt_id": "seed_000066", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 24 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建基本的 Phaser Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字位置为屏幕右下角（考虑文字宽高偏移）\n4. 设置文字样式（字体大小 24px）\n5. 使用 setOrigin(1, 1) 将锚点设置为右下角，方便定位\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文字对象，位置设置在屏幕右下角\n  const text = this.add.text(\n    this.cameras.main.width - 20,  // X 坐标：屏幕宽度 - 右边距\n    this.cameras.main.height - 20, // Y 坐标：屏幕高度 - 下边距\n    'Hello Phaser',\n    {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }\n  );\n\n  // 设置锚点为右下角 (1, 1)，使文字从右下角开始定位\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000094_v2", "prompt_id": "seed_000094", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的六边形并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 在 update 中让六边形自动向下移动\n4. 使用 Camera.startFollow 让相机跟随六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet moveSpeed = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形的参数\n  const hexRadius = 30;\n  const sides = 6;\n  const angle = (Math.PI * 2) / sides;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  graphics.beginPath();\n  for (let i = 0; i < sides; i++) {\n    const x = hexRadius * Math.cos(angle * i - Math.PI / 2);\n    const y = hexRadius * Math.sin(angle * i - Math.PI / 2);\n    if (i === 0) {\n      graphics.moveTo(x + hexRadius, y + hexRadius);\n    } else {\n      graphics.lineTo(x + hexRadius, y + hexRadius);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建六边形精灵，初始位置在场景上方\n  hexagon = this.add.sprite(400, 100, 'hexagon');\n  \n  // 设置相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 设置相机边界，让场景可以无限延伸\n  this.cameras.main.setBounds(0, 0, 800, Number.MAX_SAFE_INTEGER);\n  \n  // 添加参考网格以便观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制横线\n  for (let y = 0; y < 5000; y += 100) {\n    gridGraphics.lineBetween(0, y, 800, y);\n  }\n  \n  // 绘制竖线\n  for (let x = 0; x < 800; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 5000);\n  }\n  \n  // 添加文本提示\n  const text = this.add.text(10, 10, '六边形自动向下移动\\n相机跟随中', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 让文本固定在相机上，不随场景移动\n  text.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让六边形持续向下移动\n  hexagon.y += moveSpeed;\n  \n  // 可选：添加轻微的左右摆动效果\n  hexagon.x = 400 + Math.sin(time / 500) * 50;\n  \n  // 可选：添加旋转效果\n  hexagon.rotation += 0.01;\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000383_v2", "prompt_id": "seed_000383", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillTriangle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中使用循环创建12个 Graphics 对象\n3. 每个 Graphics 对象使用 fillStyle 设置绿色，用 fillTriangle 绘制三角形\n4. 使用 setRandomPosition 方法将三角形随机分布在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建12个随机位置的绿色三角形\n  for (let i = 0; i < 12; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置绿色填充\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制三角形（等边三角形，大小为16像素）\n    // 三角形顶点：顶部中心、左下、右下\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶点（上）\n      -size / 2, height / 2,    // 左下顶点\n      size / 2, height / 2      // 右下顶点\n    );\n    \n    // 随机设置位置（确保三角形完全在画布内）\n    graphics.setRandomPosition(\n      size / 2,                 // x 最小值\n      height / 2,               // y 最小值\n      800 - size / 2,           // x 最大值\n      600 - height / 2          // y 最大值\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000050_v2", "prompt_id": "seed_000050", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到16%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.16\n4. 配置 yoyo 为 true 实现恢复效果，duration 为 3000ms\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy();\n  \n  // 创建 Sprite 对象\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 3000,        // 3秒缩放到16%\n    yoyo: true,            // 动画结束后反向播放（恢复到原始大小）\n    loop: -1,              // -1 表示无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '矩形缩放动画\\n3秒缩放至16%，然后恢复，循环播放', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000358_v2", "prompt_id": "seed_000358", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在4秒内缩放到24%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状\n2. 创建 Tween 动画，设置 scale 从 1 到 0.24，持续 2 秒\n3. 设置 yoyo 为 true 实现恢复效果（2秒缩小 + 2秒恢复 = 4秒）\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建椭圆图形\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制椭圆（中心点在 0,0，半径 100x60）\n  graphics.fillEllipse(0, 0, 200, 120);\n  \n  // 设置椭圆位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.24,  // 缩放到 24%\n    scaleY: 0.24,  // 缩放到 24%\n    duration: 2000,  // 2秒缩小\n    yoyo: true,      // 自动恢复（再用2秒），总共4秒完成一次循环\n    loop: -1,        // 无限循环\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '椭圆缩放动画 (4秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000265_v3", "prompt_id": "seed_000265", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的黄色三角形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的黄色三角形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillTriangle, Graphics#setPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置 800x600 画布\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置黄色，使用 fillTriangle 绘制等边三角形（边长24px）\n4. 使用 setPosition 或 Phaser.Math.Between 设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个随机位置的黄色三角形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为黄色\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制等边三角形（边长24px）\n    // 三角形顶点坐标计算：\n    // 顶点：(0, -高度的2/3)\n    // 左下：(-边长/2, 高度的1/3)\n    // 右下：(边长/2, 高度的1/3)\n    const size = 24;\n    const height = (Math.sqrt(3) / 2) * size; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height * 2 / 3,           // 顶点\n      -size / 2, height / 3,         // 左下\n      size / 2, height / 3           // 右下\n    );\n    \n    // 设置随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000519_v2", "prompt_id": "seed_000519", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 2.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形缩放动画，2.5秒内从100%缩放到16%再恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建菱形精灵对象并居中显示\n3. 使用 Tween 实现缩放动画：从 scale=1 到 scale=0.16，yoyo 模式实现恢复\n4. 设置 duration=2500ms，loop=-1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 程序化生成菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（四个顶点）\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.beginPath();\n  graphics.moveTo(64, 0);      // 上顶点\n  graphics.lineTo(128, 64);    // 右顶点\n  graphics.lineTo(64, 128);    // 下顶点\n  graphics.lineTo(0, 64);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使菱形更明显\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  \n  // 销毁临时 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵并居中\n  const diamond = this.add.sprite(\n    this.cameras.main.centerX,\n    this.cameras.main.centerY,\n    'diamond'\n  );\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    scaleX: 0.16,              // X轴缩放到16%\n    scaleY: 0.16,              // Y轴缩放到16%\n    duration: 2500,            // 单程持续时间2.5秒\n    yoyo: true,                // 启用yoyo模式，自动恢复到原始值\n    loop: -1,                  // 无限循环（-1表示永久循环）\n    ease: 'Sine.easeInOut'     // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Diamond Scale Animation\\nScale: 100% → 16% → 100%\\nLoop: Infinite', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 10 }\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000065_v3", "prompt_id": "seed_000065", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的黄色圆形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的黄色圆形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillCircle, Graphics#setPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环12次\n3. 每次循环创建一个 Graphics 对象，设置黄色填充样式\n4. 使用 fillCircle 绘制半径为24像素的圆形（直径48像素）\n5. 使用 Math.random() 生成随机 x 坐标（24到776之间）和 y 坐标（24到576之间），确保圆形完全在画布内\n6. 使用 setPosition 设置圆形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制12个随机位置的黄色圆形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置黄色填充样式\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制圆形，半径为24像素（直径48像素）\n    // 圆心在 (0, 0)，后续通过 setPosition 移动\n    graphics.fillCircle(0, 0, 24);\n    \n    // 生成随机位置\n    // x: 24 到 776 (确保圆形不超出画布边界)\n    // y: 24 到 576 (确保圆形不超出画布边界)\n    const randomX = 24 + Math.random() * (800 - 48);\n    const randomY = 24 + Math.random() * (600 - 48);\n    \n    // 设置圆形位置\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000092_v3", "prompt_id": "seed_000092", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 200 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版：敌人速度随时间从200逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Text, Phaser.Time.TimerEvent, Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard\nSTEPS:\n1. 创建玩家角色和敌人组，使用Graphics绘制纹理\n2. 实现键盘控制玩家移动\n3. 使用定时器定期生成敌人，初始速度200\n4. 每秒增加敌人速度，实现难度递增\n5. 显示生存时间，检测碰撞判定游戏结束\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.survivalTime = 0; // 生存时间（秒）\n    this.enemySpeed = 200; // 敌人初始速度\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 重置游戏状态\n    this.survivalTime = 0;\n    this.enemySpeed = 200;\n    this.isGameOver = false;\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 显示速度文本\n    this.speedText = this.add.text(16, 50, 'Speed: 200', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER!', {\n      fontSize: '48px',\n      fill: '#ff0000',\n      fontFamily: 'Arial'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    this.restartText = this.add.text(400, 360, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 每1秒生成一个敌人\n    this.enemySpawnTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 每秒更新生存时间和敌人速度\n    this.survivalTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.updateSurvivalTime,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 空格键重启\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n  }\n\n  spawnEnemy() {\n    if (this.isGameOver) return;\n\n    // 随机X位置\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    // 设置敌人速度（向下移动）\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  updateSurvivalTime() {\n    if (this.isGameOver) return;\n\n    this.survivalTime++;\n    this.timeText.setText('Time: ' + this.survivalTime + 's');\n\n    // 每秒增加敌人速度20\n    this.enemySpeed += 20;\n    this.speedText.setText('Speed: ' + this.enemySpeed);\n  }\n\n  handleCollision(player, enemy) {\n    if (this.isGameOver) return;\n\n    this.isGameOver = true;\n\n    // 停止所有定时器\n    this.enemySpawnTimer.remove();\n    this.survivalTimer.remove();\n\n    // 停止所有敌人\n    this.enemies.getChildren().forEach(enemy => {\n      enemy.setVelocity(0, 0);\n    });\n\n    // 停止玩家\n    this.player.setVelocity(0, 0);\n\n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 高亮碰撞的玩家\n    this.player.setTint(0xff0000);\n  }\n\n  update() {\n    if (this.isGameOver) {\n      // 检测空格键重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.scene.restart();\n      }\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 300;\n    \n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.getChildren().forEach(enemy => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000818_v1", "prompt_id": "seed_000818", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8791666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色圆形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现青色圆形在0.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制青色圆形并生成纹理\n2. 创建 Sprite 对象作为动画目标\n3. 使用 tweens 创建 x 轴位置补间动画，设置 yoyo 和 loop 为 -1 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(25, 25, 25); // 绘制半径为25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建圆形精灵，初始位置在左侧\n  const circle = this.add.sprite(100, 300, 'circle');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 目标 x 位置（右侧）\n    duration: 500, // 持续时间 0.5 秒\n    yoyo: true, // 启用往返效果\n    repeat: -1, // 无限循环（-1 表示永久重复）\n    ease: 'Linear' // 线性缓动\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000563_v3", "prompt_id": "seed_000563", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：15 个橙色小球以 120 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 15个橙色小球以120速度在封闭空间内移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.group, Body.setBounce, Physics.add.collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制橙色圆形并生成纹理\n3. 创建物理组，添加15个小球精灵，设置随机位置和速度\n4. 设置小球的弹性系数为1（完全弹性碰撞）\n5. 添加边界碰撞和小球之间的碰撞检测\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n    this.ballCount = 15; // 小球数量\n  }\n\n  preload() {\n    // 使用 Graphics 程序化生成橙色小球纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xFF8800, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('orangeBall', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'orangeBall',\n      repeat: this.ballCount - 1, // 总共15个小球\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 设置每个小球的随机位置和速度\n    const ballsArray = this.balls.getChildren();\n    ballsArray.forEach((ball, index) => {\n      // 随机位置（避免太靠近边缘）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      ball.setPosition(x, y);\n\n      // 设置随机方向的速度，速度大小为120\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 120;\n      const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 120;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体\n      ball.setCircle(16);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 添加显示碰撞计数的文本\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加小球数量显示\n    this.ballCountText = this.add.text(10, 40, `Balls: ${this.ballCount}`, {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界显示（可选，便于观察）\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0xffffff, 1);\n    graphics.strokeRect(0, 0, 800, 600);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调函数，更新碰撞计数\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 可选：监控小球速度，确保保持恒定速度\n    const ballsArray = this.balls.getChildren();\n    ballsArray.forEach((ball) => {\n      const velocity = ball.body.velocity;\n      const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏离120太多，重新归一化（处理浮点误差）\n      if (Math.abs(speed - 120) > 1) {\n        const scale = 120 / speed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false // 设为 true 可查看碰撞体\n    }\n  },\n  scene: BallCollisionScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000941_v3", "prompt_id": "seed_000941", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 紫色玩家移出边界时从对侧出现（循环地图效果），移动速度 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 紫色玩家移出边界时从对侧出现（循环地图效果），移动速度 300\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), Graphics.generateTexture(), Body.setVelocity()\nSTEPS:\n1. 创建紫色玩家精灵，使用 Graphics 生成紫色方块纹理\n2. 启用 Arcade 物理系统，设置玩家速度为 300\n3. 在 create 中绑定键盘输入（方向键）\n4. 在 update 中处理玩家移动和边界循环逻辑\n5. 添加位置状态变量用于验证循环效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerX = 0;\n    this.playerY = 0;\n    this.wrapCount = 0; // 用于验证循环次数的状态信号\n  }\n\n  preload() {\n    // 程序化生成紫色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x9932CC, 1); // 紫色\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('player', 40, 40);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建紫色玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 关闭世界边界碰撞，允许移出边界\n    \n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 添加调试文本显示状态\n    this.debugText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.debugText.setDepth(100);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n\n    const speed = 300;\n\n    // 处理键盘输入\n    if (this.cursors.left.isDown || this.keys.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keys.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.keys.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.keys.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 处理对角线移动时的速度归一化\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(speed);\n    }\n\n    // 循环地图效果 - 边界检测与传送\n    const halfWidth = this.player.width / 2;\n    const halfHeight = this.player.height / 2;\n\n    // 左右边界循环\n    if (this.player.x < -halfWidth) {\n      this.player.x = this.cameras.main.width + halfWidth;\n      this.wrapCount++;\n    } else if (this.player.x > this.cameras.main.width + halfWidth) {\n      this.player.x = -halfWidth;\n      this.wrapCount++;\n    }\n\n    // 上下边界循环\n    if (this.player.y < -halfHeight) {\n      this.player.y = this.cameras.main.height + halfHeight;\n      this.wrapCount++;\n    } else if (this.player.y > this.cameras.main.height + halfHeight) {\n      this.player.y = -halfHeight;\n      this.wrapCount++;\n    }\n\n    // 更新状态变量\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 更新调试信息\n    this.debugText.setText([\n      `Position: (${this.playerX}, ${this.playerY})`,\n      `Speed: ${speed}`,\n      `Wrap Count: ${this.wrapCount}`,\n      `Use Arrow Keys or WASD to move`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000861_v2", "prompt_id": "seed_000861", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示\"Hello Phaser\"文字，字体大小80像素\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左下角（x: 20, y: 520），字体大小为 80px\n4. 设置文本样式（字体、颜色等）使其清晰可见\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕左下角创建文本\n  // x: 20 为左侧留白，y: 520 为距离顶部的位置（600 - 80 = 520，使文本底部对齐底部）\n  const text = this.add.text(20, 520, 'Hello Phaser', {\n    fontFamily: 'Arial',\n    fontSize: '80px',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  });\n\n  // 设置文本原点为左下角，使定位更精确\n  text.setOrigin(0, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000249_v1", "prompt_id": "seed_000249", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形并以每秒300度的速度持续旋转\nAPI: Graphics.fillStyle, Graphics.fillStar, Graphics.generateTexture, Sprite.setAngularVelocity, Physics.Arcade\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个带物理属性的 Sprite 使用该纹理\n3. 设置 Sprite 的角速度为 300 度/秒（转换为弧度）\n4. 或者在 update 中手动更新旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nconst rotationSpeed = 300; // 每秒旋转 300 度\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制星形：中心点(0, 0)，5个角，外半径60，内半径25\n  graphics.fillStar(0, 0, 5, 25, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 120, 120);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 在屏幕中心创建星形精灵\n  star = this.add.sprite(400, 300, 'starTexture');\n  \n  // 可选：添加描边效果\n  const outlineGraphics = this.add.graphics();\n  outlineGraphics.lineStyle(2, 0xffffff, 1);\n  outlineGraphics.strokeStar(0, 0, 5, 25, 60);\n  outlineGraphics.generateTexture('starOutline', 120, 120);\n  outlineGraphics.destroy();\n  \n  // 添加描边层\n  const outline = this.add.sprite(400, 300, 'starOutline');\n  outline.setDepth(-1);\n  \n  // 将描边与星形关联（同步旋转）\n  star.outline = outline;\n  \n  // 添加文字说明\n  this.add.text(400, 50, '星形旋转：300度/秒', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间差\n  // 将旋转速度转换为每毫秒的旋转角度\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 更新星形旋转角度（Phaser 使用度数）\n  star.angle += rotationDelta;\n  \n  // 同步更新描边的旋转\n  if (star.outline) {\n    star.outline.angle = star.angle;\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000537_v1", "prompt_id": "seed_000537", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色椭圆在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色椭圆从左到右往返循环的补间动画\nAPI: Graphics.fillEllipse, tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制白色椭圆并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左移到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置动画时长为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制椭圆（中心点在 0,0，宽度 80，高度 50）\n  graphics.fillEllipse(40, 25, 80, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 50);\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const ellipseSprite = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    x: 700, // 目标位置（右侧）\n    duration: 2500, // 持续时间 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000456_v1", "prompt_id": "seed_000456", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在4秒内从透明渐变到不透明并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象并设置初始 alpha 为 0（完全透明）\n3. 使用 tweens.add 创建 alpha 补间动画，从 0 到 1，持续 4000ms\n4. 设置 repeat: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建 Sprite 对象并居中显示\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.alpha = 0;\n  \n  // 创建补间动画：从透明到不透明，持续 4 秒，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 4000,            // 持续时间 4000 毫秒（4秒）\n    ease: 'Linear',            // 线性缓动函数\n    repeat: -1,                // -1 表示无限循环\n    yoyo: false                // 不使用往返效果，只从 0 到 1 循环\n  });\n  \n  // 添加文字提示\n  this.add.text(400, 500, '方块正在从透明渐变到不透明（循环播放）', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000483_v3", "prompt_id": "seed_000483", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色六边形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色六边形 2 秒左右往返循环移动\nAPI: Graphics.fillStyle, Graphics.fillCircle, Tweens.add, BaseTween.yoyo, BaseTween.repeat\nSTEPS:\n1. 使用 Graphics 绘制黄色六边形并生成纹理\n2. 创建精灵对象并应用六边形纹理\n3. 使用 Tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果\n5. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xFFD700, 1);\n  \n  // 绘制六边形（使用 beginPath 和 lineTo）\n  const hexRadius = 40;\n  const centerX = 50;\n  const centerY = 50;\n  \n  graphics.beginPath();\n  \n  // 绘制六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: hexSprite,        // 目标对象\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 2000,            // 持续时间 2 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '黄色六边形往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000433_v1", "prompt_id": "seed_000433", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的粉色圆形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布上绘制8个随机位置的粉色圆形，每个直径16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置粉色填充样式 (0xff69b4)\n4. 使用循环8次，每次生成随机坐标并绘制半径为8的圆形\n5. 使用 Phaser.Math.Between 生成随机位置，确保圆形完全在画布内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充样式\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 圆形半径（直径16像素，半径8像素）\n  const radius = 8;\n  \n  // 绘制8个随机位置的圆形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机坐标，确保圆形完全在画布内\n    // x 范围: radius 到 (width - radius)\n    // y 范围: radius 到 (height - radius)\n    const x = Phaser.Math.Between(radius, this.scale.width - radius);\n    const y = Phaser.Math.Between(radius, this.scale.height - radius);\n    \n    // 绘制圆形\n    graphics.fillCircle(x, y, radius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000134_v1", "prompt_id": "seed_000134", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色矩形以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色矩形以80速度移动并在画布边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser Game 配置，启用 arcade 物理系统\n2. 在 create 中使用 Graphics 绘制粉色矩形并生成纹理\n3. 创建物理精灵，设置初始速度为 80\n4. 设置精灵与世界边界碰撞并反弹\n5. 可选：在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 不需要重力\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet rectangle;\nconst SPEED = 80;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建粉色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1);  // 粉色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('pinkRect', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵，放置在画布中心\n  rectangle = this.physics.add.sprite(400, 300, 'pinkRect');\n\n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, SPEED);\n  rectangle.setVelocity(velocity.x, velocity.y);\n\n  // 设置与世界边界碰撞\n  rectangle.setCollideWorldBounds(true);\n\n  // 设置反弹系数为 1（完全弹性碰撞）\n  rectangle.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（防止因浮点误差导致速度衰减）\n  const currentSpeed = Math.sqrt(\n    rectangle.body.velocity.x ** 2 + \n    rectangle.body.velocity.y ** 2\n  );\n\n  if (Math.abs(currentSpeed - SPEED) > 0.1) {\n    const scale = SPEED / currentSpeed;\n    rectangle.setVelocity(\n      rectangle.body.velocity.x * scale,\n      rectangle.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000782_v2", "prompt_id": "seed_000782", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的青色圆形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的青色圆形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillCircle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中使用循环创建3个 Graphics 对象\n3. 为每个 Graphics 设置青色填充样式（0x00ffff）\n4. 使用 fillCircle 绘制半径为40的圆形（直径80像素）\n5. 使用 setRandomPosition 为每个圆形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建3个随机位置的青色圆形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置青色填充样式（0x00ffff 是青色的十六进制值）\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 绘制圆形，半径为40像素（直径80像素）\n    // 圆心在 (0, 0)，因为会通过 setRandomPosition 设置位置\n    graphics.fillCircle(0, 0, 40);\n    \n    // 设置随机位置\n    // 确保圆形完全在画布内（考虑半径40像素的偏移）\n    graphics.setRandomPosition(40, 40, 800 - 80, 600 - 80);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000689_v2", "prompt_id": "seed_000689", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 创建 Graphics 对象并绘制一个圆形\n2. 设置圆形初始透明度为 0（完全透明）\n3. 使用 tweens 创建透明度动画，从 0 到 1，持续 2 秒\n4. 设置动画循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 在画布中心绘制一个半径为 80 的圆形\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 80;\n  graphics.fillCircle(centerX, centerY, radius);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建透明度渐变动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    alpha: 1,                    // 目标透明度值（完全不透明）\n    duration: 2000,              // 动画持续时间 2 秒（2000 毫秒）\n    ease: 'Linear',              // 线性缓动函数，匀速变化\n    yoyo: true,                  // 动画反向播放（1 -> 0）\n    repeat: -1                   // 无限循环播放（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '圆形透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000553_v2", "prompt_id": "seed_000553", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2.5秒内缩放到64%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状并生成纹理\n2. 创建 Sprite 对象使用椭圆纹理\n3. 使用 Tween 创建缩放动画，从1缩放到0.64再回到1\n4. 设置 Tween 循环播放（loop: -1）和持续时间2500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillEllipse(100, 75, 200, 150); // 椭圆中心在(100, 75)，宽200，高150\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建使用椭圆纹理的 Sprite\n  const ellipseSprite = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 1250, // 2.5秒的一半，因为需要来回\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Ellipse Scale Animation\\n(64% and back, 2.5s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000531_v2", "prompt_id": "seed_000531", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2.5秒内缩放到80%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.8\n4. 设置动画时长为 2500ms，启用 yoyo 使其自动恢复，loop 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillRect(0, 0, 150, 100);\n  graphics.generateTexture('rectTexture', 150, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵并放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.8,        // 缩放到 80%\n    scaleY: 0.8,        // 缩放到 80%\n    duration: 2500,     // 2.5 秒\n    yoyo: true,         // 自动返回原始值\n    loop: -1,           // 无限循环 (-1 表示永久循环)\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动效果\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, '矩形缩放动画 (2.5秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000160_v2", "prompt_id": "seed_000160", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色椭圆在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色椭圆在1秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色椭圆并生成纹理\n2. 创建 Sprite 并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n5. 设置 duration: 1000 控制动画时长为1秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  // 绘制椭圆（中心点在 50, 30，宽度 100，高度 60）\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('yellowEllipse', 100, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象\n  const ellipse = this.add.sprite(100, 300, 'yellowEllipse');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: ellipse,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 1000, // 动画时长 1 秒\n    yoyo: true, // 往返效果（到达终点后反向播放）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000053_v2", "prompt_id": "seed_000053", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个绿色物体以 360 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 20个绿色物体以360速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成绿色圆形纹理\n3. 创建物理组，添加 20 个绿色物体\n4. 为每个物体设置随机速度（总速度为 360）和完全反弹\n5. 设置物体间的碰撞检测\n6. 添加状态信号变量记录碰撞次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet collisionCount = 0;\nlet activeObjects = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建绿色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('greenBall', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理组\n  const objectsGroup = this.physics.add.group({\n    key: 'greenBall',\n    repeat: 19, // 创建 20 个对象（0-19）\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n\n  // 设置每个物体的随机位置和速度\n  const speed = 360;\n  objectsGroup.children.iterate((child) => {\n    // 随机位置\n    child.setPosition(\n      Phaser.Math.Between(50, 750),\n      Phaser.Math.Between(50, 550)\n    );\n\n    // 随机方向，但保持总速度为 360\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    \n    child.setVelocity(vx, vy);\n    \n    // 设置完全反弹\n    child.setBounce(1, 1);\n  });\n\n  // 设置物体之间的碰撞\n  this.physics.add.collider(objectsGroup, objectsGroup, onCollision, null, this);\n\n  // 更新活动对象数量\n  activeObjects = objectsGroup.getLength();\n\n  // 显示状态信息\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 存储组引用以便在 update 中使用\n  this.objectsGroup = objectsGroup;\n}\n\nfunction update() {\n  // 更新状态显示\n  if (this.statusText) {\n    this.statusText.setText([\n      `Active Objects: ${activeObjects}`,\n      `Total Collisions: ${collisionCount}`,\n      `Speed: 360 px/s`\n    ]);\n  }\n\n  // 确保物体速度保持在 360 左右（处理浮点误差）\n  this.objectsGroup.children.iterate((child) => {\n    const velocity = child.body.velocity;\n    const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n    \n    // 如果速度偏差超过 1%，进行修正\n    if (Math.abs(currentSpeed - 360) > 3.6) {\n      const scale = 360 / currentSpeed;\n      child.setVelocity(velocity.x * scale, velocity.y * scale);\n    }\n  });\n}\n\nfunction onCollision(obj1, obj2) {\n  // 记录碰撞次数\n  collisionCount++;\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000873_v2", "prompt_id": "seed_000873", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让蓝色圆形在 2 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个蓝色圆形在2秒内完成弹跳动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建 y 轴弹跳动画，设置 ease 为 'Bounce.easeOut'\n4. 设置 Tween 循环播放，duration 为 2000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0088ff, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('blueCircle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建蓝色圆形精灵\n  const circle = this.add.sprite(400, 100, 'blueCircle');\n  \n  // 添加地面参考线（可选，用于视觉效果）\n  const groundY = 500;\n  const ground = this.add.graphics();\n  ground.lineStyle(2, 0x666666, 1);\n  ground.lineBetween(0, groundY, 800, groundY);\n  \n  // 创建弹跳动画\n  this.tweens.add({\n    targets: circle,\n    y: groundY - 25, // 落到地面位置（减去圆形半径）\n    duration: 2000, // 2秒完成一次弹跳\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: false, // 不使用 yoyo，因为弹跳效果本身已经包含回弹\n    repeat: -1, // 无限循环\n    onRepeat: () => {\n      // 每次重复时重置到起始位置\n      circle.y = 100;\n    }\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Bouncing Circle Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000594_v2", "prompt_id": "seed_000594", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色三角形在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色三角形并实现 2 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#generateTexture, Phaser.GameObjects.Sprite, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建抖动效果（x/y 方向随机偏移）\n4. 设置 Tween 循环和持续时间为 2 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制等边三角形（中心点在原点）\n  const size = 60;\n  const height = size * Math.sqrt(3) / 2;\n  graphics.beginPath();\n  graphics.moveTo(0, -height * 2/3); // 顶点\n  graphics.lineTo(-size / 2, height * 1/3); // 左下\n  graphics.lineTo(size / 2, height * 1/3); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', size, size * 1.2);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建抖动动画\n  // 使用多个 Tween 组合实现抖动效果\n  this.tweens.add({\n    targets: triangle,\n    x: '+=10', // 向右偏移\n    y: '+=8',  // 向下偏移\n    duration: 50,\n    yoyo: true, // 往返\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加旋转抖动\n  this.tweens.add({\n    targets: triangle,\n    angle: { from: -5, to: 5 }, // 左右旋转抖动\n    duration: 100,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加缩放抖动\n  this.tweens.add({\n    targets: triangle,\n    scaleX: { from: 0.95, to: 1.05 },\n    scaleY: { from: 0.95, to: 1.05 },\n    duration: 150,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 创建主循环控制（2秒一个完整周期）\n  // 使用时间轴控制抖动的强度变化\n  this.tweens.addCounter({\n    from: 0,\n    to: 1,\n    duration: 2000,\n    repeat: -1,\n    onUpdate: (tween) => {\n      const progress = tween.getValue();\n      // 使用正弦波形让抖动强度周期性变化\n      const intensity = Math.sin(progress * Math.PI * 2) * 0.5 + 0.5;\n      // 可以根据 intensity 调整抖动效果（这里作为演示）\n    }\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 550, '青色三角形抖动动画 (2秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000325_v1", "prompt_id": "seed_000325", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个基于 15x15 数组的简单 Tilemap：0 为空，1 为墙可碰撞，玩家用方向键移动且不能穿墙。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tilemaps.Tilemap\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现15x15 Tilemap，0为空地1为墙，玩家方向键移动并检测墙体碰撞\nAPI: Phaser.Tilemaps.Tilemap, Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建15x15二维数组地图数据，定义墙体(1)和空地(0)\n2. 使用Graphics生成tile纹理（墙体和地面），创建Tilemap\n3. 启用Arcade物理系统，设置墙体碰撞属性\n4. 创建玩家精灵，添加键盘控制和物理碰撞\n5. 在update中处理方向键输入，实现玩家移动\n6. 添加状态变量(playerX, playerY)用于验证\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 480,\n  height: 480,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet playerX = 0;\nlet playerY = 0;\nlet moveCount = 0;\n\n// 15x15 地图数据 (0=空地, 1=墙)\nconst mapData = [\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,0,1,1,0,1,1,1,0,1,1,1,1,0,1],\n  [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],\n  [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],\n  [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],\n  [1,0,1,1,0,1,1,1,0,1,1,1,1,0,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n];\n\nconst TILE_SIZE = 32;\nlet player;\nlet cursors;\nlet map;\nlet layer;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，不依赖外部资源\n  \n  // 创建地面纹理 (浅灰色)\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0xcccccc, 1);\n  groundGraphics.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n  groundGraphics.generateTexture('ground', TILE_SIZE, TILE_SIZE);\n  groundGraphics.destroy();\n  \n  // 创建墙体纹理 (深灰色带边框)\n  const wallGraphics = this.add.graphics();\n  wallGraphics.fillStyle(0x444444, 1);\n  wallGraphics.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n  wallGraphics.lineStyle(2, 0x222222, 1);\n  wallGraphics.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);\n  wallGraphics.generateTexture('wall', TILE_SIZE, TILE_SIZE);\n  wallGraphics.destroy();\n  \n  // 创建玩家纹理 (蓝色圆形)\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x3498db, 1);\n  playerGraphics.fillCircle(TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2 - 4);\n  playerGraphics.lineStyle(2, 0x2980b9, 1);\n  playerGraphics.strokeCircle(TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2 - 4);\n  playerGraphics.generateTexture('player', TILE_SIZE, TILE_SIZE);\n  playerGraphics.destroy();\n}\n\nfunction create() {\n  // 创建 Tilemap\n  map = this.make.tilemap({\n    data: mapData,\n    tileWidth: TILE_SIZE,\n    tileHeight: TILE_SIZE\n  });\n  \n  // 添加 tileset (使用我们创建的纹理)\n  const tiles = map.addTilesetImage('ground', null, TILE_SIZE, TILE_SIZE);\n  \n  // 创建图层\n  layer = map.createLayer(0, tiles, 0, 0);\n  \n  // 手动设置每个 tile 的纹理\n  for (let y = 0; y < 15; y++) {\n    for (let x = 0; x < 15; x++) {\n      const tile = layer.getTileAt(x, y);\n      if (tile) {\n        if (mapData[y][x] === 1) {\n          // 墙体\n          tile.setCollision(true, true, true, true);\n          // 使用 Graphics 在墙体位置绘制\n          const wallSprite = this.add.image(x * TILE_SIZE, y * TILE_SIZE, 'wall').setOrigin(0, 0);\n        } else {\n          // 地面\n          const groundSprite = this.add.image(x * TILE_SIZE, y * TILE_SIZE, 'ground').setOrigin(0, 0);\n        }\n      }\n    }\n  }\n  \n  // 设置碰撞 (所有值为1的tile可碰撞)\n  layer.setCollisionByProperty({ collides: true });\n  layer.setCollisionBetween(1, 1);\n  \n  // 创建玩家 (初始位置在空地上，例如 [1,1])\n  player = this.physics.add.sprite(1.5 * TILE_SIZE, 1.5 * TILE_SIZE, 'player');\n  player.setCollideWorldBounds(true);\n  player.body.setSize(TILE_SIZE - 8, TILE_SIZE - 8);\n  \n  // 设置玩家与tilemap的碰撞\n  this.physics.add.collider(player, layer);\n  \n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 初始化状态变量\n  playerX = Math.floor(player.x / TILE_SIZE);\n  playerY = Math.floor(player.y / TILE_SIZE);\n  \n  // 添加文本显示状态\n  this.add.text(10, 10, 'Use Arrow Keys to Move', {\n    fontSize: '16px',\n    fill: '#fff',\n    backgroundColor: '#000',\n    padding: { x: 5, y: 5 }\n  });\n  \n  this.statusText = this.add.text(10, 40, '', {\n    fontSize: '14px',\n    fill: '#fff',\n    backgroundColor: '#000',\n    padding: { x: 5, y: 5 }\n  });\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0);\n  \n  const speed = 150;\n  \n  // 方向键控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n  \n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n  \n  // 更新状态变量\n  const newX = Math.floor(player.x / TILE_SIZE);\n  const newY = Math.floor(player.y / TILE_SIZE);\n  \n  if (newX !== playerX || newY !== playerY) {\n    playerX = newX;\n    playerY = newY;\n    moveCount++;\n  }\n  \n  // 更新状态显示\n  this.statusText.setText(\n    `Position: (${playerX}, ${playerY})\\n` +\n    `Moves: ${moveCount}\\n` +\n    `Tile: ${mapData[playerY] ? mapData[playerY][playerX] : 'out'}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000973_v1", "prompt_id": "seed_000973", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Tilemap", "Input", "Physics"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色矩形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制8个24x24像素的黄色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中使用循环创建8个 Graphics 对象\n3. 每个 Graphics 对象设置黄色填充样式并绘制24x24的矩形\n4. 使用 setRandomPosition 方法将每个矩形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建8个黄色矩形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置黄色填充样式 (0xFFFF00 是黄色的十六进制值)\n    graphics.fillStyle(0xFFFF00, 1);\n    \n    // 绘制 24x24 像素的矩形，以 (0, 0) 为起点\n    graphics.fillRect(0, 0, 24, 24);\n    \n    // 将矩形随机放置在画布范围内\n    // 减去24像素确保矩形完全显示在画布内\n    graphics.setRandomPosition(0, 0, config.width - 24, config.height - 24);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000455_v2", "prompt_id": "seed_000455", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按WASD键发射子弹，速度 160，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现WASD四方向发射子弹射击敌人，显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard.addKey, Phaser.Physics.Arcade.overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家（Graphics绘制矩形）和敌人组（随机生成移动的敌人）\n2. 监听WASD键盘输入，按键时从玩家位置发射对应方向的子弹\n3. 使用物理碰撞检测子弹与敌人的overlap，命中时销毁双方并增加击杀数\n4. 在屏幕上显示击杀数文本，实时更新\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 初始生成敌人\n    this.spawnEnemies();\n\n    // 定时生成敌人\n    this.time.addEvent({\n      delay: 2000,\n      callback: this.spawnEnemies,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 设置WASD键\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 防止连续发射的冷却时间\n    this.shootCooldown = 0;\n\n    // 碰撞检测：子弹与敌人\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.killText.setDepth(100);\n\n    // 显示操作提示\n    this.add.text(16, 50, 'Press WASD to shoot', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  update(time, delta) {\n    // 更新冷却时间\n    if (this.shootCooldown > 0) {\n      this.shootCooldown -= delta;\n    }\n\n    // 检测WASD按键发射子弹\n    if (this.shootCooldown <= 0) {\n      if (this.keyW.isDown) {\n        this.shootBullet(0, -1); // 向上\n        this.shootCooldown = 200;\n      } else if (this.keyS.isDown) {\n        this.shootBullet(0, 1); // 向下\n        this.shootCooldown = 200;\n      } else if (this.keyA.isDown) {\n        this.shootBullet(-1, 0); // 向左\n        this.shootCooldown = 200;\n      } else if (this.keyD.isDown) {\n        this.shootBullet(1, 0); // 向右\n        this.shootCooldown = 200;\n      }\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -20 || bullet.x > 820 || bullet.y < -20 || bullet.y > 620) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 敌人随机移动\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active) {\n        // 简单的追踪玩家逻辑\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n        enemy.setVelocity(\n          Math.cos(angle) * 50,\n          Math.sin(angle) * 50\n        );\n      }\n    });\n  }\n\n  shootBullet(dirX, dirY) {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.setVelocity(dirX * 160, dirY * 160);\n      \n      // 设置子弹生命周期\n      this.time.delayedCall(3000, () => {\n        if (bullet.active) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      });\n    }\n  }\n\n  spawnEnemies() {\n    // 随机生成2-4个敌人\n    const count = Phaser.Math.Between(2, 4);\n    \n    for (let i = 0; i < count; i++) {\n      // 随机位置（在边缘生成）\n      let x, y;\n      const edge = Phaser.Math.Between(0, 3);\n      \n      switch(edge) {\n        case 0: // 上边\n          x = Phaser.Math.Between(0, 800);\n          y = -30;\n          break;\n        case 1: // 右边\n          x = 830;\n          y = Phaser.Math.Between(0, 600);\n          break;\n        case 2: // 下边\n          x = Phaser.Math.Between(0, 800);\n          y = 630;\n          break;\n        case 3: // 左边\n          x = -30;\n          y = Phaser.Math.Between(0, 600);\n          break;\n      }\n      \n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹命中敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    \n    enemy.destroy();\n    \n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n    \n    // 击杀特效（简单的闪光）\n    const flash = this.add.graphics();\n    flash.fillStyle(0xffffff, 0.8);\n    flash.fillCircle(enemy.x, enemy.y, 20);\n    \n    this.tweens.add({\n      targets: flash,\n      alpha: 0,\n      duration: 200,\n      onComplete: () => {\n        flash.destroy();\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000874_v1", "prompt_id": "seed_000874", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8587499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：蓝色敌人从上方以 360 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，蓝色敌人从上方以360速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider\nSTEPS:\n1. 创建物理系统配置，设置游戏场景\n2. 使用Graphics创建玩家（绿色矩形）和敌人（蓝色矩形）纹理\n3. 在create中初始化玩家精灵，设置键盘输入监听\n4. 创建敌人生成器，定时从顶部随机位置生成敌人\n5. 在update中处理玩家左右移动逻辑\n6. 设置碰撞检测，碰撞时结束游戏并显示游戏结束文本\n7. 添加分数系统，记录存活时间\n[/PLAN]\n\n```javascript\nclass DodgeGameScene extends Phaser.Scene {\n  constructor() {\n    super('DodgeGameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.playerSpeed = 300;\n    this.enemySpeed = 360;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色矩形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色矩形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 设置碰撞检测\n    this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 定时生成敌人（每1秒生成一个）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 分数计时器\n    this.scoreTimer = this.time.addEvent({\n      delay: 100,\n      callback: () => {\n        if (!this.gameOver) {\n          this.score += 1;\n          this.scoreText.setText('Score: ' + this.score);\n        }\n      },\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 玩家移动控制\n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 620) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 在屏幕顶部随机位置生成敌人\n    const x = Phaser.Math.Between(30, 770);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  hitEnemy(player, enemy) {\n    // 游戏结束\n    this.gameOver = true;\n    \n    // 停止所有物理\n    this.physics.pause();\n    \n    // 停止定时器\n    this.enemyTimer.destroy();\n    this.scoreTimer.destroy();\n    \n    // 玩家变红\n    player.setTint(0xff0000);\n    \n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    \n    // 显示最终分数\n    const finalScoreText = this.add.text(400, 370, 'Final Score: ' + this.score, {\n      fontSize: '32px',\n      fill: '#fff'\n    });\n    finalScoreText.setOrigin(0.5);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001079_v3", "prompt_id": "seed_001079", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9191666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色菱形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色菱形在1.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制菱形（四个顶点）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 1500,            // 持续时间 1.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 往返效果（到达终点后返回起点）\n    loop: -1                   // 无限循环（-1 表示永久循环）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000744_v3", "prompt_id": "seed_000744", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的星形对象\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Graphics#generateTexture\nSTEPS:\n1. 创建场景配置，设置较大的世界边界以便移动\n2. 使用 Graphics 绘制星形并生成纹理\n3. 创建星形精灵对象，设置初始位置\n4. 在 update 中让星形自动向右上方移动\n5. 使用 camera.startFollow 让相机跟随星形对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nconst MOVE_SPEED = 2;\n\nfunction preload() {\n  // 使用 Graphics 创建星形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: 32 + Math.cos(angle) * radius,\n      y: 32 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，使其比相机视口大很多\n  this.cameras.main.setBounds(0, 0, 3000, 3000);\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 创建星形精灵，放置在世界中心偏左下位置\n  star = this.add.sprite(400, 1500, 'star');\n  star.setOrigin(0.5, 0.5);\n  \n  // 设置相机跟随星形\n  this.cameras.main.startFollow(star, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（如果需要）\n  // this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加网格背景以便观察移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(3000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加文字提示\n  const text = this.add.text(10, 10, '相机跟随星形移动\\n星形自动向右上方移动', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视口上\n  \n  // 添加坐标显示\n  this.coordText = this.add.text(10, 80, '', {\n    fontSize: '16px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.coordText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 星形自动向右上方移动\n  star.x += MOVE_SPEED;\n  star.y -= MOVE_SPEED;\n  \n  // 星形旋转效果\n  star.angle += 1;\n  \n  // 更新坐标显示\n  this.coordText.setText(\n    `星形坐标: (${Math.round(star.x)}, ${Math.round(star.y)})\\n` +\n    `相机中心: (${Math.round(this.cameras.main.scrollX + 400)}, ${Math.round(this.cameras.main.scrollY + 300)})`\n  );\n  \n  // 可选：当星形到达边界时重置位置\n  if (star.x > 2900 || star.y < 100) {\n    star.x = 400;\n    star.y = 1500;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000368_v3", "prompt_id": "seed_000368", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色椭圆以 240 速度移动并在画布边界反弹\nAPI: Graphics.fillEllipse, Physics.Arcade.Sprite, setVelocity, setBounce, setCollideWorldBounds\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为 240\n4. 设置边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制椭圆（中心点在 50, 30，宽度 100，高度 60）\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 100, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（240 像素/秒，方向为右下方 45 度）\n  const speed = 240;\n  const angle = Phaser.Math.DegToRad(45);\n  ellipse.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000637_v2", "prompt_id": "seed_000637", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 360 度的速度持续旋转\nAPI: Graphics, Scene.update, GameObject.rotation\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 或 Image 对象使用该纹理\n3. 在 update 方法中根据 delta 时间增量更新旋转角度\n4. 每秒旋转 360 度，即每毫秒旋转 360/1000 度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('squareTex', 100, 100);\n  graphics.destroy();\n  \n  // 创建方块精灵并设置到屏幕中心\n  square = this.add.sprite(400, 300, 'squareTex');\n  \n  // 设置旋转中心点为方块中心\n  square.setOrigin(0.5, 0.5);\n  \n  // 添加提示文本\n  this.add.text(10, 10, '方块以每秒 360° 的速度旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 每秒旋转 360 度 = 2π 弧度\n  // 每毫秒旋转的弧度 = (2 * Math.PI) / 1000\n  // rotation 使用弧度制\n  const rotationSpeed = (2 * Math.PI) / 1000; // 每毫秒旋转的弧度\n  square.rotation += rotationSpeed * delta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000683_v2", "prompt_id": "seed_000683", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 3 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在3秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 Tween 动画实现 3 秒缩放到 0.48，然后 3 秒恢复到 1.0\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制等边三角形（中心点在 50, 50）\n  const triangleSize = 80;\n  const height = (Math.sqrt(3) / 2) * triangleSize;\n  \n  graphics.beginPath();\n  graphics.moveTo(50, 50 - height / 1.5); // 顶点\n  graphics.lineTo(50 - triangleSize / 2, 50 + height / 3); // 左下\n  graphics.lineTo(50 + triangleSize / 2, 50 + height / 3); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n  \n  // 创建三角形 Sprite 并居中显示\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  // 使用 yoyo 模式实现来回缩放效果\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 3000, // 3秒缩小到48%\n    ease: 'Sine.easeInOut',\n    yoyo: true, // 自动返回原始值\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Triangle scaling to 48% and back in 3 seconds', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Loop: Infinite', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000257_v3", "prompt_id": "seed_000257", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 200，移动速度 300，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动和跳跃，重力200，速度300，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 200\n2. 使用 Graphics 创建玩家角色和地面平台的纹理\n3. 添加玩家精灵并启用物理属性，设置碰撞边界\n4. 创建静态地面平台组，设置碰撞检测\n5. 监听键盘输入（左右方向键和空格跳跃）\n6. 在 update 中处理移动逻辑和跳跃判断\n7. 添加状态变量记录跳跃次数和位置信息\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    // 可验证的状态信号\n    this.jumpCount = 0;\n    this.playerX = 0;\n    this.playerY = 0;\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，不依赖外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 32);\n    groundGraphics.generateTexture('ground', 800, 32);\n    groundGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(32, 48);\n\n    // 创建静态平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加地面\n    this.ground = this.platforms.create(400, 584, 'ground');\n    this.ground.setScale(1).refreshBody();\n\n    // 添加多个平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 350, 'platform');\n    this.platforms.create(400, 250, 'platform');\n    this.platforms.create(100, 200, 'platform');\n    this.platforms.create(700, 200, 'platform');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加提示文本\n    this.add.text(400, 50, '使用方向键移动，空格键跳跃', {\n      fontSize: '20px',\n      fill: '#ffff00'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 更新状态信息\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 检测是否在地面上\n    if (this.player.body.touching.down) {\n      this.isGrounded = true;\n    } else {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面上才能跳跃）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `位置: (${this.playerX}, ${this.playerY})`,\n      `跳跃次数: ${this.jumpCount}`,\n      `在地面: ${this.isGrounded ? '是' : '否'}`,\n      `速度: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 200 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000885_v1", "prompt_id": "seed_000885", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色椭圆以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色椭圆以120速度移动并在边界反弹\nAPI: Graphics.fillEllipse, GameObject.setVelocity, Physics.World.setBoundsCollision, Physics.Body.setBounce, Physics.Body.setCollideWorldBounds\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制紫色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为120\n4. 设置精灵与世界边界碰撞并反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nconst SPEED = 120;\n\nfunction preload() {\n  // 创建紫色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40,30)，宽80，高60\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, SPEED);\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 设置与世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 确保世界边界碰撞开启\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为120\n  const currentSpeed = Math.sqrt(\n    ellipse.body.velocity.x * ellipse.body.velocity.x + \n    ellipse.body.velocity.y * ellipse.body.velocity.y\n  );\n  \n  if (currentSpeed !== 0) {\n    const scale = SPEED / currentSpeed;\n    ellipse.setVelocity(\n      ellipse.body.velocity.x * scale,\n      ellipse.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000212_v1", "prompt_id": "seed_000212", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个圆形，使用 Tween 动画在 1 秒内缩放到 24%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 Tween 动画设置缩放属性，从 1 到 0.24，yoyo 模式返回，循环播放\n4. 设置 Tween 持续时间为 1000ms（1秒），yoyo 为 true，loop 为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 中心点 (50, 50)，半径 50\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 在屏幕中心创建圆形精灵\n  const circle = this.add.sprite(400, 300, 'circle');\n\n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    scaleX: 0.24,             // X 轴缩放到 24%\n    scaleY: 0.24,             // Y 轴缩放到 24%\n    duration: 1000,           // 持续时间 1 秒\n    yoyo: true,               // 动画结束后反向播放（恢复到原始大小）\n    loop: -1,                 // 无限循环（-1 表示永远循环）\n    ease: 'Linear'            // 线性缓动\n  });\n\n  // 添加文本说明\n  this.add.text(400, 50, '圆形缩放动画（1秒缩放到24%，然后恢复，循环播放）', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000746_v2", "prompt_id": "seed_000746", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象应用六边形纹理\n3. 使用 Tween 实现缩放动画：从 scale=1 到 scale=0.32 再回到 scale=1\n4. 设置 Tween 循环播放（loop: -1）和 yoyo 效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形（6个顶点）\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 从原始大小(1)缩放到32%(0.32)，然后恢复，循环播放\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 1000, // 1秒\n    yoyo: true, // 自动返回原始值\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 50, '六边形缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 32%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000443_v2", "prompt_id": "seed_000443", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示 \"Hello Phaser\" 文字，字体大小 16 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左下角（x=10, y=height-20），字体大小 16px\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕左下角创建文本\n  // x: 10 像素距离左边\n  // y: 600 - 20 = 580 像素，距离底部 20 像素\n  const text = this.add.text(10, 580, 'Hello Phaser', {\n    fontSize: '16px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本原点为左下角，使定位更精确\n  text.setOrigin(0, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000354_v2", "prompt_id": "seed_000354", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的粉色菱形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的粉色菱形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillPoints, Phaser.Geom.Point\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 为每个菱形生成随机位置（考虑菱形大小，避免超出边界）\n4. 使用 fillStyle 设置粉色填充（0xff69b4）\n5. 使用 fillPoints 绘制菱形的4个顶点（上、右、下、左）\n6. 将菱形定位到随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const diamondSize = 48; // 菱形大小\n  const halfSize = diamondSize / 2; // 菱形半径\n  \n  // 绘制8个随机位置的粉色菱形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机位置（确保菱形完全在画布内）\n    const x = Phaser.Math.Between(halfSize, this.scale.width - halfSize);\n    const y = Phaser.Math.Between(halfSize, this.scale.height - halfSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 定义菱形的4个顶点（相对于中心点）\n    const points = [\n      new Phaser.Geom.Point(0, -halfSize),      // 上顶点\n      new Phaser.Geom.Point(halfSize, 0),       // 右顶点\n      new Phaser.Geom.Point(0, halfSize),       // 下顶点\n      new Phaser.Geom.Point(-halfSize, 0)       // 左顶点\n    ];\n    \n    // 绘制填充的菱形\n    graphics.fillPoints(points, true);\n    \n    // 设置菱形位置\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000167_v3", "prompt_id": "seed_000167", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的灰色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的灰色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环10次，每次创建一个 Graphics 对象\n3. 使用三角函数计算六边形的6个顶点坐标（半径16像素）\n4. 使用 Graphics API 绘制填充的六边形路径\n5. 使用 Phaser.Math.Between 为每个六边形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制10个随机位置的灰色六边形\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置灰色填充\n    graphics.fillStyle(0x808080, 1);\n    \n    // 六边形参数\n    const radius = 16; // 大小32像素，半径16像素\n    const sides = 6;\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点并绘制\n    for (let j = 0; j < sides; j++) {\n      // 计算角度（从顶部开始，逆时针）\n      const angle = (Math.PI / 3) * j - Math.PI / 2;\n      const x = radius * Math.cos(angle);\n      const y = radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（考虑边界，避免六边形超出画布）\n    const randomX = Phaser.Math.Between(radius + 10, 800 - radius - 10);\n    const randomY = Phaser.Math.Between(radius + 10, 600 - radius - 10);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000246_v2", "prompt_id": "seed_000246", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现粉色血条 UI，显示 10 格生命值，空格键扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化 10 格生命值变量\n2. 使用 Graphics 绘制 10 个粉色矩形作为血条格子\n3. 监听空格键输入事件，每次按下扣除 1 格生命值\n4. 更新血条显示，根据当前生命值重绘血条\n5. 当生命值为 0 时显示 Game Over 文本\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 当前生命值\n    this.maxHealth = 10; // 最大生命值\n    this.healthBarGraphics = null;\n    this.gameOverText = null;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建血条背景和前景图形对象\n    this.healthBarGraphics = this.add.graphics();\n    \n    // 初始绘制血条\n    this.drawHealthBar();\n    \n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n    \n    // 添加说明文本\n    this.add.text(400, 500, 'Press SPACE to take damage', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n    \n    // 监听空格键输入\n    this.input.keyboard.on('keydown-SPACE', () => {\n      if (!this.isGameOver && this.health > 0) {\n        this.takeDamage();\n      }\n    });\n  }\n\n  /**\n   * 绘制血条\n   */\n  drawHealthBar() {\n    // 清除之前的绘制\n    this.healthBarGraphics.clear();\n    \n    const barX = 200; // 血条起始 X 坐标\n    const barY = 100; // 血条起始 Y 坐标\n    const cellWidth = 40; // 每格宽度\n    const cellHeight = 30; // 每格高度\n    const cellGap = 5; // 格子间距\n    \n    // 绘制每一格血条\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = barX + i * (cellWidth + cellGap);\n      \n      // 绘制背景（深灰色边框）\n      this.healthBarGraphics.lineStyle(2, 0x666666, 1);\n      this.healthBarGraphics.strokeRect(x, barY, cellWidth, cellHeight);\n      \n      // 根据当前生命值决定填充颜色\n      if (i < this.health) {\n        // 有生命值的格子填充粉色\n        this.healthBarGraphics.fillStyle(0xff69b4, 1); // 粉色\n        this.healthBarGraphics.fillRect(x + 2, barY + 2, cellWidth - 4, cellHeight - 4);\n      } else {\n        // 没有生命值的格子填充暗色\n        this.healthBarGraphics.fillStyle(0x333333, 1);\n        this.healthBarGraphics.fillRect(x + 2, barY + 2, cellWidth - 4, cellHeight - 4);\n      }\n    }\n    \n    // 显示当前生命值文本\n    this.healthBarGraphics.fillStyle(0xffffff, 1);\n    // 使用独立的文本对象来显示生命值\n    if (this.healthText) {\n      this.healthText.destroy();\n    }\n    this.healthText = this.add.text(barX, barY + cellHeight + 20, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n  }\n\n  /**\n   * 扣血逻辑\n   */\n  takeDamage() {\n    if (this.health > 0) {\n      this.health -= 1;\n      this.drawHealthBar();\n      \n      // 检查是否游戏结束\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  /**\n   * 触发游戏结束\n   */\n  triggerGameOver() {\n    this.isGameOver = true;\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n  }\n\n  update(time, delta) {\n    // 每帧更新逻辑（当前不需要）\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: HealthBarScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000887_v3", "prompt_id": "seed_000887", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让红色六边形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色六边形并使用 Tween 实现 4 秒旋转循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setRotation\nSTEPS:\n1. 使用 Graphics 绘制红色六边形并生成纹理\n2. 创建 Sprite 对象使用六边形纹理\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 4000ms，rotation 从 0 到 2π\n4. 设置 repeat: -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制六边形\n  const hexagonSize = 60;\n  const centerX = hexagonSize;\n  const centerY = hexagonSize;\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角度60度\n    const x = centerX + hexagonSize * Math.cos(angle);\n    const y = centerY + hexagonSize * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制多边形\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexagonSize * 2, hexagonSize * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的 Sprite，放置在屏幕中央\n  const hexagonSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: hexagonSprite,        // 动画目标对象\n    rotation: Math.PI * 2,         // 旋转角度：2π 弧度（360度）\n    duration: 4000,                // 动画持续时间：4秒\n    ease: 'Linear',                // 线性缓动，保持匀速旋转\n    repeat: -1,                    // 无限循环（-1 表示永久重复）\n    yoyo: false                    // 不反向播放\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '红色六边形 4 秒旋转一周（循环）', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000629_v1", "prompt_id": "seed_000629", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 800，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动与跳跃，重力800，移动速度200，与地面碰撞不穿透\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力 y=800\n2. 使用 Graphics 创建玩家和地面的纹理\n3. 创建玩家精灵并启用物理，设置碰撞边界\n4. 创建静态地面平台组，添加多个平台\n5. 设置玩家与地面的碰撞检测\n6. 监听键盘输入（左右方向键和空格跳跃）\n7. 在 update 中处理移动逻辑（速度200）和跳跃逻辑\n8. 添加状态变量（jumpCount）用于验证游戏状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet platforms;\nlet cursors;\nlet spaceKey;\nlet jumpCount = 0; // 可验证的状态信号\nlet isGrounded = false;\n\nfunction preload() {\n  // 创建玩家纹理\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 48);\n  playerGraphics.generateTexture('player', 32, 48);\n  playerGraphics.destroy();\n\n  // 创建平台纹理\n  const platformGraphics = this.add.graphics();\n  platformGraphics.fillStyle(0x8B4513, 1);\n  platformGraphics.fillRect(0, 0, 200, 32);\n  platformGraphics.generateTexture('platform', 200, 32);\n  platformGraphics.destroy();\n\n  // 创建地面纹理\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x654321, 1);\n  groundGraphics.fillRect(0, 0, 800, 40);\n  groundGraphics.generateTexture('ground', 800, 40);\n  groundGraphics.destroy();\n}\n\nfunction create() {\n  // 创建静态平台组\n  platforms = this.physics.add.staticGroup();\n\n  // 添加地面\n  platforms.create(400, 580, 'ground').setScale(1).refreshBody();\n\n  // 添加多个平台\n  platforms.create(600, 450, 'platform');\n  platforms.create(200, 350, 'platform');\n  platforms.create(500, 250, 'platform');\n  platforms.create(100, 150, 'platform');\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 450, 'player');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 设置玩家与平台的碰撞\n  this.physics.add.collider(player, platforms, () => {\n    isGrounded = true;\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 添加文本显示状态\n  this.add.text(16, 16, 'Use Arrow Keys to Move, Space to Jump', {\n    fontSize: '18px',\n    fill: '#000'\n  });\n\n  this.jumpText = this.add.text(16, 40, 'Jumps: 0', {\n    fontSize: '18px',\n    fill: '#000'\n  });\n\n  this.statusText = this.add.text(16, 64, 'Status: Grounded', {\n    fontSize: '18px',\n    fill: '#000'\n  });\n}\n\nfunction update() {\n  // 重置接地状态\n  const touchingDown = player.body.touching.down;\n  \n  if (touchingDown) {\n    isGrounded = true;\n  }\n\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-200);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(200);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃逻辑\n  if (Phaser.Input.Keyboard.JustDown(spaceKey) && isGrounded) {\n    player.setVelocityY(-500);\n    jumpCount++;\n    isGrounded = false;\n    this.jumpText.setText('Jumps: ' + jumpCount);\n  }\n\n  // 更新状态文本\n  if (touchingDown) {\n    this.statusText.setText('Status: Grounded');\n  } else {\n    this.statusText.setText('Status: Airborne');\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001035_v3", "prompt_id": "seed_001035", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现3个物体的同步抖动动画，持续 2.5 秒后停止。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现3个物体的同步抖动动画，持续2.5秒后停止\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween#stop\nSTEPS:\n1. 使用 Graphics 创建3个不同颜色的矩形物体并生成纹理\n2. 在场景中创建3个精灵对象，分别使用生成的纹理\n3. 使用 Tween 系统为每个物体添加抖动动画（x/y坐标随机偏移）\n4. 设置动画持续时间为2.5秒，使用 yoyo 和 repeat 实现抖动效果\n5. 添加状态变量记录动画状态，动画结束后更新状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\n// 状态信号变量\nlet animationStatus = 'idle'; // 可能值: 'idle', 'shaking', 'completed'\nlet shakeCount = 0; // 抖动次数计数器\n\nfunction preload() {\n  // 使用 Graphics 生成三种颜色的纹理\n  const graphics = this.add.graphics();\n  \n  // 红色方块\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  graphics.generateTexture('redBox', 80, 80);\n  graphics.clear();\n  \n  // 绿色方块\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  graphics.generateTexture('greenBox', 80, 80);\n  graphics.clear();\n  \n  // 蓝色方块\n  graphics.fillStyle(0x0000ff, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  graphics.generateTexture('blueBox', 80, 80);\n  \n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建标题文本\n  const title = this.add.text(400, 50, 'Synchronized Shake Animation', {\n    fontSize: '28px',\n    color: '#ffffff',\n    fontStyle: 'bold'\n  });\n  title.setOrigin(0.5);\n  \n  // 创建状态显示文本\n  const statusText = this.add.text(400, 100, 'Status: Idle', {\n    fontSize: '20px',\n    color: '#ffff00'\n  });\n  statusText.setOrigin(0.5);\n  \n  // 创建计数器文本\n  const counterText = this.add.text(400, 130, 'Shake Count: 0', {\n    fontSize: '18px',\n    color: '#00ffff'\n  });\n  counterText.setOrigin(0.5);\n  \n  // 创建三个精灵对象，水平排列\n  const sprite1 = this.add.sprite(200, 300, 'redBox');\n  const sprite2 = this.add.sprite(400, 300, 'greenBox');\n  const sprite3 = this.add.sprite(600, 300, 'blueBox');\n  \n  // 存储初始位置\n  const initialPositions = [\n    { x: 200, y: 300 },\n    { x: 400, y: 300 },\n    { x: 600, y: 300 }\n  ];\n  \n  // 添加标签\n  this.add.text(200, 400, 'Red Box', {\n    fontSize: '16px',\n    color: '#ff6666'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 400, 'Green Box', {\n    fontSize: '16px',\n    color: '#66ff66'\n  }).setOrigin(0.5);\n  \n  this.add.text(600, 400, 'Blue Box', {\n    fontSize: '16px',\n    color: '#6666ff'\n  }).setOrigin(0.5);\n  \n  // 添加提示文本\n  const hintText = this.add.text(400, 500, 'Click anywhere to start shaking!', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n  hintText.setOrigin(0.5);\n  \n  // 点击开始抖动动画\n  this.input.on('pointerdown', () => {\n    if (animationStatus === 'idle' || animationStatus === 'completed') {\n      // 重置位置\n      sprite1.setPosition(initialPositions[0].x, initialPositions[0].y);\n      sprite2.setPosition(initialPositions[1].x, initialPositions[1].y);\n      sprite3.setPosition(initialPositions[2].x, initialPositions[2].y);\n      \n      // 更新状态\n      animationStatus = 'shaking';\n      shakeCount = 0;\n      statusText.setText('Status: Shaking');\n      counterText.setText('Shake Count: 0');\n      hintText.setText('Shaking in progress...');\n      \n      // 创建同步抖动动画\n      const sprites = [sprite1, sprite2, sprite3];\n      const tweens = [];\n      \n      sprites.forEach((sprite, index) => {\n        const initialX = initialPositions[index].x;\n        const initialY = initialPositions[index].y;\n        \n        // 为每个精灵创建抖动补间动画\n        const tween = this.tweens.add({\n          targets: sprite,\n          x: {\n            value: () => initialX + Phaser.Math.Between(-15, 15),\n            duration: 50,\n            ease: 'Linear'\n          },\n          y: {\n            value: () => initialY + Phaser.Math.Between(-15, 15),\n            duration: 50,\n            ease: 'Linear'\n          },\n          yoyo: false,\n          repeat: -1, // 无限重复\n          onRepeat: () => {\n            if (index === 0) { // 只在第一个物体时计数\n              shakeCount++;\n              counterText.setText(`Shake Count: ${shakeCount}`);\n            }\n          }\n        });\n        \n        tweens.push(tween);\n      });\n      \n      // 2.5秒后停止所有动画\n      this.time.delayedCall(2500, () => {\n        tweens.forEach((tween, index) => {\n          tween.stop();\n          // 恢复到初始位置\n          sprites[index].setPosition(\n            initialPositions[index].x,\n            initialPositions[index].y\n          );\n        });\n        \n        // 更新状态\n        animationStatus = 'completed';\n        statusText.setText('Status: Completed');\n        hintText.setText('Animation completed! Click to restart.');\n        \n        // 添加完成提示动画\n        this.tweens.add({\n          targets: [sprite1, sprite2, sprite3],\n          scale: { from: 1, to: 1.2 },\n          duration: 300,\n          yoyo: true,\n          ease: 'Sine.easeInOut'\n        });\n      });\n    }\n  });\n  \n  // 添加说明文本\n  const instructions = this.add.text(400, 550, 'Animation will last 2.5 seconds', {\n    fontSize: '14px',\n    color: '#aaaaaa'\n  });\n  instructions.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000835_v2", "prompt_id": "seed_000835", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "GameObjects"], "quality_score": 0.8920833333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 3 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成3个白色可收集物体，玩家碰到后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade.Factory#sprite, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，启用 Arcade Physics\n2. 使用 Graphics 生成玩家和收集物的纹理（玩家为绿色方块，收集物为白色圆形）\n3. 创建玩家精灵，添加键盘控制（方向键移动）\n4. 创建物理组，生成3个白色收集物并随机分布\n5. 添加碰撞检测，当玩家与收集物重叠时触发回调\n6. 在回调中销毁收集物、增加分数、更新分数文本\n7. 创建分数文本显示在屏幕左上角\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（白色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0xffffff, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成3个收集物\n  const positions = [\n    { x: 200, y: 150 },\n    { x: 600, y: 450 },\n    { x: 400, y: 100 }\n  ];\n\n  positions.forEach(pos => {\n    const collectible = collectibles.create(pos.x, pos.y, 'collectible');\n    collectible.setCircle(15); // 设置圆形碰撞体\n  });\n\n  // 添加碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#ffffff'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect White Circles', {\n    fontSize: '18px',\n    fontFamily: 'Arial',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 检查是否收集完所有物品\n  if (collectibles.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - All Collected!');\n  }\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000935_v3", "prompt_id": "seed_000935", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左上移动的六边形并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Polygon, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建场景并配置物理系统\n2. 使用 Graphics 绘制六边形纹理\n3. 创建物理精灵并应用六边形纹理\n4. 设置六边形向左上方向的速度\n5. 配置主相机跟随六边形对象\n6. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建背景网格以便观察相机移动\n    this.createBackground();\n\n    // 使用 Graphics 绘制六边形纹理\n    this.createHexagonTexture();\n\n    // 创建六边形精灵（位于场景中心）\n    this.hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n    this.hexagon.setScale(1.5);\n\n    // 设置六边形向左上方向移动\n    // 左上方向：x 为负，y 为负\n    const speed = 150;\n    const angle = -135; // 左上方向（-135度）\n    const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n    const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    \n    this.hexagon.setVelocity(velocityX, velocityY);\n\n    // 设置相机跟随六边形\n    this.cameras.main.startFollow(this.hexagon, true, 0.1, 0.1);\n    \n    // 设置相机边界（可选，让相机在更大的世界中移动）\n    this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n    this.physics.world.setBounds(-2000, -2000, 4000, 4000);\n\n    // 添加说明文字（固定在相机上）\n    const text = this.add.text(10, 10, '六边形向左上移动\\n相机跟随并保持居中', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机上，不随世界移动\n  }\n\n  createBackground() {\n    // 创建网格背景以便观察相机移动\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n\n    // 绘制更大范围的网格\n    const gridSize = 50;\n    const startX = -2000;\n    const startY = -2000;\n    const endX = 2000;\n    const endY = 2000;\n\n    // 垂直线\n    for (let x = startX; x <= endX; x += gridSize) {\n      graphics.lineBetween(x, startY, x, endY);\n    }\n\n    // 水平线\n    for (let y = startY; y <= endY; y += gridSize) {\n      graphics.lineBetween(startX, y, endX, y);\n    }\n\n    // 绘制中心十字标记\n    graphics.lineStyle(2, 0xff0000, 1);\n    graphics.lineBetween(-100, 0, 100, 0);\n    graphics.lineBetween(0, -100, 0, 100);\n  }\n\n  createHexagonTexture() {\n    // 创建六边形纹理\n    const graphics = this.add.graphics();\n    \n    // 计算六边形顶点\n    const radius = 30;\n    const points = [];\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n      const x = radius + Math.cos(angle) * radius;\n      const y = radius + Math.sin(angle) * radius;\n      points.push(new Phaser.Geom.Point(x, y));\n    }\n\n    // 绘制填充的六边形\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillPoints(points, true);\n\n    // 绘制边框\n    graphics.lineStyle(3, 0x00aa00, 1);\n    graphics.strokePoints(points, true);\n\n    // 生成纹理\n    graphics.generateTexture('hexagon', radius * 2, radius * 2);\n    graphics.destroy();\n  }\n\n  update(time, delta) {\n    // 可选：如果需要其他更新逻辑可以在这里添加\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000718_v2", "prompt_id": "seed_000718", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8872222222222222}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色椭圆，大小约为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色椭圆，大小约为 64 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为白色\n4. 使用 fillEllipse 在画布中央 (400, 300) 绘制椭圆，半径约为 32 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // 中心点在 (400, 300)，宽度和高度都设置为 64 像素\n  graphics.fillEllipse(400, 300, 64, 64);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000583_v2", "prompt_id": "seed_000583", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 3 个金币，重力 600，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色通过跳跃收集3个空中金币，重力600，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理世界，设置重力为600\n2. 使用Graphics绘制玩家角色（矩形）和地面平台\n3. 使用Graphics绘制3个金币（圆形）并设置物理属性\n4. 添加键盘输入监听（空格键跳跃，左右箭头移动）\n5. 实现碰撞检测：玩家与平台、玩家与金币\n6. 收集金币时增加分数并销毁金币\n7. 使用Text显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 创建金币纹理\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffff00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 添加分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff'\n    });\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.2);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 地面平台\n    this.platforms.create(400, 580, 'platform').setScale(4, 1).refreshBody();\n    \n    // 中间平台\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(50, 300, 'platform');\n    this.platforms.create(750, 250, 'platform');\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在空中放置3个金币\n    this.coins.create(600, 330, 'coin');\n    this.coins.create(50, 230, 'coin');\n    this.coins.create(750, 180, 'coin');\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n  }\n\n  update() {\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃（只能在地面上跳跃）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      this.add.text(400, 300, 'You Win!', {\n        fontSize: '64px',\n        fill: '#ffff00'\n      }).setOrigin(0.5);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000970_v1", "prompt_id": "seed_000970", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个灰色三角形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个灰色三角形，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置灰色填充样式 (0x808080)\n4. 计算画布中心点坐标 (400, 300)\n5. 使用 fillTriangle 绘制等边三角形，三个顶点相对中心点偏移约 16 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充样式\n  graphics.fillStyle(0x808080, 1);\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形大小约为 16 像素\n  const size = 16;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size / 2;\n  \n  // 顶点2：左下角\n  const x2 = centerX - size / 2;\n  const y2 = centerY + size / 2;\n  \n  // 顶点3：右下角\n  const x3 = centerX + size / 2;\n  const y3 = centerY + size / 2;\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加描边使三角形更清晰\n  graphics.lineStyle(1, 0x606060, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000604_v3", "prompt_id": "seed_000604", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个橙色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理20个橙色可复用对象，离屏自动回收\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建橙色圆形纹理用于对象显示\n2. 使用 Physics.Arcade.Group 创建对象池，设置最大数量为20\n3. 定时从对象池获取对象并发射到屏幕\n4. 在 update 中检测对象是否离开屏幕边界\n5. 离屏对象调用 kill() 回收到对象池\n6. 添加状态变量跟踪活跃对象数和总发射数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.totalSpawned = 0;     // 总发射数\n    this.recycledCount = 0;    // 回收次数\n  }\n\n  preload() {\n    // 创建橙色圆形纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xFF6600, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.generateTexture('orangeCircle', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池，最大20个对象\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'orangeCircle',\n      maxSize: 20,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 定时发射对象（每500ms发射一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界提示\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0xffffff, 0.3);\n    graphics.strokeRect(0, 0, 800, 600);\n\n    this.updateStatus();\n  }\n\n  spawnObject() {\n    // 从对象池获取或创建对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 激活对象\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 随机位置和速度\n      const spawnSide = Phaser.Math.Between(0, 3);\n      let x, y, velocityX, velocityY;\n      \n      switch(spawnSide) {\n        case 0: // 从左边发射\n          x = -20;\n          y = Phaser.Math.Between(50, 550);\n          velocityX = Phaser.Math.Between(100, 200);\n          velocityY = Phaser.Math.Between(-100, 100);\n          break;\n        case 1: // 从右边发射\n          x = 820;\n          y = Phaser.Math.Between(50, 550);\n          velocityX = Phaser.Math.Between(-200, -100);\n          velocityY = Phaser.Math.Between(-100, 100);\n          break;\n        case 2: // 从上边发射\n          x = Phaser.Math.Between(50, 750);\n          y = -20;\n          velocityX = Phaser.Math.Between(-100, 100);\n          velocityY = Phaser.Math.Between(100, 200);\n          break;\n        case 3: // 从下边发射\n          x = Phaser.Math.Between(50, 750);\n          y = 620;\n          velocityX = Phaser.Math.Between(-100, 100);\n          velocityY = Phaser.Math.Between(-200, -100);\n          break;\n      }\n      \n      obj.setPosition(x, y);\n      obj.setVelocity(velocityX, velocityY);\n      \n      this.totalSpawned++;\n      this.updateStatus();\n    }\n  }\n\n  update() {\n    // 检查所有活跃对象\n    const children = this.objectPool.getChildren();\n    this.activeCount = 0;\n    \n    children.forEach((obj) => {\n      if (obj.active) {\n        this.activeCount++;\n        \n        // 检测是否离开屏幕边界（带缓冲区）\n        const buffer = 50;\n        if (obj.x < -buffer || obj.x > 800 + buffer || \n            obj.y < -buffer || obj.y > 600 + buffer) {\n          // 回收对象\n          obj.setActive(false);\n          obj.setVisible(false);\n          obj.setVelocity(0, 0);\n          this.recycledCount++;\n        }\n      }\n    });\n    \n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const poolSize = this.objectPool.getLength();\n    const maxSize = this.objectPool.maxSize;\n    \n    this.statusText.setText([\n      `对象池状态:`,\n      `池大小: ${poolSize}/${maxSize}`,\n      `活跃对象: ${this.activeCount}`,\n      `总发射数: ${this.totalSpawned}`,\n      `回收次数: ${this.recycledCount}`,\n      `复用率: ${this.totalSpawned > 0 ? \n        ((this.recycledCount / this.totalSpawned) * 100).toFixed(1) : 0}%`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000939_v3", "prompt_id": "seed_000939", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色星形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个青色星形在2秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中使用 Graphics 绘制青色星形纹理\n3. 创建 Star 游戏对象并应用纹理\n4. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动，duration 为 2000ms\n5. 设置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制星形路径\n  const points = [];\n  const outerRadius = 40;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: 50 + Math.cos(angle) * radius,\n      y: 50 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.image(100, 300, 'star');\n  \n  // 创建补间动画：从左到右移动，然后往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 2000, // 2秒\n    ease: 'Linear',\n    yoyo: true, // 往返效果\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Star Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Cyan star moving left to right with yoyo loop', {\n    fontSize: '16px',\n    color: '#00ffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000389_v2", "prompt_id": "seed_000389", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 400，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色左右移动、跳跃、重力、地面碰撞的平台跳跃游戏\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 400\n2. 使用 Graphics 生成玩家和地面的纹理\n3. 创建玩家精灵和地面静态组，设置碰撞检测\n4. 监听键盘输入（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑（速度 200）和跳跃逻辑\n6. 添加状态变量记录跳跃次数作为可验证信号\n[/PLAN]\n\n```javascript\n// 平台跳跃游戏场景\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 生成玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 生成地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 200, 40);\n    groundGraphics.generateTexture('ground', 200, 40);\n    groundGraphics.destroy();\n\n    // 生成平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 150, 30);\n    platformGraphics.generateTexture('platform', 150, 30);\n    platformGraphics.destroy();\n  }\n\n  create() {\n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 创建地面静态组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加底部地面\n    this.platforms.create(100, 580, 'ground');\n    this.platforms.create(300, 580, 'ground');\n    this.platforms.create(500, 580, 'ground');\n    this.platforms.create(700, 580, 'ground');\n    \n    // 添加悬浮平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(500, 350, 'platform');\n    this.platforms.create(650, 250, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 400, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n    \n    // 设置玩家物理属性\n    this.player.body.setGravityY(400);\n\n    // 设置玩家与平台的碰撞\n    this.collider = this.physics.add.collider(\n      this.player, \n      this.platforms,\n      this.onPlayerLand,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, '← → 移动  空格/↑ 跳跃', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n\n    this.updateStatus();\n  }\n\n  onPlayerLand(player, platform) {\n    // 玩家着地时的回调\n    this.isGrounded = true;\n  }\n\n  update(time, delta) {\n    // 检查玩家是否在地面上\n    const touchingDown = this.player.body.touching.down;\n    \n    if (touchingDown) {\n      this.isGrounded = true;\n    }\n\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n      this.player.setFlipX(true);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n      this.player.setFlipX(false);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃逻辑\n    const jumpPressed = this.cursors.up.isDown || this.spaceKey.isDown;\n    \n    if (jumpPressed && this.isGrounded) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n      this.isGrounded = false;\n      this.updateStatus();\n    }\n\n    // 更新接地状态\n    if (!touchingDown && this.player.body.velocity.y > 0) {\n      this.isGrounded = false;\n    }\n\n    // 更新状态显示\n    if (time % 100 < delta) { // 每100ms更新一次\n      this.updateStatus();\n    }\n  }\n\n  updateStatus() {\n    const velocityY = Math.round(this.player.body.velocity.y);\n    const velocityX = Math.round(this.player.body.velocity.x);\n    const posY = Math.round(this.player.y);\n    \n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount}\\n` +\n      `位置: (${Math.round(this.player.x)}, ${posY})\\n` +\n      `速度: (${velocityX}, ${velocityY})\\n` +\n      `着地: ${this.isGrounded ? '是' : '否'}`\n    );\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 重力在玩家身上单独设置\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000840_v1", "prompt_id": "seed_000840", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左侧显示 \"Hello Phaser\" 文本，字体大小 64 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 64px，位置在屏幕左侧\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\n// 预加载函数（本例不需要加载外部资源）\nfunction preload() {\n  // 无需加载资源\n}\n\n// 创建函数\nfunction create() {\n  // 在屏幕左侧创建文本\n  // 参数：x坐标, y坐标, 文本内容, 样式配置\n  const text = this.add.text(50, 300, 'Hello Phaser', {\n    fontSize: '64px',\n    fontFamily: 'Arial',\n    color: '#ffffff'\n  });\n  \n  // 设置文本垂直居中对齐\n  text.setOrigin(0, 0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000450_v3", "prompt_id": "seed_000450", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让紫色矩形在 2 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色矩形，使用 Tween 动画在 2 秒内旋转 360 度并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.rotation\nSTEPS:\n1. 使用 Graphics 绘制紫色矩形并生成纹理\n2. 创建 Sprite 对象并应用生成的纹理\n3. 使用 tweens.add 创建旋转动画，设置 rotation 从 0 到 2π\n4. 设置动画持续时间为 2000ms，loop 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('purpleRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建 Sprite 并设置位置到屏幕中心\n  const rect = this.add.sprite(400, 300, 'purpleRect');\n  \n  // 设置旋转中心点（默认已经是中心，这里显式说明）\n  rect.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rect,           // 目标对象\n    rotation: Math.PI * 2,   // 旋转到 360 度（2π 弧度）\n    duration: 2000,          // 持续 2 秒\n    ease: 'Linear',          // 线性缓动，匀速旋转\n    loop: -1,                // -1 表示无限循环\n    repeat: 0                // repeat 为 0，使用 loop 控制循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Purple Rectangle Rotating', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000591_v1", "prompt_id": "seed_000591", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示\"Hello Phaser\"文字，字体大小80像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字内容为\"Hello Phaser\"，字体大小为80像素\n4. 将文字定位到屏幕下方中央位置\n5. 设置文字居中对齐以获得更好的视觉效果\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载任何资源\n}\n\nfunction create() {\n  // 创建文字对象\n  const text = this.add.text(\n    400,  // x 坐标：屏幕水平中心\n    550,  // y 坐标：屏幕下方位置\n    'Hello Phaser',  // 文字内容\n    {\n      fontSize: '80px',  // 字体大小\n      fontFamily: 'Arial',  // 字体系列\n      color: '#ffffff',  // 文字颜色（白色）\n      align: 'center'  // 文字对齐方式\n    }\n  );\n  \n  // 设置文字的原点为中心，使其居中显示\n  text.setOrigin(0.5, 0.5);\n}\n\n// 创建并启动 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000204_v1", "prompt_id": "seed_000204", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.alpha\nSTEPS:\n1. 使用 Graphics 绘制一个椭圆形状并生成纹理\n2. 创建一个使用该纹理的精灵对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续时间 1 秒\n4. 设置 Tween 为循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制椭圆（中心点在 100, 75，宽度 200，高度 150）\n  graphics.fillEllipse(100, 75, 200, 150);\n  \n  // 将 Graphics 生成为纹理\n  graphics.generateTexture('ellipseTexture', 200, 150);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用该纹理的精灵对象，放置在屏幕中心\n  const ellipseSprite = this.add.sprite(400, 300, 'ellipseTexture');\n  \n  // 设置初始 alpha 为 0（完全透明）\n  ellipseSprite.alpha = 0;\n  \n  // 创建 Tween 动画：从透明（alpha: 0）到不透明（alpha: 1）\n  this.tweens.add({\n    targets: ellipseSprite,           // 动画目标对象\n    alpha: 1,                          // 目标 alpha 值\n    duration: 1000,                    // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',                    // 线性缓动\n    yoyo: true,                        // 来回播放（透明->不透明->透明）\n    repeat: -1                         // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000237_v2", "prompt_id": "seed_000237", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 1.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Graphics 对象绘制矩形\n2. 设置矩形初始 alpha 为 0（完全透明）\n3. 使用 tweens.add 创建 alpha 补间动画，从 0 到 1，持续 1500ms\n4. 设置动画循环播放（loop: -1）和 yoyo 效果实现往返渐变\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4488ff, 1);\n  \n  // 在屏幕中心绘制一个 200x150 的矩形\n  const rectX = 300;\n  const rectY = 225;\n  const rectWidth = 200;\n  const rectHeight = 150;\n  graphics.fillRect(rectX, rectY, rectWidth, rectHeight);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建补间动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1,                // 目标透明度为 1（完全不透明）\n    duration: 1500,          // 持续时间 1.5 秒\n    ease: 'Linear',          // 线性缓动\n    yoyo: true,              // 往返播放（不透明后再回到透明）\n    loop: -1,                // 无限循环\n    repeat: 0                // yoyo 模式下不需要额外 repeat\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '矩形渐变动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '透明 ↔ 不透明 (1.5秒循环)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000503_v1", "prompt_id": "seed_000503", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 80 像素/秒速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建 Scene 配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 生成椭圆纹理\n3. 创建椭圆精灵对象并设置初始位置\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态计算速度并更新椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 生成椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色椭圆\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40, 30)，宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n\n  // 创建椭圆精灵，放置在画布中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n\n  // 添加 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间间隔(秒)\n  const distance = SPEED * (delta / 1000);\n\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n\n  // 根据按键状态设置移动方向\n  if (keys.w.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.s.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.a.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.d.isDown) {\n    velocityX = 1; // 向右\n  }\n\n  // 对角线移动时归一化速度（避免速度变快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const magnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= magnitude;\n    velocityY /= magnitude;\n  }\n\n  // 更新椭圆位置\n  ellipse.x += velocityX * distance;\n  ellipse.y += velocityY * distance;\n\n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 40, 760);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 30, 570);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000203_v1", "prompt_id": "seed_000203", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 360 像素/秒的速度移动\nAPI: this.input.keyboard.addKey(), this.add.graphics(), this.time.delta\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象作为可移动的玩家方块\n3. 添加 WASD 键盘监听\n4. 在 update 中根据按键状态和 delta 时间计算位置变化\n5. 更新方块位置实现移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet cursors;\nconst SPEED = 360; // 像素/秒\n\nfunction preload() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家方块，放置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n  \n  // 添加 WASD 键盘控制\n  cursors = {\n    w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the block', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间（秒）\n  const moveDistance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键并设置移动方向\n  if (cursors.w.isDown) {\n    velocityY = -1;\n  } else if (cursors.s.isDown) {\n    velocityY = 1;\n  }\n  \n  if (cursors.a.isDown) {\n    velocityX = -1;\n  } else if (cursors.d.isDown) {\n    velocityX = 1;\n  }\n  \n  // 如果同时按下两个方向键，进行归一化处理（保持对角线速度一致）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX * moveDistance;\n  player.y += velocityY * moveDistance;\n  \n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000016_v3", "prompt_id": "seed_000016", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色矩形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个24像素的绿色矩形\nAPI: Phaser.Game, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充样式为绿色（0x00ff00）\n4. 计算画布中心位置（400, 300），绘制 24x24 的矩形，矩形中心对齐画布中心\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算矩形左上角位置，使其中心位于画布中央\n  // 画布中心: (400, 300)\n  // 矩形大小: 24x24\n  // 左上角位置: (400 - 12, 300 - 12) = (388, 288)\n  const rectSize = 24;\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000125_v2", "prompt_id": "seed_000125", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色菱形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色菱形在1秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建 Sprite 使用菱形纹理\n3. 使用 Tween 动画让菱形从左移到右，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形（四个顶点）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形精灵，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左移到右，往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,              // 目标 x 坐标（右侧）\n    duration: 1000,      // 持续时间 1 秒\n    yoyo: true,          // 启用往返效果（到达终点后反向回到起点）\n    loop: -1,            // 无限循环（-1 表示永久循环）\n    ease: 'Linear'       // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000032_v2", "prompt_id": "seed_000032", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色矩形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现红色矩形在3秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置动画时长为 3000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建红色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  graphics.fillRect(0, 0, 80, 60); // 绘制 80x60 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('redRect', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'redRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（右侧）\n    duration: 3000,          // 持续时间 3 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向播放）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动函数，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Red Rectangle Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'The rectangle moves left-right in 3 seconds loop', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000163_v3", "prompt_id": "seed_000163", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现青色血条 UI：显示 10 格生命值，按鼠标左键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现青色血条 UI，10 格生命值，点击扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin, Phaser.GameObjects.Text, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建 Scene 配置，初始化生命值为 10\n2. 在 create 中使用 Graphics 绘制 10 个青色矩形表示血条\n3. 监听 pointerdown 事件，每次点击扣除 1 点生命值\n4. 更新血条显示，将扣除的生命值格子变为灰色\n5. 当生命值为 0 时，显示 \"Game Over\" 文本\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 当前生命值\n    this.maxHealth = 10; // 最大生命值\n    this.healthBars = []; // 存储血条矩形对象\n    this.gameOver = false; // 游戏结束标志\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 添加标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 添加提示文本\n    this.add.text(400, 100, 'Click anywhere to take damage', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 显示当前生命值文本\n    this.healthText = this.add.text(400, 250, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#00ffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 监听鼠标点击事件\n    this.input.on('pointerdown', this.takeDamage, this);\n  }\n\n  createHealthBar() {\n    const barWidth = 50; // 每格血条宽度\n    const barHeight = 30; // 血条高度\n    const barSpacing = 5; // 血条间距\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing) - barSpacing) / 2; // 居中起始位置\n    const startY = 150;\n\n    // 创建 10 个血条格子\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + barSpacing);\n      \n      // 使用 Graphics 绘制血条\n      const graphics = this.add.graphics();\n      \n      // 绘制青色填充矩形\n      graphics.fillStyle(0x00ffff, 1);\n      graphics.fillRect(x, startY, barWidth, barHeight);\n      \n      // 绘制白色边框\n      graphics.lineStyle(2, 0xffffff, 1);\n      graphics.strokeRect(x, startY, barWidth, barHeight);\n      \n      // 存储血条信息\n      this.healthBars.push({\n        graphics: graphics,\n        x: x,\n        y: startY,\n        width: barWidth,\n        height: barHeight,\n        active: true\n      });\n    }\n  }\n\n  takeDamage() {\n    // 如果游戏已结束，不再处理\n    if (this.gameOver) {\n      return;\n    }\n\n    // 扣除生命值\n    if (this.health > 0) {\n      this.health--;\n      \n      // 更新血条显示\n      this.updateHealthBar();\n      \n      // 更新生命值文本\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n      \n      // 检查是否游戏结束\n      if (this.health === 0) {\n        this.showGameOver();\n      }\n    }\n  }\n\n  updateHealthBar() {\n    // 从右到左更新血条（最后一个有效的血条变灰）\n    for (let i = this.maxHealth - 1; i >= 0; i--) {\n      if (this.healthBars[i].active && i >= this.health) {\n        const bar = this.healthBars[i];\n        \n        // 清除原有绘制\n        bar.graphics.clear();\n        \n        // 绘制灰色填充矩形（表示失去的生命值）\n        bar.graphics.fillStyle(0x333333, 1);\n        bar.graphics.fillRect(bar.x, bar.y, bar.width, bar.height);\n        \n        // 绘制白色边框\n        bar.graphics.lineStyle(2, 0x666666, 1);\n        bar.graphics.strokeRect(bar.x, bar.y, bar.width, bar.height);\n        \n        bar.active = false;\n        break;\n      }\n    }\n  }\n\n  showGameOver() {\n    this.gameOver = true;\n    \n    // 创建半透明黑色背景\n    const overlay = this.add.graphics();\n    overlay.fillStyle(0x000000, 0.7);\n    overlay.fillRect(0, 0, 800, 600);\n    \n    // 显示 Game Over 文本\n    this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold',\n      stroke: '#ffffff',\n      strokeThickness: 4\n    }).setOrigin(0.5);\n    \n    // 显示重新开始提示\n    this.add.text(400, 380, 'Refresh to restart', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加动画效果或其他更新逻辑\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: HealthBarScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000918_v1", "prompt_id": "seed_000918", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色六边形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色六边形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的六个顶点坐标（中心点在画布中央，半径 24 像素）\n4. 使用 Graphics API 绘制填充的绿色六边形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算六边形参数\n  const centerX = 400; // 画布中心 X\n  const centerY = 300; // 画布中心 Y\n  const radius = 24;   // 六边形半径（外接圆半径）\n  const sides = 6;     // 六边形有 6 条边\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制六边形的六个顶点\n  for (let i = 0; i < sides; i++) {\n    // 计算每个顶点的角度（从顶部开始，顺时针）\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度起始，使顶点朝上\n    \n    // 计算顶点坐标\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    // 第一个点使用 moveTo，后续点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000766_v3", "prompt_id": "seed_000766", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让紫色圆形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色圆形，使用 alpha 透明度补间动画实现 1.5 秒循环闪烁效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建 alpha 补间动画（从 1 到 0.2 再回到 1）\n4. 设置动画循环播放，持续时间 1.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建紫色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillCircle(50, 50, 50); // 在 (50,50) 位置绘制半径 50 的圆\n  graphics.generateTexture('purpleCircle', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建紫色圆形精灵，放置在屏幕中央\n  const circle = this.add.sprite(400, 300, 'purpleCircle');\n  \n  // 创建闪烁动画\n  // 使用 yoyo 模式实现闪烁效果：alpha 从 1 -> 0.2 -> 1\n  this.tweens.add({\n    targets: circle,\n    alpha: 0.2,           // 目标透明度（变暗）\n    duration: 750,        // 单程持续时间 0.75 秒\n    ease: 'Sine.easeInOut', // 平滑缓动\n    yoyo: true,           // 往返动画（0.75秒变暗 + 0.75秒变亮 = 1.5秒）\n    repeat: -1            // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Purple Circle Blinking (1.5s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000496_v2", "prompt_id": "seed_000496", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色菱形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色菱形，大小约为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 beginPath 开始路径，通过 moveTo 和 lineTo 绘制菱形的四个顶点\n5. 设置绿色填充样式，使用 fillPath 填充菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 菱形大小（从中心到顶点的距离）\n  const size = 12; // 总大小约为 24 像素\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充菱形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000091_v3", "prompt_id": "seed_000091", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象\n3. 使用 Tween 动画控制 Sprite 的 alpha 属性从 0 到 1\n4. 设置 Tween 为循环播放（yoyo + repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -50);      // 顶点\n  graphics.lineTo(-43, 25);     // 左下角\n  graphics.lineTo(43, 25);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 将 Graphics 生成为纹理\n  graphics.generateTexture('triangle', 86, 75);\n  \n  // 销毁 Graphics 对象（已生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的 Sprite\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始透明度为 0（完全透明）\n  triangle.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    alpha: 1,                    // 目标透明度值（完全不透明）\n    duration: 2000,              // 动画持续时间 2 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 反向播放（从 1 回到 0）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '三角形透明度循环动画 (2秒周期)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000532_v1", "prompt_id": "seed_000532", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 3 个橙色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，3个橙色可收集物体，碰撞后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成玩家和可收集物的纹理（绿色方块玩家，橙色圆形收集物）\n3. 创建物理精灵玩家，添加键盘控制\n4. 创建物理组包含3个橙色收集物，随机分布\n5. 添加 overlap 碰撞检测，碰撞时销毁收集物并增加分数\n6. 创建文本对象显示当前分数\n7. 在 update 中处理玩家移动逻辑\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成收集物纹理（橙色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffa500, 1);\n    collectibleGraphics.fillCircle(16, 16, 16);\n    collectibleGraphics.generateTexture('collectible', 32, 32);\n    collectibleGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n\n    // 生成3个收集物，随机位置\n    const positions = [\n      { x: 200, y: 150 },\n      { x: 600, y: 200 },\n      { x: 400, y: 450 }\n    ];\n\n    positions.forEach(pos => {\n      const collectible = this.collectibles.create(pos.x, pos.y, 'collectible');\n      collectible.setCircle(16); // 设置圆形碰撞体\n    });\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加说明文本\n    this.add.text(16, 560, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁收集物\n    collectible.destroy();\n\n    // 增加分数\n    this.score += 10;\n\n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0) {\n      this.add.text(400, 300, 'All Collected!', {\n        fontSize: '48px',\n        fill: '#ffff00',\n        fontFamily: 'Arial'\n      }).setOrigin(0.5);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000911_v2", "prompt_id": "seed_000911", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色矩形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色矩形在 2.5 秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在屏幕左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 duration 为 2500 毫秒，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 60, 40); // 绘制 60x40 的矩形\n  graphics.generateTexture('yellowRect', 60, 40);\n  graphics.destroy();\n\n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'yellowRect');\n\n  // 创建补间动画：从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: rect,\n    x: 700, // 目标 x 坐标（屏幕右侧）\n    duration: 2500, // 持续时间 2.5 秒\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动，匀速移动\n  });\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Yellow rectangle moving left-right in 2.5s loop', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000556_v3", "prompt_id": "seed_000556", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的三角形\nAPI: Graphics#fillTriangle, Camera#startFollow, Sprite#setVelocity, Physics.Arcade\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制三角形并生成纹理\n3. 创建物理精灵并设置向左下的速度\n4. 设置相机跟随该精灵对象\n5. 扩大世界边界以便三角形有足够移动空间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 扩大世界边界，让三角形有足够的移动空间\n  this.physics.world.setBounds(0, 0, 3200, 2400);\n  \n  // 使用 Graphics 绘制三角形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向右上的三角形\n  graphics.fillTriangle(\n    25, 0,   // 顶点（上）\n    0, 50,   // 左下\n    50, 50   // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵，放置在世界中心\n  this.player = this.physics.add.sprite(1600, 1200, 'triangle');\n  \n  // 设置向左下移动的速度\n  // 负 x 表示向左，正 y 表示向下\n  this.player.setVelocity(-150, 150);\n  \n  // 设置精灵的碰撞边界\n  this.player.setCollideWorldBounds(false);\n  \n  // 设置相机跟随三角形\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 3200, 2400);\n  \n  // 添加背景网格以便观察移动效果\n  this.createGrid();\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '三角形自动向左下移动\\n相机跟随中...', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 当前示例中三角形通过物理速度自动移动，不需要手动更新\n}\n\n// 辅助函数：创建网格背景以便观察相机移动\nfunction createGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 3200; x += 100) {\n    graphics.lineBetween(x, 0, x, 2400);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 2400; y += 100) {\n    graphics.lineBetween(0, y, 3200, y);\n  }\n  \n  // 添加坐标标记\n  for (let x = 0; x <= 3200; x += 400) {\n    for (let y = 0; y <= 2400; y += 400) {\n      const label = this.add.text(x + 5, y + 5, `(${x},${y})`, {\n        fontSize: '12px',\n        color: '#666666'\n      });\n    }\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000239_v3", "prompt_id": "seed_000239", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8842857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的红色三角形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 在随机位置绘制 3 个红色三角形，每个大小为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环 3 次创建 Graphics 对象\n3. 对每个 Graphics 使用 fillStyle 设置红色，用 fillTriangle 绘制等边三角形\n4. 使用 setRandomPosition 将三角形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 3 个红色三角形\n  for (let i = 0; i < 3; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 绘制等边三角形（大小为 80 像素）\n    // 三角形的三个顶点：顶部中心、左下、右下\n    const size = 80;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶点（顶部中心）\n      -size / 2, height / 2,    // 左下顶点\n      size / 2, height / 2      // 右下顶点\n    );\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const margin = size;\n    graphics.setPosition(\n      Phaser.Math.Between(margin, 800 - margin),\n      Phaser.Math.Between(margin, 600 - margin)\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000324_v2", "prompt_id": "seed_000324", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的紫色三角形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的紫色三角形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环5次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置紫色(0x800080)，使用 fillTriangle 绘制等边三角形\n4. 使用 setRandomPosition 将三角形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 三角形大小\n  const size = 64;\n  \n  // 计算等边三角形的顶点坐标（以中心为原点）\n  const height = (Math.sqrt(3) / 2) * size; // 等边三角形高度\n  const halfSize = size / 2;\n  \n  // 创建5个紫色三角形\n  for (let i = 0; i < 5; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充\n    graphics.fillStyle(0x800080, 1);\n    \n    // 绘制等边三角形（顶点朝上）\n    // 顶点1：顶部中心\n    // 顶点2：左下角\n    // 顶点3：右下角\n    graphics.fillTriangle(\n      0, -height / 2,           // 顶部顶点\n      -halfSize, height / 2,    // 左下顶点\n      halfSize, height / 2      // 右下顶点\n    );\n    \n    // 设置随机位置（考虑三角形大小，避免超出边界）\n    const margin = size;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000696_v2", "prompt_id": "seed_000696", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 500，移动速度 80，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色左右移动、跳跃、重力效果及地面碰撞的平台跳跃游戏\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 500\n2. 使用 Graphics 生成角色和地面的纹理\n3. 创建物理精灵并设置碰撞\n4. 监听键盘输入（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑，速度 80，跳跃速度 -330\n6. 添加状态变量（jumpCount）用于验证\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建角色纹理（使用 Graphics）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面\n    this.ground = this.physics.add.staticGroup();\n    this.ground.create(400, 575, 'ground');\n\n    // 创建多个平台\n    this.platforms = this.physics.add.staticGroup();\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 350, 'platform');\n    this.platforms.create(400, 250, 'platform');\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.ground, () => {\n      this.isGrounded = true;\n    });\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置接地状态（每帧检测）\n    const touchingDown = this.player.body.touching.down;\n    this.isGrounded = touchingDown;\n\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-80);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(80);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃逻辑\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.isGrounded) {\n      this.player.setVelocityY(-330);\n      this.jumpCount++;\n      this.updateStatusText();\n    }\n\n    // 如果玩家掉落到底部，重置位置\n    if (this.player.y > 600) {\n      this.player.setPosition(400, 100);\n      this.player.setVelocity(0, 0);\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Jump Count: ${this.jumpCount}\\n` +\n      `Position: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})\\n` +\n      `Grounded: ${this.isGrounded}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001036_v2", "prompt_id": "seed_001036", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色椭圆，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个粉色椭圆，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置粉色填充样式（0xFFC0CB）\n4. 使用 fillEllipse 在画布中央（400, 300）绘制椭圆，宽高为 24 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充样式\n  graphics.fillStyle(0xFFC0CB, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  graphics.fillEllipse(400, 300, 24, 24);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000121_v2", "prompt_id": "seed_000121", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色椭圆在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现橙色椭圆从左到右往返循环的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色椭圆并生成纹理\n2. 创建使用该纹理的精灵对象，初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动，持续 0.5 秒\n4. 设置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  \n  // 绘制椭圆（中心点在 0,0，宽度 80，高度 50）\n  graphics.fillEllipse(40, 25, 80, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('orangeEllipse', 80, 50);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象，初始位置在左侧\n  const ellipse = this.add.sprite(100, 300, 'orangeEllipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipse,\n    x: 700, // 移动到右侧\n    duration: 500, // 持续 0.5 秒（500 毫秒）\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000427_v3", "prompt_id": "seed_000427", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：15 个橙色小球以 120 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 15个橙色小球以120速度在封闭空间内移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.group, Body.setBounce, Physics.add.collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成橙色圆形纹理\n3. 创建物理组，添加 15 个小球精灵\n4. 为每个小球设置随机速度（总速度约 120）和完全弹性碰撞\n5. 设置世界边界碰撞和小球之间的碰撞检测\n6. 添加状态信号：碰撞计数器用于验证\n[/PLAN]\n\n```javascript\nclass BallBounceScene extends Phaser.Scene {\n  constructor() {\n    super('BallBounceScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n    this.totalBalls = 15; // 状态信号：小球总数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const width = this.cameras.main.width;\n    const height = this.cameras.main.height;\n\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8C00, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('orangeBall', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.ballGroup = this.physics.add.group({\n      key: 'orangeBall',\n      repeat: this.totalBalls - 1, // 创建15个小球\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 为每个小球设置随机位置和速度\n    const balls = this.ballGroup.getChildren();\n    balls.forEach((ball, index) => {\n      // 随机位置（避免重叠）\n      const x = Phaser.Math.Between(50, width - 50);\n      const y = Phaser.Math.Between(50, height - 50);\n      ball.setPosition(x, y);\n\n      // 设置随机速度方向，总速度约120\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const speed = 120;\n      const vx = Math.cos(angle) * speed;\n      const vy = Math.sin(angle) * speed;\n      ball.setVelocity(vx, vy);\n\n      // 设置圆形物理体（更准确的碰撞检测）\n      ball.body.setCircle(16);\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.ballGroup, this.ballGroup, this.onBallCollision, null, this);\n\n    // 添加信息文本显示状态\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 更新信息显示\n    this.updateInfo();\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调：增加碰撞计数\n    this.collisionCount++;\n    this.updateInfo();\n  }\n\n  updateInfo() {\n    // 更新状态信息显示\n    this.infoText.setText([\n      `小球数量: ${this.totalBalls}`,\n      `碰撞次数: ${this.collisionCount}`,\n      `目标速度: 120 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 可选：监控小球速度，确保保持在目标速度附近\n    // 由于是完全弹性碰撞，速度应该保持恒定\n    const balls = this.ballGroup.getChildren();\n    balls.forEach(ball => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏差过大，进行微调（防止数值误差累积）\n      if (Math.abs(currentSpeed - 120) > 5) {\n        const scale = 120 / currentSpeed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false // 设为 true 可查看物理边界\n    }\n  },\n  scene: BallBounceScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000941_v2", "prompt_id": "seed_000941", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色椭圆并生成纹理\n3. 创建物理精灵并应用椭圆纹理\n4. 设置初始速度为 200（斜向移动）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制椭圆（中心在 50, 30，宽 100，高 60）\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 100, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（斜向移动，速度大小约为 200）\n  // 使用勾股定理：√(141² + 141²) ≈ 200\n  ellipse.setVelocity(141, 141);\n  \n  // 设置与世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000126_v1", "prompt_id": "seed_000126", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 1000，移动速度 120，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现带重力的平台跳跃游戏，角色可左右移动和跳跃，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup, this.physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 1000\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建物理精灵作为玩家，创建静态物理组作为地面平台\n4. 设置键盘输入监听（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑（速度 120）和跳跃逻辑\n6. 添加碰撞检测防止角色穿透地面\n7. 添加状态变量记录跳跃次数作为可验证信号\n[/PLAN]\n\n```javascript\n// 平台跳跃游戏场景\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号：跳跃次数\n    this.isGrounded = false; // 是否在地面上\n  }\n\n  preload() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（棕色矩形）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8B4513, 1);\n    groundGraphics.fillRect(0, 0, 200, 40);\n    groundGraphics.generateTexture('ground', 200, 40);\n    groundGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x808080, 1);\n    platformGraphics.fillRect(0, 0, 150, 30);\n    platformGraphics.generateTexture('platform', 150, 30);\n    platformGraphics.destroy();\n  }\n\n  create() {\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#87CEEB');\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setCollideWorldBounds(true); // 限制在世界边界内\n    this.player.setBounce(0); // 不反弹\n\n    // 创建地面和平台静态组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加地面\n    this.platforms.create(100, 580, 'ground');\n    this.platforms.create(300, 580, 'ground');\n    this.platforms.create(500, 580, 'ground');\n    this.platforms.create(700, 580, 'ground');\n\n    // 添加平台\n    this.platforms.create(400, 450, 'platform');\n    this.platforms.create(600, 350, 'platform');\n    this.platforms.create(200, 300, 'platform');\n    this.platforms.create(700, 250, 'platform');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      // 碰撞时标记为在地面上\n      if (this.player.body.touching.down) {\n        this.isGrounded = true;\n      }\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setScrollFactor(0);\n\n    // 添加说明文本\n    this.add.text(16, 50, '← → 移动  空格/↑ 跳跃', {\n      fontSize: '16px',\n      fill: '#000',\n      backgroundColor: '#fff',\n      padding: { x: 10, y: 5 }\n    }).setScrollFactor(0);\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置地面状态\n    if (!this.player.body.touching.down) {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-120);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(120);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（空格键或上方向键）\n    if ((Phaser.Input.Keyboard.JustDown(this.spaceKey) || \n         Phaser.Input.Keyboard.JustDown(this.cursors.up)) && \n        this.isGrounded) {\n      this.player.setVelocityY(-500); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n      this.isGrounded = false;\n      this.updateStatusText();\n    }\n\n    // 更新状态文本\n    if (time % 100 < delta) { // 每100ms更新一次\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    const velocity = Math.abs(this.player.body.velocity.x).toFixed(0);\n    const posY = this.player.y.toFixed(0);\n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount} | 速度: ${velocity} | 高度: ${posY} | ${this.isGrounded ? '地面' : '空中'}`\n    );\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 }, // 重力设置为 1000\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000930_v1", "prompt_id": "seed_000930", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8906060606060605}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个星形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制星形以 240 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes, graphics.fillStar()\nSTEPS:\n1. 创建 Scene 配置和游戏实例\n2. 在 create 中使用 Graphics 绘制星形并生成纹理\n3. 创建 Sprite 并设置星形纹理\n4. 添加 WASD 键盘监听（使用 addKey 方法）\n5. 在 update 中根据按键状态计算移动方向并更新位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制五角星\n  // 参数：x, y, points(角数), innerRadius(内半径), outerRadius(外半径)\n  graphics.fillStar(32, 32, 5, 12, 28);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 64, 64);\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中心\n  star = this.add.sprite(400, 300, 'starTexture');\n  \n  // 添加 WASD 键监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键状态并设置速度方向\n  if (keyW.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keyS.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keyA.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keyD.isDown) {\n    velocityX = 1; // 向右\n  }\n  \n  // 如果同时按下多个键，需要归一化速度向量\n  if (velocityX !== 0 && velocityY !== 0) {\n    // 对角线移动时，保持速度恒定（避免斜向移动更快）\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新星形位置\n  star.x += velocityX * moveDistance;\n  star.y += velocityY * moveDistance;\n  \n  // 边界限制（可选，防止星形移出屏幕）\n  star.x = Phaser.Math.Clamp(star.x, 0, 800);\n  star.y = Phaser.Math.Clamp(star.y, 0, 600);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000120_v2", "prompt_id": "seed_000120", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 3 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在3秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 使用生成的三角形纹理\n3. 使用 Tween 实现缩放动画：从 scale=1 到 scale=0.24，持续3秒\n4. 设置 yoyo=true 实现往返效果，loop=-1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制一个等边三角形（中心点为原点）\n  const triangleSize = 100;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize);  // 顶点\n  graphics.lineTo(-triangleSize * Math.sin(Math.PI / 3), triangleSize / 2);  // 左下角\n  graphics.lineTo(triangleSize * Math.sin(Math.PI / 3), triangleSize / 2);   // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize * 2, triangleSize * 2);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成了纹理\n  \n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标\n    scaleX: 0.24,               // X轴缩放到24%\n    scaleY: 0.24,               // Y轴缩放到24%\n    duration: 3000,             // 持续3秒（3000毫秒）\n    yoyo: true,                 // 往返效果：缩小后再恢复\n    loop: -1,                   // 无限循环（-1表示永久循环）\n    ease: 'Linear'              // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Triangle scaling from 100% to 24% in 3 seconds (looping)', {\n    fontSize: '16px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000098_v2", "prompt_id": "seed_000098", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个自动向右上移动的圆形，相机跟随该圆形并保持居中显示\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Container, Phaser.Cameras.Scene2D.Camera#setBounds\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个 Sprite 对象作为移动目标\n3. 在 update 中让目标持续向右上方移动（x++, y--）\n4. 使用 camera.startFollow() 让相机跟随该目标\n5. 设置相机边界和世界边界以展示跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet target;\nlet camera;\n\nfunction preload() {\n  // 使用 Graphics 创建圆形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，让场景更大以展示相机跟随效果\n  this.physics.world.setBounds(0, 0, 3000, 3000);\n  \n  // 添加网格背景以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制网格\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.lineBetween(x, 0, x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加坐标标记\n  const style = { fontSize: '16px', fill: '#00ff00' };\n  for (let x = 0; x <= 3000; x += 500) {\n    for (let y = 0; y <= 3000; y += 500) {\n      this.add.text(x + 10, y + 10, `(${x},${y})`, style);\n    }\n  }\n  \n  // 创建移动目标（圆形）\n  target = this.add.sprite(400, 300, 'circle');\n  \n  // 添加速度属性\n  target.velocityX = 2;\n  target.velocityY = -1.5;\n  \n  // 获取主相机\n  camera = this.cameras.main;\n  \n  // 设置相机边界（与世界边界一致）\n  camera.setBounds(0, 0, 3000, 3000);\n  \n  // 让相机跟随目标，第二个参数为是否圆滑跟随\n  camera.startFollow(target, true);\n  \n  // 可选：设置跟随的平滑度（lerp值，0-1之间，越小越平滑但延迟越大）\n  camera.setLerp(0.1, 0.1);\n  \n  // 添加提示文本（固定在相机视图上）\n  const instructions = this.add.text(10, 10, \n    '相机正在跟随红色圆形\\n圆形向右上方移动', \n    { \n      fontSize: '20px', \n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }\n  );\n  instructions.setScrollFactor(0); // 固定在相机视图上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 让目标持续向右上方移动\n  target.x += target.velocityX;\n  target.y += target.velocityY;\n  \n  // 可选：当目标到达边界时反弹\n  if (target.x > 2950 || target.x < 50) {\n    target.velocityX *= -1;\n  }\n  if (target.y > 2950 || target.y < 50) {\n    target.velocityY *= -1;\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000544_v2", "prompt_id": "seed_000544", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色星形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现红色星形左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Scene 配置，设置画布尺寸\n2. 在 create 中使用 Graphics 绘制红色星形或使用 Star 游戏对象\n3. 使用 tweens.add 创建 x 轴移动补间，设置 duration 为 1500ms\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 方法1：使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  \n  // 绘制星形（5个顶点）\n  const centerX = 100;\n  const centerY = 300;\n  const outerRadius = 40;\n  const innerRadius = 20;\n  const points = 5;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (Math.PI / points) * i - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: graphics,\n    x: 700 - 100, // 移动到右侧（总宽度800，减去初始位置100，再减去星形宽度）\n    duration: 1500, // 1.5秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环\n    ease: 'Linear' // 线性移动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '红色星形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '循环次数：无限 | 单程时长：1.5秒', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000178_v3", "prompt_id": "seed_000178", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色六边形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色六边形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的六个顶点坐标（中心点在画布中央，半径约 40 像素）\n4. 使用 Graphics API 绘制六边形路径并填充黄色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 计算六边形参数\n  const centerX = 400; // 画布中心 X\n  const centerY = 300; // 画布中心 Y\n  const radius = 40;   // 六边形半径（从中心到顶点的距离）\n  const sides = 6;     // 六边形有 6 个边\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制六边形的六个顶点\n  for (let i = 0; i < sides; i++) {\n    // 计算当前顶点的角度（从顶部开始，逆时针）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    \n    // 计算顶点坐标\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    // 第一个点使用 moveTo，后续点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000603_v3", "prompt_id": "seed_000603", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让粉色星形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个粉色星形，使用 Tween 动画实现 1 秒内旋转 360 度并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制粉色星形（五角星）\n2. 将 Graphics 转换为纹理并创建 Sprite\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 设置动画持续时间为 1000ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制五角星\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1); // 粉色 (HotPink)\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    starPoints.push(x, y);\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0], starPoints[1]);\n  for (let i = 2; i < starPoints.length; i += 2) {\n    graphics.lineTo(starPoints[i], starPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 将 Graphics 生成为纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成纹理\n  \n  // 创建使用该纹理的 Sprite，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    angle: 360,              // 旋转到 360 度\n    duration: 1000,          // 持续时间 1 秒\n    ease: 'Linear',          // 线性缓动，保持匀速旋转\n    repeat: -1,              // 无限循环 (-1 表示永久重复)\n    onRepeat: function() {\n      // 每次重复时重置角度，避免角度累积\n      star.angle = 0;\n    }\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Pink Star Rotating Animation', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000350_v3", "prompt_id": "seed_000350", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在4秒内缩放到24%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个椭圆形状\n2. 创建一个 Tween 动画，设置缩放从 1 到 0.24\n3. 设置动画持续时间为 2 秒（单程），yoyo 为 true 实现往返，总计 4 秒\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置椭圆的中心位置\n  const centerX = 400;\n  const centerY = 300;\n  const radiusX = 120; // 椭圆横向半径\n  const radiusY = 80;  // 椭圆纵向半径\n  \n  // 绘制填充椭圆\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillEllipse(centerX, centerY, radiusX, radiusY);\n  \n  // 设置椭圆的原点为中心，方便缩放\n  graphics.x = 0;\n  graphics.y = 0;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.24,  // 缩放到 24%\n    scaleY: 0.24,  // 缩放到 24%\n    duration: 2000, // 单程持续 2 秒\n    yoyo: true,     // 往返播放（2秒缩小 + 2秒恢复 = 4秒完整周期）\n    loop: -1,       // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Ellipse Scale Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scaling from 100% to 24% and back in 4 seconds (looping)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000265_v1", "prompt_id": "seed_000265", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右上显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右上角显示 \"Hello Phaser\" 文字，字体大小 64 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字内容为 \"Hello Phaser\"，字体大小 64px\n4. 将文字定位到屏幕右上角，使用 setOrigin 调整锚点\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建文字对象\n  const text = this.add.text(\n    this.cameras.main.width,  // x 坐标：屏幕右边缘\n    0,                         // y 坐标：屏幕顶部\n    'Hello Phaser',           // 文字内容\n    {\n      fontSize: '64px',       // 字体大小\n      fill: '#ffffff',        // 文字颜色（白色）\n      fontFamily: 'Arial'     // 字体\n    }\n  );\n\n  // 设置锚点为右上角 (1, 0)，使文字从右上角开始绘制\n  text.setOrigin(1, 0);\n\n  // 添加一些内边距，避免文字紧贴边缘\n  text.setPosition(this.cameras.main.width - 20, 20);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000300_v3", "prompt_id": "seed_000300", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色星形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色星形以160速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带有 Arcade 物理系统的 Game 配置\n2. 在 create 中使用 Graphics 绘制蓝色星形纹理\n3. 创建物理精灵并应用星形纹理，设置速度为160\n4. 设置精灵与世界边界碰撞并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  \n  // 绘制星形（5个点，外半径30，内半径15）\n  const points = 5;\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const centerX = 32;\n  const centerY = 32;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  this.star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置速度（随机方向，速度为160）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 160);\n  this.star.setVelocity(velocity.x, velocity.y);\n  \n  // 设置与世界边界碰撞\n  this.star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  this.star.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 不需要额外的更新逻辑，物理系统会自动处理移动和反弹\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000788_v2", "prompt_id": "seed_000788", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的灰色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的灰色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布尺寸\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 使用数学计算绘制正六边形的6个顶点坐标（半径16像素）\n4. 为每个六边形设置随机位置（x: 50-750, y: 50-550，避免边缘裁剪）\n5. 使用灰色填充六边形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制12个随机位置的灰色六边形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置灰色填充\n    graphics.fillStyle(0x808080, 1);\n    \n    // 六边形参数\n    const size = 32; // 六边形大小（顶点到中心的距离）\n    const radius = size / 2; // 半径为16像素\n    \n    // 随机位置（留出边距避免六边形被裁剪）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点并绘制\n    // 从顶部顶点开始，逆时针绘制\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j - Math.PI / 2; // 每个顶点间隔60度，起始角度-90度\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(vx, vy);\n      } else {\n        graphics.lineTo(vx, vy);\n      }\n    }\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000587_v2", "prompt_id": "seed_000587", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让红色星形在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色星形淡入淡出循环动画，每次循环0.5秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Star\nSTEPS:\n1. 使用 Graphics 绘制红色星形并生成纹理\n2. 创建 Sprite 对象使用生成的星形纹理\n3. 使用 Tween 系统创建 alpha 属性动画（0→1→0）\n4. 设置 yoyo 和 repeat 实现循环淡入淡出效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制星形（5个点）\n  // 星形中心点为 (64, 64)，外半径 60，内半径 30\n  const centerX = 64;\n  const centerY = 64;\n  const outerRadius = 60;\n  const innerRadius = 30;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 128, 128);\n  graphics.destroy();\n  \n  // 创建星形精灵并放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'starTexture');\n  \n  // 设置初始 alpha 为 0（完全透明）\n  star.setAlpha(0);\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入后自动淡出\n  // repeat: -1 实现无限循环\n  this.tweens.add({\n    targets: star,\n    alpha: 1,              // 目标 alpha 值为 1（完全不透明）\n    duration: 250,         // 淡入时间 0.25 秒\n    yoyo: true,            // 启用 yoyo 效果，到达目标后反向播放（淡出）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '红色星形淡入淡出循环动画 (0.5秒/周期)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000521_v2", "prompt_id": "seed_000521", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的紫色矩形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的紫色矩形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置紫色，fillRect 绘制 24x24 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充 (紫色通常为 0x800080 或 0x9400D3)\n  graphics.fillStyle(0x800080, 1);\n  \n  // 绘制10个随机位置的矩形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保矩形完全在画布内\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const x = Math.random() * (800 - 24);\n    const y = Math.random() * (600 - 24);\n    \n    // 绘制 24x24 的矩形\n    graphics.fillRect(x, y, 24, 24);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000650_v1", "prompt_id": "seed_000650", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的蓝色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的蓝色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布尺寸\n2. 在 create 方法中循环20次\n3. 每次循环创建一个 Graphics 对象，设置蓝色填充\n4. 使用 fillTriangle 绘制等边三角形（大小16像素）\n5. 使用 setRandomPosition 或随机坐标设置三角形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建20个随机位置的蓝色三角形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置蓝色填充\n    graphics.fillStyle(0x0000ff, 1);\n    \n    // 绘制等边三角形（顶点朝上）\n    // 三角形大小为16像素，以中心为原点\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶点（上）\n      -size / 2, height / 2,    // 左下顶点\n      size / 2, height / 2      // 右下顶点\n    );\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const x = Phaser.Math.Between(size, config.width - size);\n    const y = Phaser.Math.Between(size, config.height - size);\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000781_v2", "prompt_id": "seed_000781", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的蓝色方块，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的蓝色方块，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中使用循环创建 3 个 Graphics 对象\n3. 为每个 Graphics 对象设置蓝色填充样式并绘制 32x32 的矩形\n4. 使用 setRandomPosition 方法将每个方块放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建3个蓝色方块\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置蓝色填充样式 (RGB: 0, 0, 255)\n    graphics.fillStyle(0x0000ff, 1);\n    \n    // 绘制 32x32 的矩形，以中心点为原点\n    graphics.fillRect(-16, -16, 32, 32);\n    \n    // 设置随机位置\n    // 确保方块完全在画布内（边距16像素）\n    graphics.setRandomPosition(16, 16, 800 - 32, 600 - 32);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000614_v2", "prompt_id": "seed_000614", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色六边形在 4 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色六边形，使用 Tween 实现 4 秒循环的抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制青色六边形并生成纹理\n2. 创建 Sprite 对象使用生成的六边形纹理\n3. 使用 Tween 创建抖动动画，通过快速改变 x 和 y 位置模拟抖动\n4. 设置 Tween 循环播放，duration 为 4000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制青色六边形\n  const graphics = this.add.graphics();\n  \n  // 绘制六边形\n  const hexRadius = 60;\n  const hexColor = 0x00ffff; // 青色\n  \n  graphics.fillStyle(hexColor, 1);\n  graphics.beginPath();\n  \n  // 计算六边形的六个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = hexRadius + Math.cos(angle) * hexRadius;\n    const y = hexRadius + Math.sin(angle) * hexRadius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  const textureSize = hexRadius * 2 + 10;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建六边形精灵\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建抖动动画\n  // 使用多个快速的小幅度移动来模拟抖动效果\n  this.tweens.add({\n    targets: hexSprite,\n    x: {\n      value: '+=10',\n      duration: 50,\n      ease: 'Linear',\n      yoyo: true,\n      repeat: 3\n    },\n    y: {\n      value: '+=8',\n      duration: 60,\n      ease: 'Linear',\n      yoyo: true,\n      repeat: 3\n    },\n    duration: 4000,\n    loop: -1, // 无限循环\n    onLoop: () => {\n      // 每次循环重置位置，确保抖动从中心开始\n      hexSprite.x = 400;\n      hexSprite.y = 300;\n    }\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '青色六边形抖动动画 (4秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000316_v2", "prompt_id": "seed_000316", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色矩形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个24像素的黄色矩形\nAPI: Phaser.Game, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充颜色为黄色（0xffff00）\n4. 计算中央位置并绘制 24x24 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 计算中央位置\n  // 矩形左上角坐标 = (画布中心 - 矩形大小的一半)\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectSize = 24;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 在中央绘制 24x24 的黄色矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000229_v2", "prompt_id": "seed_000229", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 4 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在4秒内缩放到32%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillStyle, graphics.fillPath, this.tweens.add, Phaser.Geom.Polygon\nSTEPS:\n1. 使用 Graphics 绘制一个六边形\n2. 创建 Tween 动画，设置 scaleX 和 scaleY 从 1 到 0.32\n3. 配置 Tween 为 yoyo 模式（往返）和 loop 模式（循环）\n4. 设置总时长为 4 秒（单程 2 秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算六边形的顶点坐标\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 80;\n  const sides = 6;\n  const points = [];\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 创建多边形并填充\n  const hexagon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(hexagon.points, true);\n  \n  // 创建缩放动画\n  // yoyo: true 表示动画会自动反向播放（缩小后放大）\n  // loop: -1 表示无限循环\n  // duration: 2000 表示单程2秒，往返共4秒\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 2000,        // 单程时长2秒\n    yoyo: true,            // 启用往返模式\n    loop: -1,              // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '六边形缩放动画 (100% ↔ 32%)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '4秒循环：2秒缩小到32% + 2秒恢复到100%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000722_v1", "prompt_id": "seed_000722", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个星形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制星形以 240 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes, graphics.fillStar()\nSTEPS:\n1. 创建 Graphics 对象绘制星形\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态更新星形位置，速度为 240 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 星形对象和按键\nlet star;\nlet keyW, keyA, keyS, keyD;\nconst speed = 240; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制星形\n  star = this.add.graphics();\n  star.x = 400; // 初始位置 x\n  star.y = 300; // 初始位置 y\n  \n  // 绘制黄色星形\n  star.fillStyle(0xffff00, 1);\n  star.fillStar(0, 0, 5, 20, 40); // 中心点(0,0)，5个角，内半径20，外半径40\n  \n  // 添加 WASD 键监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the star', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离 = 速度 * 时间增量（转换为秒）\n  const distance = speed * (delta / 1000);\n  \n  // 根据按键状态移动星形\n  if (keyW.isDown) {\n    star.y -= distance; // 向上移动\n  }\n  if (keyS.isDown) {\n    star.y += distance; // 向下移动\n  }\n  if (keyA.isDown) {\n    star.x -= distance; // 向左移动\n  }\n  if (keyD.isDown) {\n    star.x += distance; // 向右移动\n  }\n  \n  // 边界限制（可选）\n  star.x = Phaser.Math.Clamp(star.x, 0, 800);\n  star.y = Phaser.Math.Clamp(star.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000120_v1", "prompt_id": "seed_000120", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色圆形在 0.5 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色圆形，使用 tween 实现 0.5 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制灰色圆形并生成纹理\n2. 创建使用该纹理的 Sprite 对象\n3. 使用 tweens 创建抖动动画（通过快速改变 x 坐标实现抖动）\n4. 设置 tween 为循环模式，持续时间 0.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillCircle(50, 50, 50); // 圆心在 (50, 50)，半径 50\n  \n  // 生成纹理\n  graphics.generateTexture('grayCircle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 在屏幕中心创建圆形精灵\n  const circle = this.add.sprite(400, 300, 'grayCircle');\n  \n  // 创建抖动动画\n  // 抖动效果：通过快速左右移动实现\n  this.tweens.add({\n    targets: circle,\n    x: '+=10', // 向右移动 10 像素\n    duration: 50, // 单次移动持续 50 毫秒\n    yoyo: true, // 往返运动\n    repeat: 4, // 重复 4 次（总共 5 次移动，构成完整抖动）\n    ease: 'Sine.easeInOut',\n    loop: -1, // 无限循环\n    loopDelay: 0 // 每次循环间隔 0 毫秒\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '灰色圆形抖动动画（0.5秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000224_v3", "prompt_id": "seed_000224", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色星形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色星形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#generateTexture, Phaser.GameObjects.Image, Phaser.Tweens.TweenManager#add, Phaser.Tweens.BaseTween#yoyo\nSTEPS:\n1. 使用 Graphics 绘制红色星形并生成纹理\n2. 创建使用该纹理的 Image 对象，初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左移到右，duration 2500ms\n4. 设置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = Math.cos(angle) * radius + 50;\n    const y = Math.sin(angle) * radius + 50;\n    starPoints.push(x, y);\n  }\n  \n  graphics.fillPoints(starPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形图像对象，初始位置在左侧\n  const star = this.add.image(100, 300, 'star');\n  \n  // 创建补间动画：从左移到右，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧（800 - 100 = 700）\n    duration: 2500, // 2.5秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环\n    ease: 'Linear' // 线性运动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000008_v2", "prompt_id": "seed_000008", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的橙色菱形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制8个橙色菱形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置橙色，使用 fillPath 绘制菱形路径（4个顶点）\n4. 使用 setRandomPosition 将每个菱形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建8个橙色菱形\n  for (let i = 0; i < 8; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xFFA500, 1);\n    \n    // 绘制菱形（菱形中心在原点）\n    // 菱形大小为24像素，所以半径为12像素\n    const path = new Phaser.Geom.Polygon([\n      0, -12,    // 上顶点\n      12, 0,     // 右顶点\n      0, 12,     // 下顶点\n      -12, 0     // 左顶点\n    ]);\n    \n    graphics.fillPoints(path.points, true);\n    \n    // 设置随机位置（考虑边界，避免菱形超出画布）\n    const x = Phaser.Math.Between(20, 780);\n    const y = Phaser.Math.Between(20, 580);\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000315_v2", "prompt_id": "seed_000315", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右侧显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.GameObjects.Text, Scene.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字内容为 \"Hello Phaser\"，字体大小 32px\n4. 将文字定位到屏幕右侧（x 坐标接近画布宽度）\n5. 设置文字对齐方式，确保显示在右侧区域\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右侧创建文字\n  // x 坐标设置为 750（距离右边缘 50 像素）\n  // y 坐标设置为屏幕中央\n  const text = this.add.text(750, 300, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字锚点为右中，确保文字从右侧对齐\n  text.setOrigin(1, 0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000071_v2", "prompt_id": "seed_000071", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 360 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Scene.update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形，并在圆形上添加标记（如一条线）以便观察旋转\n2. 将 Graphics 添加到场景中央\n3. 在 update 方法中根据 delta 时间计算旋转角度增量\n4. 每帧更新 Graphics 的 rotation 属性，实现每秒 360 度（2π 弧度）的旋转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  circle = this.add.graphics();\n  \n  // 设置圆形位置到屏幕中央\n  circle.x = 400;\n  circle.y = 300;\n  \n  // 绘制圆形主体\n  circle.fillStyle(0x00aaff, 1);\n  circle.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的线作为旋转标记\n  circle.lineStyle(4, 0xffffff, 1);\n  circle.beginPath();\n  circle.moveTo(0, 0);\n  circle.lineTo(80, 0);\n  circle.strokePath();\n  \n  // 在圆形边缘添加一个小圆点作为额外的旋转参考\n  circle.fillStyle(0xff0000, 1);\n  circle.fillCircle(80, 0, 10);\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '圆形以每秒 360° 的速度旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量\n  // 每秒 360 度 = 2π 弧度/秒\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = Math.PI * 2; // 2π 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 根据帧时间计算旋转增量\n  \n  // 更新圆形的旋转角度\n  circle.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000681_v3", "prompt_id": "seed_000681", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色方块以200速度移动并在画布边界反弹\nAPI: Graphics.fillRect, Graphics.generateTexture, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建 Phaser 游戏配置，启用 Arcade 物理系统\n2. 在 create 中使用 Graphics 生成红色方块纹理\n3. 创建物理精灵并设置初始速度为 200\n4. 设置精灵与世界边界碰撞并反弹\n5. 设置反弹系数为 1 实现完美弹性碰撞\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成红色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('redSquare', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵，放置在画布中心\n  const square = this.physics.add.sprite(400, 300, 'redSquare');\n  \n  // 设置初始速度（斜向移动，速度大小约为200）\n  // 使用勾股定理：sqrt(141^2 + 141^2) ≈ 200\n  square.setVelocity(141, 141);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完美弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000396_v3", "prompt_id": "seed_000396", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 0.5 秒内从原始大小缩放到 32%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象使用生成的菱形纹理\n3. 使用 Tween 动画实现缩放效果：从 1 缩放到 0.32，然后恢复到 1\n4. 设置 Tween 循环播放，yoyo 效果实现来回缩放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 64）\n  graphics.beginPath();\n  graphics.moveTo(64, 0);      // 上顶点\n  graphics.lineTo(128, 64);    // 右顶点\n  graphics.lineTo(64, 128);    // 下顶点\n  graphics.lineTo(0, 64);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.32,  // 缩放到 32%\n    scaleY: 0.32,\n    duration: 500, // 0.5 秒\n    yoyo: true,    // 来回播放（缩小后恢复）\n    repeat: -1,    // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Diamond scaling animation (32% - 100%)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000408_v2", "prompt_id": "seed_000408", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色矩形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色矩形在2.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形\n2. 使用 tweens.add() 创建补间动画，设置 x 坐标从左到右\n3. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n4. 设置 duration: 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建黄色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 60, 60); // 绘制 60x60 的矩形\n  \n  // 设置初始位置（左侧）\n  graphics.x = 50;\n  graphics.y = 270; // 垂直居中\n  \n  // 创建补间动画：从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: graphics,\n    x: 690, // 目标位置（右侧，800 - 60 - 50 = 690）\n    duration: 2500, // 2.5秒\n    yoyo: true, // 往返效果（到达终点后返回起点）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动，匀速移动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '黄色矩形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '循环周期: 2.5秒 × 2 (往返) = 5秒', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000556_v2", "prompt_id": "seed_000556", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让青色三角形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色三角形，使用 Tween 动画实现 1 秒旋转一周的循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.rotation\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 rotation 从 0 到 2π\n4. 配置动画参数：duration 1000ms，loop -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制三角形（以中心为原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -40);      // 顶点\n  graphics.lineTo(-35, 30);     // 左下角\n  graphics.lineTo(35, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 70, 70);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    rotation: Math.PI * 2,       // 旋转到 360 度（2π 弧度）\n    duration: 1000,              // 持续时间 1 秒\n    ease: 'Linear',              // 线性缓动，保持匀速旋转\n    loop: -1,                    // 无限循环（-1 表示永久循环）\n    repeat: 0                    // 不需要额外重复\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '青色三角形旋转动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000536_v1", "prompt_id": "seed_000536", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让黄色矩形在 1 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色矩形的淡入淡出循环动画\nAPI: Graphics, Tween, TweenManager\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 参数实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建黄色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('yellowRect', 200, 150);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建黄色矩形精灵\n  const rect = this.add.sprite(400, 300, 'yellowRect');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入后自动淡出\n  // repeat: -1 实现无限循环\n  this.tweens.add({\n    targets: rect,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 1000,     // 动画时长 1 秒\n    yoyo: true,         // 动画结束后反向播放（淡出后淡入）\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000088_v2", "prompt_id": "seed_000088", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#fillPoints, Phaser.GameObjects.Graphics#rotation\nSTEPS:\n1. 创建 Graphics 对象用于绘制六边形\n2. 计算六边形的六个顶点坐标（使用三角函数）\n3. 使用 fillPoints 方法绘制填充的六边形\n4. 在 update 方法中根据 delta 时间累加旋转角度（80度/秒 = 80 * Math.PI / 180 弧度/秒）\n5. 将计算出的旋转值应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst rotationSpeed = 80; // 每秒旋转 80 度\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  hexagon = this.add.graphics();\n  \n  // 设置六边形的中心位置\n  hexagon.x = 400;\n  hexagon.y = 300;\n  \n  // 绘制六边形\n  drawHexagon(hexagon, 0, 0, 80);\n}\n\nfunction update(time, delta) {\n  // 将 delta（毫秒）转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧应旋转的角度（度转弧度）\n  const rotationDelta = rotationSpeed * deltaSeconds * (Math.PI / 180);\n  \n  // 累加旋转角度\n  hexagon.rotation += rotationDelta;\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} centerX - 中心点 X 坐标（相对于 graphics 对象）\n * @param {number} centerY - 中心点 Y 坐标（相对于 graphics 对象）\n * @param {number} radius - 六边形外接圆半径\n */\nfunction drawHexagon(graphics, centerX, centerY, radius) {\n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个顶点间隔 60 度（π/3 弧度）\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 设置填充样式并绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillPoints(points, true);\n  \n  // 添加描边使六边形更明显\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePoints(points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000113_v2", "prompt_id": "seed_000113", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的粉色菱形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的粉色菱形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小\n2. 在 create 方法中循环10次\n3. 每次循环创建一个 Graphics 对象\n4. 使用 fillStyle 设置粉色填充\n5. 使用 Polygon 或路径绘制菱形（4个顶点）\n6. 使用 setRandomPosition 或手动随机坐标设置位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建10个粉色菱形\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充 (FFC0CB 是标准粉色)\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 定义菱形的4个顶点（中心在原点，大小24像素）\n    // 菱形：上、右、下、左四个顶点\n    const size = 24;\n    const halfSize = size / 2;\n    \n    const diamond = new Phaser.Geom.Polygon([\n      0, -halfSize,      // 上顶点\n      halfSize, 0,       // 右顶点\n      0, halfSize,       // 下顶点\n      -halfSize, 0       // 左顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(diamond.points, true);\n    \n    // 设置随机位置（留出边距避免菱形被裁切）\n    const margin = size;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000543_v2", "prompt_id": "seed_000543", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的橙色方块，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 在随机位置绘制 5 个橙色方块，每个 48x48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环 5 次，每次生成随机坐标\n4. 使用 fillStyle 设置橙色，fillRect 绘制 48x48 方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充 (RGB: 255, 165, 0)\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 方块大小\n  const squareSize = 48;\n  \n  // 绘制 5 个随机位置的橙色方块\n  for (let i = 0; i < 5; i++) {\n    // 生成随机坐标，确保方块完全在画布内\n    const x = Phaser.Math.Between(0, config.width - squareSize);\n    const y = Phaser.Math.Between(0, config.height - squareSize);\n    \n    // 绘制方块\n    graphics.fillRect(x, y, squareSize, squareSize);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000045_v2", "prompt_id": "seed_000045", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色矩形从左到右往返循环的补间动画\nAPI: this.add.graphics, graphics.fillRect, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制白色矩形\n2. 使用 tweens.add 创建补间动画，设置 x 属性从左到右移动\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建白色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 60, 60);\n  \n  // 将 graphics 转换为纹理以便于移动\n  graphics.generateTexture('whiteRect', 60, 60);\n  graphics.destroy();\n  \n  // 创建精灵对象\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（从左到右）\n    duration: 1000,          // 动画持续时间 1 秒\n    yoyo: true,              // 往返效果（到达终点后返回起点）\n    repeat: -1,              // 无限循环（-1 表示永远重复）\n    ease: 'Linear'           // 线性缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000336_v1", "prompt_id": "seed_000336", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 200。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 200\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), Graphics.fillRect(), Graphics.generateTexture()\nSTEPS:\n1. 创建灰色玩家精灵，使用 Graphics 绘制灰色方块纹理\n2. 设置 Arcade 物理系统，配置玩家速度为 200\n3. 添加键盘输入监听（方向键控制移动）\n4. 在 update 中检测玩家是否移出边界（左/右/上/下）\n5. 当移出边界时，将玩家传送到对侧边界位置\n6. 添加状态变量记录玩家穿越边界次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossBorderCount = 0; // 状态信号：记录穿越边界次数\n  }\n\n  preload() {\n    // 使用 Graphics 创建灰色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建玩家精灵（中心位置）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 允许移出边界\n    \n    // 设置移动速度\n    this.moveSpeed = 200;\n    \n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n    \n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.updateStatusText();\n    \n    // 添加边界线（可视化）\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0xffffff, 0.5);\n    borderGraphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n    \n    // 处理键盘输入\n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setVelocityX(-this.moveSpeed);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setVelocityX(this.moveSpeed);\n    }\n    \n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setVelocityY(-this.moveSpeed);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setVelocityY(this.moveSpeed);\n    }\n    \n    // 处理边界循环\n    this.handleWorldWrap();\n    \n    // 更新状态显示\n    this.updateStatusText();\n  }\n  \n  handleWorldWrap() {\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    const worldWidth = this.cameras.main.width;\n    const worldHeight = this.cameras.main.height;\n    \n    let wrapped = false;\n    \n    // 左边界检测\n    if (this.player.x < -playerWidth / 2) {\n      this.player.x = worldWidth + playerWidth / 2;\n      wrapped = true;\n    }\n    // 右边界检测\n    else if (this.player.x > worldWidth + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      wrapped = true;\n    }\n    \n    // 上边界检测\n    if (this.player.y < -playerHeight / 2) {\n      this.player.y = worldHeight + playerHeight / 2;\n      wrapped = true;\n    }\n    // 下边界检测\n    else if (this.player.y > worldHeight + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      wrapped = true;\n    }\n    \n    // 如果发生了边界穿越，增加计数\n    if (wrapped) {\n      this.crossBorderCount++;\n    }\n  }\n  \n  updateStatusText() {\n    const posX = Math.round(this.player.x);\n    const posY = Math.round(this.player.y);\n    this.statusText.setText(\n      `Position: (${posX}, ${posY})\\n` +\n      `Border Crosses: ${this.crossBorderCount}\\n` +\n      `Speed: ${this.moveSpeed}\\n` +\n      `Controls: Arrow Keys or WASD`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000842_v2", "prompt_id": "seed_000842", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个圆形，使用 Tween 动画在 2 秒内缩放到 48%，然后恢复，循环播放\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, tween.yoyo, tween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形\n2. 使用 tweens.add 创建缩放动画，目标 scale 为 0.48\n3. 设置 duration 为 2000ms，yoyo 为 true（自动返回），loop 为 -1（无限循环）\n4. 启动动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 在中心位置绘制一个半径为 50 的圆形\n  const circleRadius = 50;\n  graphics.fillCircle(0, 0, circleRadius);\n  \n  // 将 graphics 对象移动到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标\n    scaleX: 0.48,               // X 轴缩放到 48%\n    scaleY: 0.48,               // Y 轴缩放到 48%\n    duration: 2000,             // 动画持续 2 秒\n    yoyo: true,                 // 动画结束后反向播放（恢复原始大小）\n    loop: -1,                   // 无限循环 (-1 表示永久循环)\n    ease: 'Sine.easeInOut'      // 使用正弦缓动函数使动画更平滑\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 50, 'Circle scaling animation\\n(48% → 100% → 48%)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000606_v2", "prompt_id": "seed_000606", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左上显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左上显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，位置为左上角，字体大小为 32 像素\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本任务不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕左上角 (10, 10) 位置创建文本\n  // 设置字体大小为 32 像素，颜色为白色\n  this.add.text(10, 10, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000707_v3", "prompt_id": "seed_000707", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 600。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次后需落地，跳跃力度200，重力600\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理系统配置，设置重力为600\n2. 使用Graphics绘制玩家角色和地面平台\n3. 添加键盘输入监听，检测空格键跳跃\n4. 实现双跳逻辑：记录跳跃次数，最多允许2次跳跃\n5. 检测角色与地面碰撞，落地时重置跳跃次数\n6. 添加文本显示当前跳跃次数状态\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet jumpCount = 0; // 当前已跳跃次数\nlet maxJumps = 2; // 最大跳跃次数\nlet jumpPower = -200; // 跳跃力度\nlet statusText;\n\nfunction preload() {\n  // 使用Graphics创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建地面\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x4a4a4a, 1);\n  groundGraphics.fillRect(0, 550, 800, 50);\n  groundGraphics.generateTexture('groundTex', 800, 50);\n  groundGraphics.destroy();\n\n  ground = this.physics.add.staticSprite(400, 575, 'groundTex');\n  ground.setOrigin(0.5, 0.5);\n  ground.refreshBody();\n\n  // 创建玩家角色\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 50);\n  // 添加眼睛使角色更生动\n  playerGraphics.fillStyle(0x000000, 1);\n  playerGraphics.fillCircle(12, 15, 4);\n  playerGraphics.fillCircle(28, 15, 4);\n  playerGraphics.generateTexture('playerTex', 40, 50);\n  playerGraphics.destroy();\n\n  player = this.physics.add.sprite(400, 300, 'playerTex');\n  player.setCollideWorldBounds(true);\n\n  // 添加碰撞检测\n  this.physics.add.collider(player, ground, () => {\n    // 当玩家与地面接触时，重置跳跃次数\n    if (player.body.touching.down) {\n      jumpCount = 0;\n    }\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 添加状态文本显示\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(16, 50, '按空格键跳跃（最多2次）\\n方向键左右移动', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  updateStatusText();\n}\n\nfunction update() {\n  // 水平移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 双跳逻辑\n  if (Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    // 检查是否还能跳跃\n    if (jumpCount < maxJumps) {\n      player.setVelocityY(jumpPower);\n      jumpCount++;\n      updateStatusText();\n      \n      // 添加视觉反馈 - 跳跃时改变颜色\n      if (jumpCount === 1) {\n        player.setTint(0xffff00); // 第一次跳跃变黄色\n      } else if (jumpCount === 2) {\n        player.setTint(0xff8800); // 第二次跳跃变橙色\n      }\n    }\n  }\n\n  // 检测玩家是否在地面上，重置颜色\n  if (player.body.touching.down && jumpCount === 0) {\n    player.clearTint();\n  }\n\n  // 更新状态显示\n  updateStatusText();\n}\n\nfunction updateStatusText() {\n  const remainingJumps = maxJumps - jumpCount;\n  const onGround = player && player.body && player.body.touching.down;\n  \n  statusText.setText(\n    `跳跃次数: ${jumpCount}/${maxJumps}\\n` +\n    `剩余跳跃: ${remainingJumps}\\n` +\n    `是否在地面: ${onGround ? '是' : '否'}\\n` +\n    `速度Y: ${player ? Math.round(player.body.velocity.y) : 0}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000812_v2", "prompt_id": "seed_000812", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 3 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形图形，使用 Tween 动画在 3 秒内从透明（alpha=0）渐变到完全不透明（alpha=1），并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject.alpha\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 使用该纹理，初始 alpha 设为 0\n3. 使用 tweens.add 创建透明度动画，从 0 到 1，持续 3000ms，设置 yoyo 和 repeat 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制菱形（中心点为 50, 50，宽高各 100）\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 顶点\n  graphics.lineTo(100, 50);    // 右点\n  graphics.lineTo(50, 100);    // 底点\n  graphics.lineTo(0, 50);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建透明度渐变动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    alpha: 1,                   // 目标透明度值\n    duration: 3000,             // 持续时间 3 秒\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 反向播放（1 -> 0）\n    repeat: -1                  // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000252_v3", "prompt_id": "seed_000252", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现15个物体的同步抖动动画，持续 2.5 秒后停止。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现15个物体的同步抖动动画，持续2.5秒后停止\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Group#addMultiple\nSTEPS:\n1. 创建15个使用Graphics绘制的圆形物体，排列成网格布局\n2. 使用Tween系统为所有物体添加同步的抖动动画（x和y方向随机偏移）\n3. 设置动画持续时间为2.5秒，使用yoyo和repeat实现抖动效果\n4. 动画完成后更新状态变量并停止抖动\n[/PLAN]\n\n```javascript\nclass ShakeScene extends Phaser.Scene {\n  constructor() {\n    super('ShakeScene');\n    this.animationComplete = false; // 状态信号：动画是否完成\n    this.activeObjects = 15; // 状态信号：活动物体数量\n    this.shakeIntensity = 10; // 状态信号：抖动强度\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建背景文字提示\n    this.add.text(400, 50, '15个物体同步抖动动画', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 创建状态文本显示\n    this.statusText = this.add.text(400, 550, '状态: 抖动中...', {\n      fontSize: '18px',\n      color: '#00ff00'\n    }).setOrigin(0.5);\n\n    // 存储所有物体\n    this.objects = [];\n\n    // 创建15个物体，排列成3行5列的网格\n    const rows = 3;\n    const cols = 5;\n    const startX = 200;\n    const startY = 150;\n    const spacingX = 100;\n    const spacingY = 100;\n\n    for (let i = 0; i < 15; i++) {\n      const row = Math.floor(i / cols);\n      const col = i % cols;\n      const x = startX + col * spacingX;\n      const y = startY + row * spacingY;\n\n      // 使用Graphics绘制圆形\n      const graphics = this.add.graphics();\n      graphics.fillStyle(0x3498db, 1);\n      graphics.fillCircle(0, 0, 25);\n      graphics.setPosition(x, y);\n\n      // 添加物体编号文字\n      const text = this.add.text(0, 0, (i + 1).toString(), {\n        fontSize: '16px',\n        color: '#ffffff',\n        fontStyle: 'bold'\n      }).setOrigin(0.5);\n      text.setPosition(x, y);\n\n      // 将graphics和text作为一个容器存储\n      this.objects.push({\n        graphics: graphics,\n        text: text,\n        originalX: x,\n        originalY: y\n      });\n    }\n\n    // 为所有物体创建同步的抖动动画\n    this.createShakeAnimation();\n\n    // 添加重启按钮（动画完成后可用）\n    this.restartButton = this.add.text(400, 500, '点击重启动画', {\n      fontSize: '16px',\n      color: '#888888',\n      backgroundColor: '#333333',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5).setInteractive({ useHandCursor: true });\n\n    this.restartButton.setAlpha(0.5);\n    this.restartButton.on('pointerdown', () => {\n      if (this.animationComplete) {\n        this.restartAnimation();\n      }\n    });\n  }\n\n  createShakeAnimation() {\n    this.animationComplete = false;\n    this.statusText.setText('状态: 抖动中...');\n    this.statusText.setColor('#00ff00');\n    this.restartButton.setAlpha(0.5);\n\n    // 为每个物体创建抖动动画\n    this.objects.forEach((obj, index) => {\n      // X方向抖动\n      this.tweens.add({\n        targets: [obj.graphics, obj.text],\n        x: obj.originalX + Phaser.Math.Between(-this.shakeIntensity, this.shakeIntensity),\n        duration: 50,\n        yoyo: true,\n        repeat: -1, // 无限重复\n        ease: 'Linear'\n      });\n\n      // Y方向抖动\n      this.tweens.add({\n        targets: [obj.graphics, obj.text],\n        y: obj.originalY + Phaser.Math.Between(-this.shakeIntensity, this.shakeIntensity),\n        duration: 50,\n        yoyo: true,\n        repeat: -1, // 无限重复\n        ease: 'Linear'\n      });\n    });\n\n    // 2.5秒后停止所有动画\n    this.time.delayedCall(2500, () => {\n      this.stopShakeAnimation();\n    });\n  }\n\n  stopShakeAnimation() {\n    // 停止所有tweens\n    this.tweens.killAll();\n\n    // 将所有物体恢复到原始位置\n    this.objects.forEach(obj => {\n      obj.graphics.setPosition(obj.originalX, obj.originalY);\n      obj.text.setPosition(obj.originalX, obj.originalY);\n    });\n\n    // 更新状态\n    this.animationComplete = true;\n    this.statusText.setText('状态: 动画已完成');\n    this.statusText.setColor('#ffff00');\n    this.restartButton.setAlpha(1);\n\n    // 添加完成提示闪烁效果\n    this.tweens.add({\n      targets: this.statusText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: 3\n    });\n  }\n\n  restartAnimation() {\n    // 重置状态\n    this.animationComplete = false;\n    this.activeObjects = 15;\n\n    // 停止现有动画\n    this.tweens.killAll();\n\n    // 重新开始抖动动画\n    this.createShakeAnimation();\n  }\n\n  update(time, delta) {\n    // 可以在这里添加实时状态更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: ShakeScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000912_v2", "prompt_id": "seed_000912", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "GameObjects"], "quality_score": 0.8776190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 400，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现带重力和碰撞的平台跳跃游戏，角色可左右移动和跳跃\nAPI: Phaser.Physics.Arcade, this.input.keyboard.createCursorKeys(), this.physics.add.sprite(), this.physics.add.collider()\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力 y: 400\n2. 使用 Graphics 生成玩家和地面纹理\n3. 创建玩家精灵并启用物理碰撞\n4. 创建地面平台并设置为静态物理体\n5. 添加键盘输入监听（方向键）\n6. 在 update 中处理左右移动（速度 200）和跳跃逻辑\n7. 添加状态变量记录跳跃次数作为可验证信号\n[/PLAN]\n\n```javascript\n// 平台跳跃游戏场景\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 生成玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 使用 Graphics 生成地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 64, 32);\n    groundGraphics.generateTexture('ground', 64, 32);\n    groundGraphics.destroy();\n\n    // 生成平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加主地面\n    const ground = this.platforms.create(400, 584, 'ground');\n    ground.setScale(12.5, 1).refreshBody();\n\n    // 添加几个平台\n    this.platforms.create(600, 450, 'platform');\n    this.platforms.create(50, 350, 'platform');\n    this.platforms.create(750, 300, 'platform');\n    this.platforms.create(300, 200, 'platform');\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加空格键用于跳跃\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示跳跃计数文本\n    this.jumpText = this.add.text(16, 16, 'Jumps: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 添加控制说明\n    this.add.text(16, 50, 'Arrow Keys: Move | Space/Up: Jump', {\n      fontSize: '16px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 添加背景色\n    this.cameras.main.setBackgroundColor('#87ceeb');\n  }\n\n  update(time, delta) {\n    // 检测玩家是否在地面上\n    const touchingDown = this.player.body.touching.down;\n    \n    if (touchingDown) {\n      this.isGrounded = true;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（空格键或上方向键）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.isGrounded) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n      this.jumpText.setText('Jumps: ' + this.jumpCount);\n      this.isGrounded = false;\n    }\n\n    // 如果玩家不在地面上，重置 isGrounded\n    if (!touchingDown && this.player.body.velocity.y > 0) {\n      this.isGrounded = false;\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: PlatformScene,\n  backgroundColor: '#87ceeb'\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000840_v2", "prompt_id": "seed_000840", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.88}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1.5 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在1.5秒内从原始大小缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建缩放动画（scale: 1 -> 0.24 -> 1）\n4. 设置 Tween 循环播放（loop: -1）和持续时间（1.5秒单程，往返共3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64）\n  const size = 64;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 上顶点\n  graphics.lineTo(size * 2, size);    // 右顶点\n  graphics.lineTo(size, size * 2);    // 下顶点\n  graphics.lineTo(0, size);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵并放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  // 从原始大小(1)缩放到24%(0.24)，然后恢复到原始大小\n  // yoyo: true 表示动画会反向播放（从0.24回到1）\n  // duration: 1500 表示单程1.5秒，往返共3秒\n  // loop: -1 表示无限循环\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 1500,\n    yoyo: true,\n    loop: -1,\n    ease: 'Linear'\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Diamond Scale Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% → 24% → 100% (1.5s each way)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000611_v2", "prompt_id": "seed_000611", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的椭圆在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的椭圆对象并保持居中\nAPI: Graphics.fillEllipse, Camera.startFollow, Camera.setBounds, Sprite.setVelocity\nSTEPS:\n1. 创建一个椭圆形状并生成为纹理\n2. 创建精灵对象并启用物理引擎\n3. 设置椭圆向上移动的速度\n4. 配置相机跟随椭圆对象\n5. 设置场景边界和相机边界以支持跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet graphics;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使场景可以向上扩展\n  this.physics.world.setBounds(0, -2000, 800, 3000);\n  \n  // 创建 Graphics 对象绘制椭圆\n  graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(30, 30, 60, 40); // 中心点(30,30)，宽60，高40\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTex', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建椭圆精灵并启用物理\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置椭圆向上移动的速度\n  ellipse.setVelocityY(-100); // 向上移动，负值表示向上\n  \n  // 设置椭圆的碰撞边界\n  ellipse.setCollideWorldBounds(false); // 允许超出世界边界\n  \n  // 配置相机跟随椭圆\n  this.cameras.main.startFollow(ellipse, true, 0.1, 0.1);\n  \n  // 设置相机边界，使其可以在整个世界范围内移动\n  this.cameras.main.setBounds(0, -2000, 800, 3000);\n  \n  // 添加一些参考线帮助观察相机跟随效果\n  this.add.grid(400, 0, 800, 3000, 100, 100, 0x444444, 0, 0xffffff, 0.5)\n    .setOrigin(0.5, 0);\n  \n  // 添加文本提示\n  const text = this.add.text(10, 10, 'Camera Following Ellipse\\nMoving Upward', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 让文本固定在相机上\n  text.setScrollFactor(0);\n  \n  // 添加位置信息文本\n  this.positionText = this.add.text(10, 80, '', {\n    fontSize: '16px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 更新位置信息显示\n  if (this.positionText && ellipse) {\n    this.positionText.setText([\n      `Ellipse Y: ${Math.round(ellipse.y)}`,\n      `Camera Y: ${Math.round(this.cameras.main.scrollY)}`,\n      `Velocity: ${ellipse.body.velocity.y}`\n    ]);\n  }\n  \n  // 可选：当椭圆到达顶部时重置位置\n  if (ellipse.y < -1900) {\n    ellipse.y = 300;\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000569_v3", "prompt_id": "seed_000569", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8587499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色圆形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个蓝色圆形在0.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 Sprite 对象使用生成的圆形纹理\n3. 使用 tweens 创建 x 轴移动补间动画，设置 duration 为 500ms\n4. 配置 yoyo 为 true 实现往返效果，设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  graphics.generateTexture('blueCircle', 50, 50); // 生成 50x50 的纹理\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建使用蓝色圆形纹理的精灵\n  const circle = this.add.sprite(100, 300, 'blueCircle');\n\n  // 创建补间动画：从左到右移动，然后往返循环\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（从 100 移动到 700）\n    duration: 500,             // 动画持续时间 0.5 秒\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    ease: 'Linear'             // 线性缓动函数，匀速移动\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Blue Circle Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, 'The circle moves left-right in 0.5s loop', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000145_v3", "prompt_id": "seed_000145", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色三角形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形在 2.5 秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建绿色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 顶点\n  graphics.lineTo(-25, 30);   // 左下角\n  graphics.lineTo(25, 30);    // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标位置（右侧）\n    duration: 2500,            // 持续时间 2.5 秒\n    yoyo: true,                // 启用往返效果\n    repeat: -1,                // 无限循环\n    ease: 'Linear'             // 线性缓动\n  });\n  \n  // 添加说明文本\n  this.add.text(400, 50, '绿色三角形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000013_v2", "prompt_id": "seed_000013", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现蓝色血条 UI：显示 3 格生命值，按方向键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现蓝色血条 UI，显示 3 格生命值，按方向键扣血，血量为 0 时显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化游戏配置\n2. 在 create 中使用 Graphics 绘制 3 格蓝色血条\n3. 监听方向键输入事件，每次按键扣除 1 格血量\n4. 更新血条显示，根据当前血量重绘\n5. 当血量为 0 时显示 Game Over 文本并停止输入\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 3; // 当前生命值\n    this.maxHealth = 3; // 最大生命值\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, 'Press Arrow Keys to Take Damage', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.healthBarGraphics = this.add.graphics();\n    this.drawHealthBar();\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold',\n      stroke: '#000000',\n      strokeThickness: 6\n    }).setOrigin(0.5).setVisible(false);\n\n    // 创建重启提示文本（初始隐藏）\n    this.restartText = this.add.text(400, 380, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5).setVisible(false);\n\n    // 创建当前血量显示文本\n    this.healthText = this.add.text(400, 250, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n\n    // 监听方向键输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加空格键用于重启\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 标记按键是否已按下（防止连续触发）\n    this.keyPressed = {\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n  }\n\n  update() {\n    if (this.isGameOver) {\n      // 游戏结束后检测空格键重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.restartGame();\n      }\n      return;\n    }\n\n    // 检测方向键按下（使用 JustDown 避免连续触发）\n    if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) {\n      this.takeDamage();\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) {\n      this.takeDamage();\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) {\n      this.takeDamage();\n    } else if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) {\n      this.takeDamage();\n    }\n  }\n\n  // 绘制血条\n  drawHealthBar() {\n    this.healthBarGraphics.clear();\n\n    const barWidth = 80; // 每格血条宽度\n    const barHeight = 40; // 血条高度\n    const barSpacing = 10; // 血条间距\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing) - barSpacing) / 2; // 居中起始位置\n    const startY = 150;\n\n    // 绘制每格血条\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + barSpacing);\n      \n      // 绘制血条背景（深灰色边框）\n      this.healthBarGraphics.lineStyle(3, 0x333333, 1);\n      this.healthBarGraphics.strokeRect(x, startY, barWidth, barHeight);\n\n      // 根据当前血量决定是否填充蓝色\n      if (i < this.health) {\n        // 有血量：填充蓝色\n        this.healthBarGraphics.fillStyle(0x0088ff, 1);\n        this.healthBarGraphics.fillRect(x + 3, startY + 3, barWidth - 6, barHeight - 6);\n      } else {\n        // 无血量：填充深色\n        this.healthBarGraphics.fillStyle(0x222222, 1);\n        this.healthBarGraphics.fillRect(x + 3, startY + 3, barWidth - 6, barHeight - 6);\n      }\n    }\n  }\n\n  // 扣血逻辑\n  takeDamage() {\n    if (this.health > 0) {\n      this.health--;\n      this.drawHealthBar(); // 重绘血条\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n\n      // 添加受伤闪烁效果\n      this.cameras.main.shake(200, 0.005);\n\n      // 检查是否游戏结束\n      if (this.health <= 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  // 触发游戏结束\n  triggerGameOver() {\n    this.isGameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 添加 Game Over 动画效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 屏幕闪烁效果\n    this.cameras.main.flash(500, 255, 0, 0);\n  }\n\n  // 重启游戏\n  restartGame() {\n    this.scene.restart();\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: HealthBarScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001097_v1", "prompt_id": "seed_001097", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的橙色矩形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的橙色矩形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环20次，每次生成随机坐标位置\n4. 使用 fillStyle 设置橙色，使用 fillRect 绘制 80x80 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充 (橙色的十六进制值)\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 绘制20个随机位置的矩形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机坐标，确保矩形完全在画布内\n    // x 范围: 0 到 (800 - 80)\n    // y 范围: 0 到 (600 - 80)\n    const randomX = Phaser.Math.Between(0, config.width - 80);\n    const randomY = Phaser.Math.Between(0, config.height - 80);\n    \n    // 绘制 80x80 的矩形\n    graphics.fillRect(randomX, randomY, 80, 80);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000489_v2", "prompt_id": "seed_000489", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个红色物体以 240 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建20个红色物体以240速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity\nSTEPS:\n1. 配置 Arcade 物理系统，设置世界边界反弹\n2. 使用 Graphics 创建红色圆形纹理\n3. 创建物理组，生成20个红色物体\n4. 为每个物体设置随机速度(240)和完全反弹\n5. 添加物体间碰撞检测，记录碰撞次数作为状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet collisionCount = 0;\nlet activeObjects = 0;\nlet totalBounces = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建红色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('redCircle', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 重置状态变量\n  collisionCount = 0;\n  activeObjects = 20;\n  totalBounces = 0;\n\n  // 创建物理组\n  const objects = this.physics.add.group({\n    key: 'redCircle',\n    repeat: 19, // 创建20个物体 (1 + 19)\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n\n  // 设置每个物体的随机位置和速度\n  const speed = 240;\n  objects.children.iterate((object) => {\n    // 随机位置\n    object.x = Phaser.Math.Between(50, 750);\n    object.y = Phaser.Math.Between(50, 550);\n\n    // 随机方向的速度，保持速度大小为240\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    \n    object.setVelocity(vx, vy);\n    \n    // 设置圆形碰撞体\n    object.setCircle(16);\n  });\n\n  // 添加物体间的碰撞检测\n  this.physics.add.collider(objects, objects, handleCollision, null, this);\n\n  // 显示状态信息\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 监听世界边界碰撞\n  objects.children.iterate((object) => {\n    object.body.onWorldBounds = true;\n  });\n\n  this.physics.world.on('worldbounds', () => {\n    totalBounces++;\n  });\n}\n\nfunction handleCollision(obj1, obj2) {\n  // 记录碰撞次数\n  collisionCount++;\n}\n\nfunction update() {\n  // 更新状态显示\n  if (this.statusText) {\n    this.statusText.setText([\n      `Active Objects: ${activeObjects}`,\n      `Object Collisions: ${collisionCount}`,\n      `Wall Bounces: ${totalBounces}`,\n      `Speed: 240 px/s`\n    ]);\n  }\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000823_v2", "prompt_id": "seed_000823", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让黄色矩形在 1 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色矩形，实现1秒淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 150, 100);\n  graphics.generateTexture('yellowRect', 150, 100);\n  graphics.destroy();\n\n  // 创建精灵对象\n  const rect = this.add.sprite(400, 300, 'yellowRect');\n\n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果，repeat -1 实现无限循环\n  this.tweens.add({\n    targets: rect,\n    alpha: 0, // 目标透明度为0（完全透明）\n    duration: 500, // 淡出持续500毫秒\n    yoyo: true, // 启用yoyo效果，动画结束后反向播放（淡入）\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, '黄色矩形淡入淡出循环动画', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000088_v1", "prompt_id": "seed_000088", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右上显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右上角显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 48px\n4. 将文本定位到屏幕右上角，使用 setOrigin(1, 0) 设置原点为右上\n5. 设置文本位置为 (canvas.width - 20, 20) 留出边距\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建文本对象\n  const text = this.add.text(\n    780,  // x 坐标（屏幕宽度 800 - 边距 20）\n    20,   // y 坐标（顶部边距 20）\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '48px',      // 字体大小\n      fontFamily: 'Arial',   // 字体系列\n      color: '#ffffff',      // 文字颜色（白色）\n      fontStyle: 'bold'      // 字体样式（粗体）\n    }\n  );\n  \n  // 设置文本原点为右上角 (1, 0)\n  // 这样文本会从右上角开始向左下延伸\n  text.setOrigin(1, 0);\n}\n\n// 创建并启动 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000040_v2", "prompt_id": "seed_000040", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 1.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在1.5秒内缩放到80%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 yoyo 为 true 实现往返效果\n4. 设置 loop 为 -1 实现无限循环，duration 为 1500 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 150, 100);\n  graphics.generateTexture('rectTexture', 150, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵并居中显示\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n\n  // 创建缩放动画\n  // yoyo: true 表示动画完成后反向播放（从80%回到100%）\n  // loop: -1 表示无限循环\n  // duration: 1500 表示单程动画时长1.5秒（完整一个循环是3秒）\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 1500,\n    yoyo: true,\n    loop: -1,\n    ease: 'Sine.easeInOut'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000758_v3", "prompt_id": "seed_000758", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的灰色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的灰色星形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中循环3次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象设置随机位置（考虑星形大小避免超出边界）\n4. 使用 Graphics API 绘制星形路径（5个顶点的星形）\n5. 填充灰色并渲染星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制3个随机位置的灰色星形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置随机位置（考虑星形半径32，避免超出边界）\n    const x = Phaser.Math.Between(64, 736);\n    const y = Phaser.Math.Between(64, 536);\n    \n    // 设置灰色填充\n    graphics.fillStyle(0x808080, 1);\n    \n    // 绘制星形\n    drawStar(graphics, x, y, 5, 32, 14);\n  }\n}\n\n/**\n * 绘制星形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心 x 坐标\n * @param {number} cy - 中心 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n\n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n\n  for (let i = 0; i < spikes; i++) {\n    // 外顶点\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n\n    // 内顶点\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n\n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000049_v3", "prompt_id": "seed_000049", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 10 个紫色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成10个紫色可收集物体，玩家碰到后消失并加分，显示score\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，初始化场景\n2. 使用Graphics生成玩家和收集物纹理\n3. 创建物理组存放10个紫色收集物，随机分布在场景中\n4. 创建玩家精灵，添加键盘控制\n5. 在update中检测玩家与收集物的overlap碰撞\n6. 碰撞时销毁收集物，增加分数，更新UI显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用Graphics创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 使用Graphics创建收集物纹理（紫色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x9966ff, 1);\n  collectibleGraphics.fillCircle(16, 16, 16);\n  collectibleGraphics.generateTexture('collectible', 32, 32);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setVelocity(0, 0);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 生成10个紫色收集物，随机分布\n  for (let i = 0; i < 10; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCircle(16); // 设置圆形碰撞体\n  }\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#ffffff'\n  });\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 添加碰撞检测回调\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\n// 收集物品回调函数\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 如果所有收集物都被收集，显示胜利信息\n  if (collectibles.countActive(true) === 0) {\n    const winText = this.add.text(400, 300, 'You Win!', {\n      fontSize: '64px',\n      fontFamily: 'Arial',\n      color: '#ffff00'\n    });\n    winText.setOrigin(0.5);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000860_v3", "prompt_id": "seed_000860", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让灰色圆形在 2 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色圆形闪烁动画，2秒循环一次\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 透明度实现闪烁效果\n4. 设置 yoyo 和 loop 参数实现循环闪烁\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillCircle(50, 50, 50); // 圆心(50,50)，半径50\n  \n  // 生成纹理\n  graphics.generateTexture('grayCircle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，保留纹理\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(400, 300, 'grayCircle');\n  \n  // 创建闪烁动画\n  // 使用 alpha 透明度从 1 -> 0 -> 1 实现闪烁效果\n  this.tweens.add({\n    targets: circle,\n    alpha: 0, // 目标透明度为 0（完全透明）\n    duration: 1000, // 1秒渐隐\n    yoyo: true, // 自动反向播放（渐显）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用正弦缓动使过渡更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000077_v3", "prompt_id": "seed_000077", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的蓝色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的蓝色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次\n3. 每次循环创建一个 Graphics 对象，设置蓝色填充\n4. 使用 fillTriangle 绘制等边三角形（大小16像素）\n5. 使用 setRandomPosition 或 Math.random 设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建20个随机位置的蓝色三角形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置蓝色填充\n    graphics.fillStyle(0x0000ff, 1);\n    \n    // 绘制等边三角形（大小16像素）\n    // 等边三角形的顶点坐标（中心在原点）\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    // 三个顶点坐标（顶点朝上）\n    const x1 = 0;\n    const y1 = -height * 2 / 3; // 顶点\n    const x2 = -size / 2;\n    const y2 = height / 3; // 左下角\n    const x3 = size / 2;\n    const y3 = height / 3; // 右下角\n    \n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const randomX = Phaser.Math.Between(size, config.width - size);\n    const randomY = Phaser.Math.Between(size, config.height - size);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000781_v1", "prompt_id": "seed_000781", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让橙色圆形在 2.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建橙色圆形的淡入淡出循环动画，周期2.5秒\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, alpha\nSTEPS:\n1. 使用 Graphics 绘制橙色圆形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 Tweens 创建 alpha 属性动画，从1到0再到1\n4. 设置动画持续时间2.5秒，yoyo效果实现淡入淡出，loop为-1实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillCircle(50, 50, 50); // 圆心(50,50)，半径50\n  \n  // 生成纹理\n  graphics.generateTexture('orangeCircle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，节省资源\n  \n  // 在屏幕中心创建 Sprite\n  const circle = this.add.sprite(400, 300, 'orangeCircle');\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: circle,\n    alpha: 0, // 目标透明度为0（完全透明）\n    duration: 1250, // 单程持续时间1.25秒\n    yoyo: true, // 启用yoyo效果，动画会反向播放（淡入）\n    repeat: -1, // -1表示无限循环\n    ease: 'Sine.easeInOut' // 使用正弦缓动函数，使动画更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000665_v1", "prompt_id": "seed_000665", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的菱形对象并保持居中\nAPI: Graphics#fillStyle, Graphics#fillPath, Camera#startFollow, Physics.Arcade.Sprite#setVelocity\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建物理精灵对象并应用菱形纹理\n3. 设置精灵向右移动的速度\n4. 配置相机跟随该精灵对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet camera;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让对象可以移动\n  this.physics.world.setBounds(0, 0, 3000, 600);\n  \n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形路径（中心点在 32, 32）\n  const diamondPath = new Phaser.Geom.Polygon([\n    32, 0,    // 上顶点\n    64, 32,   // 右顶点\n    32, 64,   // 下顶点\n    0, 32     // 左顶点\n  ]);\n  \n  graphics.fillPoints(diamondPath.points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵对象\n  diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置精灵向右移动的速度（每秒150像素）\n  diamond.setVelocityX(150);\n  \n  // 设置精灵的碰撞边界\n  diamond.setCollideWorldBounds(false);\n  \n  // 获取主相机\n  camera = this.cameras.main;\n  \n  // 设置相机边界与世界边界一致\n  camera.setBounds(0, 0, 3000, 600);\n  \n  // 让相机跟随菱形对象，并保持居中\n  camera.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 添加一些参考网格线，便于观察相机移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 3000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 600);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 600; y += 100) {\n    gridGraphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加说明文字（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随菱形对象\\n菱形自动向右移动', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 可以在这里添加额外的更新逻辑\n  // 当前菱形由物理引擎自动移动，相机自动跟随\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000672_v3", "prompt_id": "seed_000672", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色三角形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色三角形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置绿色填充，使用 fillTriangle 绘制等边三角形\n5. 三角形顶点相对中心点偏移约 24 像素，形成 48 像素大小的三角形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制等边三角形（顶点朝上）\n  // 三角形高度约为 48 像素，底边约为 48 像素\n  const size = 48;\n  const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n  \n  // 计算三个顶点坐标\n  const x1 = centerX;                    // 顶部顶点 x\n  const y1 = centerY - height / 2;       // 顶部顶点 y\n  const x2 = centerX - size / 2;         // 左下顶点 x\n  const y2 = centerY + height / 2;       // 左下顶点 y\n  const x3 = centerX + size / 2;         // 右下顶点 x\n  const y3 = centerY + height / 2;       // 右下顶点 y\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加边框使三角形更明显\n  graphics.lineStyle(2, 0x00aa00, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000471_v2", "prompt_id": "seed_000471", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按WASD键发射灰色子弹的例子，子弹速度 200，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按WASD键发射灰色子弹，速度200，离开边界自动回收到对象池\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard.addKey, Phaser.GameObjects.Graphics.generateTexture\nSTEPS:\n1. 创建玩家精灵和子弹组（使用对象池）\n2. 使用Graphics生成灰色子弹纹理\n3. 监听WASD键盘输入\n4. 根据按键方向从对象池获取子弹并设置速度\n5. 在update中检测子弹是否离开边界并回收\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 可验证状态：发射的子弹总数\n    this.activeBullets = 0; // 可验证状态：当前活跃的子弹数\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（灰色圆形）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0x808080, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组（对象池）\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: false\n    });\n\n    // 设置键盘输入\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 防止连续发射的冷却时间\n    this.shootCooldown = 0;\n    this.shootDelay = 200; // 毫秒\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, height - 40, 'Press WASD to shoot bullets', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新冷却时间\n    if (this.shootCooldown > 0) {\n      this.shootCooldown -= delta;\n    }\n\n    // 检测WASD按键发射子弹\n    if (this.shootCooldown <= 0) {\n      let velocityX = 0;\n      let velocityY = 0;\n      let shouldShoot = false;\n\n      if (this.keyW.isDown) {\n        velocityY = -200;\n        shouldShoot = true;\n      } else if (this.keyS.isDown) {\n        velocityY = 200;\n        shouldShoot = true;\n      }\n\n      if (this.keyA.isDown) {\n        velocityX = -200;\n        shouldShoot = true;\n      } else if (this.keyD.isDown) {\n        velocityX = 200;\n        shouldShoot = true;\n      }\n\n      if (shouldShoot) {\n        this.shootBullet(velocityX, velocityY);\n        this.shootCooldown = this.shootDelay;\n      }\n    }\n\n    // 检查并回收离开边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        const bounds = this.cameras.main;\n        if (\n          bullet.x < -20 ||\n          bullet.x > bounds.width + 20 ||\n          bullet.y < -20 ||\n          bullet.y > bounds.height + 20\n        ) {\n          this.recycleBullet(bullet);\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  shootBullet(velocityX, velocityY) {\n    // 从对象池获取子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n\n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.body.enable = true;\n      bullet.setVelocity(velocityX, velocityY);\n\n      this.bulletsFired++;\n      this.activeBullets++;\n    }\n  }\n\n  recycleBullet(bullet) {\n    // 回收子弹到对象池\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.body.enable = false;\n    bullet.setVelocity(0, 0);\n\n    this.activeBullets--;\n  }\n\n  updateStatus() {\n    this.statusText.setText(\n      `Bullets Fired: ${this.bulletsFired}\\n` +\n      `Active Bullets: ${this.activeBullets}\\n` +\n      `Pool Size: ${this.bullets.getLength()}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000972_v2", "prompt_id": "seed_000972", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随一个自动向左上移动的三角形\nAPI: Graphics.fillTriangle, Camera.startFollow, Sprite.setVelocity, Physics.Arcade\nSTEPS:\n1. 创建一个更大的世界边界，确保有足够的移动空间\n2. 使用 Graphics 绘制三角形并生成纹理\n3. 创建物理精灵并设置向左上方移动的速度\n4. 设置主相机跟随该三角形对象\n5. 在 update 中保持三角形持续移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使其足够大以便三角形移动\n  this.physics.world.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 使用 Graphics 绘制三角形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6600, 1);\n  // 绘制一个指向上方的三角形\n  graphics.fillTriangle(\n    30, 10,   // 顶点\n    10, 50,   // 左下\n    50, 50    // 右下\n  );\n  graphics.generateTexture('triangleTex', 60, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵，放置在场景中心\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置三角形的速度：向左上移动\n  // 负 x 值表示向左，负 y 值表示向上\n  triangle.setVelocity(-150, -150);\n  \n  // 设置三角形的碰撞边界\n  triangle.setCollideWorldBounds(false);\n  \n  // 设置主相机跟随三角形\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 添加背景网格以便观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x333333, 0.5);\n  \n  // 绘制网格\n  for (let x = -2000; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, -2000, x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += 100) {\n    gridGraphics.lineBetween(-2000, y, 2000, y);\n  }\n  \n  // 在中心位置绘制一个参考点\n  const centerGraphics = this.add.graphics();\n  centerGraphics.fillStyle(0x00ff00, 1);\n  centerGraphics.fillCircle(400, 300, 5);\n  \n  // 添加文本提示\n  const text = this.add.text(10, 10, '三角形向左上方移动\\n相机跟随中...', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 物理引擎会自动更新三角形位置\n  // 相机会自动跟随三角形\n  \n  // 可选：如果需要限制移动范围，可以在这里添加边界检查\n  // 这里让三角形可以无限移动\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000058_v2", "prompt_id": "seed_000058", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的黄色菱形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制12个黄色菱形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setPosition, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Phaser Game 配置，使用 800x600 画布\n2. 在 create 方法中循环12次\n3. 每次循环创建一个 Graphics 对象\n4. 使用 fillPath 和 Polygon 绘制菱形（4个顶点：上、右、下、左）\n5. 为每个菱形设置随机位置（考虑边界，避免超出画布）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 菱形大小\n  const diamondSize = 48;\n  const halfSize = diamondSize / 2;\n  \n  // 绘制12个随机位置的黄色菱形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置黄色填充\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 定义菱形的4个顶点（相对于中心点）\n    // 上、右、下、左\n    const diamond = new Phaser.Geom.Polygon([\n      0, -halfSize,      // 上顶点\n      halfSize, 0,       // 右顶点\n      0, halfSize,       // 下顶点\n      -halfSize, 0       // 左顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(diamond.points, true);\n    \n    // 设置随机位置（考虑边界，留出菱形大小的边距）\n    const randomX = Phaser.Math.Between(halfSize, 800 - halfSize);\n    const randomY = Phaser.Math.Between(halfSize, 600 - halfSize);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000626_v1", "prompt_id": "seed_000626", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现追踪镜头与震屏：玩家与敌人碰撞时触发 camera shake 3 秒，并扣减生命值显示。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现玩家与敌人碰撞时触发3秒镜头震动并扣减生命值显示\nAPI: Phaser.Cameras.Scene2D.Camera#shake, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建带物理系统的场景配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家和敌人的纯色纹理\n3. 创建玩家精灵并设置摄像机跟随（startFollow）\n4. 创建敌人精灵并设置简单移动逻辑\n5. 添加碰撞检测，触发时调用 camera.shake() 持续3秒并扣减生命值\n6. 显示生命值文本，实时更新状态\n[/PLAN]\n\n```javascript\n// Phaser3 追踪镜头与震屏效果实现\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerHealth = 100; // 可验证的状态信号\n    this.collisionCount = 0; // 碰撞次数统计\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x4a90e2, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xe74c3c, 1);\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建地面纹理（灰色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x95a5a6, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 1600, 600);\n\n    // 创建地面\n    const ground = this.physics.add.staticSprite(800, 575, 'ground');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0.2);\n    this.player.body.setGravity(0, 300);\n\n    // 创建敌人（多个敌人增加碰撞机会）\n    this.enemies = this.physics.add.group();\n    for (let i = 0; i < 3; i++) {\n      const enemy = this.enemies.create(200 + i * 400, 200, 'enemy');\n      enemy.setBounce(1);\n      enemy.setCollideWorldBounds(true);\n      enemy.setVelocity(\n        Phaser.Math.Between(-200, 200),\n        Phaser.Math.Between(-200, 200)\n      );\n      enemy.body.setGravity(0, 300);\n    }\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, ground);\n    this.physics.add.collider(this.enemies, ground);\n    this.physics.add.collider(this.enemies, this.enemies);\n\n    // 玩家与敌人碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 摄像机跟随玩家\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n    this.cameras.main.setBounds(0, 0, 1600, 600);\n\n    // 创建UI文本（固定在屏幕上）\n    this.healthText = this.add.text(16, 16, `Health: ${this.playerHealth}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.healthText.setScrollFactor(0); // 固定在屏幕上不随摄像机移动\n\n    this.collisionText = this.add.text(16, 50, `Collisions: ${this.collisionCount}`, {\n      fontSize: '20px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.collisionText.setScrollFactor(0);\n\n    this.statusText = this.add.text(16, 84, 'Status: Normal', {\n      fontSize: '18px',\n      fill: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setScrollFactor(0);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 提示文本\n    this.add.text(400, 50, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }).setOrigin(0.5).setScrollFactor(0);\n\n    // 碰撞冷却标志\n    this.canTakeDamage = true;\n  }\n\n  handleCollision(player, enemy) {\n    // 冷却机制，避免频繁触发\n    if (!this.canTakeDamage) return;\n\n    this.canTakeDamage = false;\n    this.collisionCount++;\n\n    // 扣减生命值\n    this.playerHealth -= 10;\n    if (this.playerHealth < 0) this.playerHealth = 0;\n\n    // 更新UI\n    this.healthText.setText(`Health: ${this.playerHealth}`);\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n    this.statusText.setText('Status: DAMAGED!');\n    this.statusText.setStyle({ fill: '#ff0000' });\n\n    // 触发摄像机震动 3 秒\n    // shake(duration, intensity)\n    this.cameras.main.shake(3000, 0.01);\n\n    // 玩家闪烁效果\n    this.tweens.add({\n      targets: player,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 5\n    });\n\n    // 击退效果\n    const angle = Phaser.Math.Angle.Between(\n      enemy.x, enemy.y,\n      player.x, player.y\n    );\n    player.setVelocity(\n      Math.cos(angle) * 300,\n      Math.sin(angle) * 300 - 100\n    );\n\n    // 3秒后恢复状态\n    this.time.delayedCall(3000, () => {\n      this.canTakeDamage = true;\n      this.statusText.setText('Status: Normal');\n      this.statusText.setStyle({ fill: '#00ff00' });\n    });\n\n    // 检查游戏结束\n    if (this.playerHealth <= 0) {\n      this.statusText.setText('Status: GAME OVER');\n      this.statusText.setStyle({ fill: '#ff0000', fontSize: '24px' });\n      this.physics.pause();\n    }\n  }\n\n  update() {\n    if (this.playerHealth <= 0) return;\n\n    // 玩家控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 确保敌人保持移动\n    this.enemies.children.entries.forEach(enemy => {\n      if (Math.abs(enemy.body.velocity.x) < 50) {\n        enemy.setVelocityX(Phaser.Math.Between(-200, 200));\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000806_v1", "prompt_id": "seed_000806", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Physics"], "quality_score": 0.8855882352941177}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆形状\n2. 在 create 中初始化椭圆的位置和样式\n3. 在 update 中根据 delta 时间累加旋转角度（200度/秒 = 200 * (Math.PI/180) 弧度/秒）\n4. 将计算出的旋转角度应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipseGraphics;\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制椭圆\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置椭圆的位置到画布中心\n  ellipseGraphics.x = 400;\n  ellipseGraphics.y = 300;\n  \n  // 设置填充样式并绘制椭圆\n  // 椭圆中心在 (0, 0)，宽度 200，高度 100\n  ellipseGraphics.fillStyle(0x00ff00, 1);\n  ellipseGraphics.fillEllipse(0, 0, 200, 100);\n  \n  // 添加一个参考点（小圆点）以便观察旋转效果\n  ellipseGraphics.fillStyle(0xff0000, 1);\n  ellipseGraphics.fillCircle(100, 0, 8);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 200 度\n  // 将角速度从度转换为弧度：200 * (Math.PI / 180)\n  const rotationSpeed = 200 * (Math.PI / 180); // 弧度/秒\n  \n  // delta 是毫秒，转换为秒：delta / 1000\n  const rotationIncrement = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  ellipseGraphics.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000085_v2", "prompt_id": "seed_000085", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 0.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在 0.5 秒内缩放到 16% 并恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制星形并生成纹理\n2. 创建星形精灵对象\n3. 使用 Tween 动画实现缩放效果（scale 从 1 到 0.16 再到 1）\n4. 设置 Tween 循环播放（loop: -1）和持续时间（0.5 秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = Math.cos(angle) * radius + outerRadius;\n    const y = Math.sin(angle) * radius + outerRadius;\n    points.push(x, y);\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  // 从 1 缩放到 0.16，然后返回到 1，总时长 0.5 秒\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 250, // 0.25 秒缩小\n    yoyo: true,    // 自动反向播放（恢复）\n    repeat: -1,    // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '星形缩放动画（循环播放）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000157_v2", "prompt_id": "seed_000157", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色菱形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色菱形以160速度移动并在边界反弹\nAPI: Graphics.fillStyle, Graphics.fillPath, Physics.Arcade.Sprite, Physics.World.setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建 Arcade 物理精灵并设置速度为160\n3. 启用物理世界边界碰撞和精灵边界反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形路径（中心在 32, 32，大小为 64x64）\n  const path = new Phaser.Geom.Polygon([\n    32, 0,    // 顶点\n    64, 32,   // 右点\n    32, 64,   // 底点\n    0, 32     // 左点\n  ]);\n  \n  graphics.fillPoints(path.points, true);\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始速度（160像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  this.physics.velocityFromAngle(angle, 160, diamond.body.velocity);\n  \n  // 启用世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置边界反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000171_v3", "prompt_id": "seed_000171", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 360 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Graphics 对象绘制六边形\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间更新六边形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 360; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建六边形 Graphics 对象\n  hexagon = this.add.graphics();\n  hexagon.x = 400;\n  hexagon.y = 300;\n  \n  // 绘制六边形\n  drawHexagon(hexagon);\n  \n  // 添加 WASD 键盘监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算当前帧的移动距离 (速度 * 时间)\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    hexagon.y -= distance;\n  }\n  if (keys.s.isDown) {\n    hexagon.y += distance;\n  }\n  if (keys.a.isDown) {\n    hexagon.x -= distance;\n  }\n  if (keys.d.isDown) {\n    hexagon.x += distance;\n  }\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n */\nfunction drawHexagon(graphics) {\n  const radius = 40;\n  const points = [];\n  \n  // 计算六边形的六个顶点坐标\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    points.push(x, y);\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 绘制六边形边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000374_v1", "prompt_id": "seed_000374", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 创建 Scene 并配置 Phaser.Game\n2. 在 create 方法中使用 Graphics 绘制椭圆形状\n3. 设置椭圆初始透明度为 0（完全透明）\n4. 使用 tweens 创建透明度动画，从 0 到 1，持续 4 秒\n5. 配置 tween 为循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制椭圆（中心点在画布中央，宽度 200，高度 120）\n  const centerX = 400;\n  const centerY = 300;\n  const radiusX = 100;\n  const radiusY = 60;\n  \n  graphics.fillEllipse(centerX, centerY, radiusX, radiusY);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建透明度渐变动画\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1,              // 目标透明度为 1（完全不透明）\n    duration: 4000,        // 持续时间 4 秒\n    ease: 'Linear',        // 线性渐变\n    yoyo: true,            // 往返播放（不透明后再变回透明）\n    repeat: -1             // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '4秒渐变：透明 → 不透明 → 透明（循环）', {\n    fontSize: '16px',\n    color: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000187_v2", "prompt_id": "seed_000187", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个星形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制星形以 200 像素/秒速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Sprite\nSTEPS:\n1. 创建 Graphics 对象绘制星形并生成纹理\n2. 使用生成的纹理创建 Sprite 作为可移动对象\n3. 通过 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新星形位置，速度为 200 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制五角星\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.lineStyle(2, 0xffa500, 1); // 橙色边框\n  \n  // 星形的顶点坐标（以中心为原点）\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 12;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: 32 + Math.cos(angle) * radius,\n      y: 32 + Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在屏幕中央\n  star = this.add.sprite(400, 300, 'star');\n  \n  // 设置键盘输入 - WASD\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间增量（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新星形位置\n  if (keys.w.isDown) {\n    star.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    star.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    star.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    star.x += distance; // 向右移动\n  }\n  \n  // 限制星形在屏幕范围内\n  star.x = Phaser.Math.Clamp(star.x, 0, 800);\n  star.y = Phaser.Math.Clamp(star.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000485_v3", "prompt_id": "seed_000485", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕上显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕上显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小和 Scene\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 32 像素，并居中显示\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕中央创建文本对象\n  // 参数：x 坐标, y 坐标, 文本内容, 样式配置\n  const text = this.add.text(\n    400, // x 坐标（屏幕中心）\n    300, // y 坐标（屏幕中心）\n    'Hello Phaser', // 文本内容\n    {\n      fontSize: '32px', // 字体大小\n      color: '#ffffff', // 文字颜色（白色）\n      fontFamily: 'Arial' // 字体家族\n    }\n  );\n  \n  // 设置文本的原点为中心，使其真正居中显示\n  text.setOrigin(0.5, 0.5);\n}\n\n// 创建并启动游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000216_v3", "prompt_id": "seed_000216", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：黄色敌人从上方以 200 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，黄色敌人从上方以200速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 创建 Scene 配置，启用 Arcade 物理系统\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（黄色圆形）纹理\n3. 创建玩家精灵，绑定键盘左右控制\n4. 创建敌人组，定时从顶部随机位置生成敌人，设置向下速度200\n5. 添加碰撞检测，碰撞时触发游戏结束\n6. 显示游戏状态（存活时间/分数）和游戏结束文本\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.score = 0;\n    this.gameOver = false;\n    this.survivalTime = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 生成敌人纹理（黄色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xffff00, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每1秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n\n    // 存活时间文本\n    this.timeText = this.add.text(16, 50, 'Time: 0s', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 370, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 空格键重启\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 计时器\n    this.startTime = this.time.now;\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      // 游戏结束后，按空格重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.scene.restart();\n        this.score = 0;\n        this.gameOver = false;\n        this.survivalTime = 0;\n      }\n      return;\n    }\n\n    // 玩家移动控制\n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 更新存活时间\n    this.survivalTime = Math.floor((time - this.startTime) / 1000);\n    this.timeText.setText('Time: ' + this.survivalTime + 's');\n\n    // 清理超出屏幕的敌人并增加分数\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 620) {\n        enemy.destroy();\n        this.score += 10;\n        this.scoreText.setText('Score: ' + this.score);\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) return;\n\n    // 随机 x 坐标\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    // 设置敌人向下速度为 200\n    enemy.setVelocityY(200);\n    enemy.body.setSize(30, 30);\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) return;\n\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.enemyTimer.remove();\n    \n    // 玩家变红\n    player.setTint(0xff0000);\n\n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // 显示最终分数\n    this.gameOverText.setText(\n      'GAME OVER\\nScore: ' + this.score + '\\nTime: ' + this.survivalTime + 's'\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001196_v3", "prompt_id": "seed_001196", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9221428571428572}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个绿色三角形在0.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo: true 实现往返效果，repeat: -1 实现无限循环\n5. 设置 duration 为 500 毫秒（0.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右移动，然后往返循环\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 500,               // 持续时间 500 毫秒（0.5秒）\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000416_v3", "prompt_id": "seed_000416", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的白色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的白色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.lineStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.strokePath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象计算六边形的6个顶点坐标（基于中心点和半径32像素）\n4. 使用 Graphics API 绘制白色六边形路径\n5. 为每个六边形设置随机位置（x: 32-768, y: 32-568，确保六边形完全在画布内）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 六边形参数\n  const hexRadius = 32; // 半径32像素，总大小64像素\n  const hexCount = 20;\n  \n  // 创建20个随机位置的白色六边形\n  for (let i = 0; i < hexCount; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置白色描边样式\n    graphics.lineStyle(2, 0xffffff, 1);\n    \n    // 计算六边形的6个顶点（相对于中心点）\n    const vertices = [];\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j; // 每个顶点间隔60度\n      const vx = hexRadius * Math.cos(angle);\n      const vy = hexRadius * Math.sin(angle);\n      vertices.push({ x: vx, y: vy });\n    }\n    \n    // 绘制六边形路径\n    graphics.beginPath();\n    graphics.moveTo(vertices[0].x, vertices[0].y);\n    for (let j = 1; j < 6; j++) {\n      graphics.lineTo(vertices[j].x, vertices[j].y);\n    }\n    graphics.closePath();\n    graphics.strokePath();\n    \n    // 设置随机位置（确保六边形完全在画布内）\n    const randomX = Phaser.Math.Between(hexRadius, 800 - hexRadius);\n    const randomY = Phaser.Math.Between(hexRadius, 600 - hexRadius);\n    graphics.setPosition(randomX, randomY);\n  }\n  \n  // 添加提示文本\n  this.add.text(10, 10, '20个随机位置的白色六边形', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000363_v2", "prompt_id": "seed_000363", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色菱形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色菱形 3 秒左右往返循环补间动画\nAPI: Graphics.fillStyle, Graphics.fillPath, Tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制青色菱形并生成纹理\n2. 创建 Sprite 使用菱形纹理\n3. 使用 Tweens 创建 x 轴移动动画，设置 duration 为 3000ms\n4. 配置 yoyo 为 true 实现往返效果\n5. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制菱形（使用 Path）\n  const diamondSize = 50;\n  const path = new Phaser.Geom.Path();\n  \n  // 菱形的四个顶点（中心在 50, 50）\n  path.moveTo(diamondSize, 0);                    // 上顶点\n  path.lineTo(diamondSize * 2, diamondSize);      // 右顶点\n  path.lineTo(diamondSize, diamondSize * 2);      // 下顶点\n  path.lineTo(0, diamondSize);                    // 左顶点\n  path.closePath();                               // 闭合路径\n  \n  // 填充路径\n  graphics.fillPath(path);\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', diamondSize * 2, diamondSize * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建菱形精灵，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 3000,             // 持续时间 3 秒\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 启用往返效果（到达终点后反向播放）\n    repeat: -1                  // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '青色菱形往返循环动画', {\n    fontSize: '24px',\n    color: '#00ffff',\n    align: 'center'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '动画：3秒从左到右，然后往返循环', {\n    fontSize: '16px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000170_v1", "prompt_id": "seed_000170", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让蓝色圆形在 1 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个蓝色圆形，使用 Tween 实现抖动动画效果，1秒循环一次\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现抖动效果（随机偏移 x/y 坐标）\n4. 设置 yoyo 和 repeat 实现循环抖动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0088ff, 1);\n  graphics.fillCircle(50, 50, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('blueCircle', 100, 100);\n  graphics.destroy();\n  \n  // 创建圆形精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'blueCircle');\n  \n  // 创建抖动动画\n  // 使用多个属性同时抖动来模拟抖动效果\n  this.tweens.add({\n    targets: circle,\n    x: {\n      from: 400,\n      to: 400,\n      ease: 'Sine.easeInOut',\n      duration: 50,\n      yoyo: true,\n      repeat: 9, // 重复9次，加上第一次共10次，总计1秒\n      onUpdate: function(tween, target) {\n        // 在更新时添加随机偏移实现抖动\n        const offset = Phaser.Math.Between(-5, 5);\n        target.x = 400 + offset;\n      }\n    },\n    y: {\n      from: 300,\n      to: 300,\n      ease: 'Sine.easeInOut',\n      duration: 50,\n      yoyo: true,\n      repeat: 9,\n      onUpdate: function(tween, target) {\n        const offset = Phaser.Math.Between(-5, 5);\n        target.y = 300 + offset;\n      }\n    },\n    loop: -1, // 无限循环\n    loopDelay: 0\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '抖动动画效果 (1秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000207_v2", "prompt_id": "seed_000207", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 240 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKeys(), graphics.fillRect(), graphics.generateTexture()\nSTEPS:\n1. 使用 Graphics 绘制方块并生成纹理\n2. 创建 Sprite 对象作为可移动的方块\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新方块位置，速度为 240 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 使用 Graphics 生成方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerSquare', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家方块，初始位置在屏幕中央\n  player = this.add.sprite(400, 300, 'playerSquare');\n  \n  // 添加 WASD 键监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间间隔（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 WASD 按键状态并设置移动方向\n  if (keys.w.isDown) {\n    velocityY = -1; // 向上\n  } else if (keys.s.isDown) {\n    velocityY = 1;  // 向下\n  }\n  \n  if (keys.a.isDown) {\n    velocityX = -1; // 向左\n  } else if (keys.d.isDown) {\n    velocityX = 1;  // 向右\n  }\n  \n  // 对角线移动时归一化速度（避免对角线速度过快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const normalize = Math.sqrt(2) / 2;\n    velocityX *= normalize;\n    velocityY *= normalize;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000004_v1", "prompt_id": "seed_000004", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色椭圆在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色椭圆在4秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillEllipse, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制紫色椭圆\n2. 创建补间动画，设置从左到右的 x 坐标变化\n3. 设置 duration 为 4000ms，yoyo 为 true 实现往返，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建紫色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillEllipse(0, 0, 80, 50); // 椭圆，中心点在(0,0)，宽80，高50\n  \n  // 将椭圆初始位置设置在左侧\n  graphics.x = 100;\n  graphics.y = 300; // 垂直居中\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: graphics,\n    x: 700, // 移动到右侧\n    duration: 4000, // 4秒\n    yoyo: true, // 往返效果\n    repeat: -1, // 无限循环 (-1 表示永久重复)\n    ease: 'Linear' // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '紫色椭圆左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000709_v3", "prompt_id": "seed_000709", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色星形在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色星形在 3 秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Star\nSTEPS:\n1. 使用 Graphics 绘制绿色星形纹理\n2. 创建 Star 游戏对象并应用纹理\n3. 使用 Tween 创建 y 轴弹跳动画，持续 3 秒并循环\n4. 设置缓动函数模拟弹跳效果（Bounce.easeOut）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建绿色星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制星形路径\n  const points = [];\n  const starPoints = 5;\n  const outerRadius = 50;\n  const innerRadius = 20;\n  \n  for (let i = 0; i < starPoints * 2; i++) {\n    const angle = (i * Math.PI) / starPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: 50 + Math.cos(angle) * radius,\n      y: 50 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.image(400, 200, 'star');\n  \n  // 创建弹跳动画\n  // 从初始位置(y=200)弹跳到底部(y=500)，然后返回\n  this.tweens.add({\n    targets: star,\n    y: 500, // 弹跳到的目标位置\n    duration: 1500, // 下落 1.5 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返运动\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 50, 'Bouncing Star Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 580, '3-second bounce cycle (1.5s down + 1.5s up)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000694_v1", "prompt_id": "seed_000694", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个白色物体以 360 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个白色物体以360速度随机移动，碰撞边界和彼此时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World.setBoundsCollision, Phaser.Physics.Arcade.Collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成白色圆形纹理\n3. 创建物理组，添加 15 个物体\n4. 为每个物体设置随机速度（总速度为 360）\n5. 设置物体与世界边界碰撞反弹\n6. 设置物体之间的碰撞检测\n7. 添加状态信号变量记录碰撞次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet collisionCount = 0;\nlet objectCount = 15;\nlet targetSpeed = 360;\n\nfunction preload() {\n  // 创建白色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('whiteCircle', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理组\n  const objects = this.physics.add.group({\n    key: 'whiteCircle',\n    repeat: objectCount - 1,\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n\n  // 为每个物体设置随机位置和速度\n  objects.children.iterate((object) => {\n    // 随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    object.setPosition(x, y);\n\n    // 随机方向，固定速度 360\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const vx = Math.cos(angle) * targetSpeed;\n    const vy = Math.sin(angle) * targetSpeed;\n    object.setVelocity(vx, vy);\n\n    // 设置圆形碰撞体\n    object.setCircle(16);\n  });\n\n  // 设置物体之间的碰撞\n  this.physics.add.collider(objects, objects, onCollision, null, this);\n\n  // 显示状态信息\n  const statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n\n  // 更新状态显示\n  this.events.on('update', () => {\n    statusText.setText([\n      `Objects: ${objectCount}`,\n      `Speed: ${targetSpeed}`,\n      `Collisions: ${collisionCount}`\n    ]);\n  });\n}\n\nfunction update(time, delta) {\n  // 每帧更新逻辑（如需要可在此添加）\n}\n\nfunction onCollision(obj1, obj2) {\n  // 碰撞计数器\n  collisionCount++;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000892_v3", "prompt_id": "seed_000892", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按空格键触发相机缩放效果，持续 1 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按空格键触发相机缩放效果，持续 1 秒\nAPI: Phaser.Input.Keyboard.KeyCodes.SPACE, Phaser.Cameras.Scene2D.Camera.zoomTo, Phaser.Input.Keyboard.KeyboardPlugin.addKey\nSTEPS:\n1. 创建场景并绘制一些可视化元素（使用 Graphics 绘制网格和中心标记）\n2. 在 create 中监听空格键输入\n3. 按下空格键时调用 camera.zoomTo() 方法，设置目标缩放值和持续时间 1000ms\n4. 添加状态变量 zoomCount 记录缩放触发次数，并在屏幕上显示\n5. 缩放完成后恢复原始缩放值\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.zoomCount = 0; // 状态信号：记录缩放触发次数\n    this.isZooming = false; // 防止重复触发\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 绘制背景网格\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x00ff00, 0.3);\n    \n    // 绘制垂直线\n    for (let x = 0; x <= width; x += 50) {\n      graphics.lineBetween(x, 0, x, height);\n    }\n    \n    // 绘制水平线\n    for (let y = 0; y <= height; y += 50) {\n      graphics.lineBetween(0, y, width, y);\n    }\n\n    // 绘制中心标记\n    const centerGraphics = this.add.graphics();\n    centerGraphics.fillStyle(0xff0000, 1);\n    centerGraphics.fillCircle(width / 2, height / 2, 20);\n    \n    centerGraphics.fillStyle(0xffffff, 1);\n    centerGraphics.fillCircle(width / 2, height / 2, 10);\n\n    // 绘制四个角落的参考方块\n    const cornerGraphics = this.add.graphics();\n    cornerGraphics.fillStyle(0x0000ff, 1);\n    cornerGraphics.fillRect(50, 50, 40, 40);\n    cornerGraphics.fillRect(width - 90, 50, 40, 40);\n    cornerGraphics.fillRect(50, height - 90, 40, 40);\n    cornerGraphics.fillRect(width - 90, height - 90, 40, 40);\n\n    // 添加状态文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setScrollFactor(0); // 固定在屏幕上，不受相机影响\n\n    // 添加提示文本\n    this.instructionText = this.add.text(width / 2, height - 50, 'Press SPACE to zoom camera', {\n      fontSize: '24px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.instructionText.setOrigin(0.5);\n    this.instructionText.setScrollFactor(0);\n\n    // 更新状态显示\n    this.updateStatus();\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    this.spaceKey.on('down', () => {\n      this.triggerZoom();\n    });\n\n    // 获取主相机\n    this.mainCamera = this.cameras.main;\n  }\n\n  triggerZoom() {\n    // 如果正在缩放中，忽略新的触发\n    if (this.isZooming) {\n      return;\n    }\n\n    this.isZooming = true;\n    this.zoomCount++;\n    this.updateStatus();\n\n    // 缩放到 1.5 倍，持续 1000 毫秒\n    this.mainCamera.zoomTo(1.5, 1000, 'Linear', false, (camera, progress) => {\n      // 缩放完成回调\n      if (progress === 1) {\n        // 缩放完成后，再缩放回原始大小\n        this.mainCamera.zoomTo(1.0, 1000, 'Linear', false, (cam, prog) => {\n          if (prog === 1) {\n            this.isZooming = false;\n            this.updateStatus();\n          }\n        });\n      }\n    });\n  }\n\n  updateStatus() {\n    const status = this.isZooming ? 'ZOOMING' : 'READY';\n    this.statusText.setText([\n      `Zoom Count: ${this.zoomCount}`,\n      `Status: ${status}`,\n      `Current Zoom: ${this.mainCamera.zoom.toFixed(2)}`\n    ]);\n  }\n\n  update(time, delta) {\n    // 实时更新当前缩放值\n    if (this.isZooming) {\n      this.updateStatus();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000867_v2", "prompt_id": "seed_000867", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色星形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现灰色星形在2秒内左右往返循环移动的补间动画\nAPI: Graphics.fillStyle, Graphics.fillStar, Tweens.add, BaseTween.yoyo, BaseTween.repeat\nSTEPS:\n1. 使用 Graphics 绘制灰色星形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置 duration 为 2000 毫秒完成单程移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 绘制星形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制星形 (x, y, points, innerRadius, outerRadius)\n  graphics.fillStar(50, 50, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  \n  // 销毁 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（右侧）\n    duration: 2000,          // 持续时间 2 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向播放）\n    repeat: -1,              // 无限循环（-1 表示永久重复）\n    ease: 'Linear'           // 线性缓动，匀速移动\n  });\n  \n  // 添加文字说明\n  this.add.text(300, 50, 'Star Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(300, 550, 'The star moves left to right in 2 seconds, then loops back', {\n    fontSize: '16px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000118_v3", "prompt_id": "seed_000118", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个自动向左上移动的菱形，相机跟随该对象并保持居中\nAPI: Graphics, Camera.startFollow, Camera.setBounds, Sprite\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 设置相机跟随该 Sprite 对象\n4. 在 update 中让菱形持续向左上方移动\n5. 设置足够大的世界边界以容纳移动范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst moveSpeed = 100; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，足够大以容纳移动\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1);\n  \n  // 绘制菱形（中心点在 32, 32）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 上顶点\n  graphics.lineTo(64, 32);     // 右顶点\n  graphics.lineTo(32, 64);     // 下顶点\n  graphics.lineTo(0, 32);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n\n  // 创建菱形精灵，初始位置在世界中心\n  diamond = this.add.sprite(1000, 1000, 'diamond');\n  \n  // 设置相机跟随菱形\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 可选：设置跟随偏移量（这里保持居中，所以偏移为 0）\n  this.cameras.main.setFollowOffset(0, 0);\n\n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随菱形\\n菱形向左上移动', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让菱形向左上方移动\n  // 左上方向：x 减少，y 减少\n  const deltaSeconds = delta / 1000;\n  \n  diamond.x -= moveSpeed * deltaSeconds * 0.707; // 向左移动（cos 45°）\n  diamond.y -= moveSpeed * deltaSeconds * 0.707; // 向上移动（sin 45°）\n  \n  // 可选：限制在世界边界内\n  diamond.x = Phaser.Math.Clamp(diamond.x, 32, 1968);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 32, 1968);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000179_v1", "prompt_id": "seed_000179", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9122222222222223}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现青色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 青色角色按键切换 idle/run 状态，通过 tween 和动画体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Tweens, Phaser.Animations\nSTEPS:\n1. 使用 Graphics 创建青色角色纹理（idle 和 run 两种形态）\n2. 设置键盘输入监听（空格键切换状态，方向键触发 run）\n3. 创建 idle 状态的呼吸缩放 tween 动画\n4. 创建 run 状态的快速移动和旋转 tween 动画\n5. 实现状态切换逻辑，显示当前状态文本\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 状态信号变量\nlet currentState = 'idle';\nlet stateChangeCount = 0;\nlet totalRunTime = 0;\nlet totalIdleTime = 0;\n\nfunction preload() {\n  // 创建青色角色纹理 - idle 状态（圆形）\n  const idleGraphics = this.add.graphics();\n  idleGraphics.fillStyle(0x00FFFF, 1);\n  idleGraphics.fillCircle(32, 32, 30);\n  idleGraphics.fillStyle(0xFFFFFF, 1);\n  idleGraphics.fillCircle(20, 25, 5); // 左眼\n  idleGraphics.fillCircle(44, 25, 5); // 右眼\n  idleGraphics.fillStyle(0x00CCCC, 1);\n  idleGraphics.fillCircle(32, 45, 8); // 嘴巴\n  idleGraphics.generateTexture('player_idle', 64, 64);\n  idleGraphics.destroy();\n\n  // 创建青色角色纹理 - run 状态（椭圆形，更有动感）\n  const runGraphics = this.add.graphics();\n  runGraphics.fillStyle(0x00FFFF, 1);\n  runGraphics.fillEllipse(32, 32, 50, 40);\n  runGraphics.fillStyle(0xFFFFFF, 1);\n  runGraphics.fillCircle(25, 28, 5); // 左眼\n  runGraphics.fillCircle(45, 28, 5); // 右眼\n  runGraphics.fillStyle(0x00CCCC, 1);\n  runGraphics.fillEllipse(32, 42, 12, 6); // 张开的嘴\n  // 添加运动线条\n  runGraphics.lineStyle(3, 0x00CCCC, 0.7);\n  runGraphics.lineBetween(5, 20, 15, 25);\n  runGraphics.lineBetween(5, 35, 15, 38);\n  runGraphics.generateTexture('player_run', 64, 64);\n  runGraphics.destroy();\n}\n\nfunction create() {\n  // 创建角色精灵\n  this.player = this.add.sprite(400, 300, 'player_idle');\n  this.player.setScale(2);\n\n  // 状态文本显示\n  this.stateText = this.add.text(400, 100, 'State: IDLE', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#00FFFF',\n    stroke: '#000000',\n    strokeThickness: 4\n  }).setOrigin(0.5);\n\n  // 统计信息文本\n  this.statsText = this.add.text(20, 20, '', {\n    fontSize: '18px',\n    fontFamily: 'Arial',\n    color: '#FFFFFF'\n  });\n\n  // 提示文本\n  this.add.text(400, 550, 'Press SPACE to toggle | Arrow Keys to move in RUN state', {\n    fontSize: '16px',\n    fontFamily: 'Arial',\n    color: '#AAAAAA'\n  }).setOrigin(0.5);\n\n  // 键盘输入设置\n  this.cursors = this.input.keyboard.createCursorKeys();\n  this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 空格键切换状态\n  this.spaceKey.on('down', () => {\n    this.switchState();\n  });\n\n  // 初始化时间追踪\n  this.stateStartTime = this.time.now;\n\n  // 启动 idle 动画\n  this.startIdleAnimation();\n}\n\nfunction update(time, delta) {\n  // 更新状态时间统计\n  const elapsedSeconds = (time - this.stateStartTime) / 1000;\n  if (currentState === 'idle') {\n    totalIdleTime = elapsedSeconds;\n  } else {\n    totalRunTime = elapsedSeconds;\n  }\n\n  // 更新统计文本\n  this.statsText.setText([\n    `State Changes: ${stateChangeCount}`,\n    `Current State Time: ${elapsedSeconds.toFixed(1)}s`,\n    `Total Idle Time: ${totalIdleTime.toFixed(1)}s`,\n    `Total Run Time: ${totalRunTime.toFixed(1)}s`\n  ]);\n\n  // run 状态下的方向键移动\n  if (currentState === 'run') {\n    const speed = 5;\n    let moved = false;\n\n    if (this.cursors.left.isDown) {\n      this.player.x -= speed;\n      this.player.setFlipX(true);\n      moved = true;\n    } else if (this.cursors.right.isDown) {\n      this.player.x += speed;\n      this.player.setFlipX(false);\n      moved = true;\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.y -= speed;\n      moved = true;\n    } else if (this.cursors.down.isDown) {\n      this.player.y += speed;\n      moved = true;\n    }\n\n    // 边界检查\n    this.player.x = Phaser.Math.Clamp(this.player.x, 50, 750);\n    this.player.y = Phaser.Math.Clamp(this.player.y, 150, 500);\n\n    // 如果在移动，增加旋转效果\n    if (moved && !this.player.getData('rotating')) {\n      this.player.setData('rotating', true);\n      this.tweens.add({\n        targets: this.player,\n        angle: this.player.angle + 360,\n        duration: 800,\n        ease: 'Linear',\n        onComplete: () => {\n          this.player.setData('rotating', false);\n          this.player.angle = 0;\n        }\n      });\n    }\n  }\n}\n\n// 切换状态函数\nfunction switchState() {\n  // 停止所有当前 tween\n  this.tweens.killTweensOf(this.player);\n  \n  if (currentState === 'idle') {\n    // 切换到 run 状态\n    currentState = 'run';\n    this.player.setTexture('player_run');\n    this.stateText.setText('State: RUN');\n    this.stateText.setColor('#FFFF00');\n    this.startRunAnimation();\n  } else {\n    // 切换到 idle 状态\n    currentState = 'idle';\n    this.player.setTexture('player_idle');\n    this.player.setFlipX(false);\n    this.player.angle = 0;\n    this.stateText.setText('State: IDLE');\n    this.stateText.setColor('#00FFFF');\n    this.startIdleAnimation();\n  }\n\n  stateChangeCount++;\n  this.stateStartTime = this.time.now;\n}\n\n// idle 状态动画 - 呼吸效果\nfunction startIdleAnimation() {\n  this.tweens.add({\n    targets: this.player,\n    scaleX: 2.2,\n    scaleY: 2.2,\n    duration: 1500,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1\n  });\n\n  // 轻微上下浮动\n  this.tweens.add({\n    targets: this.player,\n    y: this.player.y - 10,\n    duration: 2000,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1\n  });\n}\n\n// run 状态动画 - 快速脉冲效果\nfunction startRunAnimation() {\n  this.tweens.add({\n    targets: this.player,\n    scaleX: 2.3,\n    scaleY: 1.8,\n    duration: 300,\n    ease: 'Power2',\n    yoyo: true,\n    repeat: -1\n  });\n\n  // 添加发光效果（通过快速缩放模拟）\n  this.tweens.add({\n    targets: this.player,\n    alpha: 0.7,\n    duration: 200,\n    ease: 'Linear',\n    yoyo: true,\n    repeat: -1\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001067_v3", "prompt_id": "seed_001067", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.9100000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色六边形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色六边形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的 6 个顶点坐标（中心点在画布中央，半径约 40 像素）\n4. 使用 Graphics API 绘制六边形路径并填充红色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 计算六边形参数\n  const centerX = 400; // 画布中心 X\n  const centerY = 300; // 画布中心 Y\n  const radius = 40;   // 六边形外接圆半径（总大小约 80 像素）\n  const sides = 6;     // 六边形有 6 条边\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制六边形的 6 个顶点\n  for (let i = 0; i < sides; i++) {\n    // 六边形顶点角度（从顶部开始，逆时针）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y); // 移动到第一个顶点\n    } else {\n      graphics.lineTo(x, y); // 连线到下一个顶点\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000597_v3", "prompt_id": "seed_000597", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示\"Hello Phaser\"文字，字体大小80像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左下角（x=0, y=canvas高度），设置字体大小为80px\n4. 设置文本原点为左下角，确保文本正确定位在屏幕左下\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本任务不需要预加载外部资源\n}\n\nfunction create() {\n  // 在屏幕左下角创建文本\n  // x=0 表示左侧，y=600 表示底部\n  const text = this.add.text(0, 600, 'Hello Phaser', {\n    fontSize: '80px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本原点为左下角 (0, 1)\n  // 这样文本的左下角会对齐到 (0, 600) 位置\n  text.setOrigin(0, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000249_v3", "prompt_id": "seed_000249", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 2 秒内缩放到 24% 然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale 从 1 到 0.24 再到 1）\n4. 设置 Tween 循环播放（loop: -1）和 yoyo 效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 顶点\n  graphics.lineTo(100, 100);   // 右下\n  graphics.lineTo(0, 100);     // 左下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.24,        // 缩放到 24%\n    scaleY: 0.24,        // 缩放到 24%\n    duration: 2000,      // 2 秒\n    yoyo: true,          // 自动恢复到原始值\n    loop: -1,            // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 50, 'Triangle scaling to 24% and back (2s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000117_v3", "prompt_id": "seed_000117", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让青色椭圆在 2 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色椭圆的2秒缩放循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, this.add.graphics, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆形状\n2. 将 Graphics 转换为可复用的纹理\n3. 创建使用该纹理的精灵对象\n4. 使用 tweens 创建缩放动画，设置循环和悠悠球效果\n5. 配置动画持续时间为2秒并启动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制椭圆（中心点在 0,0，宽度100，高度60）\n  graphics.fillEllipse(0, 0, 100, 60);\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('ellipseTexture', 100, 60);\n  \n  // 销毁 Graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用该纹理的精灵，放置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'ellipseTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    scaleX: 1.5,                // X轴缩放到1.5倍\n    scaleY: 1.5,                // Y轴缩放到1.5倍\n    duration: 2000,             // 持续时间2秒\n    ease: 'Sine.easeInOut',     // 缓动函数，使动画更平滑\n    yoyo: true,                 // 悠悠球效果（放大后缩小）\n    repeat: -1                  // 无限循环（-1表示永久重复）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Cyan Ellipse Scaling Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 1.0 → 1.5 → 1.0 (2 seconds loop)', {\n    fontSize: '16px',\n    color: '#00ffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000390_v3", "prompt_id": "seed_000390", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个基于 15x15 数组的简单 Tilemap：0 为空，1 为墙可碰撞，玩家用方向键移动且不能穿墙。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tilemaps.Tilemap\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现15x15瓦片地图，玩家方向键移动且不能穿墙\nAPI: Phaser.Tilemaps.Tilemap, Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建15x15二维数组定义地图数据（0空地，1墙壁）\n2. 使用Graphics生成瓦片纹理（空地和墙壁）\n3. 通过createBlank创建Tilemap并填充瓦片数据\n4. 设置墙壁瓦片的碰撞属性\n5. 创建玩家精灵并启用物理系统\n6. 添加方向键输入控制\n7. 在update中处理玩家移动逻辑\n8. 添加玩家与墙壁的碰撞检测\n9. 维护可验证状态（玩家位置坐标）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 600,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量（可验证）\nlet gameState = {\n  playerX: 1,\n  playerY: 1,\n  moveCount: 0\n};\n\n// 15x15 地图数据：0=空地，1=墙壁\nconst mapData = [\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],\n  [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],\n  [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],\n  [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,1,1,0,1,1,1,1,1,1,1,0,1,1,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],\n  [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],\n  [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],\n  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n];\n\nconst TILE_SIZE = 40;\nlet player;\nlet cursors;\nlet tilemap;\nlet layer;\n\nfunction preload() {\n  // 使用 Graphics 创建瓦片纹理\n  const graphics = this.add.graphics();\n  \n  // 创建空地纹理（浅灰色）\n  graphics.fillStyle(0xcccccc, 1);\n  graphics.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n  graphics.lineStyle(1, 0xaaaaaa, 1);\n  graphics.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);\n  graphics.generateTexture('ground', TILE_SIZE, TILE_SIZE);\n  \n  // 创建墙壁纹理（深灰色）\n  graphics.clear();\n  graphics.fillStyle(0x333333, 1);\n  graphics.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n  graphics.lineStyle(2, 0x222222, 1);\n  graphics.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);\n  graphics.generateTexture('wall', TILE_SIZE, TILE_SIZE);\n  \n  // 创建玩家纹理（蓝色圆形）\n  graphics.clear();\n  graphics.fillStyle(0x0066ff, 1);\n  graphics.fillCircle(TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2 - 4);\n  graphics.lineStyle(2, 0x0044cc, 1);\n  graphics.strokeCircle(TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2 - 4);\n  graphics.generateTexture('player', TILE_SIZE, TILE_SIZE);\n  \n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建空白 Tilemap\n  tilemap = this.make.tilemap({\n    tileWidth: TILE_SIZE,\n    tileHeight: TILE_SIZE,\n    width: 15,\n    height: 15\n  });\n  \n  // 添加瓦片集\n  const tiles = tilemap.addTilesetImage('tiles', null, TILE_SIZE, TILE_SIZE);\n  \n  // 创建图层\n  layer = tilemap.createBlankLayer('layer1', tiles, 0, 0);\n  \n  // 手动填充瓦片数据\n  for (let y = 0; y < 15; y++) {\n    for (let x = 0; x < 15; x++) {\n      const tileIndex = mapData[y][x];\n      if (tileIndex === 1) {\n        // 墙壁\n        const tile = layer.putTileAt(1, x, y);\n        tile.setCollision(true);\n      } else {\n        // 空地\n        layer.putTileAt(0, x, y);\n      }\n    }\n  }\n  \n  // 使用 Graphics 渲染瓦片（因为 Tilemap 需要实际纹理）\n  const mapGraphics = this.add.graphics();\n  for (let y = 0; y < 15; y++) {\n    for (let x = 0; x < 15; x++) {\n      if (mapData[y][x] === 1) {\n        // 墙壁\n        mapGraphics.fillStyle(0x333333, 1);\n        mapGraphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n        mapGraphics.lineStyle(2, 0x222222, 1);\n        mapGraphics.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n      } else {\n        // 空地\n        mapGraphics.fillStyle(0xcccccc, 1);\n        mapGraphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n        mapGraphics.lineStyle(1, 0xaaaaaa, 1);\n        mapGraphics.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n      }\n    }\n  }\n  \n  // 设置图层碰撞（所有值为1的瓦片可碰撞）\n  layer.setCollisionByProperty({ collides: true });\n  layer.setCollisionBetween(1, 1);\n  \n  // 创建玩家精灵\n  player = this.physics.add.sprite(\n    gameState.playerX * TILE_SIZE + TILE_SIZE / 2,\n    gameState.playerY * TILE_SIZE + TILE_SIZE / 2,\n    'player'\n  );\n  \n  player.setCollideWorldBounds(true);\n  player.body.setSize(TILE_SIZE - 8, TILE_SIZE - 8);\n  \n  // 添加玩家与图层的碰撞\n  this.physics.add.collider(player, layer);\n  \n  // 创建方向键\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 显示状态信息\n  this.add.text(10, 10, 'Use Arrow Keys to Move', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 5, y: 5 }\n  }).setScrollFactor(0).setDepth(100);\n  \n  // 状态文本（可验证）\n  this.statusText = this.add.text(10, 40, '', {\n    fontSize: '14px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 5, y: 5 }\n  }).setScrollFactor(0).setDepth(100);\n  \n  updateStatusText.call(this);\n}\n\nfunction update() {\n  const speed = 160;\n  \n  // 重置速度\n  player.setVelocity(0);\n  \n  // 处理方向键输入\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n  \n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n  \n  // 更新游戏状态\n  const newX = Math.floor(player.x / TILE_SIZE);\n  const newY = Math.floor(player.y / TILE_SIZE);\n  \n  if (newX !== gameState.playerX || newY !== gameState.playerY) {\n    gameState.playerX = newX;\n    gameState.playerY = newY;\n    gameState.moveCount++;\n    updateStatusText.call(this);\n  }\n}\n\nfunction updateStatusText() {\n  this.statusText.setText(\n    `Position: (${gameState.playerX}, ${gameState.playerY}) | Moves: ${gameState.moveCount}`\n  );\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000973_v2", "prompt_id": "seed_000973", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Tilemap", "Input", "Physics"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色圆形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个粉色圆形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建基本的 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充颜色为粉色（0xFFC0CB）\n4. 在画布中央（400, 300）绘制半径为16的圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为粉色\n  graphics.fillStyle(0xFFC0CB, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数：x坐标, y坐标, 半径\n  // 画布尺寸 800x600，中心点为 (400, 300)\n  // 大小约32像素，使用半径16\n  graphics.fillCircle(400, 300, 16);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000233_v1", "prompt_id": "seed_000233", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个白色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个白色小球在封闭空间内以360速度移动，碰到边界和彼此时弹性碰撞\nAPI: Phaser.Physics.Arcade, Graphics.generateTexture, physics.add.group, collider, setBounce, setCollideWorldBounds\nSTEPS:\n1. 配置 Arcade 物理系统，启用世界边界\n2. 使用 Graphics 生成白色圆形纹理\n3. 创建物理组，添加5个小球，设置随机初始速度\n4. 设置小球与世界边界的碰撞反弹\n5. 设置小球之间的碰撞检测\n6. 添加碰撞计数器作为可验证状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证状态：碰撞计数\n    this.ballCount = 5; // 小球数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建白色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: this.ballCount - 1, // 总共5个球\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 设置每个小球的随机初始速度（速度大小为360）\n    const speed = 360;\n    this.balls.children.iterate((ball) => {\n      // 随机角度\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * speed;\n      const velocityY = Math.sin(angle) * speed;\n      \n      ball.setVelocity(velocityX, velocityY);\n      \n      // 随机初始位置（避免重叠）\n      ball.setPosition(\n        Phaser.Math.Between(50, this.scale.width - 50),\n        Phaser.Math.Between(50, this.scale.height - 50)\n      );\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示碰撞计数（用于验证状态）\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n\n    // 显示小球数量\n    this.ballCountText = this.add.text(10, 40, `Balls: ${this.ballCount}`, {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n\n    // 显示速度信息\n    this.speedText = this.add.text(10, 70, 'Speed: 360', {\n      fontSize: '20px',\n      color: '#ffffff'\n    });\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调，增加计数\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 确保小球速度保持在360左右（由于浮点误差可能会有微小变化）\n    this.balls.children.iterate((ball) => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏差超过1%，进行修正\n      if (Math.abs(currentSpeed - 360) > 3.6) {\n        const scale = 360 / currentSpeed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000961_v2", "prompt_id": "seed_000961", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在2秒内缩放到24%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建缩放动画，从 scale=1 到 scale=0.24，持续2秒\n4. 设置 yoyo 为 true 实现恢复效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 创建圆形精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circle');\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    scaleX: 0.24,             // X 轴缩放到 24%\n    scaleY: 0.24,             // Y 轴缩放到 24%\n    duration: 2000,           // 持续时间 2 秒（2000 毫秒）\n    yoyo: true,               // 动画结束后反向播放（恢复原始大小）\n    loop: -1,                 // 无限循环（-1 表示永久循环）\n    ease: 'Linear'            // 线性缓动\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Circle scaling animation (24% - 100% loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000174_v1", "prompt_id": "seed_000174", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在1秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 scale 属性从 1 到 0.32 再回到 1\n4. 设置 Tween 的 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建方块精灵并居中\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 创建缩放动画\n  // 使用 yoyo 实现从 1 -> 0.32 -> 1 的往返效果\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 500,  // 单程 0.5 秒\n    yoyo: true,     // 启用往返，总时长 1 秒\n    loop: -1,       // 无限循环\n    ease: 'Linear'  // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Square scaling to 32% and back (1s loop)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000516_v3", "prompt_id": "seed_000516", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色椭圆在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现橙色椭圆在0.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色椭圆并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆（中心点40,30，宽80，高60）\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const ellipseSprite = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipseSprite,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 500, // 持续时间 0.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果\n    loop: -1 // 无限循环（-1 表示永久循环）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000427_v2", "prompt_id": "seed_000427", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的圆形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个圆形作为玩家对象\n2. 生成纹理并创建 Sprite 以便移动和跟随\n3. 在 update 中让圆形对象自动向下移动\n4. 使用 camera.startFollow 让主相机跟随该对象\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.moveSpeed = 100; // 每秒向下移动的像素\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建一个大的世界边界，让相机有足够的移动空间\n    this.cameras.main.setBounds(0, 0, 800, 2000);\n    this.physics.world.setBounds(0, 0, 800, 2000);\n\n    // 绘制背景网格以便观察相机移动\n    this.createBackgroundGrid();\n\n    // 使用 Graphics 创建圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n    graphics.fillCircle(25, 25, 25); // 半径25的圆\n    graphics.generateTexture('playerCircle', 50, 50);\n    graphics.destroy();\n\n    // 创建玩家精灵（圆形）\n    this.player = this.add.sprite(400, 100, 'playerCircle');\n\n    // 设置相机跟随玩家对象\n    // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n    // roundPixels: true 可以避免像素模糊\n    // lerpX/lerpY: 0.1 表示平滑跟随（值越小越平滑，1表示立即跟随）\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n\n    // 添加文字提示\n    const text = this.add.text(400, 50, '圆形自动向下移动\\n相机跟随并居中', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      align: 'center',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setOrigin(0.5);\n    text.setScrollFactor(0); // 让文字固定在屏幕上，不随相机移动\n  }\n\n  update(time, delta) {\n    // 让圆形对象自动向下移动\n    // delta 是上一帧到这一帧的时间间隔（毫秒）\n    const moveDistance = (this.moveSpeed * delta) / 1000;\n    this.player.y += moveDistance;\n\n    // 当圆形移动到世界底部时，重置到顶部\n    if (this.player.y > 1950) {\n      this.player.y = 50;\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建网格背景以便观察相机移动\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n\n    // 绘制垂直线\n    for (let x = 0; x <= 800; x += 50) {\n      graphics.lineBetween(x, 0, x, 2000);\n    }\n\n    // 绘制水平线\n    for (let y = 0; y <= 2000; y += 50) {\n      graphics.lineBetween(0, y, 800, y);\n    }\n\n    // 添加坐标标记\n    for (let y = 0; y <= 2000; y += 200) {\n      const label = this.add.text(10, y + 5, `Y: ${y}`, {\n        fontSize: '14px',\n        fill: '#666666'\n      });\n    }\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  }\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000431_v3", "prompt_id": "seed_000431", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8776190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让白色菱形在 1.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色菱形，使用 Tween 实现 1.5 秒淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Image\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建 Image 对象使用生成的菱形纹理\n3. 使用 Tween 控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 60;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);      // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形图像对象，放置在屏幕中心\n  const diamond = this.add.image(400, 300, 'diamond');\n  \n  // 创建淡入淡出 Tween 动画\n  this.tweens.add({\n    targets: diamond,\n    alpha: 0,              // 目标透明度为 0（完全透明）\n    duration: 750,         // 单程时长 0.75 秒\n    yoyo: true,            // 启用往返效果（淡出后淡入）\n    repeat: -1,            // 无限循环\n    ease: 'Sine.easeInOut' // 使用正弦缓动函数使动画更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000250_v3", "prompt_id": "seed_000250", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的红色菱形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制8个红色菱形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景大小为 800x600\n2. 在 create 方法中循环8次\n3. 每次循环创建一个 Graphics 对象\n4. 使用 beginPath/moveTo/lineTo 绘制菱形路径（4个顶点）\n5. 使用 fillStyle 设置红色，fillPath 填充菱形\n6. 使用 setRandomPosition 设置随机位置（范围在画布内）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制8个随机位置的红色菱形\n  for (let i = 0; i < 8; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 绘制菱形（16像素大小）\n    // 菱形中心点为 (0, 0)，四个顶点分别在上下左右\n    const size = 8; // 半径为8，总大小为16\n    graphics.beginPath();\n    graphics.moveTo(0, -size);      // 上顶点\n    graphics.lineTo(size, 0);       // 右顶点\n    graphics.lineTo(0, size);       // 下顶点\n    graphics.lineTo(-size, 0);      // 左顶点\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（确保菱形完全在画布内）\n    const x = Phaser.Math.Between(size, 800 - size);\n    const y = Phaser.Math.Between(size, 600 - size);\n    graphics.setPosition(x, y);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000551_v1", "prompt_id": "seed_000551", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左上显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左上角显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左上角（x: 10, y: 10），字体大小为 48px\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本任务无需预加载资源\n}\n\nfunction create() {\n  // 在左上角创建文本对象\n  // 参数：x坐标, y坐标, 文本内容, 样式配置\n  this.add.text(10, 10, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000763_v3", "prompt_id": "seed_000763", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色矩形，大小约为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个 64x64 的红色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为红色 (0xff0000)\n4. 在画布中央 (400-32, 300-32) 绘制 64x64 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色，透明度为 1\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 计算矩形左上角坐标，使其居中\n  // 画布中心点: (400, 300)\n  // 矩形大小: 64x64\n  // 左上角坐标: (400 - 32, 300 - 32) = (368, 268)\n  const rectX = 368;\n  const rectY = 268;\n  const rectWidth = 64;\n  const rectHeight = 64;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectWidth, rectHeight);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000399_v2", "prompt_id": "seed_000399", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色三角形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色三角形在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色三角形并生成纹理\n2. 创建 Sprite 对象应用三角形纹理\n3. 使用 tweens.add 创建 x 轴移动补间动画，设置 yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9933ff, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (30, 30)，方便后续定位\n  graphics.beginPath();\n  graphics.moveTo(30, 10);      // 顶点\n  graphics.lineTo(10, 50);      // 左下角\n  graphics.lineTo(50, 50);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 60);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: triangle,           // 动画目标\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 2000,              // 持续时间 2 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返（到达终点后反向播放）\n    loop: -1                     // 无限循环（-1 表示永久循环）\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000690_v3", "prompt_id": "seed_000690", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到80%后恢复，循环播放\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add() 创建缩放动画，设置 scale 从 1 到 0.8\n4. 配置 yoyo: true 使动画往返播放\n5. 配置 loop: -1 使动画无限循环\n6. 设置 duration: 3000 (3秒)\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色填充\n  graphics.fillRect(0, 0, 150, 100); // 绘制 150x100 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('rectangleTexture', 150, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建使用该纹理的 Sprite，放置在屏幕中央\n  const rectangle = this.add.sprite(400, 300, 'rectangleTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: rectangle,           // 动画目标对象\n    scaleX: 0.8,                  // X轴缩放到 80%\n    scaleY: 0.8,                  // Y轴缩放到 80%\n    duration: 3000,               // 持续时间 3秒\n    yoyo: true,                   // 启用往返效果（缩放到80%后自动恢复）\n    loop: -1,                     // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'        // 缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '矩形缩放动画 (3秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '矩形会在3秒内缩放到80%，然后恢复原始大小，循环播放', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000646_v2", "prompt_id": "seed_000646", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的白色矩形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的白色矩形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环15次，每次生成随机 x、y 坐标\n4. 设置白色填充样式并绘制 48x48 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置白色填充样式\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制15个随机位置的矩形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机位置，确保矩形不会超出画布边界\n    // x 范围: 0 到 (800 - 48)\n    // y 范围: 0 到 (600 - 48)\n    const x = Phaser.Math.Between(0, config.width - 48);\n    const y = Phaser.Math.Between(0, config.height - 48);\n    \n    // 绘制 48x48 的白色矩形\n    graphics.fillRect(x, y, 48, 48);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000206_v3", "prompt_id": "seed_000206", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色三角形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建 x 坐标补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-30, 30);     // 左下角\n  graphics.lineTo(30, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右，2秒完成，往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 2000,            // 持续时间 2 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000608_v2", "prompt_id": "seed_000608", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色方块，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的黄色方块，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 使用 Phaser.Math.Between 生成随机 x, y 坐标（确保方块完全在画布内）\n4. 使用 fillStyle 设置黄色（0xffff00），使用 fillRect 绘制 24x24 的方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制8个随机位置的黄色方块\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 生成随机位置（确保方块完全在画布内）\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const randomX = Phaser.Math.Between(0, 776);\n    const randomY = Phaser.Math.Between(0, 576);\n    \n    // 设置黄色填充\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制 24x24 的方块\n    graphics.fillRect(randomX, randomY, 24, 24);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000278_v3", "prompt_id": "seed_000278", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#fillPoints, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个六边形\n2. 计算六边形的六个顶点坐标（使用三角函数）\n3. 在 update 中每帧更新 Graphics 的 rotation 属性\n4. 根据 delta 时间和每秒 160 度的速度计算旋转增量\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nconst rotationSpeed = 160; // 每秒旋转 160 度\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  hexagon = this.add.graphics();\n  \n  // 设置填充颜色\n  hexagon.fillStyle(0x00ff00, 1);\n  \n  // 计算六边形的六个顶点\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 100;\n  const points = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个顶点间隔 60 度\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 绘制六边形\n  hexagon.fillPoints(points, true);\n  \n  // 设置旋转中心点为六边形中心\n  hexagon.x = 0;\n  hexagon.y = 0;\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量（delta 单位是毫秒，需要转换为秒）\n  const rotationDelta = Phaser.Math.DegToRad(rotationSpeed) * (delta / 1000);\n  \n  // 更新旋转角度\n  hexagon.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000280_v1", "prompt_id": "seed_000280", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个白色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个白色小球在封闭空间内以360速度移动，碰到边界和彼此时产生弹性碰撞\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Body#setBounce, Phaser.Physics.Arcade.ArcadePhysics#add.collider, Phaser.Physics.Arcade.World#setBoundsCollision\nSTEPS:\n1. 配置 Arcade 物理系统，设置世界边界碰撞\n2. 使用 Graphics 生成白色圆形纹理作为小球外观\n3. 创建物理组，添加 5 个小球精灵并设置随机位置\n4. 为每个小球设置随机速度方向（总速度360）和完全弹性（bounce=1）\n5. 添加小球与世界边界、小球之间的碰撞检测\n6. 添加状态信号：碰撞计数器用于验证\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 设置世界边界碰撞\n    this.physics.world.setBoundsCollision(true, true, true, true);\n\n    // 使用 Graphics 生成白色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ballTexture', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.ballGroup = this.physics.add.group({\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 创建5个小球\n    const speed = 360;\n    const ballCount = 5;\n\n    for (let i = 0; i < ballCount; i++) {\n      // 随机位置（避免太靠近边界）\n      const x = Phaser.Math.Between(50, width - 50);\n      const y = Phaser.Math.Between(50, height - 50);\n\n      // 创建小球\n      const ball = this.ballGroup.create(x, y, 'ballTexture');\n      \n      // 设置随机速度方向，但保持总速度为360\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * speed;\n      const velocityY = Math.sin(angle) * speed;\n      \n      ball.setVelocity(velocityX, velocityY);\n      \n      // 设置圆形碰撞体（更精确）\n      ball.body.setCircle(16);\n    }\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(\n      this.ballGroup, \n      this.ballGroup,\n      this.onBallCollision,\n      null,\n      this\n    );\n\n    // 添加调试文本显示碰撞次数\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 40, 'White balls bounce off walls and each other', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 绘制边界框（可选，用于可视化）\n    const border = this.add.graphics();\n    border.lineStyle(2, 0x00ff00, 0.5);\n    border.strokeRect(0, 0, width, height);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调：增加计数器\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 确保小球速度保持恒定（可选，防止浮点误差累积）\n    const targetSpeed = 360;\n    const tolerance = 5;\n\n    this.ballGroup.getChildren().forEach(ball => {\n      const currentSpeed = Math.sqrt(\n        ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2\n      );\n\n      // 如果速度偏差超过容差，重新归一化\n      if (Math.abs(currentSpeed - targetSpeed) > tolerance) {\n        const scale = targetSpeed / currentSpeed;\n        ball.body.velocity.x *= scale;\n        ball.body.velocity.y *= scale;\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000961_v3", "prompt_id": "seed_000961", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics.fillEllipse, Scene.physics.add.existing, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建 Graphics 对象并绘制白色椭圆\n2. 为椭圆添加 Arcade 物理体\n3. 设置物理体边界碰撞和反弹属性\n4. 设置初始速度为 200（斜向移动）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制白色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);  // 白色\n  \n  // 绘制椭圆（中心点在原点，宽度100，高度60）\n  const ellipseWidth = 100;\n  const ellipseHeight = 60;\n  graphics.fillEllipse(0, 0, ellipseWidth, ellipseHeight);\n  \n  // 设置椭圆初始位置在画布中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 为 Graphics 对象添加物理体\n  this.physics.add.existing(graphics);\n  \n  // 配置物理体属性\n  graphics.body.setCircle(ellipseWidth / 2);  // 设置碰撞区域为圆形（近似椭圆）\n  graphics.body.setBounce(1, 1);  // 完全弹性碰撞（x和y方向都为1）\n  graphics.body.setCollideWorldBounds(true);  // 与世界边界碰撞\n  \n  // 设置初始速度（斜向移动，速度大小为200）\n  // 使用勾股定理计算：vx² + vy² = 200²\n  const speed = 200;\n  const angle = Math.PI / 4;  // 45度角\n  const vx = speed * Math.cos(angle);\n  const vy = speed * Math.sin(angle);\n  graphics.body.setVelocity(vx, vy);\n  \n  // 保存引用以便后续使用\n  this.ellipse = graphics;\n}\n\nfunction update(time, delta) {\n  // 物理引擎自动处理移动和反弹，无需手动更新\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000409_v1", "prompt_id": "seed_000409", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：粉色敌人从上方以 120 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，玩家左右移动躲避从上方落下的粉色敌人，碰撞则游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.overlap\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制玩家（蓝色方块）和敌人（粉色圆形）纹理\n3. 创建玩家精灵，设置键盘左右控制移动\n4. 创建敌人组，定时从顶部随机位置生成敌人，设置下落速度 120\n5. 添加碰撞检测，碰到敌人时游戏结束，显示 Game Over 文本\n6. 添加分数系统，存活时间越长分数越高\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.gameOver = false;\n    this.survivalTime = 0;\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（粉色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff69b4, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 分数显示\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 370, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 空格键重启\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 定时生成敌人（每1秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 计分定时器（每100ms增加10分）\n    this.scoreTimer = this.time.addEvent({\n      delay: 100,\n      callback: () => {\n        if (!this.gameOver) {\n          this.score += 10;\n          this.survivalTime += 0.1;\n          this.scoreText.setText('Score: ' + this.score);\n        }\n      },\n      callbackScope: this,\n      loop: true\n    });\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      // 游戏结束后检测重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.restartGame();\n      }\n      return;\n    }\n\n    // 玩家移动控制\n    const moveSpeed = 300;\n    \n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-moveSpeed);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(moveSpeed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) return;\n\n    // 在顶部随机位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    // 设置敌人下落速度为 120\n    enemy.setVelocityY(120);\n    enemy.body.setSize(30, 30);\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) return;\n\n    // 游戏结束\n    this.gameOver = true;\n    \n    // 停止物理系统\n    this.physics.pause();\n    \n    // 停止定时器\n    this.enemyTimer.destroy();\n    this.scoreTimer.destroy();\n    \n    // 玩家变红\n    player.setTint(0xff0000);\n    \n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n  }\n\n  restartGame() {\n    // 重置游戏状态\n    this.score = 0;\n    this.gameOver = false;\n    this.survivalTime = 0;\n    \n    // 重启场景\n    this.scene.restart();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000850_v3", "prompt_id": "seed_000850", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9221428571428572}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色方块以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色方块以80速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制红色方块纹理\n3. 创建物理精灵并设置初始速度为 80\n4. 设置精灵与世界边界碰撞并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 使用 Graphics 创建红色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('redSquare', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  const square = this.physics.add.sprite(400, 300, 'redSquare');\n  \n  // 设置初始速度（斜向移动，总速度约为80）\n  const speed = 80;\n  const angle = Math.PI / 4; // 45度角\n  square.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n  \n  // 添加文字说明\n  this.add.text(10, 10, 'Red square bouncing at speed 80', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000470_v3", "prompt_id": "seed_000470", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让橙色三角形在 3 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建橙色三角形，使用 Tween 实现 3 秒缩放循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制橙色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 duration 为 3000ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFF8800, 1);\n  \n  // 绘制三角形（等边三角形，中心在 (50, 50)）\n  const triangleSize = 80;\n  const centerX = 50;\n  const centerY = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - triangleSize / 2); // 顶点\n  graphics.lineTo(centerX - triangleSize / 2, centerY + triangleSize / 2); // 左下\n  graphics.lineTo(centerX + triangleSize / 2, centerY + triangleSize / 2); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('orangeTriangle', 100, 100);\n  graphics.destroy();\n  \n  // 创建使用该纹理的 Sprite\n  const triangle = this.add.sprite(400, 300, 'orangeTriangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 1.5,        // 放大到 1.5 倍\n    scaleY: 1.5,\n    duration: 1500,     // 放大用时 1.5 秒\n    yoyo: true,         // 启用 yoyo 效果（放大后缩小回来）\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Orange Triangle Scale Animation (3s loop)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000547_v2", "prompt_id": "seed_000547", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的三角形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象作为可移动的游戏对象\n3. 在 update 中让三角形向右上方移动\n4. 使用 Camera.startFollow 让相机跟随三角形\n5. 设置世界边界以展示相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nconst moveSpeed = 100; // 每秒移动的像素\n\nfunction preload() {\n  // 使用 Graphics 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个向上的三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(25, 0);      // 顶点\n  graphics.lineTo(50, 50);     // 右下角\n  graphics.lineTo(0, 50);      // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，让场景更大以展示相机跟随效果\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n  \n  // 创建三角形 Sprite\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 让相机跟随三角形，并保持居中\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（这里设置为 0,0 表示居中）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 2000; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(2000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加坐标文本以便观察位置\n  this.add.text(10, 10, 'Camera follows triangle', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setScrollFactor(0); // 固定在屏幕上，不随相机移动\n  \n  // 创建动态文本显示三角形位置\n  this.positionText = this.add.text(10, 50, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  }).setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 让三角形向右上方移动\n  // 右上方向：x 增加，y 减少（Phaser 的 y 轴向下为正）\n  const moveDistance = moveSpeed * deltaSeconds;\n  triangle.x += moveDistance;\n  triangle.y -= moveDistance;\n  \n  // 限制三角形在世界边界内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 2000);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 2000);\n  \n  // 更新位置显示\n  this.positionText.setText(\n    `Triangle Position: (${Math.floor(triangle.x)}, ${Math.floor(triangle.y)})`\n  );\n  \n  // 当三角形到达边界时，可以重置位置（可选）\n  if (triangle.x >= 2000 || triangle.y <= 0) {\n    triangle.setPosition(100, 500);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000193_v1", "prompt_id": "seed_000193", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8955555555555555}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色矩形，大小约为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个 64x64 像素的黄色矩形\nAPI: Phaser.Game, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为黄色（0xffff00）\n4. 计算画布中心位置（400, 300），绘制 64x64 矩形，矩形中心对齐画布中心\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 计算矩形左上角位置，使其中心位于画布中央\n  // 画布中心：(400, 300)\n  // 矩形尺寸：64x64\n  // 左上角位置：(400 - 32, 300 - 32) = (368, 268)\n  const rectSize = 64;\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000580_v2", "prompt_id": "seed_000580", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 800，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动与跳跃，重力800，速度200，与地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 800\n2. 使用 Graphics 创建玩家角色和地面平台的纹理\n3. 添加物理精灵，设置碰撞检测\n4. 监听键盘输入（左右方向键和空格跳跃）\n5. 在 update 中处理移动逻辑，添加跳跃次数限制（仅在地面可跳）\n6. 添加状态变量记录跳跃次数和位置信息\n[/PLAN]\n\n```javascript\nclass PlatformerScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformerScene');\n    // 可验证的状态信号\n    this.jumpCount = 0;\n    this.playerX = 0;\n    this.playerY = 0;\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x3498db, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x27ae60, 1);\n    groundGraphics.fillRect(0, 0, 64, 32);\n    groundGraphics.generateTexture('ground', 64, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加主地面\n    this.platforms.create(400, 568, 'ground').setScale(12.5, 1).refreshBody();\n    \n    // 添加几个悬浮平台\n    this.platforms.create(200, 450, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(600, 400, 'ground').setScale(3, 1).refreshBody();\n    this.platforms.create(400, 300, 'ground').setScale(2, 1).refreshBody();\n    this.platforms.create(100, 250, 'ground').setScale(2, 1).refreshBody();\n    this.platforms.create(700, 250, 'ground').setScale(2, 1).refreshBody();\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加控制说明\n    this.add.text(16, 60, 'Controls:\\n← → : Move\\nSPACE: Jump', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 检测是否在地面上\n    const touchingDown = this.player.body.touching.down;\n    \n    // 更新接地状态\n    if (touchingDown) {\n      this.isGrounded = true;\n    }\n\n    // 左右移动（速度 200）\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃逻辑（仅在地面可跳）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.isGrounded) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n      this.isGrounded = false;\n    }\n\n    // 更新状态变量\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Position: (${this.playerX}, ${this.playerY})`,\n      `Jump Count: ${this.jumpCount}`,\n      `Grounded: ${this.isGrounded}`,\n      `Velocity: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: PlatformerScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001035_v2", "prompt_id": "seed_001035", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 红色玩家移出边界时从对侧出现（循环地图效果），移动速度 120。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 红色玩家可通过键盘控制移动，移出边界时从对侧出现，速度120\nAPI: Physics.Arcade.Sprite, Input.Keyboard, Graphics.generateTexture, Scene.wrap\nSTEPS:\n1. 创建红色方块玩家精灵，使用Graphics生成纹理\n2. 启用Arcade物理系统，设置玩家速度为120\n3. 添加键盘输入监听（WASD或方向键）\n4. 在update中检测边界，实现循环地图效果\n5. 添加状态变量记录玩家穿越边界次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.wrapCount = 0; // 状态信号：记录穿越边界次数\n    this.playerSpeed = 120;\n  }\n\n  preload() {\n    // 使用Graphics生成红色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff0000, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 允许移出边界\n    \n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示控制说明\n    this.add.text(10, 50, 'Controls: Arrow Keys or WASD', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n\n    // 处理输入\n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-this.playerSpeed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(this.playerSpeed);\n    }\n\n    // 实现循环地图效果\n    const halfWidth = this.player.width / 2;\n    const halfHeight = this.player.height / 2;\n    let wrapped = false;\n\n    // 水平边界检测\n    if (this.player.x < -halfWidth) {\n      this.player.x = this.scale.width + halfWidth;\n      wrapped = true;\n    } else if (this.player.x > this.scale.width + halfWidth) {\n      this.player.x = -halfWidth;\n      wrapped = true;\n    }\n\n    // 垂直边界检测\n    if (this.player.y < -halfHeight) {\n      this.player.y = this.scale.height + halfHeight;\n      wrapped = true;\n    } else if (this.player.y > this.scale.height + halfHeight) {\n      this.player.y = -halfHeight;\n      wrapped = true;\n    }\n\n    // 更新穿越计数\n    if (wrapped) {\n      this.wrapCount++;\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Wrap Count: ${this.wrapCount}\\n` +\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})\\n` +\n      `Speed: ${this.playerSpeed}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001209_v3", "prompt_id": "seed_001209", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，根据中心点和半径计算6个顶点坐标\n4. 使用循环15次，每次生成随机 x、y 坐标（考虑边界）\n5. 在每个随机位置绘制紫色填充的六边形（大小64像素）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9966ff, 1);\n  \n  // 六边形半径（从中心到顶点的距离）\n  const hexRadius = 32; // 64像素大小的六边形半径为32\n  \n  // 绘制六边形的辅助函数\n  function drawHexagon(gfx, x, y, radius) {\n    gfx.beginPath();\n    \n    // 计算六边形的6个顶点（从顶部开始，顺时针）\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度起始，使顶点朝上\n      const vx = x + radius * Math.cos(angle);\n      const vy = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        gfx.moveTo(vx, vy);\n      } else {\n        gfx.lineTo(vx, vy);\n      }\n    }\n    \n    gfx.closePath();\n    gfx.fillPath();\n  }\n  \n  // 绘制15个随机位置的六边形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const x = hexRadius + Math.random() * (800 - hexRadius * 2);\n    const y = hexRadius + Math.random() * (600 - hexRadius * 2);\n    \n    drawHexagon(graphics, x, y, hexRadius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000644_v2", "prompt_id": "seed_000644", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 0.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 0.5 秒内缩放到 80% 然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建缩放动画，从 1 缩放到 0.8 再回到 1\n4. 设置 Tween 的 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个等边三角形（中心在原点）\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, -60);      // 顶点\n  graphics.lineTo(-52, 30);     // 左下角\n  graphics.lineTo(52, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 104, 90);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵并居中\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 500,        // 0.5 秒\n    yoyo: true,           // 动画结束后反向播放（恢复到原始大小）\n    repeat: -1,           // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '三角形缩放循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000352_v3", "prompt_id": "seed_000352", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让方块在1秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，duration 设为 1000ms\n4. 设置 Tween 的 yoyo 为 true 和 repeat 为 -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 1000,            // 动画持续时间 1 秒\n    yoyo: true,                // 反向播放（不透明再变回透明）\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    ease: 'Linear'             // 线性缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000386_v1", "prompt_id": "seed_000386", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的粉色六边形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的粉色六边形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次\n3. 每次循环创建一个 Graphics 对象\n4. 使用粉色填充样式 (0xFFC0CB)\n5. 计算六边形的6个顶点坐标（半径12像素，使每个六边形大小为24像素）\n6. 使用 beginPath、moveTo、lineTo 绘制六边形路径\n7. 使用 fillPath 填充路径\n8. 为每个六边形设置随机位置（x: 0-800, y: 0-600）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个粉色六边形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 六边形半径（大小24像素，半径12像素）\n    const radius = 12;\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算并绘制六边形的6个顶点\n    // 六边形从顶部开始，每个角度间隔60度\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j - Math.PI / 2; // 从顶部开始(-90度)\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n    \n    // 设置随机位置\n    // 确保六边形完全在画布内（留出半径的边距）\n    const randomX = radius + Math.random() * (800 - 2 * radius);\n    const randomY = radius + Math.random() * (600 - 2 * radius);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000072_v1", "prompt_id": "seed_000072", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色菱形在 4 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色菱形在4秒内完成抖动动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制灰色菱形形状并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建抖动效果（快速左右/上下移动）\n4. 设置 Tween 持续时间为4秒，yoyo和repeat实现循环抖动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制菱形（使用四个点构成的多边形）\n  // 菱形中心在 (50, 50)，宽度100，高度100\n  graphics.beginPath();\n  graphics.moveTo(50, 0);      // 顶点\n  graphics.lineTo(100, 50);    // 右点\n  graphics.lineTo(50, 100);    // 底点\n  graphics.lineTo(0, 50);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建抖动动画效果\n  // 使用多个连续的小幅度移动来模拟抖动\n  this.tweens.add({\n    targets: diamond,\n    x: '+=10',           // 向右移动10像素\n    duration: 50,        // 快速移动\n    yoyo: true,          // 来回移动\n    repeat: 0,           // 单次不重复\n    onComplete: () => {\n      // 第一次抖动完成后，创建主抖动循环\n      this.tweens.add({\n        targets: diamond,\n        x: { from: 390, to: 410 },  // 左右抖动范围\n        y: { from: 295, to: 305 },  // 上下抖动范围\n        duration: 50,                // 每次抖动持续时间\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1,                  // 无限循环\n        repeatDelay: 0\n      });\n    }\n  });\n  \n  // 创建一个更自然的抖动效果 - 使用timeline\n  this.tweens.timeline({\n    targets: diamond,\n    loop: -1,  // 无限循环\n    loopDelay: 0,\n    tweens: [\n      // 快速抖动序列\n      { x: '+=8', y: '+=3', duration: 40, ease: 'Power1' },\n      { x: '-=12', y: '-=5', duration: 40, ease: 'Power1' },\n      { x: '+=15', y: '+=8', duration: 40, ease: 'Power1' },\n      { x: '-=18', y: '-=4', duration: 40, ease: 'Power1' },\n      { x: '+=12', y: '+=6', duration: 40, ease: 'Power1' },\n      { x: '-=8', y: '-=10', duration: 40, ease: 'Power1' },\n      { x: '+=10', y: '+=5', duration: 40, ease: 'Power1' },\n      { x: '-=15', y: '-=7', duration: 40, ease: 'Power1' },\n      { x: '+=13', y: '+=4', duration: 40, ease: 'Power1' },\n      { x: '-=10', y: '-=6', duration: 40, ease: 'Power1' },\n      { x: '+=7', y: '+=8', duration: 40, ease: 'Power1' },\n      { x: '-=9', y: '-=5', duration: 40, ease: 'Power1' },\n      { x: '+=11', y: '+=3', duration: 40, ease: 'Power1' },\n      { x: '-=14', y: '-=7', duration: 40, ease: 'Power1' },\n      { x: '+=8', y: '+=6', duration: 40, ease: 'Power1' },\n      { x: '-=6', y: '-=4', duration: 40, ease: 'Power1' },\n      { x: '+=5', y: '+=2', duration: 40, ease: 'Power1' },\n      { x: '-=7', y: '-=5', duration: 40, ease: 'Power1' },\n      { x: '+=4', y: '+=3', duration: 40, ease: 'Power1' },\n      { x: '-=2', y: '-=1', duration: 40, ease: 'Power1' },\n      // 回到原位\n      { x: 400, y: 300, duration: 3200, ease: 'Power1' }  // 剩余时间回到中心\n    ]\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '灰色菱形抖动动画 (4秒循环)', {\n    fontSize: '24px',\n    fill: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000411_v1", "prompt_id": "seed_000411", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 3 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在3秒内缩放到32%后恢复，循环播放\nAPI: Graphics.fillPolygon, Scene.tweens.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制六边形形状\n2. 创建 Tween 动画，将 scale 从 1 缩放到 0.32\n3. 设置 yoyo 为 true 实现自动恢复\n4. 设置 repeat 为 -1 实现无限循环\n5. 设置 duration 为 3000ms（3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形的中心点和半径\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 100;\n  \n  // 计算六边形的六个顶点坐标\n  const hexagon = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    hexagon.push(x, y);\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillPolygon(hexagon);\n  \n  // 设置六边形的原点为中心点，方便缩放\n  graphics.x = 0;\n  graphics.y = 0;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.32,        // 缩放到 32%\n    scaleY: 0.32,        // 缩放到 32%\n    duration: 3000,      // 3秒完成缩放\n    yoyo: true,          // 自动反向播放（恢复原始大小）\n    repeat: -1,          // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 550, '六边形缩放动画（3秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000015_v1", "prompt_id": "seed_000015", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的绿色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的绿色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中循环12次\n3. 每次循环创建一个 Graphics 对象\n4. 使用三角函数计算六边形的6个顶点坐标（半径8像素）\n5. 使用 beginPath/moveTo/lineTo 绘制六边形路径\n6. 使用 fillStyle 设置绿色并填充\n7. 使用 Phaser.Math.Between 随机设置每个六边形的位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建12个随机位置的绿色六边形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 六边形的半径（大小16像素，半径为8）\n    const radius = 8;\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    for (let j = 0; j < 6; j++) {\n      // 六边形每个角度间隔60度（PI/3弧度）\n      const angle = (Math.PI / 3) * j;\n      const x = radius * Math.cos(angle);\n      const y = radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n    \n    // 设置随机位置\n    const randomX = Phaser.Math.Between(20, 780);\n    const randomY = Phaser.Math.Between(20, 580);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000331_v2", "prompt_id": "seed_000331", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让红色矩形在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色矩形的抖动循环动画效果\nAPI: Graphics, Tweens, TweenManager\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建抖动效果（通过快速改变 x/y 位置模拟抖动）\n4. 设置 Tween 循环播放，duration 为 2000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建红色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('redRect', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建红色矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'redRect');\n  \n  // 创建抖动动画效果\n  // 通过在短时间内快速改变位置来模拟抖动\n  this.tweens.add({\n    targets: rect,\n    x: '+=10',  // 向右偏移\n    y: '+=5',   // 向下偏移\n    duration: 50,  // 快速移动\n    yoyo: true,    // 往返运动\n    repeat: -1,    // 无限重复\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 创建整体的循环时间线（2秒一个周期）\n  // 使用多个方向的抖动来创建更真实的效果\n  this.tweens.timeline({\n    targets: rect,\n    loop: -1,  // 无限循环\n    tweens: [\n      {\n        x: '+=8',\n        y: '+=6',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '-=16',\n        y: '-=4',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '+=12',\n        y: '-=8',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '-=8',\n        y: '+=10',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '+=6',\n        y: '-=6',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '-=10',\n        y: '+=4',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '+=8',\n        y: '-=2',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '-=6',\n        y: '+=3',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '+=4',\n        y: '-=5',\n        duration: 100,\n        ease: 'Power1'\n      },\n      {\n        x: '-=2',\n        y: '+=2',\n        duration: 100,\n        ease: 'Power1'\n      },\n      // 回到原位\n      {\n        x: 400,\n        y: 300,\n        duration: 1000,\n        ease: 'Sine.easeOut'\n      }\n    ]\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '红色矩形抖动动画 (2秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000652_v1", "prompt_id": "seed_000652", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的紫色星形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的紫色星形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景大小为 800x600\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象设置随机位置（确保星形完全在画布内）\n4. 使用 Graphics API 绘制五角星路径（通过计算五角星的顶点坐标）\n5. 填充紫色（0x800080）并渲染星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 星形大小\n  const starSize = 80;\n  const halfSize = starSize / 2;\n  \n  // 绘制12个随机位置的紫色星形\n  for (let i = 0; i < 12; i++) {\n    // 随机位置（确保星形完全在画布内）\n    const x = Phaser.Math.Between(halfSize, 800 - halfSize);\n    const y = Phaser.Math.Between(halfSize, 600 - halfSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    graphics.setPosition(x, y);\n    \n    // 绘制五角星\n    drawStar(graphics, 0, 0, 5, halfSize, halfSize * 0.4, 0x800080);\n  }\n}\n\n/**\n * 绘制星形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心点 x 坐标\n * @param {number} cy - 中心点 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n * @param {number} color - 填充颜色\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n  \n  graphics.fillStyle(color, 1);\n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n  \n  for (let i = 0; i < spikes; i++) {\n    // 外顶点\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n    \n    // 内顶点\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n  \n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000684_v2", "prompt_id": "seed_000684", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的绿色椭圆，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的绿色椭圆，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中使用循环创建 10 个 Graphics 对象\n3. 每个 Graphics 对象绘制绿色椭圆（使用 fillEllipse，半径为 40 像素）\n4. 使用 setRandomPosition 将每个椭圆随机分布在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 10 个随机位置的绿色椭圆\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制椭圆，中心点在 (0, 0)，半径为 40 像素（直径 80 像素）\n    // fillEllipse(x, y, width, height)\n    graphics.fillEllipse(0, 0, 80, 80);\n    \n    // 设置随机位置\n    // 留出边距，确保椭圆完全显示在画布内\n    const margin = 40;\n    graphics.setPosition(\n      Phaser.Math.Between(margin, config.width - margin),\n      Phaser.Math.Between(margin, config.height - margin)\n    );\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000247_v2", "prompt_id": "seed_000247", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色方块以200速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制蓝色方块并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 启用世界边界碰撞和精灵边界反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nconst SPEED = 200;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建蓝色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('blueSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'blueSquare');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * SPEED;\n  const velocityY = Math.sin(angle * Math.PI / 180) * SPEED;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 启用与世界边界的碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 启用边界反弹\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（防止因碰撞导致速度衰减）\n  const velocity = square.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - SPEED) > 1) {\n    const scale = SPEED / currentSpeed;\n    square.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000663_v1", "prompt_id": "seed_000663", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的方块在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的方块并保持居中\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个方块纹理\n2. 创建 Sprite 对象作为移动的方块\n3. 在 create 中设置方块的初始位置和速度（向右上移动）\n4. 使用 camera.startFollow 让相机跟随方块\n5. 在 update 中持续更新方块位置实现自动移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet velocityX = 100; // 向右移动速度\nlet velocityY = -80; // 向上移动速度\n\nfunction preload() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('player', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个大的背景网格以便观察相机移动\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x555555, 0.5);\n  \n  // 绘制网格（扩大范围以便方块移动）\n  for (let x = 0; x <= 3000; x += 50) {\n    gridGraphics.lineBetween(x, 0, x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 50) {\n    gridGraphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加坐标标记\n  const style = { fontSize: '14px', color: '#ffffff' };\n  this.add.text(50, 50, 'Start (0,0)', style);\n  this.add.text(1500, 50, '(1500,0)', style);\n  this.add.text(50, 1000, '(0,1000)', style);\n  \n  // 创建玩家方块\n  player = this.add.sprite(100, 500, 'player');\n  player.setOrigin(0.5, 0.5);\n  \n  // 设置相机边界（扩大场景范围）\n  this.cameras.main.setBounds(0, 0, 3000, 2000);\n  \n  // 相机跟随玩家，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 添加提示文本（固定在相机上）\n  const infoText = this.add.text(10, 10, 'Camera following green square', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让方块持续向右上移动\n  player.x += velocityX * (delta / 1000);\n  player.y += velocityY * (delta / 1000);\n  \n  // 可选：当方块移出场景边界时重置位置\n  if (player.x > 2900 || player.y < 100) {\n    player.x = 100;\n    player.y = 500;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000517_v1", "prompt_id": "seed_000517", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8733333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在4秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale: 1 -> 0.24 -> 1）\n4. 设置 Tween 的 duration 为 4000ms，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff88, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 100）\n  const centerX = 64;\n  const centerY = 64;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 顶点\n  graphics.lineTo(centerX + size, centerY);      // 右点\n  graphics.lineTo(centerX, centerY + size);      // 底点\n  graphics.lineTo(centerX - size, centerY);      // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 4000,        // 4秒缩放到24%\n    yoyo: true,            // 自动返回原始大小\n    loop: -1,              // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '菱形循环缩放动画 (1.0 ↔ 0.24)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000400_v3", "prompt_id": "seed_000400", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.Scene#update, Phaser.GameObjects.Graphics#setRotation\nSTEPS:\n1. 创建 Graphics 对象绘制方块\n2. 在 update 方法中根据 delta 时间累加旋转角度\n3. 使用 setRotation 方法更新方块旋转角度（注意转换为弧度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 旋转速度：每秒 80 度\nconst ROTATION_SPEED = 80;\n\n// 用于存储方块对象\nlet square;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制方块\n  square = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  square.fillStyle(0xff0000, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在 (0, 0)\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 设置方块位置到屏幕中心\n  square.x = 400;\n  square.y = 300;\n  \n  // 添加提示文本\n  this.add.text(10, 10, '方块旋转速度: 80度/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是上一帧到当前帧的时间差（毫秒）\n  // 计算本帧应该旋转的角度（度）\n  const rotationDegrees = ROTATION_SPEED * (delta / 1000);\n  \n  // 将角度转换为弧度（Phaser 使用弧度）\n  const rotationRadians = Phaser.Math.DegToRad(rotationDegrees);\n  \n  // 累加旋转角度\n  square.rotation += rotationRadians;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000404_v2", "prompt_id": "seed_000404", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色矩形，大小约为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个 64x64 像素的黄色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充颜色为黄色（0xffff00）\n4. 在画布中央绘制 64x64 像素的矩形（中心点为 400,300，矩形左上角为 368,268）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 计算矩形左上角坐标，使其在画布中央\n  // 画布中心: (400, 300)\n  // 矩形大小: 64x64\n  // 左上角坐标: (400 - 32, 300 - 32) = (368, 268)\n  const rectX = config.width / 2 - 32;\n  const rectY = config.height / 2 - 32;\n  const rectSize = 64;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000580_v1", "prompt_id": "seed_000580", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text, text.setOrigin\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小 32px\n4. 计算右下角位置（width - padding, height - padding）\n5. 使用 setOrigin(1, 1) 将文本锚点设置为右下角，实现右下对齐\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文本对象，位置在右下角（留出 20 像素边距）\n  const text = this.add.text(\n    780,  // x 坐标：800 - 20\n    580,  // y 坐标：600 - 20\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '32px',  // 字体大小\n      color: '#ffffff',  // 文字颜色（白色）\n      fontFamily: 'Arial'  // 字体\n    }\n  );\n  \n  // 设置文本锚点为右下角 (1, 1)\n  // 这样文本会以右下角为基准点定位\n  text.setOrigin(1, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000223_v2", "prompt_id": "seed_000223", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1.5秒内缩放到80%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建缩放动画，从 1 到 0.8 再到 1\n4. 设置 Tween 循环播放（loop: -1）和持续时间（1500ms）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = hexRadius + 10;\n  const centerY = hexRadius + 10;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  const textureSize = (hexRadius + 10) * 2;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 使用 yoyo 模式实现缩放到 0.8 后恢复到 1\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 750, // 1.5秒的一半，因为 yoyo 会来回\n    ease: 'Sine.easeInOut',\n    yoyo: true, // 自动反向播放\n    loop: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Hexagon scaling animation (1.0 → 0.8 → 1.0)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000403_v2", "prompt_id": "seed_000403", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色圆形以300速度移动并在画布边界反弹\nAPI: Graphics.fillCircle, GameObject.setVelocity, Physics.World.setBoundsCollision, Physics.Body.setBounce, Physics.Body.setCollideWorldBounds\nSTEPS:\n1. 配置 Arcade 物理系统并启用世界边界\n2. 使用 Graphics 绘制白色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为300\n4. 设置物理体与世界边界碰撞并反弹系数为1\n5. 确保圆形在边界内完全反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(20, 20, 20); // 在(20,20)位置绘制半径20的圆\n  \n  // 生成纹理\n  graphics.generateTexture('whiteCircle', 40, 40);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'whiteCircle');\n  \n  // 设置初始速度（随机方向，速度为300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 300);\n  circle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置物理体属性\n  circle.setCollideWorldBounds(true); // 与世界边界碰撞\n  circle.setBounce(1, 1); // 完全弹性碰撞，反弹系数为1\n  \n  // 设置圆形碰撞体为圆形（更精确的碰撞检测）\n  circle.body.setCircle(20);\n  \n  // 可选：添加文字提示\n  this.add.text(10, 10, 'White circle bouncing at 300 speed', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000253_v1", "prompt_id": "seed_000253", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的紫色三角形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的紫色三角形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景大小为 800x600\n2. 在 create 方法中使用循环创建5个 Graphics 对象\n3. 为每个 Graphics 对象设置紫色填充样式（0x800080）\n4. 使用 fillTriangle 方法绘制等边三角形，边长64像素\n5. 使用 setRandomPosition 方法将三角形随机放置在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建5个紫色三角形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充样式\n    graphics.fillStyle(0x800080, 1);\n    \n    // 绘制等边三角形\n    // 三角形的三个顶点坐标（相对于 graphics 对象的原点）\n    // 顶点：(0, -h), (-w/2, h/2), (w/2, h/2)\n    // 其中 h = 64 * sqrt(3) / 2 ≈ 55.4\n    const size = 64;\n    const height = size * Math.sqrt(3) / 2;\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶部顶点\n      -size / 2, height / 2,    // 左下顶点\n      size / 2, height / 2      // 右下顶点\n    );\n    \n    // 随机设置位置（确保三角形完全在画布内）\n    const margin = size / 2;\n    graphics.setPosition(\n      Phaser.Math.Between(margin, 800 - margin),\n      Phaser.Math.Between(margin, 600 - margin)\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000696_v3", "prompt_id": "seed_000696", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色三角形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色三角形以240速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制黄色三角形并生成纹理\n3. 创建物理精灵并设置初始速度为240\n4. 启用世界边界碰撞和反弹\n5. 设置精灵与世界边界的碰撞检测\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 创建黄色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(25, 5);      // 顶点\n  graphics.lineTo(45, 45);     // 右下角\n  graphics.lineTo(5, 45);      // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度为240）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 240);\n  triangle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：让三角形根据移动方向旋转\n  this.physics.world.on('worldbounds', (body) => {\n    // 可以在这里添加碰撞音效等\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000353_v3", "prompt_id": "seed_000353", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 300\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), this.physics.add.sprite(), Graphics.fillRect(), Graphics.generateTexture()\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制橙色方块并生成纹理作为玩家\n3. 创建物理精灵并设置移动速度为 300\n4. 监听键盘输入（方向键）控制玩家移动\n5. 在 update 中检测边界，实现循环地图效果（左右上下边界穿越）\n6. 添加状态信号变量记录玩家位置循环次数\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 循环地图游戏\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量\nlet player;\nlet cursors;\nlet wrapCount = 0; // 记录循环次数（状态信号）\nlet wrapText;\n\nfunction preload() {\n  // 使用 Graphics 创建橙色玩家纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8800, 1); // 橙色\n  graphics.fillRect(0, 0, 40, 40);\n  graphics.generateTexture('player', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建橙色玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n  \n  // 设置移动速度\n  player.body.setMaxVelocity(300, 300);\n  \n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加 WASD 控制\n  this.wasd = this.input.keyboard.addKeys({\n    up: Phaser.Input.Keyboard.KeyCodes.W,\n    down: Phaser.Input.Keyboard.KeyCodes.S,\n    left: Phaser.Input.Keyboard.KeyCodes.A,\n    right: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 显示循环次数文本\n  wrapText = this.add.text(16, 16, 'Wrap Count: 0', {\n    fontSize: '24px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 添加说明文本\n  this.add.text(16, 60, 'Use Arrow Keys or WASD to move\\nSpeed: 300', {\n    fontSize: '16px',\n    fill: '#cccccc',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 绘制边界参考线\n  const borderGraphics = this.add.graphics();\n  borderGraphics.lineStyle(2, 0x00ff00, 0.5);\n  borderGraphics.strokeRect(0, 0, 800, 600);\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0);\n  \n  // 处理键盘输入\n  if (cursors.left.isDown || this.wasd.left.isDown) {\n    player.setVelocityX(-300);\n  } else if (cursors.right.isDown || this.wasd.right.isDown) {\n    player.setVelocityX(300);\n  }\n  \n  if (cursors.up.isDown || this.wasd.up.isDown) {\n    player.setVelocityY(-300);\n  } else if (cursors.down.isDown || this.wasd.down.isDown) {\n    player.setVelocityY(300);\n  }\n  \n  // 循环地图效果 - 检测边界并从对侧出现\n  const playerWidth = player.width;\n  const playerHeight = player.height;\n  \n  // 左右边界循环\n  if (player.x > config.width + playerWidth / 2) {\n    player.x = -playerWidth / 2;\n    wrapCount++;\n    updateWrapText();\n  } else if (player.x < -playerWidth / 2) {\n    player.x = config.width + playerWidth / 2;\n    wrapCount++;\n    updateWrapText();\n  }\n  \n  // 上下边界循环\n  if (player.y > config.height + playerHeight / 2) {\n    player.y = -playerHeight / 2;\n    wrapCount++;\n    updateWrapText();\n  } else if (player.y < -playerHeight / 2) {\n    player.y = config.height + playerHeight / 2;\n    wrapCount++;\n    updateWrapText();\n  }\n}\n\nfunction updateWrapText() {\n  wrapText.setText('Wrap Count: ' + wrapCount);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000969_v2", "prompt_id": "seed_000969", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色菱形以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色菱形以80速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 使用 Graphics 绘制黄色菱形并生成纹理\n2. 创建 Arcade 物理精灵并应用菱形纹理\n3. 设置初始速度为 80（x和y方向）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);        // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始速度（80速度，沿对角线方向）\n  diamond.setVelocity(80, 80);\n  \n  // 启用世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, '黄色菱形以80速度移动并反弹', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000144_v3", "prompt_id": "seed_000144", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色菱形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色菱形在1.5秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制绿色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 实现 y 轴弹跳动画，配置 ease 为 Bounce 效果\n4. 设置 Tween 循环播放（loop: -1）和持续时间 1500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制菱形（四个顶点）\n  const size = 50;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);        // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建菱形精灵，放置在屏幕中央上方\n  const diamond = this.add.sprite(400, 200, 'diamond');\n  \n  // 创建弹跳动画\n  // 使用 yoyo 模式实现上下弹跳，ease 使用 Bounce.easeOut 实现弹跳效果\n  this.tweens.add({\n    targets: diamond,\n    y: 400, // 弹跳到的目标位置\n    duration: 750, // 单程时间 750ms\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返运动\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加说明文字\n  const text = this.add.text(400, 550, '绿色菱形弹跳动画 (1.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000215_v2", "prompt_id": "seed_000215", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个圆形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制圆形以 160 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制圆形作为玩家\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新圆形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet player;\nlet keys;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建圆形玩家\n  player = this.add.graphics();\n  player.fillStyle(0x00ff00, 1);\n  player.fillCircle(0, 0, 20); // 半径 20 的圆形\n  \n  // 设置初始位置\n  player.x = 400;\n  player.y = 300;\n  \n  // 添加 WASD 键盘监听\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 根据按键状态设置速度方向\n  if (keys.W.isDown) {\n    velocityY = -1;\n  }\n  if (keys.S.isDown) {\n    velocityY = 1;\n  }\n  if (keys.A.isDown) {\n    velocityX = -1;\n  }\n  if (keys.D.isDown) {\n    velocityX = 1;\n  }\n  \n  // 归一化对角线移动（避免对角线速度过快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000676_v2", "prompt_id": "seed_000676", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个青色星形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个青色星形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个外顶点和 5 个内顶点坐标（基于中心点和半径）\n4. 使用 beginPath、moveTo、lineTo 绘制星形路径\n5. 使用青色填充星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充样式 (cyan: 0x00ffff)\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 40; // 外半径 40px，总大小约 80px\n  const innerRadius = 18; // 内半径约为外半径的 0.45 倍\n  const points = 5; // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制星形的各个顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算角度（从顶部开始，逆时针旋转）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 计算顶点坐标\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充星形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000651_v1", "prompt_id": "seed_000651", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让紫色菱形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色菱形，使用 Tween 实现 1.5 秒闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 控制 alpha 属性实现闪烁效果（0→1→0）\n4. 设置 Tween 循环和持续时间为 1.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9b59b6, 1);\n  \n  // 绘制菱形（中心点在 50, 50）\n  const size = 50;\n  graphics.beginPath();\n  graphics.moveTo(50, 0);           // 上顶点\n  graphics.lineTo(100, 50);         // 右顶点\n  graphics.lineTo(50, 100);         // 下顶点\n  graphics.lineTo(0, 50);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建闪烁 Tween 动画\n  this.tweens.add({\n    targets: diamond,\n    alpha: {\n      from: 1,\n      to: 0\n    },\n    duration: 750,        // 0.75 秒淡出\n    yoyo: true,           // 反向播放（淡入）\n    repeat: -1,           // 无限循环\n    ease: 'Sine.easeInOut' // 平滑过渡\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Purple Diamond Blinking (1.5s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000106_v1", "prompt_id": "seed_000106", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9466666666666668}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色椭圆，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色椭圆，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建基础 Phaser.Game 配置，设置画布宽高为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置黄色填充样式（0xffff00）\n4. 使用 fillEllipse 方法在画布中央（400, 300）绘制椭圆，半径为 48 像素\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 绘制黄色椭圆\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充样式\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 为椭圆中心点坐标\n  // width 为椭圆的宽度（直径），height 为椭圆的高度（直径）\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  const ellipseWidth = 48;\n  const ellipseHeight = 48;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000575_v2", "prompt_id": "seed_000575", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的橙色菱形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在场景中绘制8个随机位置的橙色菱形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillPath, Phaser.Geom.Polygon, Graphics#setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置橙色，用 Polygon 定义菱形路径并填充\n4. 使用 setRandomPosition 或手动设置随机坐标放置菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 绘制8个随机位置的橙色菱形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xFFA500, 1);\n    \n    // 定义菱形的四个顶点（相对于中心点）\n    // 菱形大小为24像素，所以从中心到顶点距离为12\n    const size = 12; // 半径\n    const diamond = new Phaser.Geom.Polygon([\n      0, -size,      // 上顶点\n      size, 0,       // 右顶点\n      0, size,       // 下顶点\n      -size, 0       // 左顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(diamond.points, true);\n    \n    // 设置随机位置\n    // 留出边距，确保菱形完全显示在画布内\n    const margin = 20;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    \n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000315_v3", "prompt_id": "seed_000315", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2.5秒内缩放到64%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状并生成纹理\n2. 创建椭圆精灵对象\n3. 使用 Tween 创建缩放动画，从 1 到 0.64 再到 1\n4. 设置 Tween 循环播放，持续时间 2.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制椭圆（中心点在 0,0，宽度 120，高度 80）\n  graphics.fillEllipse(0, 0, 120, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTexture', 120, 80);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建椭圆精灵，放置在屏幕中央\n  const ellipse = this.add.sprite(400, 300, 'ellipseTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: ellipse,\n    scaleX: 0.64,  // 缩放到 64%\n    scaleY: 0.64,\n    duration: 1250, // 2.5秒的一半，因为需要来回\n    yoyo: true,     // 启用 yoyo 效果，动画结束后反向播放\n    repeat: -1,     // 无限循环 (-1 表示永久重复)\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '椭圆循环缩放动画\\n2.5秒一个周期', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000531_v1", "prompt_id": "seed_000531", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色星形以360速度移动并在画布边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setCollideWorldBounds, Sprite.setBounce, Sprite.setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制红色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置精灵速度为 360（斜向移动以体现速度）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制五角星（中心点在64,64，半径为60）\n  graphics.fillStar(64, 64, 5, 20, 60, 0);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 128, 128);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置速度（斜向移动以体现360的速度）\n  // 使用勾股定理：sqrt(x^2 + y^2) = 360\n  // 设置为45度角移动：x = y = 360 / sqrt(2) ≈ 254.56\n  star.setVelocity(254.56, 254.56);\n  \n  // 启用世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  star.setBounce(1, 1);\n  \n  // 添加文字提示\n  this.add.text(10, 10, 'Red star moving at 360 speed\\nBouncing off canvas edges', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000182_v1", "prompt_id": "seed_000182", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 3 个粉色敌人巡逻移动，在 300 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 3个粉色敌人左右巡逻，玩家接近时追踪，速度300\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建物理系统配置，启用 Arcade 物理引擎\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（粉色圆形）纹理\n3. 创建玩家精灵，支持键盘方向键控制移动\n4. 创建敌人组，初始化3个敌人，设置巡逻边界和初始速度\n5. 在 update 中检测玩家与敌人距离，小于阈值时切换为追踪模式\n6. 敌人巡逻模式：碰到边界反向；追踪模式：朝向玩家移动\n7. 添加状态变量追踪敌人状态（patrolling/chasing）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemyStates = []; // 状态信号：记录每个敌人的状态\n    this.chasingCount = 0; // 状态信号：正在追踪的敌人数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（粉色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff69b4, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 初始化3个敌人，分别在不同位置\n    const enemyPositions = [\n      { x: 150, y: 150 },\n      { x: 400, y: 450 },\n      { x: 650, y: 250 }\n    ];\n\n    enemyPositions.forEach((pos, index) => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 设置巡逻参数\n      enemy.patrolMinX = pos.x - 150;\n      enemy.patrolMaxX = pos.x + 150;\n      enemy.patrolSpeed = 300;\n      enemy.chaseSpeed = 300;\n      enemy.detectionRange = 200; // 检测范围\n      \n      // 初始化巡逻方向（随机左右）\n      enemy.setVelocityX(Phaser.Math.Between(0, 1) === 0 ? -300 : 300);\n      \n      // 初始化状态\n      this.enemyStates[index] = 'patrolling';\n    });\n\n    // 设置键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 560, '使用方向键移动玩家 | 敌人会在玩家接近时追踪', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 更新敌人行为\n    this.chasingCount = 0;\n    this.enemies.children.entries.forEach((enemy, index) => {\n      const distanceToPlayer = Phaser.Math.Distance.Between(\n        enemy.x, enemy.y,\n        this.player.x, this.player.y\n      );\n\n      // 判断是否应该追踪玩家\n      if (distanceToPlayer < enemy.detectionRange) {\n        // 追踪模式\n        this.enemyStates[index] = 'chasing';\n        this.chasingCount++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        // 设置速度朝向玩家\n        this.physics.velocityFromRotation(\n          angle,\n          enemy.chaseSpeed,\n          enemy.body.velocity\n        );\n\n        // 设置敌人颜色变化（追踪时变红）\n        enemy.setTint(0xff0000);\n      } else {\n        // 巡逻模式\n        this.enemyStates[index] = 'patrolling';\n        enemy.clearTint();\n\n        // 检查是否到达巡逻边界\n        if (enemy.x <= enemy.patrolMinX && enemy.body.velocity.x < 0) {\n          enemy.setVelocityX(enemy.patrolSpeed);\n        } else if (enemy.x >= enemy.patrolMaxX && enemy.body.velocity.x > 0) {\n          enemy.setVelocityX(-enemy.patrolSpeed);\n        }\n\n        // 保持Y轴速度为0（水平巡逻）\n        enemy.setVelocityY(0);\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Enemy States: ${this.enemyStates.join(', ')}`,\n      `Chasing Count: ${this.chasingCount}/3`,\n      `Player Position: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000876_v2", "prompt_id": "seed_000876", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让灰色方块在 1.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色方块，使用 Tween 动画在 1.5 秒内旋转一圈并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setRotation\nSTEPS:\n1. 使用 Graphics 绘制灰色方块并生成纹理\n2. 创建 Sprite 对象并设置到屏幕中心\n3. 使用 tweens.add 创建旋转动画，设置 rotation 从 0 到 2π\n4. 配置动画时长为 1500ms，loop 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('graySquare', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建灰色方块精灵并放置在屏幕中心\n  const square = this.add.sprite(400, 300, 'graySquare');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    rotation: Math.PI * 2,     // 旋转角度：2π 弧度（360度）\n    duration: 1500,            // 动画时长：1.5 秒\n    ease: 'Linear',            // 线性缓动，匀速旋转\n    loop: -1,                  // -1 表示无限循环\n    repeat: 0                  // 每次循环不需要额外重复\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Rotating Gray Square', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000356_v3", "prompt_id": "seed_000356", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建精灵对象使用六边形纹理\n3. 使用 Tween 实现缩放动画，从1到0.32再回到1\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 60;\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 从原始大小(1) -> 缩放到32%(0.32) -> 恢复到原始大小(1)\n  this.tweens.add({\n    targets: hexSprite,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 1000, // 1秒缩小到32%\n    yoyo: true,     // 自动反向播放（恢复到原始大小）\n    repeat: -1,     // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '六边形缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '1秒缩放到32%，然后恢复，循环播放', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000443_v1", "prompt_id": "seed_000443", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Container, Phaser.Scene.cameras\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建精灵对象作为可移动的菱形\n3. 在 update 中让菱形持续向下移动\n4. 使用相机的 startFollow 方法跟随菱形对象\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst MOVE_SPEED = 100; // 每秒向下移动的像素数\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  createGrid.call(this);\n  \n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1);\n  \n  // 绘制菱形（中心点在 32, 32）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 上顶点\n  graphics.lineTo(64, 32);     // 右顶点\n  graphics.lineTo(32, 64);     // 下顶点\n  graphics.lineTo(0, 32);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形精灵对象，初始位置在场景上方中央\n  diamond = this.add.sprite(400, 100, 'diamond');\n  \n  // 设置相机跟随菱形对象\n  // 第二个参数 true 表示圆形插值（更平滑）\n  // lerp 参数控制跟随的平滑度（0.1 表示每帧移动距离的 10%）\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 可选：设置相机边界，让相机不会移出场景范围\n  // 这里设置一个更大的世界边界\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n  \n  // 添加提示文本（固定在相机视图中）\n  const text = this.add.text(10, 10, '相机跟随菱形对象\\n菱形自动向下移动', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图中，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 让菱形持续向下移动\n  // delta 是以毫秒为单位的时间间隔\n  diamond.y += (MOVE_SPEED * delta) / 1000;\n  \n  // 可选：当菱形移动到一定距离后重置位置（循环效果）\n  if (diamond.y > 2500) {\n    diamond.y = 100;\n  }\n}\n\n// 辅助函数：创建网格背景\nfunction createGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制更大范围的网格\n  const gridSize = 50;\n  const worldHeight = 3000;\n  const worldWidth = 800;\n  \n  // 垂直线\n  for (let x = 0; x <= worldWidth; x += gridSize) {\n    graphics.lineBetween(x, 0, x, worldHeight);\n  }\n  \n  // 水平线\n  for (let y = 0; y <= worldHeight; y += gridSize) {\n    graphics.lineBetween(0, y, worldWidth, y);\n  }\n  \n  // 添加坐标标记\n  const style = { fontSize: '12px', fill: '#00ff00' };\n  for (let y = 0; y <= worldHeight; y += 200) {\n    const label = this.add.text(10, y, `Y: ${y}`, style);\n    label.setDepth(1);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000232_v1", "prompt_id": "seed_000232", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8733333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文本，字体大小 24px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本位置为右下角（x: 800, y: 600），使用 setOrigin(1, 1) 使文本右下对齐\n4. 设置字体大小为 24px，颜色为白色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右下角创建文本\n  // 位置设置为 (800, 600)，即画布的右下角\n  const text = this.add.text(800, 600, 'Hello Phaser', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置原点为右下角 (1, 1)，使文本从右下角对齐\n  // 这样文本会完整显示在画布内，不会溢出\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000094_v3", "prompt_id": "seed_000094", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色圆形在2.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Math.Linear\nSTEPS:\n1. 使用 Graphics 绘制红色圆形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 yoyo 和 loop 实现往返循环\n4. 配置动画持续时间为2500毫秒，目标位置为右侧\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  \n  // 生成纹理\n  graphics.generateTexture('redCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'redCircle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 目标 x 坐标（右侧位置）\n    duration: 2500, // 持续时间 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达目标后反向播放）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, '红色圆形左右往返循环移动', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000076_v3", "prompt_id": "seed_000076", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形并以每秒160度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#moveTo, Phaser.GameObjects.Graphics#lineTo, Phaser.GameObjects.Graphics#closePath, Phaser.GameObjects.Graphics#fillPath, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 绘制菱形路径（四个顶点连接成菱形）\n2. 设置菱形的原点到中心点，便于旋转\n3. 在 update 方法中根据时间增量计算旋转角度（160度/秒 = 160 * delta/1000）\n4. 累加旋转角度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet rotationAngle = 0;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置填充颜色\n  diamond.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心在原点）\n  diamond.beginPath();\n  diamond.moveTo(0, -60);    // 上顶点\n  diamond.lineTo(50, 0);     // 右顶点\n  diamond.lineTo(0, 60);     // 下顶点\n  diamond.lineTo(-50, 0);    // 左顶点\n  diamond.closePath();\n  diamond.fillPath();\n  \n  // 将菱形移动到画布中心\n  diamond.x = 400;\n  diamond.y = 300;\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量：每秒160度\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 160; // 度/秒\n  const rotationIncrement = Phaser.Math.DegToRad(rotationSpeed * delta / 1000);\n  \n  // 累加旋转角度\n  rotationAngle += rotationIncrement;\n  \n  // 应用旋转\n  diamond.rotation = rotationAngle;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000679_v3", "prompt_id": "seed_000679", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现灰色敌人追踪：敌人以 80 速度追踪玩家位置，玩家速度 80*1.2 可躲避。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现灰色敌人以80速度追踪玩家，玩家速度96可躲避\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.ArcadePhysics#moveToObject, Phaser.Input.Keyboard#createCursorKeys, Phaser.GameObjects.Graphics#generateTexture\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（灰色圆形）纹理\n3. 创建玩家精灵，设置速度为 96 (80*1.2)\n4. 创建敌人精灵，在 update 中使用 moveToObject 追踪玩家，速度 80\n5. 添加键盘输入控制玩家移动（方向键）\n6. 添加玩家与敌人碰撞检测，碰撞时减少玩家生命值\n7. 显示状态信息（生命值、距离）作为可验证信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet enemy;\nlet cursors;\nlet healthText;\nlet distanceText;\nlet gameOverText;\n\n// 游戏状态变量（可验证信号）\nlet health = 100;\nlet isGameOver = false;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x4444ff, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建敌人纹理（灰色圆形）\n  const enemyGraphics = this.add.graphics();\n  enemyGraphics.fillStyle(0x888888, 1);\n  enemyGraphics.fillCircle(20, 20, 20);\n  enemyGraphics.generateTexture('enemy', 40, 40);\n  enemyGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵（中心位置）\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  \n  // 创建敌人精灵（随机位置）\n  const startX = Phaser.Math.Between(50, 750);\n  const startY = Phaser.Math.Between(50, 550);\n  enemy = this.physics.add.sprite(startX, startY, 'enemy');\n  \n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加碰撞检测\n  this.physics.add.overlap(player, enemy, hitEnemy, null, this);\n  \n  // 创建UI文本\n  healthText = this.add.text(16, 16, 'Health: 100', {\n    fontSize: '20px',\n    fill: '#ffffff'\n  });\n  \n  distanceText = this.add.text(16, 46, 'Distance: 0', {\n    fontSize: '20px',\n    fill: '#ffffff'\n  });\n  \n  gameOverText = this.add.text(400, 300, '', {\n    fontSize: '48px',\n    fill: '#ff0000',\n    fontStyle: 'bold'\n  });\n  gameOverText.setOrigin(0.5);\n  \n  // 添加提示文本\n  const instructionText = this.add.text(400, 550, 'Use Arrow Keys to Move - Avoid the Gray Enemy!', {\n    fontSize: '18px',\n    fill: '#aaaaaa'\n  });\n  instructionText.setOrigin(0.5);\n}\n\nfunction update() {\n  if (isGameOver) {\n    player.setVelocity(0, 0);\n    enemy.setVelocity(0, 0);\n    return;\n  }\n  \n  // 玩家移动控制（速度 96 = 80 * 1.2）\n  const playerSpeed = 96;\n  player.setVelocity(0, 0);\n  \n  if (cursors.left.isDown) {\n    player.setVelocityX(-playerSpeed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(playerSpeed);\n  }\n  \n  if (cursors.up.isDown) {\n    player.setVelocityY(-playerSpeed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(playerSpeed);\n  }\n  \n  // 对角线移动时归一化速度\n  if (player.body.velocity.x !== 0 && player.body.velocity.y !== 0) {\n    player.body.velocity.normalize().scale(playerSpeed);\n  }\n  \n  // 敌人追踪玩家（速度 80）\n  const enemySpeed = 80;\n  this.physics.moveToObject(enemy, player, enemySpeed);\n  \n  // 计算并显示距离\n  const distance = Phaser.Math.Distance.Between(\n    player.x, player.y,\n    enemy.x, enemy.y\n  );\n  distanceText.setText('Distance: ' + Math.floor(distance));\n  \n  // 更新生命值显示\n  healthText.setText('Health: ' + health);\n}\n\nfunction hitEnemy(player, enemy) {\n  if (isGameOver) return;\n  \n  // 减少生命值\n  health -= 10;\n  \n  // 击退效果\n  const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);\n  player.setVelocity(\n    Math.cos(angle) * 200,\n    Math.sin(angle) * 200\n  );\n  \n  // 检查游戏结束\n  if (health <= 0) {\n    health = 0;\n    isGameOver = true;\n    gameOverText.setText('GAME OVER!\\nEnemy Caught You!');\n    player.setTint(0xff0000);\n  } else {\n    // 短暂无敌效果（视觉反馈）\n    player.setTint(0xff8888);\n    this.time.delayedCall(200, () => {\n      if (!isGameOver) {\n        player.clearTint();\n      }\n    });\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001121_v3", "prompt_id": "seed_001121", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.865}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Phaser.Cameras.Scene2D.CameraManager.main\nSTEPS:\n1. 创建场景配置，设置较大的世界边界以便星形移动\n2. 使用 Graphics 绘制一个星形作为跟随对象\n3. 在 create 中通过 this.cameras.main.startFollow() 让主相机跟随星形\n4. 在 update 中让星形持续向右上方移动（x++, y--）\n5. 设置相机边界与世界边界一致，确保跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet star;\nlet graphics;\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，创建一个更大的游戏世界\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n\n  // 创建 Graphics 对象绘制星形\n  graphics = this.add.graphics();\n  \n  // 绘制一个黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(3, 0xffa500, 1);\n  \n  // 星形的中心点\n  const centerX = 400;\n  const centerY = 400;\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const points = 5;\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 将 graphics 对象作为跟随目标\n  star = graphics;\n  \n  // 设置相机跟随星形\n  this.cameras.main.startFollow(star, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（默认居中，这里显式设置为0,0表示居中）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加提示文字（固定在相机视图中）\n  const text = this.add.text(10, 10, '相机跟随星形移动\\n星形自动向右上移动', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图中，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 星形向右上方移动\n  // 向右移动（x 增加）\n  star.x += 2;\n  // 向上移动（y 减少）\n  star.y -= 1.5;\n  \n  // 如果星形移动到世界边界外，重置位置\n  if (star.x > 1900 || star.y < 100) {\n    star.x = 400;\n    star.y = 400;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000368_v1", "prompt_id": "seed_000368", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 3 个粉色敌人巡逻移动，在 300 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 3个粉色敌人巡逻移动，速度300左右往返，玩家接近时追踪\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建玩家和3个敌人的Graphics纹理（玩家蓝色，敌人粉色）\n2. 初始化玩家精灵和敌人物理组，设置初始位置和速度\n3. 在update中检测玩家与每个敌人的距离，判断巡逻或追踪状态\n4. 巡逻模式：敌人左右往返，碰到边界反向\n5. 追踪模式：距离<200时，敌人朝玩家方向移动\n6. 使用键盘控制玩家移动，维护enemiesChasing状态变量用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesChasing = 0; // 状态信号：当前追踪玩家的敌人数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（粉色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff69b4, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 创建3个敌人，分别在不同位置\n    const enemyPositions = [\n      { x: 150, y: 150 },\n      { x: 400, y: 100 },\n      { x: 650, y: 200 }\n    ];\n\n    enemyPositions.forEach(pos => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 设置初始巡逻方向（随机向左或向右）\n      enemy.patrolDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;\n      enemy.setVelocityX(300 * enemy.patrolDirection);\n      \n      // 标记敌人状态\n      enemy.isChasing = false;\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 550, '使用方向键移动玩家 | 敌人接近时会追踪', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 重置追踪计数\n    this.enemiesChasing = 0;\n\n    // 敌人AI逻辑\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, this.player.y,\n        enemy.x, enemy.y\n      );\n\n      const chaseDistance = 200; // 追踪触发距离\n      const patrolSpeed = 300;\n      const chaseSpeed = 250;\n\n      if (distance < chaseDistance) {\n        // 追踪模式\n        enemy.isChasing = true;\n        this.enemiesChasing++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        // 设置速度朝向玩家\n        this.physics.velocityFromRotation(angle, chaseSpeed, enemy.body.velocity);\n\n      } else {\n        // 巡逻模式\n        enemy.isChasing = false;\n\n        // 检测是否碰到世界边界，反向移动\n        if (enemy.body.blocked.left || enemy.body.blocked.right) {\n          enemy.patrolDirection *= -1;\n        }\n\n        // 保持水平巡逻\n        enemy.setVelocityX(patrolSpeed * enemy.patrolDirection);\n        enemy.setVelocityY(0);\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText(\n      `追踪中的敌人: ${this.enemiesChasing}/3\\n` +\n      `玩家位置: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000876_v3", "prompt_id": "seed_000876", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：10 个橙色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 10个橙色小球以360速度在封闭空间内移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.generateTexture, Physics.add.group, Body.setBounce, Physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，启用边界碰撞\n2. 使用 Graphics 绘制橙色圆形纹理\n3. 创建物理组，添加 10 个小球精灵\n4. 为每个小球设置随机速度（总速度 360）和完全弹性（bounce=1）\n5. 添加小球之间的碰撞检测\n6. 添加碰撞计数器作为验证信号\n[/PLAN]\n\n```javascript\nclass BallScene extends Phaser.Scene {\n  constructor() {\n    super('BallScene');\n    this.collisionCount = 0; // 碰撞计数器（验证信号）\n    this.ballCount = 10; // 小球数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8800, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 设置世界边界碰撞\n    this.physics.world.setBoundsCollision(true, true, true, true);\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: this.ballCount - 1, // 总共10个球\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 为每个小球设置随机位置和速度\n    const speed = 360;\n    this.balls.children.iterate((ball) => {\n      // 随机位置（避免太靠近边缘）\n      const x = Phaser.Math.Between(50, width - 50);\n      const y = Phaser.Math.Between(50, height - 50);\n      ball.setPosition(x, y);\n\n      // 随机方向，但保持速度为360\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(angle * Math.PI / 180) * speed;\n      const velocityY = Math.sin(angle * Math.PI / 180) * speed;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形物理体（更精确的碰撞）\n      ball.body.setCircle(16);\n    });\n\n    // 添加小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示碰撞计数文本\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示小球数量文本\n    this.ballCountText = this.add.text(10, 50, `Balls: ${this.ballCount}`, {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界线（可视化）\n    const border = this.add.graphics();\n    border.lineStyle(2, 0xffffff, 1);\n    border.strokeRect(0, 0, width, height);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 验证速度保持在360左右（由于浮点误差可能略有偏差）\n    // 可选：在控制台输出验证信息\n    if (time % 1000 < 20) { // 每秒检查一次\n      this.balls.children.iterate((ball) => {\n        const velocity = ball.body.velocity;\n        const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n        \n        // 如果速度偏差过大，重新归一化（修正浮点误差）\n        if (Math.abs(currentSpeed - 360) > 5) {\n          const scale = 360 / currentSpeed;\n          ball.setVelocity(velocity.x * scale, velocity.y * scale);\n        }\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false // 设为 true 可查看物理边界\n    }\n  },\n  scene: BallScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001181_v1", "prompt_id": "seed_001181", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现粉色角色按键切换 idle/run 状态，用帧动画和 tween 体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Animations.AnimationManager, Phaser.Input.Keyboard, Phaser.Tweens\nSTEPS:\n1. 使用 Graphics 程序化生成粉色角色的 idle 和 run 状态帧纹理\n2. 创建 idle 和 run 两个帧动画\n3. 监听键盘输入（空格键切换状态，方向键触发 run）\n4. 根据状态播放对应动画，并添加 tween 效果（idle 时上下浮动，run 时水平抖动）\n5. 显示当前状态文本作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle'; // 可验证的状态信号\n    this.stateChangeCount = 0; // 状态切换次数\n  }\n\n  preload() {\n    // 生成 idle 状态的帧纹理（3帧，粉色方块，大小变化）\n    for (let i = 0; i < 3; i++) {\n      const graphics = this.add.graphics();\n      const size = 60 + i * 5; // 大小从60到70渐变\n      const offsetX = (70 - size) / 2;\n      const offsetY = (70 - size) / 2;\n      \n      // 绘制粉色身体\n      graphics.fillStyle(0xff69b4, 1);\n      graphics.fillRoundedRect(offsetX, offsetY, size, size, 10);\n      \n      // 绘制眼睛\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(offsetX + size * 0.35, offsetY + size * 0.4, 4);\n      graphics.fillCircle(offsetX + size * 0.65, offsetY + size * 0.4, 4);\n      \n      // 绘制笑脸\n      graphics.lineStyle(2, 0x000000, 1);\n      graphics.beginPath();\n      graphics.arc(offsetX + size * 0.5, offsetY + size * 0.6, size * 0.2, 0, Math.PI, false);\n      graphics.strokePath();\n      \n      graphics.generateTexture(`idle_${i}`, 70, 70);\n      graphics.destroy();\n    }\n\n    // 生成 run 状态的帧纹理（4帧，倾斜姿态）\n    for (let i = 0; i < 4; i++) {\n      const graphics = this.add.graphics();\n      const angle = (i % 2 === 0) ? -10 : 10; // 左右倾斜\n      \n      // 保存变换状态\n      graphics.save();\n      graphics.translateCanvas(35, 35);\n      graphics.rotateCanvas(Phaser.Math.DegToRad(angle));\n      graphics.translateCanvas(-35, -35);\n      \n      // 绘制粉色身体（拉长形状表示奔跑）\n      graphics.fillStyle(0xff69b4, 1);\n      graphics.fillRoundedRect(10, 15, 50, 40, 8);\n      \n      // 绘制眼睛（更有活力的表情）\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(27, 30, 4);\n      graphics.fillCircle(43, 30, 4);\n      \n      // 绘制兴奋的笑脸\n      graphics.lineStyle(3, 0x000000, 1);\n      graphics.beginPath();\n      graphics.arc(35, 40, 10, 0, Math.PI, false);\n      graphics.strokePath();\n      \n      // 绘制运动线条\n      graphics.lineStyle(2, 0xffa0d0, 0.6);\n      graphics.lineBetween(5, 25 + i * 3, 15, 25 + i * 3);\n      graphics.lineBetween(5, 35 + i * 3, 15, 35 + i * 3);\n      \n      graphics.restore();\n      graphics.generateTexture(`run_${i}`, 70, 70);\n      graphics.destroy();\n    }\n  }\n\n  create() {\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x87ceeb, 1);\n    bg.fillRect(0, 0, 800, 600);\n\n    // 创建地面\n    const ground = this.add.graphics();\n    ground.fillStyle(0x90ee90, 1);\n    ground.fillRect(0, 500, 800, 100);\n\n    // 创建角色精灵\n    this.player = this.add.sprite(400, 450, 'idle_0');\n    this.player.setScale(2);\n\n    // 创建 idle 动画\n    this.anims.create({\n      key: 'idle_anim',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' },\n        { key: 'idle_2' },\n        { key: 'idle_1' }\n      ],\n      frameRate: 4,\n      repeat: -1\n    });\n\n    // 创建 run 动画\n    this.anims.create({\n      key: 'run_anim',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 8,\n      repeat: -1\n    });\n\n    // 播放初始 idle 动画\n    this.player.play('idle_anim');\n\n    // 创建 idle 状态的浮动 tween\n    this.idleTween = this.tweens.add({\n      targets: this.player,\n      y: 440,\n      duration: 1000,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 创建状态显示文本\n    this.stateText = this.add.text(400, 50, 'State: IDLE', {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#ff69b4',\n      stroke: '#ffffff',\n      strokeThickness: 4\n    });\n    this.stateText.setOrigin(0.5);\n\n    // 创建计数器文本\n    this.counterText = this.add.text(400, 100, 'State Changes: 0', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 3\n    });\n    this.counterText.setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 550, 'Press SPACE to toggle | Arrow Keys to RUN', {\n      fontSize: '20px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 2\n    }).setOrigin(0.5);\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 空格键切换状态\n    this.spaceKey.on('down', () => {\n      this.toggleState();\n    });\n  }\n\n  update() {\n    // 方向键触发 run 状态\n    if (this.cursors.left.isDown || this.cursors.right.isDown || \n        this.cursors.up.isDown || this.cursors.down.isDown) {\n      if (this.currentState !== 'run') {\n        this.setState('run');\n      }\n    }\n  }\n\n  toggleState() {\n    if (this.currentState === 'idle') {\n      this.setState('run');\n    } else {\n      this.setState('idle');\n    }\n  }\n\n  setState(newState) {\n    if (this.currentState === newState) return;\n\n    this.currentState = newState;\n    this.stateChangeCount++;\n    this.counterText.setText(`State Changes: ${this.stateChangeCount}`);\n\n    // 停止所有 tweens\n    this.tweens.killTweensOf(this.player);\n\n    if (newState === 'idle') {\n      // 切换到 idle 动画\n      this.player.play('idle_anim');\n      this.stateText.setText('State: IDLE');\n      this.stateText.setColor('#ff69b4');\n\n      // 重置位置并启动浮动 tween\n      this.player.y = 450;\n      this.tweens.add({\n        targets: this.player,\n        y: 440,\n        duration: 1000,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n\n    } else if (newState === 'run') {\n      // 切换到 run 动画\n      this.player.play('run_anim');\n      this.stateText.setText('State: RUN');\n      this.stateText.setColor('#ff0000');\n\n      // 重置位置并启动水平抖动 tween\n      this.player.y = 450;\n      this.tweens.add({\n        targets: this.player,\n        x: this.player.x + 10,\n        duration: 100,\n        ease: 'Linear',\n        yoyo: true,\n        repeat: -1\n      });\n\n      // 添加轻微的上下跳动\n      this.tweens.add({\n        targets: this.player,\n        y: 445,\n        duration: 200,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  scene: GameScene,\n  pixelArt: false,\n  antialias: true\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000805_v1", "prompt_id": "seed_000805", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.9649999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 粉色玩家移出边界时从对侧出现（循环地图效果），移动速度 360。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 粉色玩家移出边界时从对侧出现（循环地图效果），移动速度 360\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建带物理系统的 Scene 配置\n2. 使用 Graphics 绘制粉色玩家纹理\n3. 创建物理精灵并设置速度为 360\n4. 监听键盘输入（方向键）控制移动\n5. 在 update 中检测边界，实现循环效果\n6. 添加状态变量记录玩家位置信息用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.wrapCount = 0; // 状态信号：记录玩家穿越边界次数\n    this.currentX = 0;  // 状态信号：当前X坐标\n    this.currentY = 0;  // 状态信号：当前Y坐标\n  }\n\n  preload() {\n    // 使用 Graphics 创建粉色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF69B4, 1); // 粉色\n    graphics.fillCircle(20, 20, 20);\n    graphics.generateTexture('player', 40, 40);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 关闭世界边界碰撞，允许穿越\n    \n    // 设置玩家速度为 360\n    this.moveSpeed = 360;\n    \n    // 创建方向键输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 创建 WASD 键作为备选\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n    \n    // 添加调试文本显示状态\n    this.debugText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    // 绘制边界参考线\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0xFFFFFF, 0.5);\n    borderGraphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0, 0);\n    \n    // 处理键盘输入\n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-this.moveSpeed);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(this.moveSpeed);\n    }\n    \n    if (this.cursors.up.isDown || this.keyW.isDown) {\n      this.player.setVelocityY(-this.moveSpeed);\n    } else if (this.cursors.down.isDown || this.keyS.isDown) {\n      this.player.setVelocityY(this.moveSpeed);\n    }\n    \n    // 对角线移动时归一化速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(this.moveSpeed);\n    }\n    \n    // 循环边界检测\n    const playerRadius = 20; // 玩家半径\n    \n    // 左右边界循环\n    if (this.player.x < -playerRadius) {\n      this.player.x = 800 + playerRadius;\n      this.wrapCount++;\n    } else if (this.player.x > 800 + playerRadius) {\n      this.player.x = -playerRadius;\n      this.wrapCount++;\n    }\n    \n    // 上下边界循环\n    if (this.player.y < -playerRadius) {\n      this.player.y = 600 + playerRadius;\n      this.wrapCount++;\n    } else if (this.player.y > 600 + playerRadius) {\n      this.player.y = -playerRadius;\n      this.wrapCount++;\n    }\n    \n    // 更新状态信号\n    this.currentX = Math.round(this.player.x);\n    this.currentY = Math.round(this.player.y);\n    \n    // 更新调试信息\n    this.debugText.setText([\n      `Position: (${this.currentX}, ${this.currentY})`,\n      `Velocity: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`,\n      `Wrap Count: ${this.wrapCount}`,\n      `Speed: ${this.moveSpeed}`,\n      '',\n      'Controls: Arrow Keys or WASD'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001187_v3", "prompt_id": "seed_001187", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个黄色小球以 240 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个黄色小球在封闭空间内以240速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade.Group, setBounce, setCollideWorldBounds, collider, setVelocity, Graphics.fillCircle, generateTexture\nSTEPS:\n1. 配置 Arcade 物理系统，启用世界边界\n2. 使用 Graphics 创建黄色圆形纹理\n3. 创建物理组，添加 5 个小球精灵\n4. 为每个小球设置随机初始速度（速度大小为 240）\n5. 设置小球与世界边界碰撞反弹\n6. 设置小球之间的碰撞检测\n7. 添加碰撞计数器作为可验证状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证状态：碰撞计数\n    this.ballCount = 5; // 可验证状态：小球数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 创建黄色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1); // 黄色\n    graphics.fillCircle(16, 16, 16); // 半径 16 的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: this.ballCount - 1, // 创建 5 个小球\n      setXY: {\n        x: Phaser.Math.Between(50, width - 50),\n        y: Phaser.Math.Between(50, height - 50),\n        stepX: 0,\n        stepY: 0\n      }\n    });\n\n    // 为每个小球设置属性\n    this.balls.children.entries.forEach((ball, index) => {\n      // 设置随机位置，避免重叠\n      ball.setPosition(\n        Phaser.Math.Between(50 + index * 30, width - 50),\n        Phaser.Math.Between(50 + index * 30, height - 50)\n      );\n\n      // 设置碰撞边界反弹\n      ball.setBounce(1, 1); // 完全弹性碰撞\n      ball.setCollideWorldBounds(true); // 与世界边界碰撞\n\n      // 设置随机速度方向，速度大小为 240\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const vx = Math.cos(angle) * 240;\n      const vy = Math.sin(angle) * 240;\n      ball.setVelocity(vx, vy);\n\n      // 设置圆形碰撞体（更精确）\n      ball.body.setCircle(16);\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.handleCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatus();\n  }\n\n  handleCollision(ball1, ball2) {\n    // 碰撞回调，增加计数\n    this.collisionCount++;\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    this.statusText.setText([\n      `Balls: ${this.ballCount}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 240 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 确保速度保持在 240（可选，用于修正浮点误差）\n    this.balls.children.entries.forEach(ball => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度有偏差，重新归一化到 240\n      if (Math.abs(currentSpeed - 240) > 1) {\n        const scale = 240 / currentSpeed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000864_v1", "prompt_id": "seed_000864", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9042857142857141}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在1秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 实现缩放动画（scale: 1 -> 0.48 -> 1）\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff88, 1);\n  \n  // 绘制菱形（中心点为 50, 50，边长约 80）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 上顶点\n  graphics.lineTo(centerX + size, centerY);      // 右顶点\n  graphics.lineTo(centerX, centerY + size);      // 下顶点\n  graphics.lineTo(centerX - size, centerY);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  // 从原始大小(1) -> 48%(0.48) -> 原始大小(1)，总时长2秒\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 1000,        // 1秒缩小到48%\n    yoyo: true,            // 自动反向播放（恢复到原始大小）\n    repeat: -1,            // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000703_v3", "prompt_id": "seed_000703", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 4 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让方块在4秒内缩放到64%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillRect, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块\n2. 创建 Tween 动画，设置 scale 属性从 1 到 0.64\n3. 设置 yoyo 为 true 实现恢复效果\n4. 设置 duration 为 2000ms（来回共4秒）\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(-50, -50, 100, 100); // 以中心点为原点绘制 100x100 的方块\n  \n  // 将 graphics 转换为纹理\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，使用纹理代替\n  \n  // 在屏幕中心创建方块精灵\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    scale: 0.64,              // 缩放到 64%（0.64 倍）\n    duration: 2000,           // 单程持续时间 2 秒\n    yoyo: true,               // 启用悠悠球效果（自动恢复）\n    loop: -1,                 // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'    // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Square scaling to 64% and back\\n(4 seconds per cycle)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000784_v2", "prompt_id": "seed_000784", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色椭圆以360速度移动并在画布边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser 游戏配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制灰色椭圆并生成纹理\n3. 创建物理精灵，设置速度为360，启用世界边界碰撞和反弹\n4. 在 update 中保持椭圆持续移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建灰色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillEllipse(40, 30, 80, 60); // 椭圆中心点和宽高\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  this.ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置世界边界碰撞\n  this.ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1，实现完全弹性碰撞\n  this.ellipse.setBounce(1, 1);\n  \n  // 设置初始速度（斜向移动，速度大小约为360）\n  // 使用勾股定理：sqrt(254^2 + 254^2) ≈ 359.3\n  this.ellipse.setVelocity(254, 254);\n  \n  // 可选：添加提示文本\n  this.add.text(10, 10, 'Gray ellipse bouncing at speed ~360', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 物理系统自动处理移动和碰撞，无需额外更新逻辑\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000242_v3", "prompt_id": "seed_000242", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的橙色椭圆，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的橙色椭圆，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环3次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置橙色（0xFFA500），使用 fillEllipse 绘制椭圆（中心0,0，半径32）\n4. 使用 setRandomPosition 将每个椭圆随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建3个橙色椭圆\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const ellipse = this.add.graphics();\n    \n    // 设置橙色填充（0xFFA500 是橙色的十六进制值）\n    ellipse.fillStyle(0xFFA500, 1);\n    \n    // 绘制椭圆，中心点在(0, 0)，宽高各64像素（半径32）\n    ellipse.fillEllipse(0, 0, 64, 64);\n    \n    // 设置随机位置（考虑椭圆大小，避免超出边界）\n    const randomX = Phaser.Math.Between(32, 800 - 32);\n    const randomY = Phaser.Math.Between(32, 600 - 32);\n    ellipse.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000288_v3", "prompt_id": "seed_000288", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色菱形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色菱形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返，loop 为 -1 实现无限循环，duration 为 4000 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0066ff, 1);\n  \n  // 绘制菱形（四个顶点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 上顶点\n  graphics.lineTo(30, 0);     // 右顶点\n  graphics.lineTo(0, 30);     // 下顶点\n  graphics.lineTo(-30, 0);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 60, 60);\n  graphics.destroy();\n  \n  // 创建菱形精灵，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 4000,            // 持续时间 4 秒\n    yoyo: true,                // 往返模式\n    loop: -1,                  // 无限循环\n    ease: 'Linear'             // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000429_v1", "prompt_id": "seed_000429", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让绿色椭圆在 0.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建绿色椭圆并使用 Tween 实现 0.5 秒旋转一次的循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#generateTexture, Phaser.GameObjects.Sprite, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制绿色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 500ms，angle 从 0 到 360\n4. 设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建绿色椭圆纹理\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制椭圆（中心在纹理中心）\n  // fillEllipse(x, y, width, height)\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('greenEllipse', 100, 60);\n  \n  // 销毁 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建椭圆精灵，放置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'greenEllipse');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    angle: 360,                 // 旋转到 360 度\n    duration: 500,              // 持续时间 0.5 秒\n    repeat: -1,                 // 无限循环（-1 表示永远重复）\n    ease: 'Linear'              // 线性缓动，保证匀速旋转\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '绿色椭圆旋转动画 (0.5秒/圈)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000501_v1", "prompt_id": "seed_000501", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的白色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的白色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.lineStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.strokePath, Math.cos, Math.sin, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 使用三角函数计算六边形的6个顶点坐标（基于中心点和半径16像素）\n4. 为每个 Graphics 对象设置随机位置（使用 Phaser.Math.Between）\n5. 使用 lineStyle 设置白色描边，绘制六边形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制12个随机位置的白色六边形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置白色描边样式\n    graphics.lineStyle(2, 0xffffff, 1);\n    \n    // 六边形参数\n    const radius = 16; // 半径16像素，使得六边形大小约为32像素\n    const sides = 6;\n    const angle = (Math.PI * 2) / sides;\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的顶点并绘制\n    for (let j = 0; j < sides; j++) {\n      const x = radius * Math.cos(angle * j - Math.PI / 2);\n      const y = radius * Math.sin(angle * j - Math.PI / 2);\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 描边路径\n    graphics.strokePath();\n    \n    // 设置随机位置（留出边距避免六边形被裁剪）\n    const randomX = Phaser.Math.Between(50, 750);\n    const randomY = Phaser.Math.Between(50, 550);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000321_v2", "prompt_id": "seed_000321", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8999999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的橙色矩形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制20个橙色矩形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环20次，每次生成随机坐标\n4. 使用 fillStyle 设置橙色，fillRect 绘制 80x80 的矩形\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为橙色 (0xFFA500)\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 绘制20个随机位置的矩形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机 x 坐标 (0 到 width-80，确保矩形不超出画布)\n    const x = Phaser.Math.Between(0, this.scale.width - 80);\n    \n    // 生成随机 y 坐标 (0 到 height-80，确保矩形不超出画布)\n    const y = Phaser.Math.Between(0, this.scale.height - 80);\n    \n    // 绘制 80x80 的矩形\n    graphics.fillRect(x, y, 80, 80);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000489_v3", "prompt_id": "seed_000489", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的青色矩形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的青色矩形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环3次，每次生成随机 x、y 坐标（确保矩形完全在画布内）\n4. 设置青色填充样式（0x00ffff）并绘制 16x16 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充样式\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制3个随机位置的矩形\n  for (let i = 0; i < 3; i++) {\n    // 生成随机位置，确保矩形完全在画布内（减去矩形大小16）\n    const randomX = Phaser.Math.Between(0, config.width - 16);\n    const randomY = Phaser.Math.Between(0, config.height - 16);\n    \n    // 绘制 16x16 的矩形\n    graphics.fillRect(randomX, randomY, 16, 16);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000245_v3", "prompt_id": "seed_000245", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 按空格键触发相机缩放效果，持续 1 秒。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按空格键触发相机缩放效果，持续1秒\nAPI: Phaser.Input.Keyboard.KeyCodes.SPACE, Phaser.Cameras.Scene2D.Camera#zoomTo, Phaser.Input.Keyboard.KeyboardPlugin#addKey\nSTEPS:\n1. 创建场景并绘制一些可视化元素（使用Graphics绘制网格和中心标记）\n2. 在create中监听空格键输入事件\n3. 按下空格键时调用camera.zoomTo方法触发缩放效果\n4. 添加状态变量记录缩放次数作为可验证信号\n5. 显示文本提示和缩放次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.zoomCount = 0; // 可验证的状态信号\n    this.isZooming = false;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 绘制背景网格\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n    \n    // 绘制垂直线\n    for (let x = 0; x <= 800; x += 50) {\n      graphics.lineBetween(x, 0, x, 600);\n    }\n    \n    // 绘制水平线\n    for (let y = 0; y <= 600; y += 50) {\n      graphics.lineBetween(0, y, 800, y);\n    }\n\n    // 绘制中心标记\n    graphics.fillStyle(0xff0000, 1);\n    graphics.fillCircle(400, 300, 20);\n    \n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillRect(350, 250, 100, 100);\n\n    // 绘制四个角的标记\n    graphics.fillStyle(0x0000ff, 1);\n    graphics.fillCircle(100, 100, 15);\n    graphics.fillCircle(700, 100, 15);\n    graphics.fillCircle(100, 500, 15);\n    graphics.fillCircle(700, 500, 15);\n\n    // 添加提示文本\n    this.instructionText = this.add.text(400, 50, 'Press SPACE to Zoom', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.instructionText.setOrigin(0.5);\n    this.instructionText.setScrollFactor(0); // 固定在屏幕上\n\n    // 添加缩放次数显示\n    this.zoomCountText = this.add.text(400, 100, `Zoom Count: ${this.zoomCount}`, {\n      fontSize: '20px',\n      color: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.zoomCountText.setOrigin(0.5);\n    this.zoomCountText.setScrollFactor(0);\n\n    // 添加状态显示\n    this.statusText = this.add.text(400, 550, 'Status: Ready', {\n      fontSize: '18px',\n      color: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setOrigin(0.5);\n    this.statusText.setScrollFactor(0);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    this.spaceKey.on('down', () => {\n      if (!this.isZooming) {\n        this.triggerZoom();\n      }\n    });\n\n    // 获取主相机\n    this.mainCamera = this.cameras.main;\n  }\n\n  triggerZoom() {\n    this.isZooming = true;\n    this.zoomCount++;\n    \n    // 更新状态文本\n    this.zoomCountText.setText(`Zoom Count: ${this.zoomCount}`);\n    this.statusText.setText('Status: Zooming In...');\n    this.statusText.setColor('#ff0000');\n\n    // 缩放到2倍，持续1000毫秒\n    this.mainCamera.zoomTo(2, 1000, 'Sine.easeInOut', false, (camera, progress) => {\n      // 缩放进行中的回调\n      if (progress === 1) {\n        // 缩放完成后，缩小回原始大小\n        this.statusText.setText('Status: Zooming Out...');\n        this.statusText.setColor('#ffaa00');\n        \n        this.mainCamera.zoomTo(1, 1000, 'Sine.easeInOut', false, (camera, progress) => {\n          if (progress === 1) {\n            // 完全恢复后\n            this.isZooming = false;\n            this.statusText.setText('Status: Ready');\n            this.statusText.setColor('#00ff00');\n          }\n        });\n      }\n    });\n  }\n\n  update(time, delta) {\n    // 可以在这里添加其他更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: GameScene,\n  parent: 'game-container'\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000867_v3", "prompt_id": "seed_000867", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Input"], "quality_score": 0.9466666666666668}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色菱形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色菱形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色菱形并生成纹理\n2. 创建精灵对象并应用菱形纹理\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1); // 蓝色\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);        // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：4秒内从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,              // 目标 x 坐标（右侧）\n    duration: 4000,      // 持续时间 4 秒\n    ease: 'Linear',      // 线性缓动\n    yoyo: true,          // 启用往返（到达终点后反向播放）\n    repeat: -1           // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000429_v2", "prompt_id": "seed_000429", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色圆形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的粉色圆形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环5次创建 Graphics 对象\n3. 每个 Graphics 对象使用 fillStyle 设置粉色，用 fillCircle 绘制半径为24的圆形\n4. 使用 setRandomPosition 将每个圆形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建5个随机位置的粉色圆形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充 (0xff69b4 是粉色的十六进制值)\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 绘制圆形，圆心在 (0, 0)，半径为 24 (直径48)\n    graphics.fillCircle(0, 0, 24);\n    \n    // 设置随机位置\n    // 考虑圆形半径，确保圆形完全在画布内\n    const randomX = Phaser.Math.Between(24, 800 - 24);\n    const randomY = Phaser.Math.Between(24, 600 - 24);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000089_v2", "prompt_id": "seed_000089", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让紫色矩形在 2.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色矩形，使用 Tween 实现 2.5 秒弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 使用 Graphics 绘制紫色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建 y 轴弹跳动画，设置 ease 为 Bounce，duration 为 2500ms\n4. 设置 yoyo 和 repeat: -1 实现循环弹跳效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建紫色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('purpleRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const rect = this.add.sprite(400, 200, 'purpleRect');\n  \n  // 创建弹跳动画\n  this.tweens.add({\n    targets: rect,\n    y: 500, // 弹跳到的目标位置\n    duration: 2500, // 2.5 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 来回运动\n    repeat: -1, // 无限循环\n    hold: 0 // 到达目标后立即返回\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Purple Rectangle Bounce Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 580, 'Loop: 2.5s per bounce cycle', {\n    fontSize: '16px',\n    color: '#888888'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000461_v3", "prompt_id": "seed_000461", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 120 像素/秒速度移动\nAPI: Graphics.fillEllipse, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆形状\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建椭圆图形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(0, 0, 60, 40); // 中心点为 (0,0)，宽 60，高 40\n  \n  // 生成纹理并创建精灵\n  graphics.generateTexture('ellipseTex', 60, 40);\n  graphics.destroy();\n  \n  // 创建椭圆精灵并设置初始位置\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置 WASD 键盘输入\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间，delta 单位是毫秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动椭圆\n  if (keys.w.isDown) {\n    ellipse.y -= distance;\n  }\n  if (keys.s.isDown) {\n    ellipse.y += distance;\n  }\n  if (keys.a.isDown) {\n    ellipse.x -= distance;\n  }\n  if (keys.d.isDown) {\n    ellipse.x += distance;\n  }\n  \n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 0, 800);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000183_v1", "prompt_id": "seed_000183", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个自动向下移动的圆形，相机跟随该对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Graphics#fillCircle\nSTEPS:\n1. 创建 Scene 配置，设置足够大的世界边界以便对象移动\n2. 在 create 中使用 Graphics 绘制一个圆形作为跟随目标\n3. 使用 Camera.startFollow 方法让相机跟随该圆形对象\n4. 在 update 中让圆形对象持续向下移动\n5. 设置相机边界以限制相机跟随范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\nlet moveSpeed = 2;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 设置世界边界，使其比屏幕大，以便对象可以移动\n  this.cameras.main.setBounds(0, 0, 800, 2000);\n  this.physics.world.setBounds(0, 0, 800, 2000);\n\n  // 创建一个 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(0, 0, 20); // 以中心点绘制半径为20的圆\n  \n  // 生成纹理以便后续使用\n  graphics.generateTexture('circleTexture', 40, 40);\n  graphics.destroy();\n\n  // 创建圆形精灵对象\n  circle = this.add.sprite(400, 100, 'circleTexture');\n  \n  // 绘制一些背景参考网格，便于观察相机跟随效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制横线\n  for (let y = 0; y <= 2000; y += 100) {\n    gridGraphics.moveTo(0, y);\n    gridGraphics.lineTo(800, y);\n  }\n  \n  // 绘制竖线\n  for (let x = 0; x <= 800; x += 100) {\n    gridGraphics.moveTo(x, 0);\n    gridGraphics.lineTo(x, 2000);\n  }\n  \n  gridGraphics.strokePath();\n\n  // 添加坐标文本标记\n  for (let y = 0; y <= 2000; y += 200) {\n    this.add.text(10, y + 10, `Y: ${y}`, {\n      fontSize: '16px',\n      color: '#ffffff'\n    });\n  }\n\n  // 设置相机跟随圆形对象\n  // 参数：目标对象, 是否立即跟随, lerp平滑度X, lerp平滑度Y\n  this.cameras.main.startFollow(circle, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量，使目标保持在屏幕特定位置\n  // this.cameras.main.setFollowOffset(0, -100); // 让圆形显示在屏幕上方一些\n\n  // 添加提示文本（固定在相机上）\n  const instructionText = this.add.text(10, 10, '相机跟随圆形向下移动', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  instructionText.setScrollFactor(0); // 固定在相机视图上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让圆形持续向下移动\n  circle.y += moveSpeed;\n\n  // 当圆形到达世界底部时，重置到顶部\n  if (circle.y > 1950) {\n    circle.y = 100;\n  }\n\n  // 显示当前圆形位置（固定在相机上的调试信息）\n  if (this.debugText) {\n    this.debugText.destroy();\n  }\n  \n  this.debugText = this.add.text(10, 550, `圆形位置: (${Math.round(circle.x)}, ${Math.round(circle.y)})`, {\n    fontSize: '16px',\n    color: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.debugText.setScrollFactor(0);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000431_v2", "prompt_id": "seed_000431", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：灰色敌人从上方以 300 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现躲避游戏，灰色敌人从上方以300速度落下，玩家左右移动躲避，碰到游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 创建玩家（绿色方块）和敌人（灰色方块）纹理\n3. 设置键盘输入监听（左右方向键）\n4. 创建敌人生成器，定时从顶部随机位置生成敌人\n5. 设置碰撞检测，碰到敌人时游戏结束\n6. 在 update 中处理玩家移动和敌人边界检测\n7. 添加分数系统和游戏状态显示\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（灰色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x808080, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每1秒）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n\n    // 重启提示文本\n    this.restartText = this.add.text(400, 370, 'Press SPACE to Restart', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n    this.restartText.setOrigin(0.5);\n    this.restartText.setVisible(false);\n\n    // 空格键重启\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n  }\n\n  update(time, delta) {\n    if (this.isGameOver) {\n      // 游戏结束后按空格重启\n      if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n        this.restartGame();\n      }\n      return;\n    }\n\n    // 玩家左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 检查敌人是否超出屏幕底部\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 620) {\n        // 敌人超出屏幕，增加分数并销毁\n        this.score += 10;\n        this.scoreText.setText('Score: ' + this.score);\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.isGameOver) return;\n\n    // 在顶部随机位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    // 设置敌人下落速度为 300\n    enemy.setVelocityY(300);\n    enemy.body.setSize(30, 30);\n  }\n\n  hitEnemy(player, enemy) {\n    // 碰到敌人，游戏结束\n    this.isGameOver = true;\n    \n    // 停止物理系统\n    this.physics.pause();\n    \n    // 停止敌人生成\n    this.enemyTimer.remove();\n    \n    // 玩家变红\n    player.setTint(0xff0000);\n    \n    // 显示游戏结束文本\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n  }\n\n  restartGame() {\n    // 重置游戏状态\n    this.score = 0;\n    this.isGameOver = false;\n    \n    // 重启场景\n    this.scene.restart();\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000870_v3", "prompt_id": "seed_000870", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9191666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 160 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建游戏配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 绘制椭圆并生成纹理\n3. 创建椭圆精灵对象并设置到画布中心\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态更新椭圆位置，应用速度 160 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 使用 Graphics 程序化生成椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40,30)，宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建椭圆精灵，放置在画布中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  \n  // 添加 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算实际移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新椭圆位置\n  if (keys.w.isDown) {\n    ellipse.y -= distance;\n  }\n  if (keys.s.isDown) {\n    ellipse.y += distance;\n  }\n  if (keys.a.isDown) {\n    ellipse.x -= distance;\n  }\n  if (keys.d.isDown) {\n    ellipse.x += distance;\n  }\n  \n  // 边界限制（可选，防止椭圆移出画布）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 40, 760);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 30, 570);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000599_v3", "prompt_id": "seed_000599", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 16 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为屏幕右下角（800-padding, 600-padding）\n4. 设置文本原点为右下角 (1, 1)，使文本从右下角对齐\n5. 设置字体大小为 16px，颜色为白色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右下角创建文本\n  // 位置设置为 (780, 580)，留出 20 像素的边距\n  const text = this.add.text(780, 580, 'Hello Phaser', {\n    fontSize: '16px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本原点为右下角 (1, 1)\n  // 这样文本会从右下角开始对齐，而不是从左上角\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000509_v3", "prompt_id": "seed_000509", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形移动，速度 120 像素/秒\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制矩形作为玩家\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新矩形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象\nlet player;\n// 按键对象\nlet keyW, keyA, keyS, keyD;\n// 移动速度（像素/秒）\nconst SPEED = 120;\n\nfunction preload() {\n  // 本游戏不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形（50x50 的红色矩形）\n  player = this.add.graphics();\n  player.fillStyle(0xff0000, 1);\n  player.fillRect(0, 0, 50, 50);\n  \n  // 设置初始位置（屏幕中心）\n  player.x = 400 - 25; // 减去矩形宽度的一半使其居中\n  player.y = 300 - 25; // 减去矩形高度的一半使其居中\n  \n  // 绑定 WASD 按键\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the red square', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧的移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    player.y -= moveDistance; // 向上移动\n  }\n  if (keyS.isDown) {\n    player.y += moveDistance; // 向下移动\n  }\n  if (keyA.isDown) {\n    player.x -= moveDistance; // 向左移动\n  }\n  if (keyD.isDown) {\n    player.x += moveDistance; // 向右移动\n  }\n  \n  // 限制在画布范围内（可选）\n  player.x = Phaser.Math.Clamp(player.x, 0, 750); // 800 - 50\n  player.y = Phaser.Math.Clamp(player.y, 0, 550); // 600 - 50\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000685_v2", "prompt_id": "seed_000685", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个星形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制星形以 200 像素/秒速度移动\nAPI: Graphics.fillStar, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象绘制星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新星形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nlet keys;\nconst SPEED = 200;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置星形样式\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xffa500, 1);\n  \n  // 绘制星形（五角星）\n  // 参数：x, y, points(角数), innerRadius(内半径), outerRadius(外半径)\n  graphics.fillStar(50, 50, 5, 20, 40);\n  graphics.strokeStar(50, 50, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中央\n  star = this.add.sprite(400, 300, 'starTexture');\n  \n  // 设置键盘输入 - 使用 WASD 键\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD keys to move the star', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间间隔（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 检测 W 键（向上）\n  if (keys.w.isDown) {\n    star.y -= distance;\n  }\n  \n  // 检测 S 键（向下）\n  if (keys.s.isDown) {\n    star.y += distance;\n  }\n  \n  // 检测 A 键（向左）\n  if (keys.a.isDown) {\n    star.x -= distance;\n  }\n  \n  // 检测 D 键（向右）\n  if (keys.d.isDown) {\n    star.x += distance;\n  }\n  \n  // 边界限制（可选）- 防止星形完全移出屏幕\n  star.x = Phaser.Math.Clamp(star.x, 0, 800);\n  star.y = Phaser.Math.Clamp(star.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000485_v2", "prompt_id": "seed_000485", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 橙色玩家在边界循环出现，移动速度160\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Graphics.fillRect, Physics.add.sprite\nSTEPS:\n1. 创建物理世界和橙色玩家精灵（使用Graphics生成纹理）\n2. 设置键盘输入监听（方向键控制移动）\n3. 在update中检测玩家位置，超出边界时从对侧重新出现\n4. 添加状态变量记录玩家穿越边界次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossBoundaryCount = 0; // 状态信号：记录穿越边界次数\n  }\n\n  preload() {\n    // 程序化生成橙色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8800, 1); // 橙色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 关闭世界边界碰撞，允许移出\n    \n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加WASD按键支持\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n    \n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.updateStatusText();\n    \n    // 添加边界线提示（可选）\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0xFFFFFF, 0.5);\n    borderGraphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n    \n    // 处理键盘输入\n    if (this.cursors.left.isDown || this.keys.a.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown || this.keys.d.isDown) {\n      this.player.setVelocityX(160);\n    }\n    \n    if (this.cursors.up.isDown || this.keys.w.isDown) {\n      this.player.setVelocityY(-160);\n    } else if (this.cursors.down.isDown || this.keys.s.isDown) {\n      this.player.setVelocityY(160);\n    }\n    \n    // 对角线移动时标准化速度\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(160);\n    }\n    \n    // 边界循环逻辑\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    let wrapped = false;\n    \n    // 左右边界\n    if (this.player.x > 800 + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      wrapped = true;\n    } else if (this.player.x < -playerWidth / 2) {\n      this.player.x = 800 + playerWidth / 2;\n      wrapped = true;\n    }\n    \n    // 上下边界\n    if (this.player.y > 600 + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      wrapped = true;\n    } else if (this.player.y < -playerHeight / 2) {\n      this.player.y = 600 + playerHeight / 2;\n      wrapped = true;\n    }\n    \n    // 更新穿越计数\n    if (wrapped) {\n      this.crossBoundaryCount++;\n      this.updateStatusText();\n    }\n  }\n  \n  updateStatusText() {\n    this.statusText.setText([\n      'Boundary Crosses: ' + this.crossBoundaryCount,\n      'Position: (' + Math.round(this.player.x) + ', ' + Math.round(this.player.y) + ')',\n      'Speed: 160',\n      'Controls: Arrow Keys or WASD'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000944_v2", "prompt_id": "seed_000944", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到48%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建缩放动画，scale 从 1 到 0.48\n4. 设置 yoyo: true 实现恢复效果，duration: 3000，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建矩形 Sprite\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setOrigin(0.5, 0.5);\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.48,\n    scaleY: 0.48,\n    duration: 3000,        // 3秒缩放到48%\n    yoyo: true,            // 动画结束后反向播放（恢复到原始大小）\n    loop: -1,              // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n\n  // 添加提示文本\n  const text = this.add.text(400, 50, 'Rectangle scaling to 48% in 3s (looping)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000192_v2", "prompt_id": "seed_000192", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个红色物体以 240 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 20个红色物体以240速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity\nSTEPS:\n1. 创建物理引擎配置，启用 arcade 物理系统\n2. 使用 Graphics 生成红色圆形纹理\n3. 创建物理组，添加 20 个红色物体\n4. 为每个物体设置随机速度（总速度为 240）和反弹属性\n5. 设置物体之间的碰撞检测\n6. 添加状态信号变量记录碰撞次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet collisionCount = 0;\nlet objectCount = 20;\nlet targetSpeed = 240;\n\nfunction preload() {\n  // 使用 Graphics 创建红色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('redBall', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理组\n  const redObjects = this.physics.add.group({\n    key: 'redBall',\n    repeat: objectCount - 1,\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n\n  // 为每个物体设置随机位置和速度\n  redObjects.children.iterate((object) => {\n    // 随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    object.setPosition(x, y);\n\n    // 设置圆形碰撞体\n    object.setCircle(16);\n\n    // 生成随机角度，然后根据目标速度计算 vx 和 vy\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const vx = Math.cos(angle) * targetSpeed;\n    const vy = Math.sin(angle) * targetSpeed;\n    \n    object.setVelocity(vx, vy);\n    \n    // 设置完全弹性碰撞\n    object.setBounce(1, 1);\n  });\n\n  // 设置物体之间的碰撞\n  this.physics.add.collider(redObjects, redObjects, onCollision, null, this);\n\n  // 显示状态信息\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n\n  // 存储到场景数据中以便访问\n  this.redObjects = redObjects;\n}\n\nfunction update() {\n  // 更新状态显示\n  this.statusText.setText([\n    `Objects: ${objectCount}`,\n    `Target Speed: ${targetSpeed}`,\n    `Collisions: ${collisionCount}`\n  ]);\n\n  // 确保物体速度保持在目标速度附近（可选，用于补偿浮点误差）\n  this.redObjects.children.iterate((object) => {\n    const body = object.body;\n    const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n    \n    // 如果速度偏差超过 5%，进行修正\n    if (Math.abs(currentSpeed - targetSpeed) > targetSpeed * 0.05) {\n      const angle = Math.atan2(body.velocity.y, body.velocity.x);\n      body.setVelocity(\n        Math.cos(angle) * targetSpeed,\n        Math.sin(angle) * targetSpeed\n      );\n    }\n  });\n}\n\nfunction onCollision(obj1, obj2) {\n  // 碰撞计数器\n  collisionCount++;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000823_v3", "prompt_id": "seed_000823", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左侧显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字位置在屏幕左侧，字体大小为 48 像素\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕左侧显示文字\n  // x: 50 表示距离左边 50 像素\n  // y: 300 表示垂直居中\n  const text = this.add.text(50, 300, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字垂直居中对齐\n  text.setOrigin(0, 0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000382_v1", "prompt_id": "seed_000382", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 12 个灰色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 12 个灰色可复用对象，离屏自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, GameObject.setActive, GameObject.setVisible, Group.get, Group.killAndHide\nSTEPS:\n1. 创建灰色方块纹理使用 Graphics.generateTexture\n2. 使用 Physics.Arcade.Group 创建对象池，设置 maxSize 为 12\n3. 在 create 中初始化对象池并定时发射对象\n4. 在 update 中检测对象是否离开屏幕，若离开则回收到对象池\n5. 添加状态信号：activeCount（活跃对象数）、recycledCount（已回收次数）\n[/PLAN]\n\n```javascript\nclass PoolScene extends Phaser.Scene {\n  constructor() {\n    super('PoolScene');\n    this.activeCount = 0;\n    this.recycledCount = 0;\n    this.totalSpawned = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建灰色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1);\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('grayBox', 40, 40);\n    graphics.destroy();\n\n    // 创建物理对象池\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'grayBox',\n      maxSize: 12,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 创建显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 定时发射对象（每 500ms 发射一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  spawnObject() {\n    // 从对象池获取一个对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 随机 Y 位置\n      const randomY = Phaser.Math.Between(50, 550);\n      \n      // 激活并设置位置\n      obj.setActive(true);\n      obj.setVisible(true);\n      obj.setPosition(-50, randomY);\n      \n      // 设置随机速度（向右移动）\n      const speed = Phaser.Math.Between(100, 300);\n      obj.setVelocityX(speed);\n      \n      this.totalSpawned++;\n      this.activeCount = this.objectPool.getChildren().filter(c => c.active).length;\n      this.updateStatus();\n    }\n  }\n\n  update() {\n    // 检查所有活跃对象\n    this.objectPool.getChildren().forEach((obj) => {\n      if (obj.active) {\n        // 检测是否离开屏幕右侧\n        if (obj.x > 850) {\n          this.recycleObject(obj);\n        }\n      }\n    });\n  }\n\n  recycleObject(obj) {\n    // 回收对象到池中\n    obj.setActive(false);\n    obj.setVisible(false);\n    obj.setVelocity(0, 0);\n    \n    this.recycledCount++;\n    this.activeCount = this.objectPool.getChildren().filter(c => c.active).length;\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const poolSize = this.objectPool.getLength();\n    this.statusText.setText([\n      `Pool Size: ${poolSize}/12`,\n      `Active Objects: ${this.activeCount}`,\n      `Total Spawned: ${this.totalSpawned}`,\n      `Recycled Count: ${this.recycledCount}`,\n      `Reuse Rate: ${this.totalSpawned > 0 ? ((this.recycledCount / this.totalSpawned) * 100).toFixed(1) : 0}%`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: PoolScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001090_v3", "prompt_id": "seed_001090", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让绿色圆形在 0.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色圆形，使用 Tween 动画在 0.5 秒内旋转 360 度并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制绿色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 设置动画持续时间为 500ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillCircle(50, 50, 40); // 在中心绘制半径为 40 的圆\n  \n  // 生成纹理\n  graphics.generateTexture('greenCircle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建使用该纹理的 Sprite\n  const circle = this.add.sprite(400, 300, 'greenCircle');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: circle,        // 动画目标对象\n    angle: 360,             // 旋转到 360 度\n    duration: 500,          // 持续时间 0.5 秒（500 毫秒）\n    ease: 'Linear',         // 线性缓动，保持匀速旋转\n    repeat: -1,             // -1 表示无限循环\n    onRepeat: function() {\n      // 每次循环重置角度，避免角度累积\n      circle.angle = 0;\n    }\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '绿色圆形旋转动画 (0.5秒/圈)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000415_v1", "prompt_id": "seed_000415", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 200 像素/秒的速度移动\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制六边形形状\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态更新六边形位置，速度为 200 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建六边形 Graphics 对象\n  hexagon = this.add.graphics();\n  hexagon.x = 400;\n  hexagon.y = 300;\n  \n  // 绘制六边形\n  drawHexagon(hexagon);\n  \n  // 设置 WASD 键盘输入\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离（速度 * 时间差 / 1000）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动六边形\n  if (keys.w.isDown) {\n    hexagon.y -= distance;\n  }\n  if (keys.s.isDown) {\n    hexagon.y += distance;\n  }\n  if (keys.a.isDown) {\n    hexagon.x -= distance;\n  }\n  if (keys.d.isDown) {\n    hexagon.x += distance;\n  }\n  \n  // 限制六边形在画布范围内\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\n// 辅助函数：绘制六边形\nfunction drawHexagon(graphics) {\n  const radius = 40;\n  const points = [];\n  \n  // 计算六边形的六个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillPoints(points, true);\n  \n  // 绘制六边形边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePoints(points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000387_v2", "prompt_id": "seed_000387", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在4秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 scale 属性从 1 到 0.48 再回到 1\n4. 设置 Tween 的 duration 为 2000ms（单程），yoyo 为 true，loop 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制三角形（等边三角形，中心在 (50, 50)）\n  const triangleSize = 80;\n  const centerX = 50;\n  const centerY = 50;\n  const height = triangleSize * Math.sqrt(3) / 2;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - height * 2/3); // 顶点\n  graphics.lineTo(centerX - triangleSize/2, centerY + height * 1/3); // 左下\n  graphics.lineTo(centerX + triangleSize/2, centerY + height * 1/3); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建使用该纹理的 Sprite，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.48, // 缩放到 48%\n    scaleY: 0.48,\n    duration: 2000, // 单程 2 秒\n    yoyo: true, // 来回播放（缩小后放大）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Triangle Scaling Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% → 48% → 100% (4 seconds loop)', {\n    fontSize: '16px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000381_v1", "prompt_id": "seed_000381", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为 200\n4. 设置边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制椭圆（中心点在 60, 40，宽度 120，高度 80）\n  graphics.fillEllipse(60, 40, 120, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（200 像素/秒，方向为右下方）\n  ellipse.setVelocity(200, 200);\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000081_v1", "prompt_id": "seed_000081", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 5 个金币，重力 600，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集5个金币，重力600，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建带物理引擎的场景配置（重力600）\n2. 使用Graphics绘制玩家、平台和金币的纹理\n3. 创建玩家精灵并添加物理属性，设置碰撞边界\n4. 创建静态平台组和金币组（5个金币）\n5. 添加键盘输入控制（左右移动+跳跃）\n6. 设置玩家与平台的碰撞检测\n7. 设置玩家与金币的重叠检测，收集时增加分数\n8. 创建文本显示当前分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.scoreText = null;\n    this.player = null;\n    this.platforms = null;\n    this.coins = null;\n    this.cursors = null;\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 创建静态平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 地面平台\n    this.platforms.create(400, 568, 'platform').setScale(4, 1).refreshBody();\n    \n    // 中间平台\n    this.platforms.create(600, 450, 'platform');\n    this.platforms.create(200, 400, 'platform');\n    this.platforms.create(400, 300, 'platform');\n    this.platforms.create(100, 200, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.2);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n\n    // 在不同平台上方放置5个金币\n    const coinPositions = [\n      { x: 200, y: 350 },\n      { x: 400, y: 250 },\n      { x: 600, y: 400 },\n      { x: 100, y: 150 },\n      { x: 700, y: 500 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.3);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 设置金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.scoreText.setDepth(10);\n  }\n\n  collectCoin(player, coin) {\n    // 移除金币\n    coin.disableBody(true, true);\n\n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      // 显示胜利信息\n      const winText = this.add.text(400, 300, 'You Win!', {\n        fontSize: '64px',\n        fill: '#00ff00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6\n      });\n      winText.setOrigin(0.5);\n    }\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000820_v3", "prompt_id": "seed_000820", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#moveTo, Phaser.GameObjects.Graphics#lineTo, Phaser.GameObjects.Graphics#closePath, Phaser.GameObjects.Graphics#fillPath, Phaser.GameObjects.Graphics#setRotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 方法中使用 Graphics 绘制一个六边形\n2. 计算六边形的六个顶点坐标（使用三角函数）\n3. 在 update 方法中根据 delta 时间累加旋转角度\n4. 每帧调用 setRotation 更新六边形的旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nlet currentRotation = 0;\nconst rotationSpeed = Phaser.Math.DegToRad(200); // 每秒 200 度转换为弧度\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  hexagon = this.add.graphics();\n  \n  // 设置六边形的中心位置\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 100;\n  \n  // 设置填充颜色\n  hexagon.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形\n  hexagon.beginPath();\n  \n  // 计算六边形的六个顶点（从顶部开始，逆时针）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每个角 60 度，从顶部开始\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    \n    if (i === 0) {\n      hexagon.moveTo(x, y);\n    } else {\n      hexagon.lineTo(x, y);\n    }\n  }\n  \n  hexagon.closePath();\n  hexagon.fillPath();\n  \n  // 设置六边形的位置（Graphics 的坐标系原点）\n  hexagon.x = centerX;\n  hexagon.y = centerY;\n  \n  // 添加提示文本\n  this.add.text(10, 10, '六边形旋转速度: 200°/秒', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 根据 delta 时间计算旋转增量（delta 单位是毫秒）\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  currentRotation += rotationDelta;\n  \n  // 更新六边形的旋转\n  hexagon.setRotation(currentRotation);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000210_v2", "prompt_id": "seed_000210", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕上显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕上显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸和 Scene\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 48 像素\n4. 将文本定位在屏幕中心位置\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕中心创建文本对象\n  const text = this.add.text(400, 300, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本的原点为中心，使其居中显示\n  text.setOrigin(0.5, 0.5);\n}\n\n// 创建并启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000263_v3", "prompt_id": "seed_000263", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 8 个蓝色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成8个蓝色可收集物体，玩家碰到后消失并加分显示score\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理系统配置，使用 arcade 物理引擎\n2. 使用 Graphics 生成玩家纹理（绿色方块）和收集物纹理（蓝色圆形）\n3. 创建物理精灵玩家，添加键盘控制\n4. 创建物理组，随机生成8个蓝色收集物\n5. 设置 overlap 检测，碰撞时销毁收集物并加分\n6. 创建文本显示分数，每次收集更新显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 生成纹理，无需外部资源\n}\n\nfunction create() {\n  // 生成玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 生成收集物纹理（蓝色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x0099ff, 1);\n  collectibleGraphics.fillCircle(12, 12, 12);\n  collectibleGraphics.generateTexture('collectible', 24, 24);\n  collectibleGraphics.destroy();\n\n  // 创建玩家精灵\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物物理组\n  collectibles = this.physics.add.group();\n\n  // 随机生成8个收集物\n  for (let i = 0; i < 8; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCircle(12); // 设置圆形碰撞体\n  }\n\n  // 设置玩家与收集物的重叠检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect Blue Circles', {\n    fontSize: '18px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  player.setVelocity(0);\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n\n  // 检查是否收集完所有物品\n  if (score >= 8 && collectibles.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - ALL COLLECTED!');\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.disableBody(true, true);\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 添加收集音效反馈（使用粒子效果替代）\n  const particles = this.add.particles(collectible.x, collectible.y, 'collectible', {\n    speed: { min: 50, max: 150 },\n    scale: { start: 0.5, end: 0 },\n    alpha: { start: 1, end: 0 },\n    lifespan: 300,\n    quantity: 8,\n    blendMode: 'ADD'\n  });\n\n  // 300ms后销毁粒子发射器\n  this.time.delayedCall(300, () => {\n    particles.destroy();\n  });\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001031_v1", "prompt_id": "seed_001031", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.88}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让白色星形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色星形并使用 Tween 动画实现 4 秒旋转一次的循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Image, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 绘制白色星形并生成纹理\n2. 在场景中心创建使用该纹理的 Image 对象\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 4000ms，rotation 从 0 到 2π，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = 50 + Math.cos(angle) * radius;\n    const y = 50 + Math.sin(angle) * radius;\n    starPoints.push(x, y);\n  }\n  \n  // 填充白色星形\n  graphics.fillStyle(0xffffff, 1);\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0], starPoints[1]);\n  for (let i = 2; i < starPoints.length; i += 2) {\n    graphics.lineTo(starPoints[i], starPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 在场景中心创建星形图像\n  const star = this.add.image(400, 300, 'star');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: star,\n    rotation: Math.PI * 2, // 旋转 360 度（2π 弧度）\n    duration: 4000, // 4 秒完成一次旋转\n    ease: 'Linear', // 线性缓动，保持匀速旋转\n    repeat: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000564_v2", "prompt_id": "seed_000564", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.Scene#update, Phaser.Math.DegToRad\nSTEPS:\n1. 创建 Graphics 对象绘制矩形\n2. 在 update 方法中根据 delta 时间增量更新旋转角度\n3. 使用 setRotation 方法应用旋转（每秒 240 度 = 4.189 弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet rectangle;\nlet currentRotation = 0;\nconst rotationSpeed = Phaser.Math.DegToRad(240); // 每秒 240 度转换为弧度\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  rectangle = this.add.graphics();\n  \n  // 设置矩形样式和位置\n  rectangle.fillStyle(0x00ff00, 1);\n  rectangle.fillRect(-50, -30, 100, 60); // 以中心点为原点绘制\n  \n  // 设置矩形位置到屏幕中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n  \n  // 添加参考点（可选，用于观察旋转）\n  const centerDot = this.add.graphics();\n  centerDot.fillStyle(0xff0000, 1);\n  centerDot.fillCircle(400, 300, 5);\n  \n  // 添加文字说明\n  this.add.text(10, 10, '矩形旋转速度: 240度/秒', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 根据 delta 时间增量更新旋转角度\n  // delta 单位是毫秒，需要转换为秒\n  currentRotation += rotationSpeed * (delta / 1000);\n  \n  // 应用旋转\n  rectangle.setRotation(currentRotation);\n  \n  // 可选：防止角度值无限增长，每 2π 重置一次\n  if (currentRotation >= Math.PI * 2) {\n    currentRotation -= Math.PI * 2;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000335_v2", "prompt_id": "seed_000335", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色矩形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色矩形在3秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Tweens.BaseTween.loop, Phaser.Tweens.BaseTween.yoyo\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add() 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 3000 毫秒（3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 80, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('redRect', 80, 60);\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'redRect');\n  \n  // 创建补间动画：从左到右移动，3秒往返循环\n  this.tweens.add({\n    targets: rect,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 3000,            // 持续时间 3 秒\n    yoyo: true,                // 启用往返效果（到达目标后反向播放）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动函数，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Red rectangle moving left-right in 3s loop', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000163_v2", "prompt_id": "seed_000163", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#setRotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个三角形\n2. 在 update 方法中根据 delta 时间累加旋转角度\n3. 使用 setRotation 方法更新三角形的旋转角度（将角度转换为弧度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet currentRotation = 0; // 当前旋转角度（弧度）\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象并绘制三角形\n  triangle = this.add.graphics();\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心在原点）\n  const size = 80;\n  const height = size * Math.sqrt(3) / 2;\n  triangle.fillTriangle(\n    0, -height * 2 / 3,           // 顶点\n    -size / 2, height / 3,        // 左下角\n    size / 2, height / 3          // 右下角\n  );\n  \n  // 将三角形放置在屏幕中心\n  triangle.x = 400;\n  triangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 160 度\n  const rotationSpeed = 160; // 度/秒\n  const rotationSpeedRadians = Phaser.Math.DegToRad(rotationSpeed); // 转换为弧度/秒\n  \n  // 根据 delta 时间（毫秒）计算本帧应旋转的角度\n  currentRotation += rotationSpeedRadians * (delta / 1000);\n  \n  // 应用旋转\n  triangle.setRotation(currentRotation);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000424_v2", "prompt_id": "seed_000424", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色椭圆在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色椭圆在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制白色椭圆并生成纹理\n2. 创建 Sprite 对象并应用椭圆纹理\n3. 使用 tweens 创建补间动画，设置从左到右移动\n4. 配置 yoyo 实现往返效果，loop(-1) 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制椭圆 (x, y, width, height)\n  graphics.fillEllipse(40, 30, 80, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n  \n  // 创建椭圆精灵，初始位置在左侧\n  const ellipse = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: ellipse,\n    x: 700, // 目标位置（右侧）\n    duration: 2000, // 持续时间 2 秒\n    yoyo: true, // 启用往返效果（到达目标后反向回到起点）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000777_v2", "prompt_id": "seed_000777", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的三角形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左上移动的三角形\nAPI: Graphics.fillTriangle, Camera.startFollow, Camera.setBounds, Physics.Arcade.Sprite\nSTEPS:\n1. 使用 Graphics 绘制三角形纹理\n2. 创建物理精灵对象并应用三角形纹理\n3. 设置精灵速度使其向左上方移动\n4. 配置相机跟随精灵并设置场景边界\n5. 在 update 中保持精灵持续移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet triangle;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个指向上方的三角形\n  graphics.fillTriangle(\n    0, -20,    // 顶点（上）\n    -15, 20,   // 左下角\n    15, 20     // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 30, 40);\n  graphics.destroy();\n  \n  // 创建物理精灵对象\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置三角形向左上方移动的速度\n  triangle.setVelocity(-150, -150);\n  \n  // 设置世界边界，让三角形可以在更大的空间移动\n  this.physics.world.setBounds(-2000, -2000, 4000, 4000);\n  triangle.setCollideWorldBounds(false);\n  \n  // 设置相机边界（与世界边界一致）\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 相机跟随三角形\n  this.cameras.main.startFollow(triangle, true, 0.1, 0.1);\n  \n  // 设置相机跟随偏移量为0，保持三角形居中\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加背景网格以便观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = -2000; x <= 2000; x += 100) {\n    gridGraphics.moveTo(x, -2000);\n    gridGraphics.lineTo(x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += 100) {\n    gridGraphics.moveTo(-2000, y);\n    gridGraphics.lineTo(2000, y);\n  }\n  gridGraphics.strokePath();\n  \n  // 添加文本提示\n  const text = this.add.text(10, 10, '三角形向左上方移动\\n相机跟随保持居中', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 三角形通过 setVelocity 自动移动，相机自动跟随\n  // 可以添加额外的逻辑，例如边界检测或方向改变\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000058_v1", "prompt_id": "seed_000058", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8587499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 600，移动速度 300，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色左右移动、跳跃，重力600，速度300，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 600\n2. 使用 Graphics 创建角色（矩形）和地面平台纹理\n3. 添加键盘输入监听（左右方向键和空格跳跃）\n4. 在 update 中处理移动逻辑（速度 300）和跳跃检测\n5. 设置角色与地面的碰撞检测，添加状态变量记录跳跃次数\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号：跳跃次数\n    this.isGrounded = false; // 是否在地面上\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色矩形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色矩形）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建平台纹理（棕色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8b4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建角色精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面和平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加底部地面\n    this.platforms.create(400, 575, 'ground');\n    \n    // 添加几个平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 350, 'platform');\n    this.platforms.create(400, 250, 'platform');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      // 碰撞时标记为在地面上\n      if (this.player.body.touching.down) {\n        this.isGrounded = true;\n      }\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.updateStatusText();\n\n    // 添加控制说明\n    this.add.text(16, 60, '← → 移动  空格/↑ 跳跃', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 重置地面状态（每帧检测）\n    const wasGrounded = this.isGrounded;\n    this.isGrounded = this.player.body.touching.down;\n\n    // 左右移动控制（速度 300）\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      // 停止时添加阻力效果\n      this.player.setVelocityX(this.player.body.velocity.x * 0.85);\n      \n      // 速度很小时直接停止\n      if (Math.abs(this.player.body.velocity.x) < 10) {\n        this.player.setVelocityX(0);\n      }\n    }\n\n    // 跳跃控制（空格键或上方向键）\n    const jumpPressed = Phaser.Input.Keyboard.JustDown(this.spaceKey) || \n                       Phaser.Input.Keyboard.JustDown(this.cursors.up);\n    \n    if (jumpPressed && this.isGrounded) {\n      this.player.setVelocityY(-500); // 跳跃力度\n      this.jumpCount++; // 增加跳跃计数\n      this.updateStatusText();\n    }\n\n    // 更新状态文本（显示速度信息）\n    if (time % 100 < delta) { // 每100ms更新一次，减少性能开销\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    const vx = Math.round(this.player.body.velocity.x);\n    const vy = Math.round(this.player.body.velocity.y);\n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount}\\n` +\n      `速度: X=${vx} Y=${vy}\\n` +\n      `状态: ${this.isGrounded ? '地面' : '空中'}`\n    );\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb', // 天空蓝背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 }, // 重力设置为 600\n      debug: false // 设置为 true 可查看物理边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000990_v2", "prompt_id": "seed_000990", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的粉色星形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Graphics.setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环5次，每次创建一个 Graphics 对象\n3. 使用 Graphics API 绘制五角星路径（通过计算五角星的顶点坐标）\n4. 填充粉色（0xFFC0CB）\n5. 使用 setRandomPosition 或手动随机设置每个星形的位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制5个随机位置的粉色星形\n  for (let i = 0; i < 5; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 绘制五角星\n    drawStar(graphics, 0, 0, 5, 32, 13);\n    \n    // 设置随机位置（考虑星形大小，避免超出边界）\n    const randomX = Phaser.Math.Between(50, 750);\n    const randomY = Phaser.Math.Between(50, 550);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n/**\n * 绘制五角星\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心点 x 坐标\n * @param {number} cy - 中心点 y 坐标\n * @param {number} spikes - 尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n\n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n\n  for (let i = 0; i < spikes; i++) {\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n\n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000248_v1", "prompt_id": "seed_000248", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让橙色矩形在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建橙色矩形的淡入淡出循环动画，每次循环0.5秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 创建淡入淡出动画，设置 yoyo 和 repeat 属性实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建橙色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillRect(0, 0, 200, 150);\n  \n  // 生成纹理\n  graphics.generateTexture('orangeRect', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已保存\n  \n  // 创建 Sprite 对象，位置居中\n  const rect = this.add.sprite(400, 300, 'orangeRect');\n  \n  // 设置初始透明度为 0（完全透明）\n  rect.setAlpha(0);\n  \n  // 创建淡入淡出 Tween 动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    alpha: 1,                // 目标透明度值（淡入到完全不透明）\n    duration: 500,           // 单次动画持续时间 500ms（0.5秒）\n    yoyo: true,              // 启用 yoyo 效果（淡入后自动淡出）\n    repeat: -1,              // 无限循环（-1 表示永久重复）\n    ease: 'Linear'           // 使用线性缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '橙色矩形淡入淡出循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000508_v3", "prompt_id": "seed_000508", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：20 个圆形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建收集游戏，玩家控制角色收集 20 个随机分布的圆形物品，收集完成后显示通关提示\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.GameObjects.Text\nSTEPS:\n1. 使用 Graphics 生成玩家和收集物的纹理\n2. 创建启用物理的玩家精灵，添加键盘控制\n3. 创建物理组，生成 20 个随机位置的收集物\n4. 添加碰撞检测，收集时移除物品并增加计数\n5. 当收集数达到 20 时显示通关文本\n[/PLAN]\n\n```javascript\nclass CollectionGame extends Phaser.Scene {\n  constructor() {\n    super('CollectionGame');\n    this.score = 0;\n    this.totalItems = 20;\n    this.gameCompleted = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建收集物纹理（黄色圆形）\n    const itemGraphics = this.add.graphics();\n    itemGraphics.fillStyle(0xffff00, 1);\n    itemGraphics.fillCircle(12, 12, 12);\n    itemGraphics.generateTexture('item', 24, 24);\n    itemGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setVelocityDrag(500);\n    this.player.setMaxVelocity(300);\n\n    // 创建收集物组\n    this.items = this.physics.add.group();\n    \n    // 随机生成 20 个收集物\n    for (let i = 0; i < this.totalItems; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const item = this.items.create(x, y, 'item');\n      item.setCircle(12);\n      item.body.setOffset(0, 0);\n    }\n\n    // 添加碰撞检测\n    this.physics.add.overlap(this.player, this.items, this.collectItem, null, this);\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, `收集: ${this.score}/${this.totalItems}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加提示文本\n    this.add.text(16, 50, '使用方向键移动', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  collectItem(player, item) {\n    // 移除收集物\n    item.destroy();\n    \n    // 增加分数\n    this.score++;\n    this.scoreText.setText(`收集: ${this.score}/${this.totalItems}`);\n\n    // 检查是否完成\n    if (this.score >= this.totalItems && !this.gameCompleted) {\n      this.gameCompleted = true;\n      this.winText.setVisible(true);\n      \n      // 停止玩家移动\n      this.player.setVelocity(0, 0);\n      \n      // 添加闪烁效果\n      this.tweens.add({\n        targets: this.winText,\n        alpha: { from: 1, to: 0.3 },\n        duration: 500,\n        yoyo: true,\n        repeat: -1\n      });\n    }\n  }\n\n  update(time, delta) {\n    if (this.gameCompleted) {\n      return; // 游戏完成后停止更新\n    }\n\n    // 键盘控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectionGame\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001007_v2", "prompt_id": "seed_001007", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色椭圆，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色椭圆，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建基础 Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充颜色为白色 (0xffffff)\n4. 使用 fillEllipse 在画布中央 (400, 300) 绘制椭圆，宽高均为 24 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  graphics.fillEllipse(400, 300, 24, 24);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000755_v2", "prompt_id": "seed_000755", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个黄色物体以 160 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个黄色物体以160速度随机移动，碰撞边界和彼此时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World.setBoundsCollision, Phaser.Physics.Arcade.Collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成黄色圆形纹理\n3. 创建物理组，添加 15 个黄色物体\n4. 为每个物体设置随机速度（总速度为 160）和反弹属性\n5. 设置世界边界碰撞和物体间碰撞检测\n6. 添加状态信号（活跃物体数量）用于验证\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet activeObjectsCount = 0;\nlet totalCollisions = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建黄色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillCircle(16, 16, 16); // 半径16的圆\n  graphics.generateTexture('yellowCircle', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界碰撞\n  this.physics.world.setBoundsCollision(true, true, true, true);\n  \n  // 创建物理组\n  const objects = this.physics.add.group({\n    key: 'yellowCircle',\n    repeat: 14, // 创建15个物体（1个初始 + 14个重复）\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n  \n  // 为每个物体设置随机位置和速度\n  objects.children.iterate((object) => {\n    // 随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    object.setPosition(x, y);\n    \n    // 随机方向，但保持速度为160\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const speed = 160;\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    object.setVelocity(vx, vy);\n    \n    // 确保物体是圆形碰撞体\n    object.setCircle(16);\n  });\n  \n  // 设置物体间的碰撞检测\n  this.physics.add.collider(objects, objects, onObjectCollision, null, this);\n  \n  // 更新状态信号\n  activeObjectsCount = objects.countActive(true);\n  \n  // 显示状态信息\n  this.statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 存储物理组引用\n  this.objects = objects;\n}\n\nfunction update(time, delta) {\n  // 更新状态显示\n  if (this.statusText) {\n    this.statusText.setText([\n      `Active Objects: ${activeObjectsCount}`,\n      `Total Collisions: ${totalCollisions}`,\n      `FPS: ${Math.round(this.game.loop.actualFps)}`\n    ]);\n  }\n  \n  // 验证所有物体的速度保持在160左右（允许小误差）\n  this.objects.children.iterate((object) => {\n    const velocity = object.body.velocity;\n    const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n    \n    // 如果速度偏差太大，重新归一化到160\n    if (Math.abs(currentSpeed - 160) > 5) {\n      const angle = Math.atan2(velocity.y, velocity.x);\n      object.setVelocity(Math.cos(angle) * 160, Math.sin(angle) * 160);\n    }\n  });\n}\n\n// 碰撞回调函数\nfunction onObjectCollision(obj1, obj2) {\n  totalCollisions++;\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000997_v2", "prompt_id": "seed_000997", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色方块在2秒内左右往返循环移动\nAPI: this.add.graphics(), graphics.generateTexture(), this.tweens.add(), yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制白色方块并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens.add() 创建补间动画，设置目标 x 坐标到右侧\n4. 配置 yoyo: true 实现往返效果，repeat: -1 实现无限循环\n5. 设置 duration: 2000 实现2秒移动时间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1); // 白色\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的方块\n  \n  // 生成纹理\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象，放置在左侧起始位置\n  const square = this.add.sprite(100, 300, 'whiteSquare');\n  \n  // 创建补间动画：从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: square,        // 动画目标对象\n    x: 700,                 // 目标 x 坐标（右侧位置）\n    duration: 2000,         // 持续时间 2 秒\n    yoyo: true,             // 启用往返效果（到达终点后反向播放）\n    repeat: -1,             // 无限循环（-1 表示永久重复）\n    ease: 'Linear'          // 线性缓动，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'White square moving left-right with yoyo loop', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000737_v3", "prompt_id": "seed_000737", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 240 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版，敌人速度随时间从240逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Time.TimerEvent\nSTEPS:\n1. 创建玩家精灵（使用Graphics绘制），添加键盘控制\n2. 创建敌人组，使用物理系统，初始速度240\n3. 定时生成敌人从顶部下落\n4. 检测玩家与敌人碰撞，碰撞后游戏结束\n5. 使用计时器记录生存时间并显示\n6. 每秒增加敌人速度，实现难度递增\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.player = null;\n    this.enemies = null;\n    this.cursors = null;\n    this.survivalTime = 0;\n    this.timeText = null;\n    this.gameOver = false;\n    this.enemySpeed = 240;\n    this.speedIncreaseTimer = null;\n    this.enemySpawnTimer = null;\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy',\n      maxSize: 20\n    });\n\n    // 设置键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建生存时间显示\n    this.timeText = this.add.text(16, 16, 'Time: 0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建速度显示\n    this.speedText = this.add.text(16, 50, 'Speed: 240', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每1秒）\n    this.enemySpawnTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 定时增加敌人速度（每2秒增加30）\n    this.speedIncreaseTimer = this.time.addEvent({\n      delay: 2000,\n      callback: this.increaseSpeed,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 游戏说明\n    this.add.text(400, 300, 'Use Arrow Keys to Move\\nDodge the Red Blocks!', {\n      fontSize: '28px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      align: 'center'\n    }).setOrigin(0.5).setAlpha(0.7);\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 更新生存时间\n    this.survivalTime += delta;\n    const seconds = Math.floor(this.survivalTime / 1000);\n    this.timeText.setText('Time: ' + seconds + 's');\n\n    // 玩家移动\n    const speed = 300;\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 随机X位置\n    const x = Phaser.Math.Between(30, 770);\n    \n    // 创建敌人\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  increaseSpeed() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 增加速度\n    this.enemySpeed += 30;\n    this.speedText.setText('Speed: ' + this.enemySpeed);\n\n    // 更新所有现有敌人的速度\n    this.enemies.children.entries.forEach((enemy) => {\n      enemy.setVelocityY(this.enemySpeed);\n    });\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) {\n      return;\n    }\n\n    this.gameOver = true;\n\n    // 停止所有计时器\n    if (this.enemySpawnTimer) {\n      this.enemySpawnTimer.remove();\n    }\n    if (this.speedIncreaseTimer) {\n      this.speedIncreaseTimer.remove();\n    }\n\n    // 停止所有物理对象\n    this.physics.pause();\n\n    // 玩家变红\n    this.player.setTint(0xff0000);\n\n    // 显示游戏结束信息\n    const finalTime = Math.floor(this.survivalTime / 1000);\n    const gameOverText = this.add.text(400, 300, \n      'GAME OVER!\\nSurvival Time: ' + finalTime + 's\\nFinal Speed: ' + this.enemySpeed + '\\n\\nClick to Restart', {\n      fontSize: '32px',\n      fill: '#ff0000',\n      fontFamily: 'Arial',\n      align: 'center',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 20 }\n    }).setOrigin(0.5);\n\n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000890_v1", "prompt_id": "seed_000890", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.875}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左上移动的六边形\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Camera.startFollow, Physics.Arcade.Sprite.setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置，用于控制六边形移动\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建物理精灵对象，应用六边形纹理\n4. 设置精灵向左上方移动的速度（负 x 和负 y）\n5. 使用 Camera.startFollow 让主相机跟随六边形\n6. 设置相机边界以展示跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让六边形有足够的移动空间\n  this.physics.world.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形（正六边形，半径40）\n  const hexagonPoints = [];\n  const radius = 40;\n  const centerX = 50;\n  const centerY = 50;\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶点开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    hexagonPoints.push({ x, y });\n  }\n  \n  graphics.fillPoints(hexagonPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy();\n  \n  // 创建物理精灵，初始位置在世界中心\n  hexagon = this.physics.add.sprite(0, 0, 'hexagon');\n  \n  // 设置六边形向左上方移动\n  // 负 x 表示向左，负 y 表示向上\n  hexagon.setVelocity(-150, -150);\n  \n  // 设置精灵的世界边界碰撞\n  hexagon.setCollideWorldBounds(false); // 不限制在世界边界内，让它自由移动\n  \n  // 获取主相机\n  const camera = this.cameras.main;\n  \n  // 设置相机边界为世界边界\n  camera.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 让相机跟随六边形\n  camera.startFollow(hexagon);\n  \n  // 可选：设置跟随平滑效果（lerp），值越小越平滑\n  // camera.setLerp(0.1, 0.1);\n  \n  // 添加一些参考网格线，帮助观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = -2000; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, -2000, x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += 100) {\n    gridGraphics.lineBetween(-2000, y, 2000, y);\n  }\n  \n  // 添加提示文本（固定在相机视图）\n  const text = this.add.text(10, 10, '六边形正在向左上方移动\\n相机自动跟随', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 可选：在控制台输出六边形位置，观察移动效果\n  // console.log('Hexagon position:', hexagon.x.toFixed(2), hexagon.y.toFixed(2));\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000718_v1", "prompt_id": "seed_000718", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色圆形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色圆形在0.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制青色圆形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(25, 25, 25); // 绘制半径为25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('cyanCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为纹理已生成\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'cyanCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧位置）\n    duration: 500,             // 持续时间 0.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '青色圆形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000563_v2", "prompt_id": "seed_000563", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字位置为左下角（x: 20, y: 600 - 20），使用 setOrigin(0, 1) 确保左下对齐\n4. 设置字体大小为 32 像素，颜色为白色\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 在屏幕左下显示文字\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕左下角创建文字\n  // x: 20 表示距离左边 20 像素\n  // y: 580 表示距离顶部 580 像素（600 - 20）\n  const text = this.add.text(20, 580, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置原点为左下角 (0, 1)\n  // 0 表示水平方向左对齐，1 表示垂直方向底部对齐\n  text.setOrigin(0, 1);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000152_v3", "prompt_id": "seed_000152", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, GameObject.rotation, Scene.time\nSTEPS:\n1. 创建 Graphics 对象绘制六边形\n2. 计算六边形的六个顶点坐标（使用三角函数）\n3. 在 update 方法中根据 delta 时间累加旋转角度\n4. 每秒旋转 160 度，即每毫秒旋转 160/1000 度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形\n  const centerX = 0;\n  const centerY = 0;\n  const radius = 80;\n  const sides = 6;\n  \n  graphics.beginPath();\n  \n  // 计算六边形的顶点\n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边使六边形更明显\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 将六边形放置在屏幕中心\n  graphics.setPosition(400, 300);\n  \n  // 保存引用以便在 update 中使用\n  hexagon = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 160 度\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 160; // 度/秒\n  const rotationRadians = Phaser.Math.DegToRad(rotationSpeed); // 转换为弧度/秒\n  \n  // 根据 delta 时间增加旋转角度\n  hexagon.rotation += rotationRadians * (delta / 1000);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000280_v2", "prompt_id": "seed_000280", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的灰色菱形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的灰色菱形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillPath, Phaser.Geom.Polygon, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环20次创建菱形\n3. 每个菱形使用 Graphics 对象绘制，通过 Polygon 定义菱形路径（4个顶点）\n4. 设置灰色填充样式（0x808080）\n5. 使用 setRandomPosition 将每个菱形随机放置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 菱形大小\n  const size = 80;\n  const halfSize = size / 2;\n  \n  // 创建20个随机位置的灰色菱形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置灰色填充\n    graphics.fillStyle(0x808080, 1);\n    \n    // 定义菱形的4个顶点（相对于中心点）\n    // 菱形：上、右、下、左四个顶点\n    const diamond = new Phaser.Geom.Polygon([\n      0, -halfSize,        // 上顶点\n      halfSize, 0,         // 右顶点\n      0, halfSize,         // 下顶点\n      -halfSize, 0         // 左顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(diamond.points, true);\n    \n    // 设置随机位置（考虑菱形大小，避免超出边界）\n    const randomX = Phaser.Math.Between(halfSize, config.width - halfSize);\n    const randomY = Phaser.Math.Between(halfSize, config.height - halfSize);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000585_v3", "prompt_id": "seed_000585", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色方块在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色方块在1秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色方块并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建绿色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('greenSquare', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建绿色方块精灵，初始位置在左侧\n  const square = this.add.sprite(100, 300, 'greenSquare');\n  \n  // 创建补间动画：从左移动到右，1秒完成\n  this.tweens.add({\n    targets: square,\n    x: 700,              // 目标 x 坐标（右侧位置）\n    duration: 1000,      // 持续时间 1 秒\n    ease: 'Linear',      // 线性缓动\n    yoyo: true,          // 启用往返效果（到达终点后反向回到起点）\n    loop: -1             // 无限循环（-1 表示永远循环）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '绿色方块左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000510_v2", "prompt_id": "seed_000510", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的椭圆在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的椭圆对象并保持居中\nAPI: Graphics.fillEllipse, Camera.startFollow, Sprite.setVelocityY, Physics.add.sprite\nSTEPS:\n1. 创建物理世界并设置较大的世界边界以容纳移动\n2. 使用 Graphics 绘制椭圆纹理并创建物理精灵\n3. 设置精灵向下移动的速度\n4. 配置相机跟随精灵并保持居中\n5. 在 update 中可选添加边界检测逻辑\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使其足够大以容纳移动\n  this.physics.world.setBounds(0, 0, 800, 3000);\n\n  // 使用 Graphics 创建椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(32, 32, 60, 40); // 中心点(32,32)，宽60，高40\n  graphics.generateTexture('ellipseTex', 64, 64);\n  graphics.destroy();\n\n  // 创建物理精灵\n  ellipse = this.physics.add.sprite(400, 100, 'ellipseTex');\n  \n  // 设置椭圆向下移动的速度\n  ellipse.setVelocityY(150);\n\n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n  \n  // 相机跟随椭圆对象，保持居中\n  this.cameras.main.startFollow(ellipse, true, 0.1, 0.1);\n  \n  // 添加一些参考线以便观察移动效果\n  const referenceGraphics = this.add.graphics();\n  referenceGraphics.lineStyle(2, 0xffffff, 0.3);\n  \n  // 绘制水平参考线\n  for (let y = 0; y < 3000; y += 100) {\n    referenceGraphics.lineBetween(0, y, 800, y);\n    \n    // 添加距离标记\n    const text = this.add.text(10, y + 10, `${y}px`, {\n      fontSize: '14px',\n      color: '#ffffff'\n    });\n    text.setScrollFactor(1); // 跟随世界移动\n  }\n\n  // 添加提示文本（固定在相机上）\n  const infoText = this.add.text(10, 10, '椭圆自动向下移动\\n相机跟随并保持居中', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机上不滚动\n}\n\nfunction update(time, delta) {\n  // 当椭圆到达世界底部时，重置到顶部\n  if (ellipse.y > 2950) {\n    ellipse.y = 50;\n  }\n\n  // 可选：显示当前位置信息\n  // console.log('Ellipse Y:', Math.floor(ellipse.y));\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000196_v2", "prompt_id": "seed_000196", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形，并添加一个标记线以便观察旋转\n2. 将 Graphics 添加到 Container 中以便控制旋转\n3. 在 update 方法中根据 delta 时间计算旋转角度增量\n4. 每帧更新 Container 的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个圆形（蓝色填充）\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的红色线，用于观察旋转\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, 0);\n  graphics.lineTo(80, 0);\n  graphics.strokePath();\n  \n  // 在圆的边缘添加一个小圆点作为额外的旋转标记\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(80, 0, 10);\n  \n  // 将 Graphics 添加到 Container 中以便控制旋转\n  this.rotatingCircle = this.add.container(400, 300, [graphics]);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形以每秒 200° 的速度旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  // 显示当前旋转角度的文字\n  this.angleText = this.add.text(400, 550, '当前角度: 0°', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 200 度\n  const rotationSpeed = 200; // 度/秒\n  \n  // 将度转换为弧度（Phaser 使用弧度）\n  const rotationSpeedRadians = Phaser.Math.DegToRad(rotationSpeed);\n  \n  // 根据 delta 时间（毫秒）计算本帧应该旋转的角度\n  const rotationIncrement = rotationSpeedRadians * (delta / 1000);\n  \n  // 更新容器的旋转角度\n  this.rotatingCircle.rotation += rotationIncrement;\n  \n  // 更新角度显示文字（转换回度数并取模 360）\n  const currentDegrees = Phaser.Math.RadToDeg(this.rotatingCircle.rotation) % 360;\n  this.angleText.setText(`当前角度: ${Math.floor(currentDegrees)}°`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000301_v3", "prompt_id": "seed_000301", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的白色星形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的白色星形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景大小为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象生成随机位置（x: 40-760, y: 40-560，确保星形完全显示）\n4. 使用 Graphics API 绘制五角星形状（通过计算5个外顶点和5个内顶点的坐标）\n5. 设置填充颜色为白色（0xffffff），填充路径完成绘制\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个随机位置的白色星形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置（确保星形完全显示在画布内）\n    const x = Phaser.Math.Between(40, 760);\n    const y = Phaser.Math.Between(40, 560);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为白色\n    graphics.fillStyle(0xffffff, 1);\n    \n    // 绘制星形\n    drawStar(graphics, x, y, 5, 40, 16);\n  }\n}\n\n/**\n * 绘制星形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心点 x 坐标\n * @param {number} cy - 中心点 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n\n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n\n  for (let i = 0; i < spikes; i++) {\n    // 外顶点\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n\n    // 内顶点\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n\n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000674_v3", "prompt_id": "seed_000674", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让白色三角形在 2 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色三角形，使用 Tween 实现 2 秒淡入淡出循环动画\nAPI: Graphics.fillTriangle, Tween.add, alpha, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tweens 对 alpha 属性进行动画，设置 yoyo 和 repeat:-1 实现循环淡入淡出\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点为 (50, 50)，边长约 80\n  graphics.fillTriangle(\n    50, 10,      // 顶点\n    10, 90,      // 左下\n    90, 90       // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形 Sprite 并居中显示\n  const triangle = this.add.sprite(400, 300, 'triangleTexture');\n  \n  // 创建淡入淡出动画\n  // duration: 2000ms (2秒完成一次完整的淡入淡出)\n  // yoyo: true (往返动画，淡入后淡出)\n  // repeat: -1 (无限循环)\n  this.tweens.add({\n    targets: triangle,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 1000,     // 单程 1 秒（淡入或淡出）\n    yoyo: true,         // 启用往返，淡出后再淡入\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut' // 使用正弦缓动使过渡更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000724_v1", "prompt_id": "seed_000724", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色三角形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色三角形在1秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillTriangle, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制蓝色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置从左到右的 x 坐标变化\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  \n  // 绘制三角形（三个顶点坐标）\n  // 中心点在 (25, 25)，三角形向上\n  graphics.fillTriangle(\n    25, 10,  // 顶点（上）\n    10, 40,  // 左下顶点\n    40, 40   // 右下顶点\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建使用该纹理的 Sprite\n  const triangle = this.add.sprite(100, 300, 'triangleTexture');\n  \n  // 创建补间动画：从左移动到右，1秒完成，往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 1000, // 持续时间 1 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后返回起点）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000463_v2", "prompt_id": "seed_000463", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个粉色敌人巡逻移动，在 360 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 20个粉色敌人左右巡逻，玩家接近时追踪，速度360\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.World#overlap, Phaser.Math.Distance.Between, Body#setVelocityX, Body#setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（粉色圆形）纹理\n3. 创建物理组管理 20 个敌人，设置初始随机位置和巡逻方向\n4. 在 update 中检测每个敌人与玩家的距离，近距离时追踪，远距离时巡逻\n5. 添加键盘控制玩家移动，碰撞检测，维护状态变量（存活敌人数、玩家生命值）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.aliveEnemies = 20; // 状态信号：存活敌人数\n    this.playerHealth = 100; // 状态信号：玩家生命值\n    this.detectionRange = 200; // 检测范围\n    this.patrolSpeed = 360; // 巡逻速度\n    this.chaseSpeed = 360; // 追踪速度\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0099ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（粉色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff69b4, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      key: 'enemy',\n      repeat: 19, // 创建20个敌人\n      setXY: { \n        x: 100, \n        y: 100, \n        stepX: 0, \n        stepY: 0 \n      }\n    });\n\n    // 初始化每个敌人的位置和巡逻数据\n    this.enemies.children.entries.forEach((enemy, index) => {\n      // 随机分布在场景中\n      enemy.x = Phaser.Math.Between(50, 750);\n      enemy.y = Phaser.Math.Between(50, 550);\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(1, 1);\n      \n      // 存储巡逻数据\n      enemy.patrolDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1; // 随机初始方向\n      enemy.patrolLeft = enemy.x - 100; // 巡逻左边界\n      enemy.patrolRight = enemy.x + 100; // 巡逻右边界\n      enemy.isChasing = false;\n      \n      // 设置初始速度\n      enemy.body.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n    });\n\n    // 添加碰撞检测\n    this.physics.add.overlap(this.player, this.enemies, this.handleCollision, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 300;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach((enemy) => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, \n        this.player.y, \n        enemy.x, \n        enemy.y\n      );\n\n      // 检测玩家是否在范围内\n      if (distance < this.detectionRange) {\n        // 追踪模式\n        enemy.isChasing = true;\n        \n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, \n          enemy.y, \n          this.player.x, \n          this.player.y\n        );\n        \n        // 设置追踪速度\n        enemy.body.setVelocity(\n          Math.cos(angle) * this.chaseSpeed,\n          Math.sin(angle) * this.chaseSpeed\n        );\n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          // 从追踪切换回巡逻，重置速度\n          enemy.isChasing = false;\n          enemy.body.setVelocity(0);\n          enemy.body.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n        \n        // 巡逻边界检测和反向\n        if (enemy.patrolDirection === 1 && enemy.x >= enemy.patrolRight) {\n          enemy.patrolDirection = -1;\n          enemy.body.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        } else if (enemy.patrolDirection === -1 && enemy.x <= enemy.patrolLeft) {\n          enemy.patrolDirection = 1;\n          enemy.body.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n      }\n    });\n\n    this.updateStatusText();\n  }\n\n  handleCollision(player, enemy) {\n    // 碰撞处理：敌人消失，玩家扣血\n    enemy.destroy();\n    this.aliveEnemies--;\n    this.playerHealth -= 10;\n\n    // 创建碰撞特效\n    const flash = this.add.circle(enemy.x, enemy.y, 20, 0xffffff, 0.8);\n    this.tweens.add({\n      targets: flash,\n      alpha: 0,\n      scale: 2,\n      duration: 300,\n      onComplete: () => flash.destroy()\n    });\n\n    // 检查游戏结束条件\n    if (this.aliveEnemies <= 0) {\n      this.showGameOver('Victory! All enemies defeated!');\n    } else if (this.playerHealth <= 0) {\n      this.showGameOver('Game Over! Player defeated!');\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Enemies: ${this.aliveEnemies} | Health: ${this.playerHealth}\\n` +\n      `Use Arrow Keys or WASD to move`\n    );\n  }\n\n  showGameOver(message) {\n    // 停止物理系统\n    this.physics.pause();\n    \n    // 显示游戏结束信息\n    const gameOverText = this.add.text(400, 300, message, {\n      fontSize: '32px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 }\n    });\n    gameOverText.setOrigin(0.5);\n\n    // 重启提示\n    const restartText = this.add.text(400, 350, 'Click to restart', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    restartText.setOrigin(0.5);\n\n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001131_v2", "prompt_id": "seed_001131", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text, displayWidth, displayHeight\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字样式（字体大小 32px，颜色等）\n4. 计算右下角位置：使用 displayWidth 和 displayHeight 获取文字实际显示尺寸\n5. 设置文字原点为右下角，并定位到屏幕右下角\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本任务无需预加载资源\n}\n\nfunction create() {\n  // 创建文字对象\n  const text = this.add.text(0, 0, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 设置文字原点为右下角 (1, 1)\n  text.setOrigin(1, 1);\n\n  // 将文字定位到屏幕右下角\n  // x 坐标为画布宽度，y 坐标为画布高度\n  text.setPosition(this.scale.width, this.scale.height);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000223_v1", "prompt_id": "seed_000223", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让红色三角形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色三角形并使用 Tween 动画实现 4 秒旋转一次的循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制红色三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 4000ms，rotation 从 0 到 2π\n4. 设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制一个等边三角形（中心在原点）\n  const triangleSize = 60;\n  const height = triangleSize * Math.sqrt(3) / 2;\n  \n  graphics.beginPath();\n  graphics.moveTo(0, -height * 2/3); // 顶点\n  graphics.lineTo(-triangleSize / 2, height * 1/3); // 左下\n  graphics.lineTo(triangleSize / 2, height * 1/3); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  const textureSize = 100;\n  graphics.generateTexture('triangle', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建 Sprite 并放置在屏幕中央\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: triangle,\n    rotation: Math.PI * 2, // 旋转 360 度（2π 弧度）\n    duration: 4000, // 4 秒\n    ease: 'Linear', // 线性缓动，保持匀速旋转\n    repeat: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000221_v3", "prompt_id": "seed_000221", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的六边形\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用六边形纹理\n3. 设置 Sprite 自动向上移动（通过 update 或物理系统）\n4. 使用 Camera.startFollow 让相机跟随六边形\n5. 设置相机边界和场景边界以展示跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet moveSpeed = 100; // 向上移动速度\n\nfunction preload() {\n  // 使用 Graphics 创建六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制六边形\n  const hexRadius = 30;\n  const hexPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = hexRadius + hexRadius * Math.cos(angle);\n    const y = hexRadius + hexRadius * Math.sin(angle);\n    hexPoints.push(x, y);\n  }\n  \n  // 填充六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillPoints(hexPoints, true);\n  \n  // 添加边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePoints(hexPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界（扩大场景范围以展示相机跟随）\n  this.physics.world.setBounds(0, 0, 800, 3000);\n  \n  // 创建六边形精灵，初始位置在场景底部\n  hexagon = this.physics.add.sprite(400, 2900, 'hexagon');\n  \n  // 设置六边形向上移动\n  hexagon.setVelocityY(-moveSpeed);\n  \n  // 设置相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n  \n  // 添加一些参考线帮助观察相机跟随效果\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制水平参考线（每100像素一条）\n  for (let y = 0; y < 3000; y += 100) {\n    graphics.lineBetween(0, y, 800, y);\n    \n    // 添加坐标文字\n    const text = this.add.text(10, y + 5, `Y: ${y}`, {\n      fontSize: '14px',\n      color: '#888888'\n    });\n    text.setScrollFactor(1); // 跟随世界移动\n  }\n  \n  // 添加中心十字线（固定在屏幕中心）\n  const centerGraphics = this.add.graphics();\n  centerGraphics.lineStyle(2, 0xff0000, 0.8);\n  centerGraphics.lineBetween(400, 0, 400, 600); // 垂直线\n  centerGraphics.lineBetween(0, 300, 800, 300); // 水平线\n  centerGraphics.setScrollFactor(0); // 固定在相机视图\n  \n  // 添加提示文字\n  const instructions = this.add.text(10, 10, \n    '相机跟随六边形\\n六边形自动向上移动', \n    {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    }\n  );\n  instructions.setScrollFactor(0); // 固定在相机视图\n  \n  // 显示六边形位置信息\n  this.positionText = this.add.text(10, 560, '', {\n    fontSize: '14px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 更新位置信息显示\n  if (hexagon && this.positionText) {\n    this.positionText.setText(\n      `六边形位置: (${Math.round(hexagon.x)}, ${Math.round(hexagon.y)})\\n` +\n      `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n    );\n  }\n  \n  // 当六边形到达顶部时，重置到底部\n  if (hexagon.y < 100) {\n    hexagon.setPosition(400, 2900);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000686_v2", "prompt_id": "seed_000686", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在1.5秒内缩放到16%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillCircle, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制一个圆形\n2. 创建 Tween 动画，设置 scale 从 1 到 0.16\n3. 配置 yoyo 为 true 实现恢复效果\n4. 设置 loop 为 -1 实现无限循环\n5. 设置 duration 为 1500ms（1.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制圆形（中心点在 0,0，半径 50）\n  graphics.fillCircle(0, 0, 50);\n  \n  // 将圆形放置在屏幕中央\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    scaleX: 0.16,               // X 轴缩放到 16%\n    scaleY: 0.16,               // Y 轴缩放到 16%\n    duration: 1500,             // 动画持续时间 1.5 秒\n    yoyo: true,                 // 启用悠悠球效果（动画结束后反向播放回到初始状态）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Circle scaling animation (1.5s to 16% and back, looping)', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000577_v3", "prompt_id": "seed_000577", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 20 个绿色物体以 360 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建20个绿色物体以360速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity\nSTEPS:\n1. 配置 Arcade 物理系统，设置世界边界反弹\n2. 使用 Graphics 创建绿色圆形纹理\n3. 创建物理组，添加20个物体并设置随机位置\n4. 为每个物体设置随机方向的360速度和完全反弹\n5. 设置物体间的碰撞检测，添加状态变量记录碰撞次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\n// 状态信号变量\nlet collisionCount = 0;\nlet activeObjects = 0;\nlet totalDistance = 0;\n\nfunction preload() {\n  // 创建绿色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('greenCircle', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界反弹\n  this.physics.world.setBoundsCollision(true, true, true, true);\n  \n  // 创建物理组\n  const objects = this.physics.add.group({\n    key: 'greenCircle',\n    repeat: 19, // 创建20个物体（0-19）\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n  \n  // 设置每个物体的随机位置和速度\n  objects.children.iterate((obj) => {\n    // 随机位置（避免太靠近边界）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    obj.setPosition(x, y);\n    \n    // 随机方向的360速度\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const vx = Math.cos(angle) * 360;\n    const vy = Math.sin(angle) * 360;\n    obj.setVelocity(vx, vy);\n    \n    // 设置圆形碰撞体\n    obj.setCircle(16);\n  });\n  \n  // 更新活跃物体数量\n  activeObjects = objects.getLength();\n  \n  // 设置物体间的碰撞\n  this.physics.add.collider(objects, objects, handleCollision, null, this);\n  \n  // 显示状态信息\n  const statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  // 存储引用供 update 使用\n  this.statusText = statusText;\n  this.objects = objects;\n  this.lastPositions = new Map();\n  \n  // 初始化位置记录\n  objects.children.iterate((obj) => {\n    this.lastPositions.set(obj, { x: obj.x, y: obj.y });\n  });\n}\n\nfunction handleCollision(obj1, obj2) {\n  // 记录碰撞次数\n  collisionCount++;\n}\n\nfunction update(time, delta) {\n  // 计算总移动距离\n  let frameDistance = 0;\n  this.objects.children.iterate((obj) => {\n    const lastPos = this.lastPositions.get(obj);\n    if (lastPos) {\n      const dx = obj.x - lastPos.x;\n      const dy = obj.y - lastPos.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      frameDistance += distance;\n      \n      // 更新位置记录\n      this.lastPositions.set(obj, { x: obj.x, y: obj.y });\n    }\n  });\n  \n  totalDistance += frameDistance;\n  \n  // 更新状态显示\n  this.statusText.setText([\n    `Active Objects: ${activeObjects}`,\n    `Collisions: ${collisionCount}`,\n    `Total Distance: ${Math.floor(totalDistance)}px`,\n    `Average Speed: 360px/s`\n  ]);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000873_v3", "prompt_id": "seed_000873", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置 800x600 画布\n2. 在 create 方法中创建 Graphics 对象\n3. 计算菱形的四个顶点坐标（中心点为画布中央，菱形对角线长度为 48 像素）\n4. 使用 Graphics API 绘制菱形路径并填充蓝色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 计算画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 菱形大小（对角线长度的一半）\n  const size = 24;\n  \n  // 绘制菱形路径\n  graphics.beginPath();\n  \n  // 上顶点\n  graphics.moveTo(centerX, centerY - size);\n  \n  // 右顶点\n  graphics.lineTo(centerX + size, centerY);\n  \n  // 下顶点\n  graphics.lineTo(centerX, centerY + size);\n  \n  // 左顶点\n  graphics.lineTo(centerX - size, centerY);\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000736_v3", "prompt_id": "seed_000736", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 300 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制椭圆形状\n2. 使用 addKey 监听 W/A/S/D 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建椭圆图形\n  ellipse = this.add.graphics();\n  ellipse.fillStyle(0x00ff00, 1);\n  ellipse.fillEllipse(0, 0, 60, 40); // 中心点为 (0,0)，宽60，高40\n  \n  // 设置初始位置到屏幕中心\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 添加 WASD 键监听\n  keys = {\n    w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    ellipse.y -= moveDistance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    ellipse.y += moveDistance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    ellipse.x -= moveDistance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    ellipse.x += moveDistance; // 向右移动\n  }\n  \n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 0, 800);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000507_v3", "prompt_id": "seed_000507", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色菱形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色菱形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Graphics 对象用于绘制形状\n2. 计算菱形的四个顶点坐标（中心点为画布中心，边长约 24 像素）\n3. 使用 fillStyle 设置黄色填充\n4. 使用 fillPath 或 fillPoints 绘制菱形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 定义菱形的四个顶点（菱形大小约为 24 像素）\n  // 菱形是一个正方形旋转 45 度，所以对角线长度为 24 像素\n  // 从中心到顶点的距离为 12 像素\n  const size = 12;\n  const points = [\n    centerX, centerY - size,  // 上顶点\n    centerX + size, centerY,  // 右顶点\n    centerX, centerY + size,  // 下顶点\n    centerX - size, centerY   // 左顶点\n  ];\n  \n  // 绘制菱形\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  graphics.lineTo(points[2], points[3]);\n  graphics.lineTo(points[4], points[5]);\n  graphics.lineTo(points[6], points[7]);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000700_v3", "prompt_id": "seed_000700", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个白色方块从左到右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个白色方块并生成纹理\n2. 创建一个精灵对象使用该纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 实现往返效果，loop 设置为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建白色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建白色方块精灵，初始位置在左侧\n  const square = this.add.sprite(100, 300, 'whiteSquare');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 1000,            // 动画持续时间 1 秒\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动函数，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'White square moving left-right with loop', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000407_v2", "prompt_id": "seed_000407", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个青色矩形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个青色矩形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用 fillStyle 设置青色填充色（0x00ffff）\n4. 使用 fillRect 在画布中央（400-12, 300-12）绘制 24x24 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为青色（Cyan）\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 计算矩形左上角位置（画布中央 - 矩形尺寸的一半）\n  const rectSize = 24;\n  const x = config.width / 2 - rectSize / 2;  // 400 - 12 = 388\n  const y = config.height / 2 - rectSize / 2; // 300 - 12 = 288\n  \n  // 在画布中央绘制 24x24 的青色矩形\n  graphics.fillRect(x, y, rectSize, rectSize);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000254_v1", "prompt_id": "seed_000254", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个绿色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 20 个绿色可复用对象，离屏自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, Group.get, Group.killAndHide, Physics.world.on\nSTEPS:\n1. 创建 Graphics 生成绿色方块纹理\n2. 使用 Physics.Arcade.Group 创建对象池，maxSize 设为 20\n3. 在 create 中初始化对象池，设置对象移动速度\n4. 监听 worldbounds 事件，对象离屏时自动回收\n5. 定时从对象池获取对象并激活，展示复用效果\n6. 添加 activeCount 和 totalSpawned 作为可验证状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.totalSpawned = 0;     // 总生成次数\n    this.recycledCount = 0;    // 回收次数\n  }\n\n  preload() {\n    // 创建绿色方块纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('greenBlock', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池，最大容量 20\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'greenBlock',\n      maxSize: 20,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        // 设置对象离开世界边界时触发事件\n        obj.body.setCollideWorldBounds(false);\n        obj.body.onWorldBounds = true;\n      }\n    });\n\n    // 监听世界边界事件，自动回收离屏对象\n    this.physics.world.on('worldbounds', (body) => {\n      const sprite = body.gameObject;\n      if (this.objectPool.contains(sprite)) {\n        this.recycleObject(sprite);\n      }\n    });\n\n    // 启用世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 定时生成对象（每 500ms）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示说明\n    this.add.text(10, 560, '对象池演示：绿色方块离屏后自动回收重用', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n\n    this.updateStatus();\n  }\n\n  spawnObject() {\n    // 从对象池获取对象（如果池满则复用）\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 随机位置和速度\n      const startX = Phaser.Math.Between(50, 750);\n      const startY = -32; // 从顶部生成\n      const velocityX = Phaser.Math.Between(-100, 100);\n      const velocityY = Phaser.Math.Between(100, 200);\n\n      // 激活对象\n      obj.setActive(true);\n      obj.setVisible(true);\n      obj.setPosition(startX, startY);\n      obj.body.setVelocity(velocityX, velocityY);\n      obj.body.setAngularVelocity(Phaser.Math.Between(-180, 180));\n\n      this.totalSpawned++;\n      this.activeCount = this.objectPool.countActive(true);\n      this.updateStatus();\n    }\n  }\n\n  recycleObject(obj) {\n    // 回收对象到池中\n    obj.setActive(false);\n    obj.setVisible(false);\n    obj.body.setVelocity(0, 0);\n    obj.body.setAngularVelocity(0);\n    \n    this.recycledCount++;\n    this.activeCount = this.objectPool.countActive(true);\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const poolSize = this.objectPool.getLength();\n    const activeObjs = this.objectPool.countActive(true);\n    const inactiveObjs = this.objectPool.countActive(false);\n    \n    this.statusText.setText([\n      `对象池状态:`,\n      `总容量: ${poolSize} / 20`,\n      `活跃对象: ${activeObjs}`,\n      `空闲对象: ${inactiveObjs}`,\n      `总生成次数: ${this.totalSpawned}`,\n      `回收次数: ${this.recycledCount}`,\n      `复用率: ${this.totalSpawned > 0 ? Math.floor((this.recycledCount / this.totalSpawned) * 100) : 0}%`\n    ]);\n  }\n\n  update(time, delta) {\n    // 可选：手动检查离屏对象（worldbounds 事件已处理）\n    this.objectPool.children.iterate((obj) => {\n      if (obj.active) {\n        // 检查是否完全离开屏幕\n        if (obj.y > 650 || obj.x < -50 || obj.x > 850) {\n          this.recycleObject(obj);\n        }\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000816_v3", "prompt_id": "seed_000816", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8587499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 240 像素/秒的速度移动\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中使用 Graphics 绘制六边形并生成纹理\n3. 创建 Sprite 并应用六边形纹理\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态更新六边形位置（速度 240 像素/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算六边形的顶点坐标（半径 30 像素）\n  const radius = 30;\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = radius + Math.cos(angle) * radius;\n    const y = radius + Math.sin(angle) * radius;\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillPoints(points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', radius * 2, radius * 2);\n  graphics.destroy();\n  \n  // 创建六边形精灵并放置在屏幕中央\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置键盘输入（WASD）\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文字\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新六边形位置\n  if (keys.W.isDown) {\n    hexagon.y -= distance;\n  }\n  if (keys.S.isDown) {\n    hexagon.y += distance;\n  }\n  if (keys.A.isDown) {\n    hexagon.x -= distance;\n  }\n  if (keys.D.isDown) {\n    hexagon.x += distance;\n  }\n  \n  // 限制六边形在屏幕范围内\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000318_v2", "prompt_id": "seed_000318", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建菱形精灵对象并设置初始位置\n3. 在 create 中使用 camera.startFollow 让相机跟随菱形\n4. 在 update 中让菱形持续向下移动\n5. 设置世界边界确保有足够的移动空间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst moveSpeed = 100; // 每秒向下移动的像素数\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制菱形（四个三角形组成）\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，让菱形有足够的移动空间\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n  this.physics.world.setBounds(0, 0, 800, 3000);\n  \n  // 创建菱形精灵\n  diamond = this.add.sprite(400, 100, 'diamond');\n  \n  // 设置相机跟随菱形\n  // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n  // roundPixels: 是否四舍五入像素，避免抖动\n  // lerpX/lerpY: 平滑跟随系数 (0-1)，1 表示立即跟随，小于 1 表示有延迟效果\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 添加提示文字（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随菱形\\n菱形持续向下移动', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视口，不随世界移动\n  \n  // 添加位置信息文字\n  this.positionText = this.add.text(10, 80, '', {\n    fontSize: '16px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n  \n  // 添加背景网格以便观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制水平线\n  for (let y = 0; y <= 3000; y += 100) {\n    gridGraphics.lineBetween(0, y, 800, y);\n  }\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 800; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 3000);\n  }\n}\n\nfunction update(time, delta) {\n  // 让菱形向下移动\n  // delta 是毫秒数，转换为秒\n  diamond.y += (moveSpeed * delta) / 1000;\n  \n  // 更新位置信息\n  this.positionText.setText(\n    `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})\\n` +\n    `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n  );\n  \n  // 当菱形到达底部时，重置到顶部\n  if (diamond.y > 2900) {\n    diamond.y = 100;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000232_v3", "prompt_id": "seed_000232", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8920833333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个方块\n2. 将方块定位到画布中心\n3. 在 update 方法中根据 delta 时间累加旋转角度（120度/秒 = 2.094弧度/秒）\n4. 每帧更新方块的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nconst rotationSpeed = Phaser.Math.DegToRad(120); // 每秒 120 度转换为弧度\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制方块\n  square = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  square.fillStyle(0xff0000, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在原点\n  // 使用 -50, -50 作为起点，使旋转中心在方块中心\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 将方块定位到画布中心\n  square.setPosition(400, 300);\n  \n  // 添加提示文本\n  const text = this.add.text(10, 10, '方块旋转速度: 120度/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间差\n  // 将 delta 转换为秒并乘以旋转速度\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  square.rotation += rotationDelta;\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000135_v2", "prompt_id": "seed_000135", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 tweens.add 创建一个 alpha 从 0 到 1 的补间动画，持续时间 1000ms\n4. 设置补间动画为循环播放（yoyo: true 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circleTexture', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n  \n  // 创建使用该纹理的 Sprite，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circleTexture');\n  circle.alpha = 0; // 初始设置为完全透明\n  \n  // 创建循环的透明度补间动画\n  this.tweens.add({\n    targets: circle,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 1000, // 持续时间 1 秒\n    yoyo: true, // 来回播放（透明 -> 不透明 -> 透明）\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000136_v2", "prompt_id": "seed_000136", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现紫色圆形左右往返循环补间动画\nAPI: this.add.graphics, graphics.fillCircle, graphics.generateTexture, this.add.sprite, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建精灵对象放置在左侧起始位置\n3. 使用 tweens.add 创建 x 轴移动补间，设置 duration 为 2500ms\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 在 (25, 25) 位置绘制半径为 25 的圆\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建精灵对象，放置在屏幕左侧\n  const circle = this.add.sprite(100, 300, 'purpleCircle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 移动到右侧位置\n    duration: 2500, // 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加文字说明\n  this.add.text(10, 10, 'Purple Circle Tween Animation', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000794_v3", "prompt_id": "seed_000794", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个青色矩形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个青色的 24x24 像素矩形\nAPI: Phaser.Game, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用 fillStyle 设置青色（0x00ffff）\n4. 计算画布中心坐标（400, 300），绘制 24x24 矩形，使其中心对齐\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为青色（Cyan）\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 计算矩形左上角坐标，使其中心位于画布中央\n  // 画布中心：(400, 300)\n  // 矩形大小：24x24\n  // 左上角坐标：(400 - 12, 300 - 12) = (388, 288)\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectSize = 24;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000254_v3", "prompt_id": "seed_000254", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现紫色血条 UI，显示 10 格生命值，空格键扣血，血量为 0 时显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建游戏场景，初始化生命值为 10\n2. 使用 Graphics 绘制 10 个紫色方块作为血条\n3. 监听空格键输入，每次按下扣除 1 点生命值\n4. 更新血条显示，隐藏对应的血格\n5. 当生命值为 0 时显示 Game Over 文本\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 当前生命值\n    this.maxHealth = 10; // 最大生命值\n    this.healthBars = []; // 存储血条方块\n    this.gameOver = false; // 游戏结束标志\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, 'Press SPACE to take damage', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold',\n      stroke: '#000000',\n      strokeThickness: 6\n    }).setOrigin(0.5).setVisible(false);\n\n    // 创建生命值显示文本\n    this.healthText = this.add.text(400, 450, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5);\n  }\n\n  createHealthBar() {\n    const barWidth = 50; // 每格血条的宽度\n    const barHeight = 30; // 血条高度\n    const barGap = 10; // 血条间隔\n    const startX = 400 - (this.maxHealth * (barWidth + barGap) - barGap) / 2; // 居中起始位置\n    const startY = 200;\n\n    // 创建 10 个紫色血条方块\n    for (let i = 0; i < this.maxHealth; i++) {\n      const graphics = this.add.graphics();\n      \n      // 绘制外边框（深紫色）\n      graphics.fillStyle(0x4a0e4e, 1);\n      graphics.fillRect(\n        startX + i * (barWidth + barGap) - 2,\n        startY - 2,\n        barWidth + 4,\n        barHeight + 4\n      );\n\n      // 绘制内部填充（亮紫色）\n      graphics.fillStyle(0x9b59b6, 1);\n      graphics.fillRect(\n        startX + i * (barWidth + barGap),\n        startY,\n        barWidth,\n        barHeight\n      );\n\n      // 添加高光效果\n      graphics.fillStyle(0xc39bd3, 0.5);\n      graphics.fillRect(\n        startX + i * (barWidth + barGap),\n        startY,\n        barWidth,\n        barHeight / 3\n      );\n\n      this.healthBars.push(graphics);\n    }\n  }\n\n  update() {\n    // 检测空格键按下（使用 justDown 避免连续触发）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && !this.gameOver) {\n      this.takeDamage();\n    }\n  }\n\n  takeDamage() {\n    if (this.health > 0) {\n      this.health--;\n      \n      // 隐藏对应的血条\n      this.healthBars[this.health].setVisible(false);\n      \n      // 更新生命值文本\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n\n      // 添加屏幕震动效果\n      this.cameras.main.shake(200, 0.005);\n\n      // 检查是否游戏结束\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  triggerGameOver() {\n    this.gameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n\n    // 添加闪烁动画\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 添加缩放动画\n    this.tweens.add({\n      targets: this.gameOverText,\n      scale: 1.2,\n      duration: 1000,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 更改生命值文本颜色\n    this.healthText.setColor('#ff0000');\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: HealthBarScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n\n// 导出状态变量用于验证\ngame.getHealth = function() {\n  const scene = game.scene.scenes[0];\n  return scene ? scene.health : 0;\n};\n\ngame.isGameOver = function() {\n  const scene = game.scene.scenes[0];\n  return scene ? scene.gameOver : false;\n};\n```", "metadata": {"id": "distill_seed_000994_v2", "prompt_id": "seed_000994", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 5 个青色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理5个青色可复用对象，离屏后自动回收并重用\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, Group.get, Group.killAndHide, Physics.world.on\nSTEPS:\n1. 创建青色方块纹理（使用Graphics生成）\n2. 使用Physics.Arcade.Group创建对象池，设置maxSize为5\n3. 在create中初始化对象池并设置对象属性\n4. 实现定时发射机制，从对象池中获取对象\n5. 在update中检测对象是否离屏，离屏则回收到对象池\n6. 添加状态变量追踪活跃对象数和回收次数\n[/PLAN]\n\n```javascript\nclass PoolScene extends Phaser.Scene {\n  constructor() {\n    super('PoolScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.recycledCount = 0;    // 已回收次数\n    this.spawnedCount = 0;     // 已生成次数\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建青色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('cyanBlock', 40, 40);\n    graphics.destroy();\n\n    // 创建物理对象池\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'cyanBlock',\n      maxSize: 5,  // 最大5个对象\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        // 对象创建时的回调\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 定时发射对象（每1秒发射一个）\n    this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 创建状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, '青色方块会从左侧发射，离开屏幕后自动回收到对象池', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n\n    this.updateStatusText();\n  }\n\n  spawnObject() {\n    // 从对象池获取对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 设置对象位置和速度\n      obj.setPosition(50, Phaser.Math.Between(100, 500));\n      obj.setVelocity(Phaser.Math.Between(100, 200), 0);\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      this.spawnedCount++;\n      this.activeCount = this.objectPool.countActive(true);\n      this.updateStatusText();\n    }\n  }\n\n  update() {\n    // 检查所有活跃对象\n    this.objectPool.children.entries.forEach((obj) => {\n      if (obj.active) {\n        // 如果对象离开屏幕右侧，回收它\n        if (obj.x > this.cameras.main.width + 50) {\n          this.recycleObject(obj);\n        }\n      }\n    });\n  }\n\n  recycleObject(obj) {\n    // 回收对象到对象池\n    obj.setActive(false);\n    obj.setVisible(false);\n    obj.setVelocity(0, 0);\n    \n    this.recycledCount++;\n    this.activeCount = this.objectPool.countActive(true);\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    const poolSize = this.objectPool.getLength();\n    const activeObjs = this.objectPool.countActive(true);\n    const inactiveObjs = this.objectPool.countActive(false);\n    \n    this.statusText.setText([\n      `对象池大小: ${poolSize}/5`,\n      `活跃对象: ${activeObjs}`,\n      `空闲对象: ${inactiveObjs}`,\n      `已生成次数: ${this.spawnedCount}`,\n      `已回收次数: ${this.recycledCount}`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: PoolScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001122_v3", "prompt_id": "seed_001122", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色星形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现红色星形从左到右往返循环的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 tweens 创建从左到右的移动动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  \n  // 绘制五角星\n  const starPoints = [];\n  const outerRadius = 40;\n  const innerRadius = 16;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = Math.cos(angle) * radius + outerRadius;\n    const y = Math.sin(angle) * radius + outerRadius;\n    starPoints.push(x, y);\n  }\n  \n  graphics.fillPoints(starPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('star', outerRadius * 2, outerRadius * 2);\n  graphics.destroy();\n  \n  // 创建星形精灵\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 1500, // 1.5秒\n    yoyo: true, // 启用往返\n    repeat: -1, // 无限循环 (-1 表示永久重复)\n    ease: 'Linear' // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '红色星形往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000178_v2", "prompt_id": "seed_000178", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色六边形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建绿色六边形在1.5秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.Easing.Bounce\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建 Y 轴弹跳动画，设置持续时间 1.5 秒\n4. 配置 ease 为 Bounce.easeOut 实现弹跳效果\n5. 设置 yoyo 和 repeat: -1 实现循环弹跳\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形（中心点为 50, 50，半径为 40）\n  const hexRadius = 40;\n  const centerX = 50;\n  const centerY = 50;\n  const sides = 6;\n  \n  graphics.beginPath();\n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 六边形每个角 60 度\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy();\n  \n  // 创建 Sprite 对象\n  const hexagon = this.add.sprite(400, 200, 'hexagon');\n  \n  // 创建弹跳动画 Tween\n  this.tweens.add({\n    targets: hexagon,\n    y: 400, // 从 200 弹跳到 400\n    duration: 1500, // 1.5 秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 来回弹跳\n    repeat: -1, // 无限循环\n    hold: 0 // 到达目标点后立即返回\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Green Hexagon Bouncing Animation', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000541_v3", "prompt_id": "seed_000541", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让青色椭圆在 2 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色椭圆的缩放循环动画，2秒完成一次缩放\nAPI: Graphics.fillEllipse, Scene.add.graphics, Scene.tweens.add, Tween, loop\nSTEPS:\n1. 使用 Graphics 绘制青色椭圆\n2. 创建 Tween 动画控制椭圆的 scale 属性\n3. 设置动画持续时间为 2000ms，配置循环播放\n4. 设置 yoyo 效果实现缩放往返\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建青色椭圆\n  const ellipse = this.add.graphics();\n  ellipse.fillStyle(0x00ffff, 1); // 青色\n  ellipse.fillEllipse(0, 0, 150, 100); // 在原点绘制椭圆\n  \n  // 设置椭圆位置到屏幕中心\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: ellipse,\n    scaleX: 1.5,  // 水平缩放到 1.5 倍\n    scaleY: 1.5,  // 垂直缩放到 1.5 倍\n    duration: 2000, // 持续时间 2 秒\n    yoyo: true,     // 往返效果（放大后再缩小）\n    loop: -1,       // 无限循环 (-1 表示永久循环)\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000390_v2", "prompt_id": "seed_000390", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 3 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形并使用 Tween 动画在 3 秒内缩放到 64%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个星形纹理\n2. 创建 Sprite 对象并应用星形纹理\n3. 使用 tweens.add 创建缩放动画，从 1 缩放到 0.64\n4. 设置 yoyo 为 true 实现往返效果，duration 为 3000ms\n5. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置星形样式\n  graphics.fillStyle(0xffff00, 1); // 黄色填充\n  graphics.lineStyle(3, 0xffa500, 1); // 橙色描边\n  \n  // 绘制星形（中心点在 64, 64）\n  const points = [];\n  const outerRadius = 60;\n  const innerRadius = 25;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = 64 + Math.cos(angle) * radius;\n    const y = 64 + Math.sin(angle) * radius;\n    points.push(x, y);\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 128, 128);\n  graphics.destroy();\n  \n  // 创建星形精灵并居中\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: star,\n    scaleX: 0.64,  // 缩放到 64%\n    scaleY: 0.64,\n    duration: 3000,  // 3 秒\n    yoyo: true,  // 往返动画（缩小后再放大）\n    repeat: -1,  // 无限循环\n    ease: 'Sine.easeInOut'  // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Star Scaling Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% → 64% → 100% (3s loop)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000770_v1", "prompt_id": "seed_000770", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的青色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的青色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中使用循环创建12个 Graphics 对象\n3. 每个 Graphics 对象绘制青色（0x00ffff）填充的三角形，边长16像素\n4. 使用 setRandomPosition 方法将三角形随机分布在场景中\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建12个青色三角形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为青色\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 绘制等边三角形，大小为16像素\n    // 计算三角形的三个顶点坐标（以中心为原点）\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    // 三个顶点：顶部、左下、右下\n    const x1 = 0;\n    const y1 = -height * 2 / 3; // 顶点\n    const x2 = -size / 2;\n    const y2 = height / 3; // 左下\n    const x3 = size / 2;\n    const y3 = height / 3; // 右下\n    \n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 随机设置位置（留出边距避免三角形超出画布）\n    const margin = 20;\n    graphics.setRandomPosition(\n      margin,\n      margin,\n      config.width - margin * 2,\n      config.height - margin * 2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000185_v1", "prompt_id": "seed_000185", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色圆形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色圆形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置目标 x 坐标到右侧\n4. 配置动画时长为 2.5 秒，启用 yoyo 实现往返，loop 设为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径为25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'purpleCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 目标 x 坐标（右侧位置）\n    duration: 2500, // 2.5 秒 = 2500 毫秒\n    yoyo: true, // 启用往返效果\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性运动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000794_v1", "prompt_id": "seed_000794", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的灰色菱形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的灰色菱形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环20次\n3. 每次循环创建一个 Graphics 对象，使用灰色填充\n4. 使用 beginPath、moveTo、lineTo 绘制菱形路径（4个顶点）\n5. 使用 Phaser.Math.Between 生成随机坐标位置\n6. 调用 fillPath 完成菱形绘制\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 菱形大小为 80 像素\n  const size = 80;\n  const halfSize = size / 2;\n  \n  // 绘制 20 个随机位置的灰色菱形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置（确保菱形完全在画布内）\n    const x = Phaser.Math.Between(halfSize, 800 - halfSize);\n    const y = Phaser.Math.Between(halfSize, 600 - halfSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置灰色填充 (0x808080)\n    graphics.fillStyle(0x808080, 1);\n    \n    // 绘制菱形路径\n    graphics.beginPath();\n    \n    // 菱形的四个顶点（上、右、下、左）\n    graphics.moveTo(x, y - halfSize);           // 上顶点\n    graphics.lineTo(x + halfSize, y);           // 右顶点\n    graphics.lineTo(x, y + halfSize);           // 下顶点\n    graphics.lineTo(x - halfSize, y);           // 左顶点\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000585_v1", "prompt_id": "seed_000585", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 0.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建使用该纹理的 Image 对象，初始透明度设为 0\n3. 使用 Tween 系统实现 alpha 从 0 到 1 的循环动画，持续 0.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 50;\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建六边形图像对象，放置在屏幕中心\n  const hexagon = this.add.image(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexagon.setAlpha(0);\n  \n  // 创建循环 Tween 动画：从透明到不透明\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1,              // 目标透明度为 1（完全不透明）\n    duration: 500,         // 持续时间 0.5 秒（500 毫秒）\n    yoyo: true,            // 反向播放（从 1 回到 0）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000029_v1", "prompt_id": "seed_000029", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#lineTo, Phaser.GameObjects.Graphics#closePath, Phaser.GameObjects.Graphics#fillPath, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制六边形路径\n2. 在 create 中初始化六边形，设置其位置在屏幕中心\n3. 在 update 中根据 delta 时间增量计算旋转角度（300度/秒 = 300 * delta / 1000）\n4. 使用 setRotation 方法更新六边形的旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制六边形\n  hexagon = this.add.graphics();\n  \n  // 设置填充颜色\n  hexagon.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形\n  const radius = 80; // 六边形半径\n  const sides = 6;\n  \n  hexagon.beginPath();\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2; // 从顶部开始\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      hexagon.moveTo(x, y);\n    } else {\n      hexagon.lineTo(x, y);\n    }\n  }\n  \n  hexagon.closePath();\n  hexagon.fillPath();\n  \n  // 设置六边形位置到屏幕中心\n  hexagon.x = config.width / 2;\n  hexagon.y = config.height / 2;\n  \n  // 初始化旋转角度\n  hexagon.rotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 300 度\n  // 将角度转换为弧度：300度 = 300 * (Math.PI / 180) 弧度\n  const rotationSpeed = 300 * (Math.PI / 180); // 弧度/秒\n  \n  // 根据 delta 时间（毫秒）计算本帧应旋转的角度\n  hexagon.rotation += rotationSpeed * (delta / 1000);\n  \n  // 可选：防止角度无限增长，保持在 0-2π 范围内\n  if (hexagon.rotation > Math.PI * 2) {\n    hexagon.rotation -= Math.PI * 2;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000706_v3", "prompt_id": "seed_000706", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的粉色六边形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的粉色六边形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象设置随机位置（x: 0-800, y: 0-600）\n4. 使用 Graphics API 绘制正六边形（粉色填充，半径12像素，大小24像素）\n5. 通过三角函数计算六边形的6个顶点坐标并连线\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个随机位置的粉色六边形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置随机位置（留出边距，避免六边形被裁剪）\n    const x = Phaser.Math.Between(30, 770);\n    const y = Phaser.Math.Between(30, 570);\n    graphics.setPosition(x, y);\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xff69b4, 1); // 粉色 (HotPink)\n    \n    // 绘制正六边形\n    // 半径为 12 像素（直径 24 像素）\n    const radius = 12;\n    const sides = 6;\n    \n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    for (let j = 0; j < sides; j++) {\n      // 从顶部开始绘制（-90度偏移）\n      const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;\n      const px = Math.cos(angle) * radius;\n      const py = Math.sin(angle) * radius;\n      \n      if (j === 0) {\n        graphics.moveTo(px, py);\n      } else {\n        graphics.lineTo(px, py);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000072_v2", "prompt_id": "seed_000072", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建带有 Arcade 物理引擎的游戏配置\n2. 使用 Graphics 绘制黄色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 启用世界边界碰撞和精灵反弹属性\n5. 设置画布边界与精灵的碰撞检测\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillEllipse(50, 40, 100, 80); // 椭圆中心偏移，宽100高80\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 100, 80);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 200);\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 启用椭圆的反弹属性\n  ellipse.setBounce(1, 1); // x和y方向都完全反弹\n  \n  // 设置椭圆与世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 确保世界边界碰撞已启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000079_v2", "prompt_id": "seed_000079", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的青色圆形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的青色圆形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环绘制3个圆形，每次随机生成 x、y 坐标\n4. 使用 fillStyle 设置青色 (0x00ffff)，fillCircle 绘制半径为 40 的圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充样式 (cyan)\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制3个随机位置的圆形\n  for (let i = 0; i < 3; i++) {\n    // 生成随机位置，确保圆形完全在画布内\n    // 圆形半径为 40 (直径 80)，所以坐标范围是 [40, width-40] 和 [40, height-40]\n    const x = Phaser.Math.Between(40, 760);\n    const y = Phaser.Math.Between(40, 560);\n    const radius = 40; // 大小为 80 像素，半径为 40\n    \n    // 绘制圆形\n    graphics.fillCircle(x, y, radius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000689_v1", "prompt_id": "seed_000689", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Arcade 物理精灵并应用三角形纹理\n3. 设置精灵速度为160，启用世界边界碰撞和反弹\n4. 配置物理系统使精灵在碰到边界时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心对齐）\n  // 三角形顶点：上(0, -20), 左下(-20, 20), 右下(20, 20)\n  graphics.fillTriangle(\n    0, -20,    // 顶点\n    -20, 20,   // 左下\n    20, 20     // 右下\n  );\n  \n  // 生成纹理（40x40 像素，包含三角形）\n  graphics.generateTexture('triangle', 40, 40);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（160像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 160;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 160;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 确保三角形不会因为摩擦而减速\n  triangle.body.setDamping(false);\n  \n  // 可选：让三角形旋转以增强视觉效果\n  triangle.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000060_v1", "prompt_id": "seed_000060", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字位置在左下角（x=10, y=height-40），字体大小 32px\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕左下角显示文字\n  // x: 10 像素距离左边\n  // y: 600 - 40 = 560 像素，距离底部约 40 像素\n  const text = this.add.text(10, 560, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字原点为左下角，使定位更精确\n  text.setOrigin(0, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000152_v1", "prompt_id": "seed_000152", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色菱形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色菱形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon\nSTEPS:\n1. 创建 Graphics 对象用于绘制形状\n2. 计算画布中心点坐标（400, 300）\n3. 定义菱形的四个顶点坐标（上、右、下、左）\n4. 使用 Graphics 的 fillStyle 设置蓝色填充\n5. 使用 beginPath、moveTo、lineTo 绘制菱形路径并填充\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 获取画布中心坐标\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 菱形大小（从中心到顶点的距离）\n  const size = 40; // 总大小约 80 像素\n  \n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 定义菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充菱形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000169_v2", "prompt_id": "seed_000169", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色圆形以300速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setCollideWorldBounds, setBounce\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制绿色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为300\n4. 设置世界边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 不需要重力\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);  // 绿色\n  graphics.fillCircle(25, 25, 25);  // 在中心绘制半径为25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();  // 销毁 graphics 对象，节省资源\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'circle');\n  \n  // 设置初始速度（随机方向，速度为300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 300);\n  circle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置与世界边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000557_v1", "prompt_id": "seed_000557", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的方块在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个自动向左移动的方块，相机跟随并保持居中\nAPI: Graphics, Camera.startFollow, Sprite, Physics\nSTEPS:\n1. 使用 Graphics 创建方块纹理\n2. 创建物理精灵对象并设置向左移动的速度\n3. 使用 Camera.startFollow 让相机跟随方块\n4. 添加背景参考物以观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBox', 50, 50);\n  graphics.destroy();\n\n  // 创建背景网格作为参考\n  createGrid.call(this);\n\n  // 创建玩家方块（使用物理系统）\n  this.player = this.physics.add.sprite(400, 300, 'playerBox');\n  \n  // 设置方块向左移动\n  this.player.setVelocityX(-150);\n\n  // 设置世界边界（扩大世界以便方块移动）\n  this.physics.world.setBounds(-2000, 0, 4000, 600);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(-2000, 0, 4000, 600);\n  \n  // 让相机跟随方块\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随红色方块\\n方块向左移动', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图上\n}\n\nfunction update(time, delta) {\n  // 可选：如果方块移动到世界边界，可以反向移动\n  if (this.player.x <= -1950) {\n    this.player.setVelocityX(150); // 向右移动\n  } else if (this.player.x >= 1950) {\n    this.player.setVelocityX(-150); // 向左移动\n  }\n}\n\n// 创建网格背景以便观察相机移动\nfunction createGrid() {\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制垂直线\n  for (let x = -2000; x <= 2000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 600);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 600; y += 100) {\n    gridGraphics.lineBetween(-2000, y, 2000, y);\n  }\n  \n  // 添加位置标记\n  for (let x = -2000; x <= 2000; x += 200) {\n    const marker = this.add.text(x, 300, x.toString(), {\n      fontSize: '14px',\n      fill: '#00ff00'\n    });\n    marker.setOrigin(0.5);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000214_v1", "prompt_id": "seed_000214", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9292857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 10 个紫色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成10个紫色可收集物体，玩家碰到后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（绿色方块）和可收集物体（紫色圆形）的纹理\n3. 创建物理组存储10个可收集物体，随机分布在场景中\n4. 添加文本显示分数，初始化 score 变量\n5. 使用键盘控制玩家移动（方向键）\n6. 使用 overlap 检测玩家与收集物体的碰撞，触发收集逻辑\n7. 收集时销毁物体、增加分数、更新文本显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建可收集物体纹理（紫色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x9b59b6, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setVelocityDrag(500);\n\n  // 创建可收集物体组\n  collectibles = this.physics.add.group();\n\n  // 生成10个可收集物体，随机分布\n  for (let i = 0; i < 10; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCircle(15); // 设置圆形碰撞体\n  }\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect Purple Items', {\n    fontSize: '18px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 重置玩家速度\n  player.setVelocity(0);\n\n  // 键盘控制\n  const speed = 300;\n  \n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物体\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 检查是否收集完所有物体\n  if (collectibles.countActive(true) === 0) {\n    // 显示胜利文本\n    this.add.text(400, 300, 'You Win!\\nScore: ' + score, {\n      fontSize: '48px',\n      fill: '#ffff00',\n      fontFamily: 'Arial',\n      align: 'center'\n    }).setOrigin(0.5);\n\n    // 停止玩家移动\n    player.setVelocity(0);\n    cursors = null;\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000860_v2", "prompt_id": "seed_000860", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色三角形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色三角形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置白色填充\n5. 使用 fillTriangle 绘制等边三角形，三个顶点围绕中心点，边长约32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 三角形的大小（从中心到顶点的距离）\n  const size = 32;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size * 0.67; // 向上偏移\n  \n  // 顶点2：左下\n  const x2 = centerX - size * 0.87; // sin(60°) ≈ 0.87\n  const y2 = centerY + size * 0.33;\n  \n  // 顶点3：右下\n  const x3 = centerX + size * 0.87;\n  const y3 = centerY + size * 0.33;\n  \n  // 设置填充颜色为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加描边使三角形更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000791_v3", "prompt_id": "seed_000791", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色圆形以300速度移动并在画布边界反弹\nAPI: Graphics.fillCircle, GameObject.setVelocity, Physics.World.setBoundsCollision, Physics.arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制白色圆形并生成纹理\n3. 创建物理精灵并设置随机初始速度(速度大小为300)\n4. 启用世界边界碰撞和精灵反弹属性\n5. 在 update 中保持速度恒定为300\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ball;\nconst SPEED = 300;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(20, 20, 20); // 圆心在(20,20)，半径20\n  graphics.generateTexture('ballTexture', 40, 40);\n  graphics.destroy();\n\n  // 创建物理精灵\n  ball = this.physics.add.sprite(400, 300, 'ballTexture');\n  \n  // 设置随机初始速度方向，但保持速度大小为300\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const vx = Math.cos(angle) * SPEED;\n  const vy = Math.sin(angle) * SPEED;\n  ball.setVelocity(vx, vy);\n  \n  // 设置碰撞边界\n  ball.setCollideWorldBounds(true);\n  ball.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 启用世界边界\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为300\n  const velocity = ball.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed !== 0) {\n    const scale = SPEED / currentSpeed;\n    ball.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000253_v2", "prompt_id": "seed_000253", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 4 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在4秒内缩放到24%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 实现缩放动画：从 scale 1 到 0.24，yoyo 模式使其自动恢复\n4. 设置 loop: -1 实现无限循环，duration: 2000 使单程2秒（往返共4秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 100）\n  graphics.beginPath();\n  graphics.moveTo(64, 14);      // 上顶点\n  graphics.lineTo(114, 64);     // 右顶点\n  graphics.lineTo(64, 114);     // 下顶点\n  graphics.lineTo(14, 64);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.24,           // 缩放到 24%\n    scaleY: 0.24,           // 缩放到 24%\n    duration: 2000,         // 单程 2 秒\n    yoyo: true,             // 启用 yoyo 模式，自动恢复到原始大小\n    loop: -1,               // 无限循环\n    ease: 'Linear'          // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '菱形缩放动画：4秒循环（2秒缩小 + 2秒恢复）', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000400_v2", "prompt_id": "seed_000400", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：10 个矩形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色收集 10 个随机分布的矩形，收集完成后显示通关提示\nAPI: Phaser.Physics.Arcade.Factory#sprite, Phaser.Physics.Arcade.World#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard#createCursorKeys\nSTEPS:\n1. 创建玩家角色（使用 Graphics 绘制圆形）\n2. 随机生成 10 个可收集的矩形物体（使用 Graphics 绘制）\n3. 添加键盘控制（方向键控制玩家移动）\n4. 使用物理碰撞检测玩家与矩形的重叠\n5. 收集矩形时销毁物体并增加计数\n6. 当收集数量达到 10 时显示\"恭喜通关\"文本\n7. 添加分数显示文本实时更新收集进度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet winText;\nlet collectedCount = 0;\nconst TOTAL_COLLECTIBLES = 10;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色圆形）\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.fillCircle(20, 20, 20);\n  graphics.generateTexture('player', 40, 40);\n  graphics.destroy();\n\n  // 创建收集物纹理（黄色矩形）\n  const collectGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  collectGraphics.fillStyle(0xffeb3b, 1);\n  collectGraphics.fillRect(0, 0, 30, 30);\n  collectGraphics.generateTexture('collectible', 30, 30);\n  collectGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setVelocityMax(200);\n  player.setDrag(500);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成 10 个收集物\n  for (let i = 0; i < TOTAL_COLLECTIBLES; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    \n    // 添加轻微的浮动效果\n    this.tweens.add({\n      targets: collectible,\n      y: collectible.y + 10,\n      duration: 1000 + Math.random() * 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, `收集进度: ${collectedCount}/${TOTAL_COLLECTIBLES}`, {\n    fontSize: '24px',\n    fontFamily: 'Arial',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  scoreText.setDepth(10);\n\n  // 创建通关文本（初始隐藏）\n  winText = this.add.text(400, 300, '🎉 恭喜通关！🎉', {\n    fontSize: '48px',\n    fontFamily: 'Arial',\n    color: '#ffeb3b',\n    stroke: '#000000',\n    strokeThickness: 6\n  });\n  winText.setOrigin(0.5);\n  winText.setVisible(false);\n  winText.setDepth(20);\n\n  // 添加操作提示\n  this.add.text(16, 560, '使用方向键移动', {\n    fontSize: '18px',\n    fontFamily: 'Arial',\n    color: '#aaaaaa'\n  });\n}\n\nfunction update() {\n  // 玩家移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-200);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(200);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-200);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(200);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n  \n  // 增加收集计数\n  collectedCount++;\n  \n  // 更新分数文本\n  scoreText.setText(`收集进度: ${collectedCount}/${TOTAL_COLLECTIBLES}`);\n  \n  // 播放收集音效（使用屏幕闪烁代替）\n  this.cameras.main.flash(100, 255, 235, 59, false);\n  \n  // 检查是否通关\n  if (collectedCount >= TOTAL_COLLECTIBLES) {\n    winGame.call(this);\n  }\n}\n\nfunction winGame() {\n  // 显示通关文本\n  winText.setVisible(true);\n  \n  // 添加通关动画\n  this.tweens.add({\n    targets: winText,\n    scale: { from: 0.5, to: 1.2 },\n    duration: 500,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 停止玩家移动\n  player.setVelocity(0, 0);\n  \n  // 禁用键盘控制\n  cursors.left.enabled = false;\n  cursors.right.enabled = false;\n  cursors.up.enabled = false;\n  cursors.down.enabled = false;\n  \n  // 添加庆祝粒子效果（使用简单的图形模拟）\n  for (let i = 0; i < 50; i++) {\n    const particle = this.add.graphics();\n    const color = Phaser.Display.Color.RandomRGB();\n    particle.fillStyle(color.color, 1);\n    particle.fillCircle(0, 0, 5);\n    particle.setPosition(400, 300);\n    \n    this.tweens.add({\n      targets: particle,\n      x: Phaser.Math.Between(100, 700),\n      y: Phaser.Math.Between(100, 500),\n      alpha: 0,\n      duration: 1500,\n      ease: 'Cubic.easeOut',\n      onComplete: () => particle.destroy()\n    });\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000815_v2", "prompt_id": "seed_000815", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8891666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个绿色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理20个绿色可复用对象，离屏自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建 Graphics 生成绿色方块纹理\n2. 使用 Physics.Arcade.Group 创建对象池，设置 maxSize 为 20\n3. 在 create 中初始化对象池，配置回收条件\n4. 定时从对象池获取对象并设置速度\n5. 在 update 中检测对象是否离屏，离屏则回收到池中\n6. 添加状态变量跟踪活跃对象数和回收次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.recycledCount = 0;    // 累计回收次数\n    this.spawnedCount = 0;     // 累计生成次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 1. 程序化生成绿色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('greenBlock', 32, 32);\n    graphics.destroy();\n\n    // 2. 创建物理对象池，最大容量 20\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'greenBlock',\n      maxSize: 20,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 3. 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 4. 定时生成对象（每 500ms 生成一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 5. 添加说明文本\n    this.add.text(10, 560, '绿色方块会从上方生成并向下移动，离屏后自动回收', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n  }\n\n  spawnObject() {\n    // 从对象池获取或创建对象\n    let obj = this.objectPool.get();\n    \n    if (obj) {\n      // 随机 X 位置，从屏幕上方生成\n      const x = Phaser.Math.Between(50, 750);\n      const y = -50;\n      \n      // 激活并显示对象\n      obj.setActive(true);\n      obj.setVisible(true);\n      obj.setPosition(x, y);\n      \n      // 设置随机向下速度\n      const velocityY = Phaser.Math.Between(100, 300);\n      obj.setVelocity(0, velocityY);\n      \n      this.spawnedCount++;\n      this.activeCount = this.objectPool.countActive(true);\n    }\n  }\n\n  update(time, delta) {\n    // 检查所有活跃对象\n    this.objectPool.children.entries.forEach((obj) => {\n      if (obj.active) {\n        // 检测是否离开屏幕底部\n        if (obj.y > 650) {\n          // 回收对象\n          obj.setActive(false);\n          obj.setVisible(false);\n          obj.setVelocity(0, 0);\n          \n          this.recycledCount++;\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.activeCount = this.objectPool.countActive(true);\n    const poolSize = this.objectPool.getLength();\n    \n    this.statusText.setText([\n      `对象池容量: ${poolSize}/20`,\n      `活跃对象: ${this.activeCount}`,\n      `累计生成: ${this.spawnedCount}`,\n      `累计回收: ${this.recycledCount}`,\n      `复用率: ${this.spawnedCount > 0 ? ((this.recycledCount / this.spawnedCount) * 100).toFixed(1) : 0}%`\n    ]);\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000816_v2", "prompt_id": "seed_000816", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右上显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右上角显示 \"Hello Phaser\" 文字，字体大小 48px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本位置在右上角，使用 setOrigin(1, 0) 实现右对齐\n4. 配置文本样式：fontSize 为 48px\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在右上角创建文本\n  // 位置：x = 画布宽度 - 20（右边距），y = 20（上边距）\n  const text = this.add.text(\n    this.cameras.main.width - 20,  // x 坐标：右侧边距 20px\n    20,                              // y 坐标：上边距 20px\n    'Hello Phaser',                  // 文本内容\n    {\n      fontSize: '48px',              // 字体大小 48px\n      color: '#ffffff',              // 白色文字\n      fontFamily: 'Arial'            // 字体\n    }\n  );\n  \n  // 设置原点为右上角 (1, 0)，使文本从右上角定位\n  text.setOrigin(1, 0);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000040_v3", "prompt_id": "seed_000040", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色星形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现红色星形从左到右往返循环的补间动画\nAPI: this.add.graphics, graphics.generateTexture, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制红色星形并生成纹理\n2. 创建 Sprite 对象使用生成的星形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n5. 设置动画时长为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形\n  const graphics = this.add.graphics();\n  \n  // 设置红色填充\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制星形（5个顶点）\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 20;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右移动，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5秒\n    yoyo: true, // 往返效果\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000008_v3", "prompt_id": "seed_000008", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色六边形在 2.5 秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 创建 Sprite 对象并设置初始位置（左侧）\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右，duration 为 2500ms\n4. 设置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制六边形\n  const hexagonRadius = 40;\n  const centerX = 50;\n  const centerY = 50;\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexagonRadius * Math.cos(angle);\n    const y = centerY + hexagonRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象\n  const hexagonSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，然后往返循环\n  this.tweens.add({\n    targets: hexagonSprite,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5 秒\n    ease: 'Linear',\n    yoyo: true, // 往返效果\n    loop: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000293_v2", "prompt_id": "seed_000293", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色六边形通过补间动画在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add.tween\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 创建使用该纹理的 Sprite 对象并定位到左侧\n3. 使用 add.tween 创建补间动画，设置 x 坐标从左到右移动，duration 2500ms\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制六边形\n  const hexagonRadius = 40;\n  const hexagonCenterX = 50;\n  const hexagonCenterY = 50;\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶部开始，每60度一个顶点\n    const x = hexagonCenterX + hexagonRadius * Math.cos(angle);\n    const y = hexagonCenterY + hexagonRadius * Math.sin(angle);\n    points.push(x, y);\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillPoints(points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexagon = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，然后往返循环\n  this.tweens.add({\n    targets: hexagon,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性移动\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000293_v1", "prompt_id": "seed_000293", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让绿色矩形在 1.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色矩形，使用 Tween 动画在 1.5 秒内旋转 360 度并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#rotation\nSTEPS:\n1. 使用 Graphics 绘制绿色矩形并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 rotation 属性从 0 到 2π\n4. 设置动画时长为 1500ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('greenRect', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象并设置到屏幕中心\n  const rect = this.add.sprite(400, 300, 'greenRect');\n  \n  // 设置旋转中心点为矩形中心\n  rect.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    rotation: Math.PI * 2,   // 旋转到 360 度（2π 弧度）\n    duration: 1500,          // 动画时长 1.5 秒\n    ease: 'Linear',          // 线性缓动，保持匀速旋转\n    repeat: -1,              // -1 表示无限循环\n    yoyo: false              // 不需要来回播放\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000074_v2", "prompt_id": "seed_000074", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让黄色方块在 3 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色方块，使用 Tween 实现 3 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制黄色方块并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建抖动动画，设置 x/y 属性随机偏移\n4. 配置 duration 为 3000ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建黄色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('yellowSquare', 100, 100);\n  graphics.destroy();\n\n  // 在屏幕中心创建黄色方块 Sprite\n  const square = this.add.sprite(400, 300, 'yellowSquare');\n\n  // 创建抖动动画\n  // 使用多个 Tween 组合实现抖动效果\n  this.tweens.add({\n    targets: square,\n    x: '+=10', // 向右偏移\n    y: '+=8',  // 向下偏移\n    duration: 100,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1,\n    repeatDelay: 0\n  });\n\n  // 添加旋转抖动增强效果\n  this.tweens.add({\n    targets: square,\n    angle: { from: -2, to: 2 },\n    duration: 150,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1,\n    repeatDelay: 0\n  });\n\n  // 添加缩放抖动\n  this.tweens.add({\n    targets: square,\n    scaleX: { from: 0.98, to: 1.02 },\n    scaleY: { from: 1.02, to: 0.98 },\n    duration: 200,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1,\n    repeatDelay: 0\n  });\n\n  // 添加文字说明\n  this.add.text(400, 500, 'Yellow Square Shake Animation', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000598_v1", "prompt_id": "seed_000598", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色方块以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色方块以120速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds, Phaser.Physics.Arcade.Body.setVelocity\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 生成橙色方块纹理\n3. 创建物理精灵并设置初始速度为120\n4. 设置精灵与世界边界碰撞并反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建橙色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的方块\n  graphics.generateTexture('orangeSquare', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const square = this.physics.add.sprite(400, 300, 'orangeSquare');\n  \n  // 设置速度为120（斜向移动，使 x 和 y 方向的合速度约为120）\n  const speed = 120;\n  const angle = Math.PI / 4; // 45度角\n  square.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000372_v1", "prompt_id": "seed_000372", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色三角形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色三角形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置紫色填充样式（0x800080）\n4. 计算画布中心点坐标（400, 300）\n5. 使用 fillTriangle 绘制三角形，三个顶点围绕中心点，边长约 24 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充样式\n  graphics.fillStyle(0x800080, 1);\n  \n  // 计算画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 三角形的大小（边长约 24 像素）\n  const size = 24;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - (size * Math.sqrt(3) / 3);\n  \n  // 顶点2：左下角\n  const x2 = centerX - size / 2;\n  const y2 = centerY + (size * Math.sqrt(3) / 6);\n  \n  // 顶点3：右下角\n  const x3 = centerX + size / 2;\n  const y3 = centerY + (size * Math.sqrt(3) / 6);\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加描边使三角形更清晰\n  graphics.lineStyle(2, 0x9932cc, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000201_v2", "prompt_id": "seed_000201", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色圆形以300速度移动并在画布边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser 游戏配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制红色圆形并生成纹理\n3. 创建物理精灵，设置初始速度为300\n4. 设置物理边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力，保持匀速运动\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);  // 红色\n  graphics.fillCircle(25, 25, 25);  // 圆心在 (25, 25)，半径 25\n  \n  // 生成纹理\n  graphics.generateTexture('redCircle', 50, 50);\n  graphics.destroy();  // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'redCircle');\n  \n  // 设置速度（随机方向，速度为 300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 300);\n  circle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置碰撞世界边界\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 不需要额外的更新逻辑，物理系统会自动处理\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000104_v1", "prompt_id": "seed_000104", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色矩形以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色矩形以 80 速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制粉色矩形并生成纹理\n3. 创建物理精灵并设置初始速度为 80\n4. 启用世界边界碰撞和反弹\n5. 设置精灵与世界边界碰撞时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFC0CB, 1); // 粉色 (Pink)\n  graphics.fillRect(0, 0, 60, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkRect', 60, 40);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const rectangle = this.physics.add.sprite(400, 300, 'pinkRect');\n  \n  // 设置初始速度（随机方向，速度为 80）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 80);\n  rectangle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置世界边界碰撞\n  rectangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  rectangle.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000782_v3", "prompt_id": "seed_000782", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让白色星形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个白色星形在 4 秒内完成一次旋转并循环的动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Tweens.TweenManager#add\nSTEPS:\n1. 使用 Graphics 或 Star 几何体创建白色星形对象\n2. 使用 tweens.add 创建旋转补间动画，设置 angle 属性从 0 到 360\n3. 设置动画持续时间为 4000ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 方法1: 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制星形路径（5个角的星形）\n  const centerX = 400;\n  const centerY = 300;\n  const outerRadius = 80;\n  const innerRadius = 40;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 创建旋转补间动画\n  // 注意：Graphics 对象的旋转中心默认在 (0, 0)，需要调整\n  this.tweens.add({\n    targets: graphics,\n    angle: 360,           // 旋转到 360 度\n    duration: 4000,       // 持续时间 4 秒\n    repeat: -1,           // 无限循环\n    ease: 'Linear'        // 线性缓动，保持匀速旋转\n  });\n  \n  // 方法2（备选）：使用 Star 几何体\n  // 如果需要更简洁的方式，可以使用内置的 Star 对象\n  /*\n  const star = this.add.star(400, 300, 5, 40, 80, 0xffffff);\n  \n  this.tweens.add({\n    targets: star,\n    angle: 360,\n    duration: 4000,\n    repeat: -1,\n    ease: 'Linear'\n  });\n  */\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000564_v3", "prompt_id": "seed_000564", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形移动，速度 240 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.Math.Vector2\nSTEPS:\n1. 创建 Scene 并初始化 Phaser.Game 配置\n2. 使用 Graphics 绘制菱形形状并生成纹理\n3. 创建 Sprite 对象作为可移动的菱形\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态计算移动方向并更新位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点为原点）\n  const size = 30;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置键盘输入监听 WASD\n  keys = this.input.keyboard.addKeys({\n    W: Phaser.Input.Keyboard.KeyCodes.W,\n    A: Phaser.Input.Keyboard.KeyCodes.A,\n    S: Phaser.Input.Keyboard.KeyCodes.S,\n    D: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the diamond', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动方向向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  if (keys.W.isDown) {\n    velocityY = -1;\n  } else if (keys.S.isDown) {\n    velocityY = 1;\n  }\n  \n  if (keys.A.isDown) {\n    velocityX = -1;\n  } else if (keys.D.isDown) {\n    velocityX = 1;\n  }\n  \n  // 如果有移动输入，归一化向量并应用速度\n  if (velocityX !== 0 || velocityY !== 0) {\n    // 创建向量并归一化（确保对角线移动速度一致）\n    const velocity = new Phaser.Math.Vector2(velocityX, velocityY);\n    velocity.normalize();\n    \n    // 根据 delta 时间计算实际移动距离\n    const moveDistance = SPEED * (delta / 1000);\n    \n    // 更新菱形位置\n    diamond.x += velocity.x * moveDistance;\n    diamond.y += velocity.y * moveDistance;\n    \n    // 限制在屏幕范围内\n    diamond.x = Phaser.Math.Clamp(diamond.x, 0, 800);\n    diamond.y = Phaser.Math.Clamp(diamond.y, 0, 600);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000236_v2", "prompt_id": "seed_000236", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的橙色圆形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的橙色圆形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillCircle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环3次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置橙色（0xffa500），使用 fillCircle 绘制半径为8的圆形（直径16像素）\n4. 使用 setRandomPosition 为每个圆形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建3个随机位置的橙色圆形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xffa500, 1);\n    \n    // 绘制圆形，半径为8（直径16像素）\n    graphics.fillCircle(0, 0, 8);\n    \n    // 设置随机位置（考虑圆形半径，避免超出边界）\n    graphics.setRandomPosition(8, 8, config.width - 16, config.height - 16);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000747_v1", "prompt_id": "seed_000747", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左下移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左下移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制菱形纹理\n2. 创建菱形精灵对象并设置初始位置\n3. 在 create 中调用 camera.startFollow 让相机跟随菱形\n4. 在 update 中更新菱形位置，使其向左下移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst MOVE_SPEED = 100; // 每秒移动像素\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（中心点在 32, 32）\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 0);    // 上顶点\n  graphics.lineTo(64, 32);   // 右顶点\n  graphics.lineTo(32, 64);   // 下顶点\n  graphics.lineTo(0, 32);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加边框\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，初始位置在场景中心偏右上\n  diamond = this.add.sprite(600, 200, 'diamond');\n  \n  // 设置相机跟随菱形\n  this.cameras.main.startFollow(diamond);\n  \n  // 可选：设置相机边界，让相机可以自由移动\n  // 这里设置一个较大的世界边界\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 添加提示文字（固定在相机视图中）\n  const text = this.add.text(10, 10, '相机跟随菱形移动', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在屏幕上，不随相机移动\n  \n  // 添加坐标显示\n  this.coordsText = this.add.text(10, 50, '', {\n    fontSize: '16px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.coordsText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（基于时间的移动，确保不同帧率下速度一致）\n  const moveDistance = MOVE_SPEED * (delta / 1000);\n  \n  // 向左下移动（x 减少，y 增加）\n  // 使用 45 度角移动，所以 x 和 y 的变化量相同\n  const offset = moveDistance * Math.sqrt(2) / 2;\n  \n  diamond.x -= offset;\n  diamond.y += offset;\n  \n  // 更新坐标显示\n  this.coordsText.setText(\n    `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})`\n  );\n  \n  // 可选：添加旋转效果，让菱形在移动时旋转\n  diamond.rotation += 0.02;\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000734_v1", "prompt_id": "seed_000734", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在 1.5 秒内缩放到 16% 然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 实现缩放动画，从 1 到 0.16 再回到 1\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64）\n  const size = 64;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 上顶点\n  graphics.lineTo(size * 2, size);    // 右顶点\n  graphics.lineTo(size, size * 2);    // 下顶点\n  graphics.lineTo(0, size);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.16,        // 缩放到 16%\n    scaleY: 0.16,        // 缩放到 16%\n    duration: 1500,      // 1.5 秒\n    yoyo: true,          // 自动反向播放（恢复到原始大小）\n    repeat: -1,          // 无限循环\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Diamond Scaling Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% → 16% → 100% (Loop)', {\n    fontSize: '16px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000234_v2", "prompt_id": "seed_000234", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：8 个矩形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色收集8个随机分布的矩形，收集完成后显示\"恭喜通关\"\nAPI: Phaser.Physics.Arcade.Factory#sprite, Phaser.Physics.Arcade.Factory#group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World#overlap, Phaser.GameObjects.Text\nSTEPS:\n1. 使用 Graphics 创建玩家和收集物的纹理（不同颜色的矩形）\n2. 创建玩家精灵并添加 Arcade 物理引擎，设置键盘控制\n3. 创建 8 个收集物精灵并随机分布在场景中\n4. 使用 overlap 检测玩家与收集物的碰撞，碰撞后移除收集物并增加计数\n5. 当收集计数达到 8 时，显示\"恭喜通关\"文本并停止游戏\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet collectibles;\nlet cursors;\nlet collectedCount = 0;\nlet totalCollectibles = 8;\nlet scoreText;\nlet victoryText;\nlet gameOver = false;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色矩形）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00aaff, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（黄色矩形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0xffdd00, 1);\n  collectibleGraphics.fillRect(0, 0, 30, 30);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setVelocityDrag(500);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成 8 个收集物\n  for (let i = 0; i < totalCollectibles; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    \n    // 添加轻微的浮动效果\n    this.tweens.add({\n      targets: collectible,\n      y: collectible.y + 10,\n      duration: 1000,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, `收集进度: ${collectedCount}/${totalCollectibles}`, {\n    fontSize: '24px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 创建胜利文本（初始隐藏）\n  victoryText = this.add.text(400, 300, '恭喜通关！', {\n    fontSize: '64px',\n    fill: '#00ff00',\n    fontFamily: 'Arial',\n    fontStyle: 'bold'\n  });\n  victoryText.setOrigin(0.5);\n  victoryText.setVisible(false);\n\n  // 添加游戏说明\n  this.add.text(16, 50, '使用方向键移动，收集所有黄色方块', {\n    fontSize: '18px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  });\n}\n\nfunction update() {\n  if (gameOver) {\n    return;\n  }\n\n  // 玩家移动控制\n  const speed = 300;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 移除收集物\n  collectible.destroy();\n\n  // 增加收集计数\n  collectedCount++;\n\n  // 更新分数文本\n  scoreText.setText(`收集进度: ${collectedCount}/${totalCollectibles}`);\n\n  // 检查是否收集完成\n  if (collectedCount >= totalCollectibles) {\n    gameOver = true;\n    victoryText.setVisible(true);\n    player.setVelocity(0, 0);\n\n    // 添加胜利动画效果\n    this.tweens.add({\n      targets: victoryText,\n      scale: { from: 0.5, to: 1.2 },\n      duration: 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000884_v1", "prompt_id": "seed_000884", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 5 个青色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 5 个青色可复用对象，对象离开屏幕后自动回收并重新使用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建 Scene 类，在 create 中使用 Graphics 生成青色圆形纹理\n2. 使用 Physics.Arcade.Group 创建对象池，设置 maxSize 为 5\n3. 在 create 中初始化 5 个对象并赋予随机速度\n4. 在 update 中检测对象是否离开屏幕边界，离开则回收并重新发射\n5. 添加状态变量 recycleCount 记录回收次数，用于验证对象池功能\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.recycleCount = 0; // 记录回收次数\n    this.activeCount = 0; // 记录当前活跃对象数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillCircle(16, 16, 16); // 半径 16 的圆形\n    graphics.generateTexture('cyanBall', 32, 32);\n    graphics.destroy();\n\n    // 创建物理对象池\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'cyanBall',\n      maxSize: 5,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 初始化 5 个对象\n    for (let i = 0; i < 5; i++) {\n      this.spawnObject();\n    }\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  spawnObject() {\n    // 从对象池获取或创建对象\n    let obj = this.objectPool.get();\n    \n    if (!obj) {\n      return; // 对象池已满\n    }\n\n    // 随机位置（屏幕上边缘或左边缘）\n    const spawnSide = Phaser.Math.Between(0, 1);\n    let x, y;\n    \n    if (spawnSide === 0) {\n      // 从上边缘生成\n      x = Phaser.Math.Between(50, 750);\n      y = -20;\n    } else {\n      // 从左边缘生成\n      x = -20;\n      y = Phaser.Math.Between(50, 550);\n    }\n\n    obj.setPosition(x, y);\n    obj.setActive(true);\n    obj.setVisible(true);\n\n    // 设置随机速度\n    const velocityX = Phaser.Math.Between(50, 150);\n    const velocityY = Phaser.Math.Between(50, 150);\n    obj.setVelocity(velocityX, velocityY);\n\n    // 设置边界\n    obj.setBounce(0);\n    obj.setCollideWorldBounds(false);\n\n    this.activeCount++;\n  }\n\n  recycleObject(obj) {\n    // 回收对象\n    obj.setActive(false);\n    obj.setVisible(false);\n    obj.setVelocity(0, 0);\n    \n    this.recycleCount++;\n    this.activeCount--;\n\n    // 重新生成对象\n    this.time.delayedCall(100, () => {\n      this.spawnObject();\n    });\n  }\n\n  update(time, delta) {\n    // 检查所有活跃对象是否离开屏幕\n    this.objectPool.children.entries.forEach((obj) => {\n      if (obj.active) {\n        // 检查是否离开屏幕边界\n        if (obj.x < -50 || obj.x > 850 || obj.y < -50 || obj.y > 650) {\n          this.recycleObject(obj);\n        }\n      }\n    });\n\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      'Object Pool Demo',\n      `Recycle Count: ${this.recycleCount}`,\n      `Active Objects: ${this.activeCount}`,\n      `Pool Size: ${this.objectPool.getLength()}`,\n      `Max Size: ${this.objectPool.maxSize}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001122_v2", "prompt_id": "seed_001122", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个基于 8x8 数组的简单 Tilemap：0 为空，1 为墙可碰撞，玩家用方向键移动且不能穿墙。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tilemaps.Tilemap\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现基于8x8数组的Tilemap，玩家用方向键移动且不能穿墙\nAPI: Phaser.Tilemaps.Tilemap, Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建8x8地图数组，0为空地，1为墙壁\n2. 使用Graphics生成瓦片纹理（空地和墙壁）\n3. 通过Tilemap.createBlankLayer创建图层并填充瓦片\n4. 设置墙壁瓦片的碰撞属性\n5. 创建玩家精灵并启用物理系统\n6. 添加方向键输入控制\n7. 在update中处理玩家移动逻辑\n8. 设置玩家与墙壁的碰撞检测\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 512,\n  height: 512,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet cursors;\nlet map;\nlet layer;\nlet playerX = 1; // 玩家在地图数组中的X坐标\nlet playerY = 1; // 玩家在地图数组中的Y坐标\nlet moveTimer = 0; // 移动冷却计时器\nconst MOVE_DELAY = 200; // 移动延迟（毫秒）\nconst TILE_SIZE = 64; // 瓦片大小\n\n// 8x8地图数据：0=空地，1=墙壁\nconst mapData = [\n  [1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 0, 0, 0, 0, 1],\n  [1, 0, 1, 1, 1, 0, 0, 1],\n  [1, 0, 1, 0, 0, 0, 1, 1],\n  [1, 0, 0, 0, 1, 0, 0, 1],\n  [1, 0, 1, 0, 0, 0, 0, 1],\n  [1, 0, 0, 0, 0, 1, 0, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1]\n];\n\nfunction preload() {\n  // 创建空地瓦片纹理\n  const floorGraphics = this.add.graphics();\n  floorGraphics.fillStyle(0x8B7355, 1);\n  floorGraphics.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n  floorGraphics.lineStyle(2, 0x654321, 1);\n  floorGraphics.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);\n  floorGraphics.generateTexture('floor', TILE_SIZE, TILE_SIZE);\n  floorGraphics.destroy();\n\n  // 创建墙壁瓦片纹理\n  const wallGraphics = this.add.graphics();\n  wallGraphics.fillStyle(0x4A4A4A, 1);\n  wallGraphics.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n  wallGraphics.fillStyle(0x333333, 1);\n  wallGraphics.fillRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 8);\n  wallGraphics.lineStyle(2, 0x222222, 1);\n  wallGraphics.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);\n  wallGraphics.generateTexture('wall', TILE_SIZE, TILE_SIZE);\n  wallGraphics.destroy();\n\n  // 创建玩家纹理\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00FF00, 1);\n  playerGraphics.fillCircle(TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2 - 8);\n  playerGraphics.lineStyle(3, 0x00AA00, 1);\n  playerGraphics.strokeCircle(TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2 - 8);\n  playerGraphics.generateTexture('player', TILE_SIZE, TILE_SIZE);\n  playerGraphics.destroy();\n}\n\nfunction create() {\n  // 创建Tilemap\n  map = this.make.tilemap({\n    tileWidth: TILE_SIZE,\n    tileHeight: TILE_SIZE,\n    width: 8,\n    height: 8\n  });\n\n  // 添加瓦片集\n  const tiles = map.addTilesetImage('tiles', null, TILE_SIZE, TILE_SIZE, 0, 0);\n  \n  // 手动设置瓦片集纹理\n  map.tilesets[0].setImage(this.textures.get('floor'));\n\n  // 创建图层\n  layer = map.createBlankLayer('layer1', tiles, 0, 0);\n\n  // 填充地图数据\n  for (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n      const tileIndex = mapData[y][x];\n      if (tileIndex === 0) {\n        // 空地\n        const tile = layer.putTileAt(0, x, y);\n        if (tile) {\n          tile.setTexture('floor');\n        }\n      } else if (tileIndex === 1) {\n        // 墙壁\n        const tile = layer.putTileAt(1, x, y);\n        if (tile) {\n          tile.setTexture('wall');\n          tile.setCollision(true); // 设置碰撞\n        }\n      }\n    }\n  }\n\n  // 设置图层碰撞（所有索引为1的瓦片可碰撞）\n  layer.setCollisionByProperty({ collides: true });\n  layer.setCollision(1);\n\n  // 创建玩家\n  player = this.physics.add.sprite(\n    playerX * TILE_SIZE + TILE_SIZE / 2,\n    playerY * TILE_SIZE + TILE_SIZE / 2,\n    'player'\n  );\n  player.setCollideWorldBounds(true);\n  player.body.setSize(TILE_SIZE - 16, TILE_SIZE - 16);\n\n  // 设置玩家与图层的碰撞\n  this.physics.add.collider(player, layer);\n\n  // 创建方向键输入\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 显示状态信息\n  this.add.text(16, 520, 'Use Arrow Keys to Move', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 显示玩家位置（可验证的状态信号）\n  this.positionText = this.add.text(16, 16, '', {\n    fontSize: '16px',\n    fill: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 8, y: 4 }\n  });\n\n  updatePositionText.call(this);\n}\n\nfunction update(time, delta) {\n  // 更新移动计时器\n  if (moveTimer > 0) {\n    moveTimer -= delta;\n    return;\n  }\n\n  let newX = playerX;\n  let newY = playerY;\n  let moved = false;\n\n  // 检测方向键输入\n  if (cursors.left.isDown) {\n    newX = playerX - 1;\n    moved = true;\n  } else if (cursors.right.isDown) {\n    newX = playerX + 1;\n    moved = true;\n  } else if (cursors.up.isDown) {\n    newY = playerY - 1;\n    moved = true;\n  } else if (cursors.down.isDown) {\n    newY = playerY + 1;\n    moved = true;\n  }\n\n  // 如果尝试移动，检查新位置是否有效\n  if (moved) {\n    if (canMoveTo(newX, newY)) {\n      playerX = newX;\n      playerY = newY;\n      \n      // 平滑移动到新位置\n      this.tweens.add({\n        targets: player,\n        x: playerX * TILE_SIZE + TILE_SIZE / 2,\n        y: playerY * TILE_SIZE + TILE_SIZE / 2,\n        duration: 150,\n        ease: 'Power2'\n      });\n\n      moveTimer = MOVE_DELAY;\n      updatePositionText.call(this);\n    } else {\n      // 碰到墙壁，播放抖动效果\n      this.cameras.main.shake(100, 0.005);\n      moveTimer = MOVE_DELAY / 2; // 碰墙后较短的冷却时间\n    }\n  }\n}\n\n// 检查是否可以移动到指定位置\nfunction canMoveTo(x, y) {\n  // 检查边界\n  if (x < 0 || x >= 8 || y < 0 || y >= 8) {\n    return false;\n  }\n  \n  // 检查是否是墙壁\n  return mapData[y][x] === 0;\n}\n\n// 更新位置文本显示\nfunction updatePositionText() {\n  this.positionText.setText(`Position: (${playerX}, ${playerY})`);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001176_v3", "prompt_id": "seed_001176", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Tilemap", "Input", "Physics"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的绿色星形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的绿色星形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Graphics#setPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽度800，高度600\n2. 在 create 方法中循环15次，每次创建一个 Graphics 对象\n3. 使用 Graphics API 绘制五角星路径（通过计算5个外顶点和5个内顶点的坐标）\n4. 为每个星形设置随机位置（x: 0-768, y: 0-568，保证星形完全在画布内）\n5. 填充绿色并渲染星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制15个随机位置的绿色星形\n  for (let i = 0; i < 15; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为绿色\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制星形路径\n    drawStar(graphics, 16, 16, 5, 16, 8);\n    \n    // 设置随机位置（确保星形完全在画布内）\n    const randomX = Phaser.Math.Between(16, 784);\n    const randomY = Phaser.Math.Between(16, 584);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n/**\n * 绘制星形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心点 x 坐标\n * @param {number} cy - 中心点 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n\n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n\n  for (let i = 0; i < spikes; i++) {\n    // 外顶点\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n\n    // 内顶点\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n\n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000357_v3", "prompt_id": "seed_000357", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色三角形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色三角形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色三角形并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n5. 设置 duration 为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵，放置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 2500,            // 持续时间 2.5 秒\n    yoyo: true,                // 往返效果（到达终点后返回起点）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000567_v3", "prompt_id": "seed_000567", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让粉色星形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个粉色星形，使用 Tween 实现 1.5 秒闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.DegToRad\nSTEPS:\n1. 使用 Graphics 绘制粉色星形并生成纹理\n2. 创建 Sprite 对象使用生成的星形纹理\n3. 使用 Tween 动画控制 alpha 透明度实现闪烁效果\n4. 设置 yoyo 和 loop 参数实现循环闪烁\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色星形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制星形（五角星）\n  const starPoints = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push(\n      outerRadius + radius * Math.cos(angle),\n      outerRadius + radius * Math.sin(angle)\n    );\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(starPoints[0], starPoints[1]);\n  for (let i = 2; i < starPoints.length; i += 2) {\n    graphics.lineTo(starPoints[i], starPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('pinkStar', outerRadius * 2, outerRadius * 2);\n  graphics.destroy();\n  \n  // 创建星形精灵并居中显示\n  const star = this.add.sprite(400, 300, 'pinkStar');\n  \n  // 创建闪烁动画\n  // 使用 alpha 透明度从 1 渐变到 0.2 再回到 1，实现闪烁效果\n  this.tweens.add({\n    targets: star,\n    alpha: 0.2,           // 目标透明度（较暗）\n    duration: 750,        // 单程时长 0.75 秒\n    yoyo: true,           // 往返动画（0.75秒变暗 + 0.75秒变亮 = 1.5秒）\n    repeat: -1,           // 无限循环\n    ease: 'Sine.easeInOut' // 平滑过渡\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '粉色星形闪烁动画 (1.5秒/次)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000680_v2", "prompt_id": "seed_000680", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让青色三角形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色三角形，使用 Tween 动画在 1 秒内完成一次旋转并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setOrigin\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Sprite 对象并设置原点为中心\n3. 使用 Tween 动画旋转 360 度，duration 1000ms，loop -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为青色\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (50, 50)，边长约 80\n  graphics.beginPath();\n  graphics.moveTo(50, 10);      // 顶点\n  graphics.lineTo(10, 90);      // 左下\n  graphics.lineTo(90, 90);      // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建三角形精灵并放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置原点为中心，使旋转围绕中心进行\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    angle: 360,                  // 旋转到 360 度\n    duration: 1000,              // 持续时间 1 秒\n    ease: 'Linear',              // 线性缓动，保持匀速旋转\n    repeat: -1,                  // 无限循环 (-1 表示永久重复)\n    onRepeat: function() {\n      // 每次重复时重置角度，避免累积\n      triangle.angle = 0;\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000536_v2", "prompt_id": "seed_000536", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个六边形，使用 Tween 动画在 4 秒内从透明渐变到完全不透明并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画控制 alpha 属性从 0 到 1，持续 4 秒，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形的参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100;  // 绘制中心点（相对于纹理）\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1); // 绿色填充\n  graphics.lineStyle(4, 0xffffff, 1); // 白色边框\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制多边形\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n  graphics.strokePoints(polygon.points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成了纹理\n  \n  // 创建六边形精灵并设置位置\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  hexagon.alpha = 0; // 设置初始透明度为 0\n  \n  // 创建 Tween 动画：从透明到不透明，4 秒循环\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1,           // 目标透明度为 1（完全不透明）\n    duration: 4000,     // 持续时间 4 秒\n    ease: 'Linear',     // 线性缓动\n    yoyo: false,        // 不反向播放\n    repeat: -1,         // 无限循环\n    repeatDelay: 0      // 重复延迟为 0\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, 'Hexagon Fade In Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'The hexagon fades from transparent to opaque in 4 seconds (looping)', {\n    fontSize: '16px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000375_v2", "prompt_id": "seed_000375", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个六边形，使用 tween 动画实现 2 秒内缩放到 80% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用生成的六边形纹理\n3. 使用 tweens 创建缩放动画，从 1 到 0.8 再回到 1\n4. 设置 yoyo 和 loop 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角度间隔 60 度\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制填充的六边形\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 从原始大小 (1) 缩放到 80% (0.8)，然后恢复到原始大小\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 2000, // 2 秒\n    yoyo: true, // 动画结束后反向播放（恢复到原始大小）\n    loop: -1, // 无限循环 (-1 表示永久循环)\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '六边形缩放动画 (循环播放)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000475_v2", "prompt_id": "seed_000475", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让粉色菱形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色菱形在1.5秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制粉色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建 y 轴弹跳动画，设置缓动函数模拟弹跳效果\n4. 设置动画循环播放，总时长1.5秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建粉色菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（旋转45度的正方形）\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，初始位置在屏幕中上方\n  const diamond = this.add.sprite(400, 200, 'diamond');\n  \n  // 设置原点为中心\n  diamond.setOrigin(0.5, 0.5);\n  \n  // 创建弹跳动画\n  // 使用 Bounce.easeOut 模拟真实的弹跳效果\n  this.tweens.add({\n    targets: diamond,\n    y: 400, // 弹跳到的目标位置\n    duration: 750, // 下落时间 0.75秒\n    ease: 'Bounce.easeOut', // 弹跳缓动\n    yoyo: true, // 来回运动\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加轻微的缩放效果增强弹跳感\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 1.1,\n    scaleY: 0.9,\n    duration: 750,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 550, '粉色菱形弹跳动画 (1.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000333_v2", "prompt_id": "seed_000333", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色椭圆，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个粉色椭圆，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置粉色填充样式（0xff69b4）\n4. 使用 fillEllipse 在画布中央绘制椭圆，半径约为 24 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充样式\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // 中心点：(400, 300)，宽度和高度均为 24 像素\n  graphics.fillEllipse(400, 300, 24, 24);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000121_v3", "prompt_id": "seed_000121", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个紫色三角形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现紫色三角形左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -40);    // 顶点\n  graphics.lineTo(-35, 30);   // 左下角\n  graphics.lineTo(35, 30);    // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 70, 70);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: triangle,           // 动画目标\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 2000,              // 持续时间 2 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 启用往返效果\n    repeat: -1                   // 无限循环 (-1 表示永久重复)\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '紫色三角形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000690_v2", "prompt_id": "seed_000690", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色六边形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色六边形以160速度移动并在画布边界反弹\nAPI: Graphics, Phaser.Game, Scene.create, Scene.update, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 绘制青色六边形并生成纹理\n3. 创建 Sprite 对象并设置初始速度（160像素/秒）\n4. 在 update 中检测边界碰撞并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet hexagon;\nlet velocityX = 160;\nlet velocityY = 120;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制六边形（中心点为原点）\n  const size = 30; // 六边形半径\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每60度一个顶点\n    const x = size * Math.cos(angle);\n    const y = size * Math.sin(angle);\n    points.push(new Phaser.Math.Vector2(x, y));\n  }\n  \n  graphics.fillPoints(points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', size * 2, size * 2);\n  graphics.destroy(); // 销毁临时 graphics 对象\n  \n  // 创建六边形精灵\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始位置（随机）\n  hexagon.x = Phaser.Math.Between(100, 700);\n  hexagon.y = Phaser.Math.Between(100, 500);\n}\n\nfunction update(time, delta) {\n  // 计算移动距离（速度 * 时间）\n  const deltaSeconds = delta / 1000;\n  hexagon.x += velocityX * deltaSeconds;\n  hexagon.y += velocityY * deltaSeconds;\n  \n  // 获取六边形的边界\n  const radius = 30;\n  \n  // 检测左右边界碰撞\n  if (hexagon.x - radius <= 0) {\n    hexagon.x = radius;\n    velocityX = Math.abs(velocityX); // 向右反弹\n  } else if (hexagon.x + radius >= 800) {\n    hexagon.x = 800 - radius;\n    velocityX = -Math.abs(velocityX); // 向左反弹\n  }\n  \n  // 检测上下边界碰撞\n  if (hexagon.y - radius <= 0) {\n    hexagon.y = radius;\n    velocityY = Math.abs(velocityY); // 向下反弹\n  } else if (hexagon.y + radius >= 600) {\n    hexagon.y = 600 - radius;\n    velocityY = -Math.abs(velocityY); // 向上反弹\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000376_v2", "prompt_id": "seed_000376", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 3 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在 3 秒内缩放到 48% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 Tween 创建缩放动画，从 1 缩放到 0.48，yoyo 模式自动恢复\n4. 设置 loop: -1 实现无限循环，duration: 3000 控制单程 3 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (50, 50)，半径约 40\n  graphics.beginPath();\n  graphics.moveTo(50, 10);  // 顶点\n  graphics.lineTo(15, 75);  // 左下角\n  graphics.lineTo(85, 75);  // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建三角形 Sprite，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置三角形的原点为中心\n  triangle.setOrigin(0.5, 0.5);\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.48,  // 缩放到 48%\n    scaleY: 0.48,  // 缩放到 48%\n    duration: 3000,  // 3 秒完成缩放\n    yoyo: true,  // 自动返回原始大小\n    loop: -1,  // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 50, '三角形缩放动画\\n3秒缩放到48%后恢复', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000257_v2", "prompt_id": "seed_000257", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个矩形\n2. 设置矩形的原点为中心点以实现中心旋转\n3. 在 update 方法中根据 delta 时间增量更新 rotation 属性\n4. 将角速度转换为弧度（120度/秒 = 120 * Math.PI / 180 弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制矩形，中心点在 (0, 0)，这样旋转时会围绕中心旋转\n  const rectWidth = 150;\n  const rectHeight = 80;\n  graphics.fillRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);\n  \n  // 将 Graphics 对象定位到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 的 data 中，方便 update 访问\n  this.rotatingRect = graphics;\n  \n  // 添加说明文字\n  this.add.text(10, 10, '矩形以每秒 120 度的速度旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 将每秒 120 度转换为弧度/毫秒\n  // 120 度 = 120 * (Math.PI / 180) 弧度\n  // delta 是毫秒，所以需要除以 1000\n  const angularVelocity = (120 * Math.PI / 180) / 1000; // 弧度/毫秒\n  \n  // 更新旋转角度\n  this.rotatingRect.rotation += angularVelocity * delta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000291_v2", "prompt_id": "seed_000291", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 120 像素/秒速度移动\nAPI: Graphics.fillEllipse, input.keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆形状\n2. 使用 input.keyboard.addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间更新椭圆位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet ellipse;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建椭圆图形\n  ellipse = this.add.graphics();\n  ellipse.fillStyle(0x00ff00, 1);\n  ellipse.fillEllipse(0, 0, 60, 40); // 中心点在 (0,0)，宽60，高40\n  \n  // 设置初始位置\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 添加 WASD 键盘监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  const movement = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    ellipse.y -= movement;\n  }\n  if (keyS.isDown) {\n    ellipse.y += movement;\n  }\n  if (keyA.isDown) {\n    ellipse.x -= movement;\n  }\n  if (keyD.isDown) {\n    ellipse.x += movement;\n  }\n  \n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 30, 770);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000183_v2", "prompt_id": "seed_000183", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色椭圆以360速度移动并在画布边界反弹\nAPI: Graphics.fillEllipse, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色椭圆并生成纹理\n3. 创建物理精灵并设置初始速度为 360\n4. 设置精灵与世界边界碰撞并反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nlet ellipse;\nconst SPEED = 360;\n\nfunction preload() {\n  // 使用 Graphics 创建灰色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillEllipse(40, 30, 80, 60); // 椭圆：宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵，初始位置在画布中心\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置初始速度（随机方向，速度为360）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * SPEED;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * SPEED;\n  ellipse.setVelocity(velocityX, velocityY);\n  \n  // 设置与世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度（修正因碰撞可能产生的速度变化）\n  const velocity = ellipse.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed !== 0 && Math.abs(currentSpeed - SPEED) > 1) {\n    const scale = SPEED / currentSpeed;\n    ellipse.setVelocity(velocity.x * scale, velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000242_v1", "prompt_id": "seed_000242", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#setRotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制三角形\n2. 在 create 中初始化三角形的位置和形状\n3. 在 update 中根据 delta 时间累加旋转角度（120度/秒 = 2.094弧度/秒）\n4. 使用 setRotation 方法更新三角形的旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  triangle = this.add.graphics();\n  \n  // 设置三角形样式\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（以原点为中心）\n  // 三角形顶点坐标：顶部、左下、右下\n  triangle.fillTriangle(\n    0, -50,    // 顶点\n    -40, 40,   // 左下\n    40, 40     // 右下\n  );\n  \n  // 设置三角形位置到屏幕中心\n  triangle.setPosition(400, 300);\n  \n  // 添加提示文字\n  this.add.text(400, 550, '三角形以每秒 120° 的速度旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 每秒旋转 120 度，转换为弧度：120° = 120 * (Math.PI / 180) ≈ 2.094 弧度\n  const rotationSpeed = Phaser.Math.DegToRad(120);\n  \n  // 累加旋转角度\n  currentRotation += rotationSpeed * deltaInSeconds;\n  \n  // 应用旋转\n  triangle.setRotation(currentRotation);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000441_v2", "prompt_id": "seed_000441", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色三角形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色三角形，大小约为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 fillStyle 设置白色填充\n5. 使用 fillTriangle 绘制等边三角形，顶点相对中心点偏移约 16-18 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置白色填充\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 计算画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 定义三角形大小（从中心到顶点的距离）\n  const size = 18;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size;\n  \n  // 顶点2：左下角\n  const x2 = centerX - size * Math.cos(Math.PI / 6);\n  const y2 = centerY + size * Math.sin(Math.PI / 6);\n  \n  // 顶点3：右下角\n  const x3 = centerX + size * Math.cos(Math.PI / 6);\n  const y3 = centerY + size * Math.sin(Math.PI / 6);\n  \n  // 绘制填充的三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加白色描边使三角形更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000791_v2", "prompt_id": "seed_000791", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色菱形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色菱形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算画布中心点坐标 (400, 300)\n4. 使用 beginPath 开始路径绘制，通过 moveTo 和 lineTo 绘制菱形的四个顶点\n5. 设置黄色填充样式，使用 fillPath 填充菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充样式 (0xFFFF00 是黄色的十六进制值)\n  graphics.fillStyle(0xFFFF00, 1);\n  \n  // 计算画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 菱形大小为 24 像素，即从中心到各顶点的距离为 12 像素\n  const size = 12;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000700_v2", "prompt_id": "seed_000700", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让蓝色圆形在 1 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建蓝色圆形抖动动画效果，1秒循环一次\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 Tween 创建抖动效果（随机偏移 x/y 坐标）\n4. 设置 Tween 循环播放，持续时间 1 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1);\n  graphics.fillCircle(50, 50, 50);\n  graphics.generateTexture('blueCircle', 100, 100);\n  graphics.destroy();\n\n  // 创建圆形精灵\n  const circle = this.add.sprite(400, 300, 'blueCircle');\n\n  // 创建抖动动画\n  // 抖动效果通过快速改变位置实现\n  this.tweens.add({\n    targets: circle,\n    x: {\n      value: '+=10',\n      duration: 50,\n      ease: 'Linear',\n      yoyo: true,\n      repeat: 9  // 重复9次，加上原始1次 = 10次，共1秒（50ms * 20 = 1000ms）\n    },\n    y: {\n      value: '-=10',\n      duration: 50,\n      ease: 'Linear',\n      yoyo: true,\n      repeat: 9\n    },\n    loop: -1,  // 无限循环\n    onRepeat: () => {\n      // 每次循环时随机改变抖动方向，增加随机性\n      const randomX = Phaser.Math.Between(-10, 10);\n      const randomY = Phaser.Math.Between(-10, 10);\n      \n      this.tweens.add({\n        targets: circle,\n        x: 400 + randomX,\n        y: 300 + randomY,\n        duration: 50,\n        ease: 'Linear'\n      });\n    }\n  });\n\n  // 添加提示文字\n  this.add.text(400, 500, '蓝色圆形抖动动画 (1秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000207_v1", "prompt_id": "seed_000207", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制一个六边形移动，速度为 80 像素/秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Phaser.Input.Keyboard.addKey\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制六边形并生成纹理\n3. 创建 Sprite 使用生成的六边形纹理\n4. 添加 WASD 键盘输入监听\n5. 在 update 中根据按键状态更新六边形位置（速度 80 像素/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 30;\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  // 绘制六边形（6个顶点）\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0x00aa00, 1);\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建六边形精灵，放置在屏幕中央\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置 WASD 键\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n}\n\nfunction update(time, delta) {\n  // 计算本帧应移动的距离（速度 * 时间差）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keyW.isDown) {\n    hexagon.y -= distance;\n  }\n  if (keyS.isDown) {\n    hexagon.y += distance;\n  }\n  if (keyA.isDown) {\n    hexagon.x -= distance;\n  }\n  if (keyD.isDown) {\n    hexagon.x += distance;\n  }\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000343_v2", "prompt_id": "seed_000343", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的紫色方块，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的紫色方块，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中使用循环创建10个 Graphics 对象\n3. 为每个 Graphics 对象设置紫色填充样式（0x800080）\n4. 使用 Math.random 生成随机 x、y 坐标（确保方块不超出边界）\n5. 在随机位置绘制 64x64 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建10个随机位置的紫色方块\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置紫色填充样式\n    graphics.fillStyle(0x800080, 1);\n    \n    // 生成随机位置（确保方块完全在画布内）\n    // x 范围: 0 到 (800 - 64)\n    // y 范围: 0 到 (600 - 64)\n    const randomX = Math.random() * (config.width - 64);\n    const randomY = Math.random() * (config.height - 64);\n    \n    // 绘制 64x64 的矩形\n    graphics.fillRect(randomX, randomY, 64, 64);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000605_v1", "prompt_id": "seed_000605", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色菱形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个白色菱形在 1 秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建菱形精灵对象并设置初始位置\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形（四个顶点坐标）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 上顶点\n  graphics.lineTo(size * 2, size);    // 右顶点\n  graphics.lineTo(size, size * 2);    // 下顶点\n  graphics.lineTo(0, size);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，设置初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: diamond,\n    x: 700,                    // 目标位置（右侧）\n    duration: 1000,            // 持续时间 1 秒\n    yoyo: true,                // 启用往返效果\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000032_v1", "prompt_id": "seed_000032", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让蓝色星形在 2 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建蓝色星形并使用补间动画实现2秒旋转循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 绘制蓝色星形并生成纹理\n2. 创建使用该纹理的 Sprite 对象\n3. 使用 tweens 创建旋转动画，设置持续时间2秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色星形\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x4169E1, 1);\n  \n  // 绘制星形（5个角）\n  const starPoints = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const x = 60 + Math.cos(angle) * radius;\n    const y = 60 + Math.sin(angle) * radius;\n    starPoints.push(x, y);\n  }\n  \n  graphics.fillPoints(starPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('blueStar', 120, 120);\n  \n  // 清除 graphics 对象（已生成纹理，不再需要）\n  graphics.destroy();\n  \n  // 创建使用星形纹理的 Sprite\n  const star = this.add.sprite(400, 300, 'blueStar');\n  \n  // 创建旋转补间动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    angle: 360,              // 旋转到360度（完整一圈）\n    duration: 2000,          // 持续时间2秒（2000毫秒）\n    ease: 'Linear',          // 线性缓动，保持匀速旋转\n    repeat: -1,              // 无限循环（-1表示永久重复）\n    onRepeat: function() {\n      // 每次重复时重置角度，避免累积\n      star.angle = 0;\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000733_v3", "prompt_id": "seed_000733", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 5 个黄色敌人巡逻移动，在 80 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 5个黄色敌人左右巡逻，玩家接近时追踪，速度80\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, this.physics.add.sprite, Graphics.generateTexture\nSTEPS:\n1. 创建玩家精灵和5个敌人精灵，使用Graphics生成黄色和蓝色纹理\n2. 为每个敌人设置初始巡逻方向和边界范围\n3. 在update中检测玩家与敌人距离，近距离时切换为追踪模式\n4. 巡逻模式：左右移动到边界后反向；追踪模式：朝玩家方向移动\n5. 添加键盘控制玩家移动，显示状态变量（敌人追踪数量）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.enemies = null;\n    this.cursors = null;\n    this.trackingCount = 0; // 状态信号：正在追踪的敌人数量\n    this.detectionRange = 150; // 检测范围\n    this.patrolSpeed = 80; // 巡逻速度\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（黄色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xffff00, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建5个敌人，分布在不同位置\n    const enemyPositions = [\n      { x: 150, y: 150, minX: 50, maxX: 250 },\n      { x: 400, y: 150, minX: 300, maxX: 500 },\n      { x: 650, y: 150, minX: 550, maxX: 750 },\n      { x: 250, y: 300, minX: 100, maxX: 400 },\n      { x: 550, y: 300, minX: 450, maxX: 700 }\n    ];\n\n    enemyPositions.forEach(pos => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      \n      // 自定义属性：巡逻范围和状态\n      enemy.patrolMinX = pos.minX;\n      enemy.patrolMaxX = pos.maxX;\n      enemy.patrolDirection = 1; // 1为右，-1为左\n      enemy.isTracking = false;\n      \n      // 设置初始速度\n      enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.enemies);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 更新追踪计数\n    this.trackingCount = 0;\n\n    // 敌人AI逻辑\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, \n        this.player.y, \n        enemy.x, \n        enemy.y\n      );\n\n      // 检测是否应该追踪玩家\n      if (distance < this.detectionRange) {\n        // 追踪模式\n        enemy.isTracking = true;\n        this.trackingCount++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, \n          enemy.y, \n          this.player.x, \n          this.player.y\n        );\n\n        // 设置速度朝向玩家\n        enemy.setVelocity(\n          Math.cos(angle) * this.patrolSpeed,\n          Math.sin(angle) * this.patrolSpeed\n        );\n      } else {\n        // 巡逻模式\n        if (enemy.isTracking) {\n          // 从追踪切换回巡逻，重置Y速度\n          enemy.setVelocityY(0);\n          enemy.isTracking = false;\n        }\n\n        // 检查是否到达巡逻边界\n        if (enemy.x <= enemy.patrolMinX) {\n          enemy.patrolDirection = 1; // 向右\n          enemy.setVelocityX(this.patrolSpeed);\n        } else if (enemy.x >= enemy.patrolMaxX) {\n          enemy.patrolDirection = -1; // 向左\n          enemy.setVelocityX(-this.patrolSpeed);\n        }\n\n        // 保持当前巡逻方向的速度\n        if (enemy.body.velocity.x === 0) {\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText(\n      `Tracking Enemies: ${this.trackingCount}/5\\n` +\n      `Player: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})\\n` +\n      `Detection Range: ${this.detectionRange}px`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000801_v2", "prompt_id": "seed_000801", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 160 像素/秒的速度移动\nAPI: Graphics.fillTriangle, Input.Keyboard.addKey, Sprite.setVelocity, Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制三角形并生成纹理\n3. 创建物理精灵并应用三角形纹理\n4. 监听 WASD 键盘输入\n5. 在 update 中根据按键状态设置精灵速度（160 像素/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 160;\n\nfunction preload() {\n  // 使用 Graphics 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个指向上方的三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(20, 0);      // 顶点\n  graphics.lineTo(40, 40);     // 右下角\n  graphics.lineTo(0, 40);      // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵并设置三角形纹理\n  player = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置碰撞边界，防止精灵移出屏幕\n  player.setCollideWorldBounds(true);\n  \n  // 创建 WASD 键盘监听\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the triangle', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  player.setVelocity(0, 0);\n  \n  // 根据按键设置速度\n  if (keys.W.isDown) {\n    player.setVelocityY(-SPEED);\n  }\n  if (keys.S.isDown) {\n    player.setVelocityY(SPEED);\n  }\n  if (keys.A.isDown) {\n    player.setVelocityX(-SPEED);\n  }\n  if (keys.D.isDown) {\n    player.setVelocityX(SPEED);\n  }\n  \n  // 如果同时按下两个方向键，需要归一化速度向量以保持恒定速度\n  if ((keys.W.isDown || keys.S.isDown) && (keys.A.isDown || keys.D.isDown)) {\n    const velocity = player.body.velocity;\n    velocity.normalize().scale(SPEED);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000158_v3", "prompt_id": "seed_000158", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个矩形\n2. 将矩形的原点设置为中心点，便于旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（160度/秒 = 160 * Math.PI/180 弧度/秒）\n4. 将累加的角度应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 旋转速度：每秒 160 度，转换为弧度\nconst ROTATION_SPEED = (160 * Math.PI) / 180;\n\nlet rectangle;\n\nfunction preload() {\n  // 不需要预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  rectangle = this.add.graphics();\n  \n  // 设置填充颜色\n  rectangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制矩形，以中心点为原点\n  // 矩形大小 150x100，中心在 (0, 0)\n  rectangle.fillRect(-75, -50, 150, 100);\n  \n  // 将 Graphics 对象移动到画布中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间差，需要转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 累加旋转角度\n  rectangle.rotation += ROTATION_SPEED * deltaInSeconds;\n  \n  // 可选：当旋转超过 2π 时重置，避免数值过大\n  if (rectangle.rotation >= Math.PI * 2) {\n    rectangle.rotation -= Math.PI * 2;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000752_v2", "prompt_id": "seed_000752", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让橙色菱形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色菱形，使用 Tween 动画让其在 4 秒内旋转 360 度并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制橙色菱形形状\n2. 将 Graphics 转换为纹理以便应用旋转变换\n3. 创建 Sprite 或 Image 对象使用该纹理\n4. 使用 tweens.add 创建旋转动画，设置 duration 为 4000ms，angle 从 0 到 360\n5. 设置 repeat: -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制橙色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 绘制菱形（使用四个点构成的多边形）\n  // 菱形中心在 (50, 50)，宽度 100，高度 100\n  const diamondPoints = [\n    50, 0,    // 上顶点\n    100, 50,  // 右顶点\n    50, 100,  // 下顶点\n    0, 50     // 左顶点\n  ];\n  \n  graphics.fillPoints(diamondPoints, true);\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('diamond', 100, 100);\n  \n  // 销毁原始 graphics 对象（已经生成纹理）\n  graphics.destroy();\n  \n  // 在屏幕中心创建使用该纹理的 Image 对象\n  const diamond = this.add.image(400, 300, 'diamond');\n  \n  // 设置旋转中心点（默认已经是中心）\n  diamond.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    angle: 360,                 // 旋转到 360 度\n    duration: 4000,             // 持续时间 4 秒\n    ease: 'Linear',             // 线性缓动，保持匀速旋转\n    repeat: -1,                 // 无限循环 (-1 表示永久重复)\n    yoyo: false                 // 不使用往返效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '橙色菱形 4 秒旋转一周（循环）', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000789_v1", "prompt_id": "seed_000789", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色六边形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色六边形以240速度移动并在画布边界反弹\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Graphics.generateTexture, Physics.Arcade.Sprite, Physics.World.setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制灰色六边形并生成纹理\n2. 创建 Arcade Physics 精灵并应用六边形纹理\n3. 设置精灵初始速度为 240（斜向移动）\n4. 启用世界边界碰撞和精灵反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点（正六边形，半径40）\n  const hexRadius = 40;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶部开始\n    hexPoints.push({\n      x: hexRadius + Math.cos(angle) * hexRadius,\n      y: hexRadius + Math.sin(angle) * hexRadius\n    });\n  }\n  \n  // 绘制灰色六边形\n  graphics.fillStyle(0x808080, 1);\n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0].x, hexPoints[0].y);\n  for (let i = 1; i < hexPoints.length; i++) {\n    graphics.lineTo(hexPoints[i].x, hexPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（240速度，斜向移动）\n  const speed = 240;\n  const angle = Math.PI / 4; // 45度角\n  hexagon.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置碰撞属性\n  hexagon.setCollideWorldBounds(true); // 与世界边界碰撞\n  hexagon.setBounce(1, 1); // X和Y方向完全反弹\n  \n  // 确保物理体大小匹配纹理\n  hexagon.body.setSize(hexRadius * 1.5, hexRadius * 1.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000740_v2", "prompt_id": "seed_000740", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的橙色椭圆，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的橙色椭圆，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中使用 Graphics 对象绘制椭圆\n3. 使用循环创建3个椭圆，每个使用 fillEllipse 方法绘制 64x64 大小\n4. 使用 setRandomPosition 或 Phaser.Math.Between 设置随机位置\n5. 设置橙色填充样式（0xFFA500）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建3个橙色椭圆\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充样式\n    graphics.fillStyle(0xFFA500, 1);\n    \n    // 绘制椭圆（中心点在原点，半径为32，直径64）\n    graphics.fillEllipse(0, 0, 64, 64);\n    \n    // 设置随机位置（考虑椭圆大小，避免超出边界）\n    const randomX = Phaser.Math.Between(64, config.width - 64);\n    const randomY = Phaser.Math.Between(64, config.height - 64);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000288_v2", "prompt_id": "seed_000288", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色星形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现灰色星形从左到右往返循环的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色星形并生成纹理\n2. 创建星形精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制五角星\n  const starPoints = [];\n  const numPoints = 5;\n  const outerRadius = 40;\n  const innerRadius = 16;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    starPoints.push(\n      radius * Math.cos(angle),\n      radius * Math.sin(angle)\n    );\n  }\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0], starPoints[1]);\n  \n  for (let i = 2; i < starPoints.length; i += 2) {\n    graphics.lineTo(starPoints[i], starPoints[i + 1]);\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 80, 80);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'star');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700, // 移动到右侧\n    duration: 1000, // 1秒\n    yoyo: true, // 往返\n    loop: -1, // 无限循环\n    ease: 'Linear' // 线性运动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000760_v3", "prompt_id": "seed_000760", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色椭圆，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色椭圆，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为橙色（0xFFA500）\n4. 使用 fillEllipse 在画布中央（400, 300）绘制椭圆，宽高约 80 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为橙色\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 为椭圆中心点坐标\n  // width 为椭圆宽度，height 为椭圆高度\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  const ellipseWidth = 80;\n  const ellipseHeight = 80;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000102_v2", "prompt_id": "seed_000102", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 600，移动速度 200，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色左右移动、跳跃，带重力和地面碰撞检测的平台跳跃游戏\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 600\n2. 使用 Graphics 创建角色和地面的纹理\n3. 创建角色精灵，设置物理属性和碰撞体\n4. 创建静态地面平台组，设置碰撞\n5. 监听键盘输入（左右方向键和空格跳跃）\n6. 在 update 中处理移动逻辑，左右速度 200，跳跃速度 -400\n7. 添加状态变量记录跳跃次数作为验证信号\n[/PLAN]\n\n```javascript\n// 平台跳跃游戏场景\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 状态信号：跳跃次数\n    this.isGrounded = false; // 状态信号：是否在地面\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，不依赖外部资源\n  }\n\n  create() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色方块）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 400, 32);\n    groundGraphics.generateTexture('ground', 400, 32);\n    groundGraphics.destroy();\n\n    // 创建平台纹理（棕色方块）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8b4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建角色\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建地面和平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加主地面\n    this.platforms.create(200, 568, 'ground');\n    this.platforms.create(600, 568, 'ground');\n\n    // 添加平台\n    this.platforms.create(600, 450, 'platform');\n    this.platforms.create(50, 350, 'platform');\n    this.platforms.create(750, 300, 'platform');\n    this.platforms.create(400, 200, 'platform');\n\n    // 设置角色与平台碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      // 碰撞回调，检测是否着地\n      if (this.player.body.touching.down) {\n        this.isGrounded = true;\n      }\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加控制说明\n    this.add.text(16, 60, '控制: ← → 移动, 空格/↑ 跳跃', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 重置着地状态\n    if (!this.player.body.touching.down) {\n      this.isGrounded = false;\n    }\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面时才能跳跃）\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n      this.jumpCount++;\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `跳跃次数: ${this.jumpCount}`,\n      `着地状态: ${this.isGrounded ? '是' : '否'}`,\n      `位置: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      `速度: (${Math.floor(this.player.body.velocity.x)}, ${Math.floor(this.player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000945_v2", "prompt_id": "seed_000945", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现白色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现白色血条 UI，显示 10 格生命值，空格键扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 并初始化生命值变量为 10\n2. 使用 Graphics 绘制 10 个白色方格作为血条，每格代表 1 点生命值\n3. 监听空格键输入事件，每次按下扣除 1 点生命值\n4. 根据当前生命值动态更新血条显示（已损失的血格变为灰色或透明）\n5. 当生命值降至 0 时，显示 \"Game Over\" 文本并禁用输入\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10; // 可验证的状态信号\n    this.maxHealth = 10;\n    this.healthBars = [];\n    this.gameOver = false;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 50, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 100, 'Press SPACE to take damage', {\n      fontSize: '20px',\n      color: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 创建显示当前血量的文本\n    this.healthText = this.add.text(400, 350, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    this.spaceKey.on('down', this.takeDamage, this);\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setVisible(false);\n  }\n\n  createHealthBar() {\n    const barWidth = 50;\n    const barHeight = 30;\n    const barSpacing = 10;\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing) - barSpacing) / 2;\n    const startY = 200;\n\n    // 创建 10 个血格\n    for (let i = 0; i < this.maxHealth; i++) {\n      const graphics = this.add.graphics();\n      \n      // 绘制白色边框\n      graphics.lineStyle(3, 0xffffff, 1);\n      graphics.strokeRect(0, 0, barWidth, barHeight);\n      \n      // 绘制白色填充\n      graphics.fillStyle(0xffffff, 1);\n      graphics.fillRect(2, 2, barWidth - 4, barHeight - 4);\n      \n      // 设置位置\n      graphics.setPosition(startX + i * (barWidth + barSpacing), startY);\n      \n      // 保存到数组中以便后续更新\n      this.healthBars.push(graphics);\n    }\n  }\n\n  takeDamage() {\n    // 如果游戏已结束，不再处理输入\n    if (this.gameOver) {\n      return;\n    }\n\n    // 扣除生命值\n    if (this.health > 0) {\n      this.health--;\n      this.updateHealthBar();\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n\n      // 检查是否死亡\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  updateHealthBar() {\n    // 更新血条显示\n    for (let i = 0; i < this.maxHealth; i++) {\n      const graphics = this.healthBars[i];\n      graphics.clear();\n      \n      if (i < this.health) {\n        // 剩余的血量：白色\n        graphics.lineStyle(3, 0xffffff, 1);\n        graphics.strokeRect(0, 0, 50, 30);\n        graphics.fillStyle(0xffffff, 1);\n        graphics.fillRect(2, 2, 46, 26);\n      } else {\n        // 已损失的血量：深灰色边框 + 暗灰色填充\n        graphics.lineStyle(3, 0x666666, 1);\n        graphics.strokeRect(0, 0, 50, 30);\n        graphics.fillStyle(0x333333, 0.5);\n        graphics.fillRect(2, 2, 46, 26);\n      }\n    }\n  }\n\n  triggerGameOver() {\n    this.gameOver = true;\n    \n    // 显示 Game Over 文本\n    this.gameOverText.setVisible(true);\n    \n    // 添加闪烁效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      alpha: 0.3,\n      duration: 500,\n      yoyo: true,\n      repeat: -1\n    });\n\n    // 禁用空格键输入\n    this.spaceKey.off('down', this.takeDamage, this);\n    \n    // 添加重启提示\n    this.add.text(400, 400, 'Refresh to restart', {\n      fontSize: '20px',\n      color: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 每帧更新逻辑（本例中不需要）\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  scene: HealthBarScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000910_v3", "prompt_id": "seed_000910", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个白色敌人巡逻移动，在 120 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 10个白色敌人左右巡逻，玩家接近时追踪，速度120\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建玩家和10个敌人的纹理（使用Graphics绘制白色方块）\n2. 初始化物理引擎，创建玩家精灵和敌人组\n3. 为每个敌人设置初始位置、巡逻范围和移动方向\n4. 在update中检测玩家与敌人距离，近距离时切换为追踪模式\n5. 实现敌人巡逻逻辑（到达边界反转方向）和追踪逻辑（朝玩家移动）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerSpeed = 200;\n    this.enemySpeed = 120;\n    this.detectionRange = 150; // 敌人检测玩家的距离\n    this.enemiesChasing = 0; // 状态信号：正在追踪的敌人数量\n    this.patrolDistance = 200; // 巡逻距离\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（白色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xffffff, 1);\n    enemyGraphics.fillRect(0, 0, 28, 28);\n    enemyGraphics.generateTexture('enemy', 28, 28);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建10个敌人，分布在不同位置\n    for (let i = 0; i < 10; i++) {\n      const x = 100 + (i % 5) * 150;\n      const y = 100 + Math.floor(i / 5) * 150;\n      const enemy = this.enemies.create(x, y, 'enemy');\n      \n      // 为每个敌人添加自定义属性\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 巡逻相关属性\n      enemy.patrolStartX = x;\n      enemy.patrolDirection = i % 2 === 0 ? 1 : -1; // 交替初始方向\n      enemy.isChasing = false;\n      \n      // 设置初始速度\n      enemy.setVelocityX(this.enemySpeed * enemy.patrolDirection);\n    }\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff'\n    });\n\n    // 添加玩家与敌人的碰撞检测（可选）\n    this.physics.add.overlap(this.player, this.enemies, this.handleCollision, null, this);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-this.playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(this.playerSpeed);\n    }\n\n    // 更新每个敌人的行为\n    this.enemiesChasing = 0;\n    \n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x,\n        this.player.y,\n        enemy.x,\n        enemy.y\n      );\n\n      // 检测玩家是否在检测范围内\n      if (distance < this.detectionRange) {\n        // 追踪模式\n        if (!enemy.isChasing) {\n          enemy.isChasing = true;\n        }\n        \n        this.enemiesChasing++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x,\n          enemy.y,\n          this.player.x,\n          this.player.y\n        );\n\n        // 设置速度朝向玩家\n        enemy.setVelocity(\n          Math.cos(angle) * this.enemySpeed,\n          Math.sin(angle) * this.enemySpeed\n        );\n\n        // 改变颜色表示追踪状态（红色）\n        enemy.setTint(0xff6666);\n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          enemy.isChasing = false;\n          enemy.setVelocityY(0);\n        }\n\n        // 恢复白色\n        enemy.clearTint();\n\n        // 巡逻逻辑：在起始点左右移动\n        const distanceFromStart = enemy.x - enemy.patrolStartX;\n\n        // 到达巡逻边界时反转方向\n        if (Math.abs(distanceFromStart) > this.patrolDistance) {\n          enemy.patrolDirection *= -1;\n        }\n\n        // 设置巡逻速度\n        enemy.setVelocityX(this.enemySpeed * enemy.patrolDirection);\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Player: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      `Enemies Chasing: ${this.enemiesChasing}/10`,\n      `Detection Range: ${this.detectionRange}px`,\n      'Use Arrow Keys to Move'\n    ]);\n  }\n\n  handleCollision(player, enemy) {\n    // 碰撞处理（可选实现）\n    // 这里可以添加生命值减少等逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001003_v3", "prompt_id": "seed_001003", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 360 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Container\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制六边形\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新六边形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏对象\nlet hexagon;\nlet keys;\n\n// 移动速度（像素/秒）\nconst SPEED = 360;\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  // 绘制六边形\n  const hexRadius = 40;\n  const hexPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = hexRadius * Math.cos(angle);\n    const y = hexRadius * Math.sin(angle);\n    hexPoints.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制六边形路径\n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0].x, hexPoints[0].y);\n  \n  for (let i = 1; i < hexPoints.length; i++) {\n    graphics.lineTo(hexPoints[i].x, hexPoints[i].y);\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 设置六边形初始位置（屏幕中心）\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 保存六边形引用\n  hexagon = graphics;\n  \n  // 设置 WASD 键盘输入\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧的移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    hexagon.y -= moveDistance;\n  }\n  \n  if (keys.s.isDown) {\n    hexagon.y += moveDistance;\n  }\n  \n  if (keys.a.isDown) {\n    hexagon.x -= moveDistance;\n  }\n  \n  if (keys.d.isDown) {\n    hexagon.x += moveDistance;\n  }\n  \n  // 可选：限制六边形在屏幕范围内\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000374_v2", "prompt_id": "seed_000374", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 80 像素/秒的速度移动\nAPI: Scene.input.keyboard.addKeys, Graphics.fillRect, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制一个矩形作为玩家\n2. 在 create 中通过 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间计算位移并更新矩形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象\nlet player;\n// 键盘输入\nlet keys;\n// 移动速度（像素/秒）\nconst SPEED = 80;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 40, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('playerRect', 40, 40);\n  graphics.destroy();\n  \n  // 创建玩家精灵并设置初始位置\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 添加 WASD 键盘监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the rectangle', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    player.x += distance; // 向右移动\n  }\n  \n  // 限制玩家在屏幕范围内\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000449_v3", "prompt_id": "seed_000449", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个橙色星形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个橙色星形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser 游戏配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的五个顶点和五个内凹点坐标（使用三角函数）\n4. 使用 Graphics API 绘制星形路径并填充橙色\n5. 将星形定位在画布中央（400, 300）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 40; // 外半径（星形尖端到中心的距离）\n  const innerRadius = 16; // 内半径（内凹点到中心的距离）\n  const points = 5; // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制星形的所有顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 计算角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点使用 moveTo，其他点使用 lineTo\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000141_v3", "prompt_id": "seed_000141", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形图形并使其以每秒200度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon, Scene.update\nSTEPS:\n1. 使用 Graphics 对象绘制菱形形状\n2. 将菱形的原点设置为中心点以便旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（200度/秒）\n4. 使用 setRotation 或直接修改 rotation 属性更新旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  diamond = this.add.graphics();\n  \n  // 设置填充样式\n  diamond.fillStyle(0x00ff00, 1);\n  \n  // 定义菱形的四个顶点（中心在原点）\n  const size = 80;\n  const points = [\n    { x: 0, y: -size },      // 上顶点\n    { x: size, y: 0 },       // 右顶点\n    { x: 0, y: size },       // 下顶点\n    { x: -size, y: 0 }       // 左顶点\n  ];\n  \n  // 创建多边形并填充\n  const polygon = new Phaser.Geom.Polygon(points);\n  diamond.fillPoints(polygon.points, true);\n  \n  // 将菱形移动到屏幕中心\n  diamond.x = config.width / 2;\n  diamond.y = config.height / 2;\n  \n  // 添加文字说明\n  this.add.text(10, 10, '菱形旋转速度: 200度/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 每秒旋转 200 度，转换为弧度\n  const rotationSpeed = Phaser.Math.DegToRad(200);\n  \n  // 累加旋转角度\n  diamond.rotation += rotationSpeed * deltaInSeconds;\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000465_v1", "prompt_id": "seed_000465", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左侧显示 \"Hello Phaser\" 文字，字体大小 32 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置在屏幕左侧，字体大小为 32 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载资源\n}\n\nfunction create() {\n  // 在屏幕左侧创建文本\n  // x: 50 表示距离左边 50 像素\n  // y: 300 表示垂直居中\n  this.add.text(50, 300, 'Hello Phaser', {\n    fontSize: '32px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000320_v3", "prompt_id": "seed_000320", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让绿色椭圆在 0.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色椭圆，使用 Tween 动画实现 0.5 秒旋转一周并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制绿色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 配置动画持续时间 500ms，设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.fillEllipse(50, 30, 80, 50); // 在中心绘制椭圆（宽80，高50）\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 100, 60);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建椭圆精灵并放置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    angle: 360,                 // 旋转到 360 度\n    duration: 500,              // 持续时间 0.5 秒\n    repeat: -1,                 // 无限循环 (-1 表示永久重复)\n    ease: 'Linear'              // 线性缓动，保持匀速旋转\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Green Ellipse Rotating (0.5s per cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000501_v2", "prompt_id": "seed_000501", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让橙色菱形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色菱形，使用 Tween 动画在 4 秒内旋转一周并循环\nAPI: Graphics, generateTexture, add.sprite, tweens.add\nSTEPS:\n1. 使用 Graphics 绘制橙色菱形形状\n2. 将 Graphics 转换为纹理以便应用于 Sprite\n3. 创建 Sprite 对象并设置到画布中心\n4. 使用 tweens.add 创建旋转动画，设置 4 秒完成 360 度旋转\n5. 设置动画循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8C00, 1); // 橙色\n  \n  // 绘制菱形（四个顶点）\n  const size = 60;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成纹理\n  \n  // 创建 Sprite 并放置在画布中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: diamond,\n    angle: 360,           // 旋转 360 度\n    duration: 4000,       // 持续 4 秒（4000 毫秒）\n    ease: 'Linear',       // 线性缓动，保持匀速旋转\n    repeat: -1,           // 无限循环\n    onRepeat: function() {\n      // 每次循环重复时重置角度为 0，避免角度累积\n      diamond.angle = 0;\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000789_v3", "prompt_id": "seed_000789", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 设置 Sprite 初始透明度为 0\n4. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续 2 秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('rectTexture', 200, 150);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 创建矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  \n  // 设置初始透明度为 0（完全透明）\n  rect.setAlpha(0);\n\n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    alpha: 1,                // 目标透明度值（完全不透明）\n    duration: 2000,          // 持续时间 2 秒（2000 毫秒）\n    ease: 'Linear',          // 线性缓动\n    yoyo: false,             // 不反向播放\n    repeat: -1,              // 无限循环（-1 表示永久重复）\n    repeatDelay: 0           // 重复前无延迟\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, '矩形从透明渐变到不透明（循环）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000285_v2", "prompt_id": "seed_000285", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的青色六边形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的青色六边形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中循环15次，每次创建一个 Graphics 对象\n3. 计算六边形的6个顶点坐标（使用三角函数，半径为24像素）\n4. 使用 Graphics API 绘制填充的六边形路径\n5. 为每个六边形设置随机位置（x: 24-776, y: 24-576，确保完全在画布内）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 六边形参数\n  const hexagonSize = 48; // 六边形直径\n  const radius = hexagonSize / 2; // 半径24像素\n  const hexagonCount = 15;\n  \n  // 绘制15个随机位置的青色六边形\n  for (let i = 0; i < hexagonCount; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置青色填充\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点（正六边形，顶点在正上方）\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j - Math.PI / 2; // 从正上方开始，每60度一个顶点\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（确保六边形完全在画布内）\n    const randomX = radius + Math.random() * (800 - 2 * radius);\n    const randomY = radius + Math.random() * (600 - 2 * radius);\n    graphics.setPosition(randomX, randomY);\n  }\n  \n  // 添加提示文本\n  this.add.text(10, 10, '15 Random Cyan Hexagons (48px each)', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000195_v2", "prompt_id": "seed_000195", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, this.cameras.main\nSTEPS:\n1. 创建 Scene 并配置游戏窗口\n2. 使用 Graphics 绘制星形对象作为可移动的精灵\n3. 在 create 中设置相机跟随星形对象\n4. 在 update 中让星形持续向下移动\n5. 添加背景网格以便观察相机跟随效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 每秒移动像素\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建背景网格，用于观察相机移动效果\n    this.createBackgroundGrid();\n\n    // 使用 Graphics 创建星形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1);\n    graphics.strokeStyle(0xff8800, 2);\n    \n    // 绘制五角星\n    const points = [];\n    const outerRadius = 30;\n    const innerRadius = 15;\n    for (let i = 0; i < 10; i++) {\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const angle = (i * Math.PI) / 5 - Math.PI / 2;\n      points.push({\n        x: Math.cos(angle) * radius,\n        y: Math.sin(angle) * radius\n      });\n    }\n    \n    graphics.beginPath();\n    graphics.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      graphics.lineTo(points[i].x, points[i].y);\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 生成纹理\n    graphics.generateTexture('star', 64, 64);\n    graphics.destroy();\n\n    // 创建星形精灵，初始位置在屏幕中央上方\n    this.star = this.add.sprite(400, 100, 'star');\n    this.star.setOrigin(0.5, 0.5);\n\n    // 设置相机跟随星形对象\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机边界（让星形可以移动到更大的区域）\n    this.cameras.main.setBounds(0, 0, 800, 2000);\n\n    // 添加提示文字（固定在相机视图中）\n    const text = this.add.text(10, 10, '星形自动向下移动\\n相机跟随中...', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机视图，不随相机移动\n  }\n\n  update(time, delta) {\n    // 让星形持续向下移动\n    if (this.star) {\n      // delta 是毫秒，转换为秒\n      this.star.y += this.speed * (delta / 1000);\n\n      // 可选：到达底部后重置位置（循环效果）\n      if (this.star.y > 1900) {\n        this.star.y = 100;\n      }\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建网格背景，方便观察相机移动\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x333333, 0.5);\n\n    const gridSize = 50;\n    const worldHeight = 2000;\n    const worldWidth = 800;\n\n    // 绘制垂直线\n    for (let x = 0; x <= worldWidth; x += gridSize) {\n      graphics.moveTo(x, 0);\n      graphics.lineTo(x, worldHeight);\n    }\n\n    // 绘制水平线\n    for (let y = 0; y <= worldHeight; y += gridSize) {\n      graphics.moveTo(0, y);\n      graphics.lineTo(worldWidth, y);\n    }\n\n    graphics.strokePath();\n\n    // 添加坐标标记\n    for (let y = 0; y <= worldHeight; y += 200) {\n      const label = this.add.text(10, y, `Y: ${y}`, {\n        fontSize: '14px',\n        color: '#00ff00',\n        backgroundColor: '#000000'\n      });\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: GameScene,\n  parent: 'game-container'\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000205_v2", "prompt_id": "seed_000205", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8633333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1.5 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在1.5秒内缩放到64%再恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建使用该纹理的精灵对象\n3. 使用 Tween 实现缩放动画：从 1 缩放到 0.64，yoyo 模式自动恢复\n4. 设置 loop: -1 实现无限循环，duration: 1500 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100; // 绘制中心点\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.beginPath();\n  \n  // 计算六边形的六个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角60度\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 添加描边\n  graphics.lineStyle(4, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  const textureSize = hexRadius * 2 + 20;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy(); // 销毁 graphics 对象\n  \n  // 创建精灵对象\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: hexSprite,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 1500, // 1.5秒\n    yoyo: true, // 自动恢复到原始值\n    loop: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Hexagon scaling: 100% → 64% → 100%', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000304_v3", "prompt_id": "seed_000304", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 200。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 200\nAPI: this.physics.add.sprite, this.input.keyboard.createCursorKeys, graphics.generateTexture, sprite.setVelocity, this.physics.world.wrap\nSTEPS:\n1. 创建 Physics 配置的 Game，启用 arcade 物理系统\n2. 使用 Graphics 绘制橙色方块并生成纹理作为玩家\n3. 创建物理精灵并设置移动速度为 200\n4. 使用键盘输入控制玩家四向移动\n5. 在 update 中使用 wrap 方法实现循环地图效果（玩家移出边界从对侧出现）\n6. 添加位置状态变量用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    // 状态信号变量\n    this.playerX = 0;\n    this.playerY = 0;\n    this.wrapCount = 0; // 记录穿越边界次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const { width, height } = this.cameras.main;\n\n    // 使用 Graphics 创建橙色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8C00, 1); // 橙色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n\n    // 创建物理精灵玩家\n    this.player = this.physics.add.sprite(width / 2, height / 2, 'player');\n    this.player.setCollideWorldBounds(false); // 不与边界碰撞，允许移出\n    \n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 添加显示信息文本\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界提示\n    const borderGraphics = this.add.graphics();\n    borderGraphics.lineStyle(2, 0xFFFFFF, 0.5);\n    borderGraphics.strokeRect(0, 0, width, height);\n  }\n\n  update(time, delta) {\n    const speed = 200;\n    \n    // 重置速度\n    this.player.setVelocity(0);\n\n    // 键盘控制\n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 记录穿越前的位置\n    const prevX = this.player.x;\n    const prevY = this.player.y;\n\n    // 循环地图效果：玩家移出边界时从对侧出现\n    // wrap(gameObject, padding) - padding 为边界外的额外距离\n    this.physics.world.wrap(this.player, 16);\n\n    // 检测是否发生了穿越\n    const { width, height } = this.cameras.main;\n    if (Math.abs(this.player.x - prevX) > width / 2 || \n        Math.abs(this.player.y - prevY) > height / 2) {\n      this.wrapCount++;\n    }\n\n    // 更新状态变量\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 更新显示信息\n    this.infoText.setText([\n      `Position: (${this.playerX}, ${this.playerY})`,\n      `Wrap Count: ${this.wrapCount}`,\n      `Speed: ${speed}`,\n      '',\n      'Controls: Arrow Keys or WASD',\n      'Move out of bounds to wrap around'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001227_v2", "prompt_id": "seed_001227", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的灰色星形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的灰色星形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象用于绘制星形\n3. 编写绘制星形的函数，使用 beginPath 和 lineTo 绘制5个尖角的星形路径\n4. 循环3次，每次生成随机位置（考虑星形大小避免超出边界）\n5. 在随机位置绘制灰色填充的星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制3个随机位置的星形\n  for (let i = 0; i < 3; i++) {\n    // 生成随机位置，确保星形不超出边界\n    // 星形半径为32像素（大小64的一半），留出边距\n    const x = 50 + Math.random() * (800 - 100);\n    const y = 50 + Math.random() * (600 - 100);\n    \n    drawStar(graphics, x, y, 5, 32, 16);\n  }\n}\n\n/**\n * 绘制星形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics对象\n * @param {number} cx - 中心x坐标\n * @param {number} cy - 中心y坐标\n * @param {number} spikes - 尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius) {\n  let rot = Math.PI / 2 * 3;\n  let x = cx;\n  let y = cy;\n  const step = Math.PI / spikes;\n  \n  graphics.beginPath();\n  graphics.moveTo(cx, cy - outerRadius);\n  \n  for (let i = 0; i < spikes; i++) {\n    x = cx + Math.cos(rot) * outerRadius;\n    y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n    \n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n  \n  graphics.lineTo(cx, cy - outerRadius);\n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000049_v2", "prompt_id": "seed_000049", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色方块以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色方块以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 生成粉色方块纹理\n3. 创建物理精灵并设置初始速度为200\n4. 设置边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建粉色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('pinkSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  const square = this.physics.add.sprite(400, 300, 'pinkSquare');\n  \n  // 设置初始速度 (200速度，随机方向)\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 200;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 200;\n  square.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000721_v3", "prompt_id": "seed_000721", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.fillStyle, Phaser.GameObjects.Graphics.beginPath, Phaser.GameObjects.Graphics.moveTo, Phaser.GameObjects.Graphics.lineTo, Phaser.GameObjects.Graphics.closePath, Phaser.GameObjects.Graphics.fillPath, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 使用 Graphics 绘制一个菱形（四个顶点连接成菱形）\n2. 将菱形放置在画布中心位置\n3. 在 update 方法中根据 delta 时间增量更新 rotation 属性，实现每秒 80 度的旋转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置填充颜色\n  diamond.fillStyle(0x00ffff, 1);\n  \n  // 绘制菱形（中心点在原点）\n  diamond.beginPath();\n  diamond.moveTo(0, -80);    // 上顶点\n  diamond.lineTo(60, 0);     // 右顶点\n  diamond.lineTo(0, 80);     // 下顶点\n  diamond.lineTo(-60, 0);    // 左顶点\n  diamond.closePath();\n  diamond.fillPath();\n  \n  // 将菱形移动到画布中心\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 初始旋转角度为 0\n  diamond.rotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 80 度\n  // delta 是毫秒，需要转换为秒\n  // 80 度转换为弧度：80 * (Math.PI / 180)\n  const rotationSpeed = 80 * (Math.PI / 180); // 弧度/秒\n  diamond.rotation += rotationSpeed * (delta / 1000);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000796_v1", "prompt_id": "seed_000796", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个白色矩形在3秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 3000 毫秒（3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 80, 60);\n  graphics.generateTexture('whiteRect', 80, 60);\n  graphics.destroy();\n  \n  // 创建矩形精灵，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n  \n  // 创建补间动画：从左到右移动，往返循环\n  this.tweens.add({\n    targets: rect,\n    x: 700, // 目标位置（右侧）\n    duration: 3000, // 3秒\n    yoyo: true, // 启用往返效果（到达目标后反向播放）\n    loop: -1, // 无限循环\n    ease: 'Linear' // 线性缓动，匀速移动\n  });\n  \n  // 添加文本说明\n  this.add.text(10, 10, 'White rectangle moving left-right in 3s loop', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000720_v1", "prompt_id": "seed_000720", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆\n2. 在 update 方法中根据 delta 时间增量计算旋转角度\n3. 将角度转换为弧度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet currentRotation = 0; // 当前旋转角度（弧度）\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  ellipse = this.add.graphics();\n  \n  // 设置椭圆的位置（中心点）\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 绘制椭圆\n  ellipse.fillStyle(0x00ff00, 1); // 绿色填充\n  ellipse.fillEllipse(0, 0, 150, 80); // 在本地坐标 (0, 0) 绘制椭圆，宽150，高80\n  \n  // 添加边框以便更清楚地看到旋转效果\n  ellipse.lineStyle(3, 0xffffff, 1);\n  ellipse.strokeEllipse(0, 0, 150, 80);\n  \n  // 在椭圆上添加一个标记点，方便观察旋转\n  ellipse.fillStyle(0xff0000, 1);\n  ellipse.fillCircle(75, 0, 8); // 红色圆点作为标记\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 200 度\n  const degreesPerSecond = 200;\n  \n  // delta 是毫秒，转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 计算本帧应旋转的角度（度）\n  const rotationDegrees = degreesPerSecond * deltaInSeconds;\n  \n  // 转换为弧度并累加到当前旋转角度\n  currentRotation += Phaser.Math.DegToRad(rotationDegrees);\n  \n  // 应用旋转\n  ellipse.rotation = currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000085_v3", "prompt_id": "seed_000085", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的灰色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的灰色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象用于绘制\n3. 编写六边形绘制函数，计算六边形的6个顶点坐标（基于中心点和半径）\n4. 使用循环12次，每次生成随机坐标（x: 50-750, y: 50-550）\n5. 在每个随机位置绘制灰色填充的六边形（大小32像素，即半径16）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置灰色填充\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制六边形的辅助函数\n  function drawHexagon(graphics, x, y, radius) {\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    // 从顶部开始，顺时针绘制\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度开始，每60度一个顶点\n      const px = x + radius * Math.cos(angle);\n      const py = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        graphics.moveTo(px, py);\n      } else {\n        graphics.lineTo(px, py);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  }\n  \n  // 绘制12个随机位置的六边形\n  const hexRadius = 16; // 大小32像素，半径为16\n  const margin = 50; // 边距，确保六边形不会超出画布\n  \n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置\n    const randomX = Phaser.Math.Between(margin, 800 - margin);\n    const randomY = Phaser.Math.Between(margin, 600 - margin);\n    \n    // 绘制六边形\n    drawHexagon(graphics, randomX, randomY, hexRadius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000587_v3", "prompt_id": "seed_000587", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个矩形\n2. 设置矩形的原点到中心，便于旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（120度/秒 = 2.094弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet rectangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  rectangle = this.add.graphics();\n  \n  // 设置填充颜色\n  rectangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制矩形（以 0,0 为中心，宽 100，高 60）\n  rectangle.fillRect(-50, -30, 100, 60);\n  \n  // 设置矩形位置到屏幕中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n  \n  // 添加提示文本\n  this.add.text(10, 10, '矩形以每秒 120 度的速度旋转', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 每秒 120 度 = 120 * (Math.PI / 180) 弧度/秒\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = (120 * Math.PI / 180); // 约 2.094 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  rectangle.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000291_v3", "prompt_id": "seed_000291", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 0.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在0.5秒内缩放到80%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 使用该纹理\n3. 使用 Tween 动画控制 Sprite 的 scale 属性\n4. 设置 Tween 为 yoyo 模式（缩放后恢复）并循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 Graphics 对象\n\n  // 创建使用该纹理的 Sprite，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n\n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    scaleX: 0.8,            // X 轴缩放到 80%\n    scaleY: 0.8,            // Y 轴缩放到 80%\n    duration: 500,          // 持续时间 0.5 秒（500 毫秒）\n    yoyo: true,             // 动画结束后反向播放（恢复到原始大小）\n    repeat: -1,             // 无限循环（-1 表示永久重复）\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, '矩形循环缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000181_v2", "prompt_id": "seed_000181", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让粉色方块在 2.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色方块淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 使用 Graphics 绘制粉色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建 alpha 属性动画，从 0 到 1 再到 0\n4. 设置动画循环播放，总时长 2.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkSquare', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建方块精灵并居中\n  const square = this.add.sprite(400, 300, 'pinkSquare');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n  \n  // 创建淡入淡出 Tween 动画\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: {                   // 动画属性\n      from: 0,                 // 起始值：完全透明\n      to: 1                    // 目标值：完全不透明\n    },\n    duration: 1250,            // 淡入时长 1.25 秒\n    yoyo: true,                // 启用 yoyo 效果（到达目标后反向播放）\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    ease: 'Sine.easeInOut'     // 缓动函数，使动画更平滑\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 450, 'Pink Square Fade In/Out Animation', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 490, 'Duration: 2.5 seconds per cycle', {\n    fontSize: '16px',\n    color: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000799_v2", "prompt_id": "seed_000799", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色三角形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形以200速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.Sprite\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制灰色三角形并生成纹理\n3. 创建物理精灵并设置初始速度为200\n4. 在 update 中检测边界碰撞并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#ffffff'\n};\n\nlet triangle;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 顶点\n  graphics.lineTo(-26, 15);   // 左下角\n  graphics.lineTo(26, 15);    // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 52, 45);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  triangle = this.physics.add.sprite(400, 300, 'triangleTex');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const speed = 200;\n  triangle.setVelocity(\n    Math.cos(angle * Math.PI / 180) * speed,\n    Math.sin(angle * Math.PI / 180) * speed\n  );\n  \n  // 设置碰撞边界\n  triangle.setCollideWorldBounds(true);\n  triangle.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 检查边界碰撞并反转速度\n  const bounds = this.physics.world.bounds;\n  \n  // 左右边界\n  if (triangle.x <= triangle.width / 2 || triangle.x >= bounds.width - triangle.width / 2) {\n    triangle.setVelocityX(-triangle.body.velocity.x);\n  }\n  \n  // 上下边界\n  if (triangle.y <= triangle.height / 2 || triangle.y >= bounds.height - triangle.height / 2) {\n    triangle.setVelocityY(-triangle.body.velocity.y);\n  }\n  \n  // 保持速度恒定为200\n  const currentSpeed = Math.sqrt(\n    triangle.body.velocity.x ** 2 + triangle.body.velocity.y ** 2\n  );\n  \n  if (currentSpeed !== 0 && Math.abs(currentSpeed - 200) > 1) {\n    triangle.setVelocity(\n      (triangle.body.velocity.x / currentSpeed) * 200,\n      (triangle.body.velocity.y / currentSpeed) * 200\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000635_v1", "prompt_id": "seed_000635", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个矩形\n2. 设置矩形初始透明度为 0（完全透明）\n3. 使用 Tween 动画让透明度从 0 渐变到 1，持续 4 秒\n4. 设置 Tween 为循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个矩形图形对象\n  const rectangle = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  rectangle.fillStyle(0x3498db, 1);\n  \n  // 绘制一个居中的矩形（200x150）\n  const rectX = 300;\n  const rectY = 225;\n  const rectWidth = 200;\n  const rectHeight = 150;\n  rectangle.fillRect(rectX, rectY, rectWidth, rectHeight);\n  \n  // 设置初始透明度为 0（完全透明）\n  rectangle.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，4 秒循环播放\n  this.tweens.add({\n    targets: rectangle,        // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 4000,            // 持续时间 4 秒（4000 毫秒）\n    ease: 'Linear',            // 线性缓动\n    loop: -1,                  // 无限循环\n    yoyo: false                // 不回放（只从 0 到 1，然后重新开始）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Rectangle fading in (4s loop)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000296_v2", "prompt_id": "seed_000296", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 绘制一个星形，并在 update 中以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.fillStar, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个星形\n2. 设置星形的中心点位置到画布中央\n3. 在 update 中根据 delta 时间累加旋转角度（120度/秒 = 2.094弧度/秒）\n4. 将计算出的角度应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制星形\n  this.star = this.add.graphics();\n  \n  // 设置填充颜色为金黄色\n  this.star.fillStyle(0xFFD700, 1);\n  \n  // 绘制星形：5个点，外半径80，内半径40\n  // fillStar(x, y, points, innerRadius, outerRadius)\n  this.star.fillStar(400, 300, 5, 40, 80);\n  \n  // 初始化旋转角度\n  this.currentRotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 120 度\n  // 120 度 = 120 * Math.PI / 180 = 2.0944 弧度\n  const rotationSpeed = (120 * Math.PI / 180); // 弧度/秒\n  \n  // 根据帧时间增量计算本帧应旋转的角度\n  // delta 是毫秒，需要转换为秒\n  this.currentRotation += rotationSpeed * (delta / 1000);\n  \n  // 应用旋转到星形\n  this.star.rotation = this.currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000018_v1", "prompt_id": "seed_000018", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 3 个橙色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成3个橙色可收集物体，玩家碰撞后消失并加分，显示分数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Graphics#generateTexture\nSTEPS:\n1. 创建带物理系统的 Game 配置\n2. 使用 Graphics 生成玩家和收集物的纹理\n3. 创建玩家精灵和收集物组（Physics Group）\n4. 添加键盘控制让玩家移动\n5. 使用 overlap 检测碰撞，碰撞时销毁收集物并加分\n6. 创建 Text 对象显示实时分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.scoreText = null;\n    this.player = null;\n    this.collectibles = null;\n    this.cursors = null;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 生成收集物纹理（橙色圆形）\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xff8800, 1);\n    collectibleGraphics.fillCircle(15, 15, 15);\n    collectibleGraphics.generateTexture('collectible', 30, 30);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集物组\n    this.collectibles = this.physics.add.group();\n    \n    // 在场景中随机位置生成3个收集物\n    const positions = [\n      { x: 200, y: 150 },\n      { x: 400, y: 200 },\n      { x: 600, y: 150 }\n    ];\n\n    positions.forEach(pos => {\n      const collectible = this.collectibles.create(pos.x, pos.y, 'collectible');\n      collectible.setCollideWorldBounds(true);\n      // 添加轻微的随机移动效果\n      collectible.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n      collectible.setBounce(1);\n    });\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建分数显示\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加提示文本\n    this.add.text(400, 550, 'Use Arrow Keys to Move and Collect Orange Items', {\n      fontSize: '18px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 检查是否收集完所有物品\n    if (this.collectibles.countActive(true) === 0 && this.score > 0) {\n      this.add.text(400, 300, 'All Items Collected!', {\n        fontSize: '48px',\n        fill: '#00ff00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6\n      }).setOrigin(0.5);\n    }\n  }\n\n  collectItem(player, collectible) {\n    // 销毁收集物\n    collectible.destroy();\n    \n    // 增加分数\n    this.score += 10;\n    \n    // 更新分数显示\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 添加收集效果（可选）\n    const collectText = this.add.text(\n      collectible.x,\n      collectible.y,\n      '+10',\n      {\n        fontSize: '24px',\n        fill: '#ffff00',\n        fontFamily: 'Arial'\n      }\n    ).setOrigin(0.5);\n\n    // 文字上浮并消失\n    this.tweens.add({\n      targets: collectText,\n      y: collectText.y - 50,\n      alpha: 0,\n      duration: 1000,\n      onComplete: () => {\n        collectText.destroy();\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000911_v1", "prompt_id": "seed_000911", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的橙色方块，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的橙色方块，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽度800，高度600\n2. 在 create 方法中循环15次\n3. 每次循环使用 Graphics 对象绘制一个橙色方块（颜色0xFFA500）\n4. 使用 Phaser.Math.Between 生成随机 x 和 y 坐标（确保方块完全在画布内）\n5. 每个方块大小为 64x64 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const squareSize = 64;\n  const squareCount = 15;\n  const orangeColor = 0xFFA500; // 橙色\n  \n  // 绘制15个随机位置的橙色方块\n  for (let i = 0; i < squareCount; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为橙色\n    graphics.fillStyle(orangeColor, 1);\n    \n    // 生成随机位置（确保方块完全在画布内）\n    const randomX = Phaser.Math.Between(0, config.width - squareSize);\n    const randomY = Phaser.Math.Between(0, config.height - squareSize);\n    \n    // 绘制方块\n    graphics.fillRect(randomX, randomY, squareSize, squareSize);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000078_v3", "prompt_id": "seed_000078", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现青色血条 UI：显示 10 格生命值，按鼠标左键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现青色血条 UI，显示 10 格生命值，点击鼠标扣血，血量为 0 显示 Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.InputPlugin, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Scene 并初始化 health 变量为 10\n2. 使用 Graphics 绘制 10 个青色方块表示血条\n3. 监听鼠标左键点击事件，每次点击扣除 1 点生命值\n4. 更新血条显示，已损失的生命值用灰色填充\n5. 当 health 为 0 时显示 \"Game Over\" 文本\n[/PLAN]\n\n```javascript\nclass HealthBarScene extends Phaser.Scene {\n  constructor() {\n    super('HealthBarScene');\n    this.health = 10;\n    this.maxHealth = 10;\n    this.healthBars = [];\n    this.gameOver = false;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 100, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 150, 'Click to lose health', {\n      fontSize: '20px',\n      color: '#cccccc'\n    }).setOrigin(0.5);\n\n    // 创建血条容器\n    this.createHealthBar();\n\n    // 创建健康值文本显示\n    this.healthText = this.add.text(400, 350, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#00ffff',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    // 监听鼠标点击事件\n    this.input.on('pointerdown', this.takeDamage, this);\n\n    // 创建 Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      color: '#ff0000',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setVisible(false);\n\n    // 创建重启提示文本（初始隐藏）\n    this.restartText = this.add.text(400, 380, 'Click to restart', {\n      fontSize: '24px',\n      color: '#ffffff'\n    }).setOrigin(0.5).setVisible(false);\n  }\n\n  createHealthBar() {\n    const barWidth = 50;\n    const barHeight = 30;\n    const barSpacing = 10;\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing)) / 2 + barWidth / 2;\n    const startY = 250;\n\n    // 创建 10 个血条方块\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + barSpacing);\n      \n      // 创建背景（深灰色边框）\n      const background = this.add.graphics();\n      background.lineStyle(3, 0x333333, 1);\n      background.strokeRect(x - barWidth / 2, startY - barHeight / 2, barWidth, barHeight);\n\n      // 创建填充（青色）\n      const fill = this.add.graphics();\n      fill.fillStyle(0x00ffff, 1);\n      fill.fillRect(x - barWidth / 2 + 2, startY - barHeight / 2 + 2, barWidth - 4, barHeight - 4);\n\n      this.healthBars.push({\n        background: background,\n        fill: fill,\n        active: true\n      });\n    }\n  }\n\n  takeDamage() {\n    if (this.gameOver) {\n      // 如果游戏结束，点击重启\n      this.restartGame();\n      return;\n    }\n\n    if (this.health > 0) {\n      this.health--;\n      this.updateHealthBar();\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n\n      // 添加点击反馈动画\n      this.cameras.main.shake(100, 0.005);\n\n      if (this.health === 0) {\n        this.showGameOver();\n      }\n    }\n  }\n\n  updateHealthBar() {\n    // 更新血条显示，从右到左扣血\n    const lostHealth = this.maxHealth - this.health;\n    \n    for (let i = 0; i < this.maxHealth; i++) {\n      const bar = this.healthBars[i];\n      const index = this.maxHealth - 1 - i; // 从右到左\n      \n      if (i < lostHealth) {\n        // 已损失的生命值显示为灰色\n        if (bar.active) {\n          bar.fill.clear();\n          bar.fill.fillStyle(0x444444, 1);\n          bar.fill.fillRect(\n            bar.background.x,\n            bar.background.y,\n            50 - 4,\n            30 - 4\n          );\n          \n          // 重新定位 fill\n          const barWidth = 50;\n          const barHeight = 30;\n          const barSpacing = 10;\n          const startX = 400 - (this.maxHealth * (barWidth + barSpacing)) / 2 + barWidth / 2;\n          const startY = 250;\n          const x = startX + index * (barWidth + barSpacing);\n          \n          bar.fill.clear();\n          bar.fill.fillStyle(0x444444, 1);\n          bar.fill.fillRect(x - barWidth / 2 + 2, startY - barHeight / 2 + 2, barWidth - 4, barHeight - 4);\n          bar.active = false;\n        }\n      }\n    }\n  }\n\n  showGameOver() {\n    this.gameOver = true;\n    this.gameOverText.setVisible(true);\n    this.restartText.setVisible(true);\n\n    // Game Over 动画效果\n    this.tweens.add({\n      targets: this.gameOverText,\n      scaleX: 1.2,\n      scaleY: 1.2,\n      yoyo: true,\n      duration: 500,\n      repeat: -1\n    });\n  }\n\n  restartGame() {\n    // 重启游戏\n    this.scene.restart();\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: HealthBarScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000918_v2", "prompt_id": "seed_000918", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色三角形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色三角形以300速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制青色三角形并生成纹理\n3. 创建物理精灵并设置初始速度为300\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 顶点\n  graphics.lineTo(-26, 15);   // 左下角\n  graphics.lineTo(26, 15);    // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度为300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：让三角形根据移动方向旋转\n  this.physics.world.on('worldbounds', (body) => {\n    // 世界边界碰撞事件（可用于调试）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000640_v3", "prompt_id": "seed_000640", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 300，移动速度 160，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现带重力的平台跳跃游戏，角色可左右移动和跳跃，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 300\n2. 使用 Graphics 创建玩家和地面的纹理\n3. 创建玩家精灵并设置物理属性（碰撞边界、反弹等）\n4. 创建地面平台组并设置为静态物理体\n5. 添加键盘输入监听（左右方向键和空格跳跃）\n6. 在 update 中处理移动逻辑和跳跃逻辑\n7. 添加状态变量记录跳跃次数作为验证信号\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 平台跳跃游戏\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false; // 是否在地面上\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00aa00, 1);\n    groundGraphics.fillRect(0, 0, 200, 32);\n    groundGraphics.generateTexture('ground', 200, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setBounce(0); // 不反弹\n    this.player.setCollideWorldBounds(true); // 与世界边界碰撞\n\n    // 创建地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加多个平台\n    this.platforms.create(400, 568, 'ground').setScale(4, 1).refreshBody(); // 底部地面\n    this.platforms.create(600, 450, 'ground'); // 右侧平台\n    this.platforms.create(200, 450, 'ground'); // 左侧平台\n    this.platforms.create(400, 350, 'ground').setScale(0.8, 1).refreshBody(); // 中间平台\n\n    // 设置玩家与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      // 碰撞回调，检测是否在地面上\n      if (this.player.body.touching.down) {\n        this.isGrounded = true;\n      }\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文字\n    this.add.text(16, 50, '← → 移动  空格/↑ 跳跃', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新状态文本\n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount}\\n` +\n      `速度: ${Math.abs(this.player.body.velocity.x).toFixed(0)}\\n` +\n      `高度: ${(600 - this.player.y).toFixed(0)}`\n    );\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      // 没有按键时停止水平移动\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（空格键或上方向键）\n    const jumpPressed = Phaser.Input.Keyboard.JustDown(this.cursors.up) || \n                       Phaser.Input.Keyboard.JustDown(this.spaceKey);\n    \n    if (jumpPressed && this.player.body.touching.down) {\n      this.player.setVelocityY(-400); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n      this.isGrounded = false;\n    }\n\n    // 检测是否离开地面\n    if (!this.player.body.touching.down) {\n      this.isGrounded = false;\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB', // 天空蓝背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 }, // 重力设置为 300\n      debug: false // 设置为 true 可查看物理边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001085_v3", "prompt_id": "seed_001085", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色六边形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现青色六边形在4秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制青色六边形并生成纹理\n2. 创建 Sprite 对象使用该六边形纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环，duration 为 4000 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制六边形（正六边形，半径为 40）\n  const hexRadius = 40;\n  const hexPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = hexRadius + hexRadius * Math.cos(angle);\n    const y = hexRadius + hexRadius * Math.sin(angle);\n    hexPoints.push(x, y);\n  }\n  \n  graphics.fillPoints(hexPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700, // 移动到右侧\n    duration: 4000, // 4秒\n    ease: 'Linear',\n    yoyo: true, // 往返效果\n    loop: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000119_v1", "prompt_id": "seed_000119", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的红色三角形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 在随机位置绘制 3 个红色三角形，每个大小为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小和 Scene\n2. 在 create 方法中循环 3 次创建 Graphics 对象\n3. 使用 fillStyle 设置红色，fillTriangle 绘制等边三角形（边长 80）\n4. 使用 setRandomPosition 设置每个三角形的随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 3 个红色三角形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 绘制等边三角形（边长 80 像素）\n    // 三角形中心在原点，顶点向上\n    const size = 80;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    // 三个顶点坐标（相对于中心点）\n    const x1 = 0;           // 顶部顶点\n    const y1 = -height * 2/3;\n    \n    const x2 = -size / 2;   // 左下顶点\n    const y2 = height * 1/3;\n    \n    const x3 = size / 2;    // 右下顶点\n    const y3 = height * 1/3;\n    \n    // 绘制填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 设置随机位置（考虑边界，避免三角形超出画布）\n    const margin = 60; // 留出边距\n    graphics.setRandomPosition(\n      margin,\n      margin,\n      config.width - margin * 2,\n      config.height - margin * 2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000324_v1", "prompt_id": "seed_000324", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色矩形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个24像素的黄色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用 fillStyle 设置黄色填充（0xffff00）\n4. 使用 fillRect 在画布中央绘制 24x24 的矩形，计算中心坐标为 (400-12, 300-12)\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n// 预加载函数\nfunction preload() {\n  // 本示例不需要加载外部资源\n}\n\n// 创建函数\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 计算矩形左上角坐标，使其在画布中央\n  // 画布宽度: 800, 高度: 600\n  // 矩形大小: 24x24\n  // 中心点: (800/2, 600/2) = (400, 300)\n  // 左上角: (400 - 24/2, 300 - 24/2) = (388, 288)\n  const rectSize = 24;\n  const x = (config.width / 2) - (rectSize / 2);\n  const y = (config.height / 2) - (rectSize / 2);\n  \n  // 绘制矩形\n  graphics.fillRect(x, y, rectSize, rectSize);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000229_v1", "prompt_id": "seed_000229", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 3 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在3秒内缩放到16%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 scale 属性从 1 到 0.16 再到 1\n4. 设置 Tween 循环播放（loop: -1）和持续时间 3000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setOrigin(0.5, 0.5);\n\n  // 创建缩放动画\n  // 从原始大小 (scale: 1) 缩放到 16% (scale: 0.16)，然后恢复到原始大小\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 1500, // 缩小过程 1.5 秒\n    ease: 'Sine.easeInOut',\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, 'Rectangle scaling to 16% and back', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, 'Loop animation: 3 seconds per cycle', {\n    fontSize: '18px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000358_v3", "prompt_id": "seed_000358", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让黄色六边形在 1 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建黄色六边形淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.add\nSTEPS:\n1. 使用 Graphics 绘制黄色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 参数实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xFFFF00, 1);\n  \n  // 绘制六边形\n  const hexagonRadius = 50;\n  const sides = 6;\n  const angle = (Math.PI * 2) / sides;\n  \n  // 计算六边形顶点\n  const points = [];\n  for (let i = 0; i < sides; i++) {\n    const x = hexagonRadius * Math.cos(angle * i - Math.PI / 2);\n    const y = hexagonRadius * Math.sin(angle * i - Math.PI / 2);\n    points.push(x, y);\n  }\n  \n  // 绘制多边形\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  const textureSize = hexagonRadius * 2 + 10;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexagonSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建淡入淡出 Tween 动画\n  this.tweens.add({\n    targets: hexagonSprite,\n    alpha: 0,              // 目标透明度为 0（完全透明）\n    duration: 1000,        // 持续时间 1 秒\n    yoyo: true,            // 启用往返效果（淡出后再淡入）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 550, '黄色六边形淡入淡出循环动画', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000041_v3", "prompt_id": "seed_000041", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色菱形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色菱形以160速度移动，碰到画布边界时反弹\nAPI: Graphics.fillStyle, Graphics.fillPath, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setBounce, Sprite.setCollideWorldBounds, Sprite.setVelocity\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建启用物理的精灵并应用菱形纹理\n3. 设置精灵速度为160（x和y方向各约113，使合速度为160）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形路径（中心点在32, 32，边长约45像素）\n  const path = new Phaser.Geom.Polygon([\n    32, 0,    // 上顶点\n    64, 32,   // 右顶点\n    32, 64,   // 下顶点\n    0, 32     // 左顶点\n  ]);\n  \n  graphics.fillPoints(path.points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建启用物理的精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置速度（使用勾股定理：160 = sqrt(vx^2 + vy^2)）\n  // vx = vy = 160 / sqrt(2) ≈ 113.137\n  const velocity = 160 / Math.sqrt(2);\n  diamond.setVelocity(velocity, velocity);\n  \n  // 启用世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000171_v1", "prompt_id": "seed_000171", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 青色玩家移出边界时从对侧出现（循环地图效果），移动速度 80。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 青色玩家移出边界时从对侧出现（循环地图效果），移动速度 80\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard.createCursorKeys, Graphics.fillStyle, Graphics.fillCircle, Graphics.generateTexture\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制青色圆形纹理作为玩家\n3. 创建物理精灵并设置移动速度为 80\n4. 监听键盘输入（方向键）控制玩家移动\n5. 在 update 中检测边界，实现循环地图效果（左边界→右边界，上边界→下边界等）\n6. 添加状态信号（记录穿越边界次数作为验证）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet cursors;\nlet boundaryText;\nlet crossCount = 0; // 状态信号：记录穿越边界次数\n\nconst PLAYER_SPEED = 80;\n\nfunction preload() {\n  // 使用 Graphics 创建青色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(16, 16, 16); // 半径 16 的圆形\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家精灵（初始位置在屏幕中心）\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n  \n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  \n  // 添加 WASD 键支持\n  this.wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  this.aKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  this.sKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  this.dKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  \n  // 显示状态信息\n  this.add.text(16, 16, '使用方向键或 WASD 移动', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n  \n  boundaryText = this.add.text(16, 50, '穿越边界次数: 0', {\n    fontSize: '18px',\n    fill: '#00ffff'\n  });\n  \n  // 显示玩家位置（用于调试验证）\n  this.positionText = this.add.text(16, 84, '', {\n    fontSize: '16px',\n    fill: '#aaaaaa'\n  });\n}\n\nfunction update() {\n  // 重置速度\n  player.setVelocity(0);\n  \n  // 处理键盘输入\n  if (cursors.left.isDown || this.aKey.isDown) {\n    player.setVelocityX(-PLAYER_SPEED);\n  } else if (cursors.right.isDown || this.dKey.isDown) {\n    player.setVelocityX(PLAYER_SPEED);\n  }\n  \n  if (cursors.up.isDown || this.wKey.isDown) {\n    player.setVelocityY(-PLAYER_SPEED);\n  } else if (cursors.down.isDown || this.sKey.isDown) {\n    player.setVelocityY(PLAYER_SPEED);\n  }\n  \n  // 循环地图效果：检测边界并从对侧出现\n  const playerRadius = 16; // 玩家半径\n  \n  // 左边界 → 右边界\n  if (player.x < -playerRadius) {\n    player.x = config.width + playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 右边界 → 左边界\n  if (player.x > config.width + playerRadius) {\n    player.x = -playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 上边界 → 下边界\n  if (player.y < -playerRadius) {\n    player.y = config.height + playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 下边界 → 上边界\n  if (player.y > config.height + playerRadius) {\n    player.y = -playerRadius;\n    crossCount++;\n    updateBoundaryText();\n  }\n  \n  // 更新位置显示\n  this.positionText.setText(`位置: (${Math.round(player.x)}, ${Math.round(player.y)})`);\n}\n\nfunction updateBoundaryText() {\n  boundaryText.setText(`穿越边界次数: ${crossCount}`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000857_v1", "prompt_id": "seed_000857", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色星形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色星形在2秒内左右往返循环移动的补间动画\nAPI: Graphics.fillStar, TweenManager.add, Tween.yoyo, Tween.repeat\nSTEPS:\n1. 使用 Graphics 绘制白色星形并生成纹理\n2. 创建 Sprite 对象使用生成的星形纹理\n3. 使用 Tweens 创建 x 轴移动动画，设置 duration 为 2000ms\n4. 设置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制星形 (x, y, points, innerRadius, outerRadius)\n  graphics.fillStar(50, 50, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.sprite(100, 300, 'starTexture');\n  \n  // 创建补间动画：从左到右，2秒，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700,              // 目标 x 坐标（右侧）\n    duration: 2000,      // 持续时间 2 秒\n    yoyo: true,          // 启用往返效果\n    repeat: -1,          // 无限循环 (-1 表示永远重复)\n    ease: 'Linear'       // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000147_v3", "prompt_id": "seed_000147", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色六边形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色六边形以160速度移动并在边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Polygon, Phaser.Physics.Arcade\nSTEPS:\n1. 使用 Graphics 绘制青色六边形并生成纹理\n2. 创建带物理属性的 Sprite 并应用六边形纹理\n3. 设置初始速度为 160，开启边界碰撞反弹\n4. 配置物理世界边界检测和反弹参数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 计算六边形顶点（半径50）\n  const radius = 50;\n  const hexagonPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    hexagonPoints.push({\n      x: radius + Math.cos(angle) * radius,\n      y: radius + Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制青色六边形\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.beginPath();\n  graphics.moveTo(hexagonPoints[0].x, hexagonPoints[0].y);\n  for (let i = 1; i < hexagonPoints.length; i++) {\n    graphics.lineTo(hexagonPoints[i].x, hexagonPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', radius * 2, radius * 2);\n  graphics.destroy();\n  \n  // 创建带物理属性的六边形精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置速度（随机方向，速度为160）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 160);\n  hexagon.setVelocity(velocity.x, velocity.y);\n  \n  // 设置边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  hexagon.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 确保物理世界边界与画布一致\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000376_v1", "prompt_id": "seed_000376", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色六边形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色六边形在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制六边形（中心点为原点）\n  const hexRadius = 40;\n  const hexPath = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角60度\n    const x = hexRadius * Math.cos(angle);\n    const y = hexRadius * Math.sin(angle);\n    hexPath.push(x, y);\n  }\n  \n  graphics.fillPoints(hexPath, true);\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 2000, // 持续时间 2 秒\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动（匀速移动）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000433_v3", "prompt_id": "seed_000433", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色椭圆以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色椭圆以360速度移动并在边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制橙色椭圆并生成纹理\n2. 启用 arcade 物理系统创建物理精灵\n3. 设置初始速度为 360，启用世界边界碰撞和反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆 (中心x, 中心y, 宽度, 高度)\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置速度为 360 (斜向移动，使用勾股定理分解速度)\n  const speed = 360;\n  const angle = Math.PI / 4; // 45度角\n  ellipse.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 启用世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1 (完全弹性碰撞)\n  ellipse.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000432_v2", "prompt_id": "seed_000432", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 240 像素/秒的速度移动\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建 Scene 配置，设置画布尺寸\n2. 在 create 中使用 Graphics 绘制一个方块并生成纹理\n3. 创建 Sprite 或 Rectangle 对象作为可控制的方块\n4. 使用 this.input.keyboard.addKey 监听 WASD 键\n5. 在 update 中根据按键状态更新方块位置，速度为 240 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块，初始位置在画布中心\n  player = this.add.image(400, 300, 'playerBlock');\n\n  // 设置 WASD 键监听\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离 = 速度 * 时间差（转换为秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态移动方块\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n\n  // 限制方块在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000004_v2", "prompt_id": "seed_000004", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 360 像素/秒速度移动\nAPI: Graphics.fillStyle, Graphics.fillPath, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象绘制菱形形状\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态更新菱形位置，应用速度和 delta 时间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 菱形对象\nlet diamond;\n// 键盘控制\nlet keys;\n// 移动速度（像素/秒）\nconst SPEED = 360;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建菱形 Graphics 对象\n  diamond = this.add.graphics();\n  diamond.x = 400; // 初始位置 x\n  diamond.y = 300; // 初始位置 y\n  \n  // 绘制菱形\n  drawDiamond(diamond);\n  \n  // 设置 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离（速度 * 时间，delta 单位是毫秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    diamond.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    diamond.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    diamond.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    diamond.x += distance; // 向右移动\n  }\n  \n  // 边界限制（可选，防止菱形移出屏幕）\n  diamond.x = Phaser.Math.Clamp(diamond.x, 0, 800);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 0, 600);\n}\n\n/**\n * 绘制菱形形状\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n */\nfunction drawDiamond(graphics) {\n  graphics.fillStyle(0x00ff00, 1); // 绿色填充\n  \n  // 菱形的四个顶点坐标（相对于中心点）\n  const size = 40;\n  const path = new Phaser.Geom.Polygon([\n    0, -size,      // 上顶点\n    size, 0,       // 右顶点\n    0, size,       // 下顶点\n    -size, 0       // 左顶点\n  ]);\n  \n  graphics.fillPoints(path.points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000735_v2", "prompt_id": "seed_000735", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的黄色矩形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的黄色矩形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环8次，每次生成随机 x、y 坐标\n4. 设置黄色填充样式(0xffff00)\n5. 在随机位置绘制 24x24 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充样式\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制8个随机位置的矩形\n  for (let i = 0; i < 8; i++) {\n    // 生成随机位置，确保矩形完全在画布内\n    // x 范围: 0 到 (800 - 24)\n    // y 范围: 0 到 (600 - 24)\n    const x = Phaser.Math.Between(0, 800 - 24);\n    const y = Phaser.Math.Between(0, 600 - 24);\n    \n    // 绘制 24x24 的矩形\n    graphics.fillRect(x, y, 24, 24);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000455_v3", "prompt_id": "seed_000455", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 200 像素/秒的速度移动\nAPI: this.input.keyboard.addKey(), this.add.graphics(), this.time.delta\nSTEPS:\n1. 创建 Graphics 对象绘制一个方块并生成纹理\n2. 创建 Sprite 对象作为玩家可控方块\n3. 在 create 中绑定 WASD 四个按键\n4. 在 update 中根据按键状态和 delta 时间计算位移，更新方块位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家方块，初始位置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n  \n  // 绑定 WASD 键\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the block', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n  \n  // 限制方块在屏幕范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000525_v2", "prompt_id": "seed_000525", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色星形在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色星形在 3 秒内完成弹跳动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Star\nSTEPS:\n1. 使用 Graphics 绘制绿色星形纹理\n2. 创建 Star 游戏对象并应用纹理\n3. 使用 Tween 系统创建弹跳动画（y 轴位移 + 缩放效果）\n4. 设置动画时长为 3 秒，使用 yoyo 和 repeat: -1 实现循环弹跳\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建绿色星形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制绿色星形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 18;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵并放置在屏幕中央偏上位置\n  const star = this.add.sprite(400, 200, 'starTexture');\n  \n  // 创建弹跳动画\n  // 使用两个连续的 tween 来实现更真实的弹跳效果\n  this.tweens.add({\n    targets: star,\n    y: 450, // 向下弹跳到的位置\n    scaleY: 0.8, // 落地时垂直压缩\n    scaleX: 1.2, // 落地时水平拉伸\n    duration: 1500, // 下落时间 1.5 秒\n    ease: 'Cubic.easeIn', // 下落加速\n    yoyo: true, // 返回原位\n    repeat: -1, // 无限循环\n    yoyoEase: 'Cubic.easeOut', // 上升减速\n    onYoyo: function() {\n      // 返回时恢复形状\n      star.setScale(1, 1);\n    },\n    onRepeat: function() {\n      // 每次重复时重置形状\n      star.setScale(1, 1);\n    }\n  });\n  \n  // 添加旋转效果让动画更生动\n  this.tweens.add({\n    targets: star,\n    angle: 360,\n    duration: 3000, // 3 秒完成一次旋转\n    repeat: -1,\n    ease: 'Linear'\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 550, '绿色星形弹跳动画 - 3秒循环', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000694_v2", "prompt_id": "seed_000694", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的黄色菱形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的黄色菱形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中循环创建 20 个 Graphics 对象\n3. 使用 fillPath 绘制菱形路径（4个顶点坐标）\n4. 使用 setRandomPosition 设置每个菱形的随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 20 个黄色菱形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为黄色\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制菱形路径（32像素大小）\n    // 菱形中心在原点，四个顶点分别在上下左右\n    const path = new Phaser.Geom.Polygon([\n      0, -16,    // 上顶点\n      16, 0,     // 右顶点\n      0, 16,     // 下顶点\n      -16, 0     // 左顶点\n    ]);\n    \n    // 填充路径\n    graphics.fillPoints(path.points, true);\n    \n    // 设置随机位置（考虑边界，避免菱形超出画布）\n    graphics.setRandomPosition(16, 16, 800 - 32, 600 - 32);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000529_v2", "prompt_id": "seed_000529", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 80 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), graphics.fillStyle(), graphics.beginPath(), graphics.moveTo(), graphics.lineTo(), graphics.closePath(), graphics.fillPath()\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 添加 WASD 键盘输入监听\n4. 在 update 中根据按键状态更新菱形位置（速度 80 像素/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 使用 Graphics 创建菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制菱形（中心点在 32, 32，大小 64x64）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 上顶点\n  graphics.lineTo(64, 32);     // 右顶点\n  graphics.lineTo(32, 64);     // 下顶点\n  graphics.lineTo(0, 32);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，放置在屏幕中央\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 添加 WASD 键盘输入\n  keys = {\n    w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the diamond', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离（速度 * 时间）\n  // delta 是毫秒，需要转换为秒\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测 WASD 按键状态并设置速度方向\n  if (keys.w.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.s.isDown) {\n    velocityY = 1;  // 向下\n  }\n  if (keys.a.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.d.isDown) {\n    velocityX = 1;  // 向右\n  }\n  \n  // 如果同时按下两个方向键，需要归一化速度向量\n  if (velocityX !== 0 && velocityY !== 0) {\n    // 使用勾股定理归一化，保持对角线移动速度一致\n    const normalizer = Math.sqrt(2);\n    velocityX /= normalizer;\n    velocityY /= normalizer;\n  }\n  \n  // 更新菱形位置\n  diamond.x += velocityX * distance;\n  diamond.y += velocityY * distance;\n  \n  // 限制菱形在屏幕范围内\n  diamond.x = Phaser.Math.Clamp(diamond.x, 32, 768);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 32, 568);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000051_v3", "prompt_id": "seed_000051", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色椭圆以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色椭圆以120速度移动并在画布边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser Game 配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制绿色椭圆并生成纹理\n3. 创建物理精灵，应用椭圆纹理\n4. 设置初始速度为120，启用世界边界碰撞和反弹\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet ellipse;\nconst SPEED = 120;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制椭圆 (中心在原点，宽60，高40)\n  const ellipseWidth = 60;\n  const ellipseHeight = 40;\n  graphics.fillEllipse(ellipseWidth / 2, ellipseHeight / 2, ellipseWidth / 2, ellipseHeight / 2);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTex', ellipseWidth, ellipseHeight);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  ellipse = this.physics.add.sprite(400, 300, 'ellipseTex');\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 设置初始速度（斜向移动）\n  const angle = Phaser.Math.DegToRad(45); // 45度角\n  ellipse.setVelocity(\n    Math.cos(angle) * SPEED,\n    Math.sin(angle) * SPEED\n  );\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为120\n  const currentVelocity = ellipse.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  // 如果速度发生变化，重新归一化到120\n  if (Math.abs(currentSpeed - SPEED) > 0.1) {\n    const scale = SPEED / currentSpeed;\n    ellipse.setVelocity(\n      currentVelocity.x * scale,\n      currentVelocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000275_v3", "prompt_id": "seed_000275", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 3 个白色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成3个白色可收集物体，玩家碰到后消失并加分，显示score\nAPI: Phaser.Physics.Arcade.Factory#sprite, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Graphics#generateTexture\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制玩家和收集物纹理（玩家用绿色矩形，收集物用白色圆形）\n3. 创建玩家物理精灵，添加键盘控制\n4. 创建物理组，生成3个白色收集物随机分布在场景中\n5. 添加 overlap 碰撞检测，碰撞时销毁收集物并增加分数\n6. 创建文本对象显示当前分数，每次收集后更新显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（绿色矩形）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（白色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0xffffff, 1);\n  collectibleGraphics.fillCircle(15, 15, 15);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 生成3个收集物，随机位置\n  const positions = [\n    { x: 200, y: 150 },\n    { x: 600, y: 450 },\n    { x: 400, y: 100 }\n  ];\n\n  positions.forEach(pos => {\n    const collectible = collectibles.create(pos.x, pos.y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    // 添加轻微漂浮动画\n    this.tweens.add({\n      targets: collectible,\n      y: collectible.y - 10,\n      duration: 1000,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  });\n\n  // 添加碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect White Circles', {\n    fontSize: '18px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  player.setVelocity(0);\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  }\n\n  // 检查是否收集完所有物品\n  if (score === 3 && collectibles.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - All Collected!');\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 1;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 添加收集特效（简单的粒子效果）\n  const particle = this.add.graphics();\n  particle.fillStyle(0xffffff, 1);\n  particle.fillCircle(collectible.x, collectible.y, 5);\n\n  this.tweens.add({\n    targets: particle,\n    alpha: 0,\n    scale: 3,\n    duration: 500,\n    onComplete: () => {\n      particle.destroy();\n    }\n  });\n}\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000935_v1", "prompt_id": "seed_000935", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2秒内缩放到16%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale 从 1 到 0.16 再到 1）\n4. 设置 Tween 的 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rect', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建矩形精灵，放置在屏幕中心\n  const rectangle = this.add.sprite(400, 300, 'rect');\n  \n  // 创建缩放动画\n  // yoyo: true 表示动画会反向播放（缩小后放大）\n  // repeat: -1 表示无限循环\n  // duration: 2000 表示单程2秒（缩小到16%需要2秒，恢复也需要2秒）\n  this.tweens.add({\n    targets: rectangle,\n    scaleX: 0.16,\n    scaleY: 0.16,\n    duration: 2000,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Linear'\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Rectangle scaling to 16% and back (2s each way)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000327_v2", "prompt_id": "seed_000327", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的橙色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的橙色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中循环5次创建 Graphics 对象\n3. 为每个 Graphics 设置橙色填充样式\n4. 使用 fillTriangle 绘制等边三角形（16像素大小）\n5. 使用 setRandomPosition 将三角形随机分布在画布上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建5个随机位置的橙色三角形\n  for (let i = 0; i < 5; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置橙色填充\n    graphics.fillStyle(0xFFA500, 1);\n    \n    // 绘制等边三角形（大小16像素）\n    // 三角形顶点坐标：顶部中心点为原点\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n    \n    graphics.fillTriangle(\n      0, -height * 2/3,           // 顶点（居中）\n      -size / 2, height * 1/3,    // 左下顶点\n      size / 2, height * 1/3      // 右下顶点\n    );\n    \n    // 设置随机位置（确保三角形在画布范围内）\n    graphics.setRandomPosition(\n      size, \n      size, \n      config.width - size * 2, \n      config.height - size * 2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000348_v2", "prompt_id": "seed_000348", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色圆形在 3 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色圆形，使用 tween 动画实现 3 秒抖动循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制青色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现抖动效果（随机偏移 x/y 坐标）\n4. 设置 yoyo 和 loop 实现循环抖动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(50, 50, 50); // 半径 50 的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy();\n  \n  // 创建 Sprite\n  const circle = this.add.sprite(400, 300, 'circle');\n  \n  // 创建抖动动画\n  // 使用多个 tween 组合实现抖动效果\n  this.tweens.add({\n    targets: circle,\n    x: '+=10', // 向右偏移\n    y: '+=8',  // 向下偏移\n    duration: 50,\n    yoyo: true,\n    repeat: -1, // 无限重复\n    repeatDelay: 0\n  });\n  \n  // 添加另一个方向的抖动\n  this.tweens.add({\n    targets: circle,\n    x: '-=8',\n    y: '+=10',\n    duration: 70,\n    yoyo: true,\n    repeat: -1,\n    repeatDelay: 0\n  });\n  \n  // 添加旋转抖动\n  this.tweens.add({\n    targets: circle,\n    angle: 5,\n    duration: 100,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 主控制 tween，控制整体 3 秒循环\n  this.tweens.add({\n    targets: circle,\n    scale: 1.05,\n    duration: 1500,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加提示文字\n  this.add.text(400, 500, '抖动动画循环中...', {\n    fontSize: '24px',\n    color: '#00ffff',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000080_v3", "prompt_id": "seed_000080", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色矩形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个32像素的粉色矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为粉色（0xff69b4）\n4. 在画布中央 (400-16, 300-16) 位置绘制 32x32 的矩形\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 绘制粉色矩形\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为粉色 (RGB: 255, 105, 180)\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 计算画布中央位置，使矩形居中\n  // 画布宽度: 800, 高度: 600\n  // 矩形大小: 32x32\n  // 中心位置: (800/2 - 32/2, 600/2 - 32/2) = (384, 284)\n  const centerX = config.width / 2 - 16;\n  const centerY = config.height / 2 - 16;\n  \n  // 绘制 32x32 的粉色矩形\n  graphics.fillRect(centerX, centerY, 32, 32);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000586_v1", "prompt_id": "seed_000586", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右下移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右下移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, this.add.star\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个星形纹理\n2. 创建星形游戏对象并设置初始位置\n3. 在 update 中让星形持续向右下移动\n4. 使用 camera.startFollow 让相机跟随星形对象\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet star;\nconst MOVE_SPEED = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  createGrid.call(this);\n  \n  // 使用 Graphics 创建星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  graphics.lineStyle(2, 0xff6600, 1);\n  \n  // 绘制星形（使用路径）\n  const points = 5;\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const centerX = 40;\n  const centerY = 40;\n  \n  graphics.beginPath();\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 80, 80);\n  graphics.destroy();\n  \n  // 创建星形精灵对象，初始位置在左上角\n  star = this.add.sprite(100, 100, 'starTexture');\n  \n  // 设置相机跟随星形对象\n  this.cameras.main.startFollow(star, true, 0.1, 0.1);\n  \n  // 设置相机边界，让相机可以在更大的世界中移动\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  \n  // 添加提示文字（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随星形移动', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让星形持续向右下移动\n  if (star) {\n    star.x += MOVE_SPEED;\n    star.y += MOVE_SPEED;\n    \n    // 让星形旋转，增加视觉效果\n    star.rotation += 0.02;\n  }\n}\n\n// 辅助函数：创建网格背景\nfunction createGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  const gridSize = 100;\n  const worldWidth = 2000;\n  const worldHeight = 2000;\n  \n  // 绘制垂直线\n  for (let x = 0; x <= worldWidth; x += gridSize) {\n    graphics.lineBetween(x, 0, x, worldHeight);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= worldHeight; y += gridSize) {\n    graphics.lineBetween(0, y, worldWidth, y);\n  }\n  \n  // 在每个网格交点添加坐标标记\n  const textStyle = {\n    fontSize: '12px',\n    color: '#00ff00',\n    backgroundColor: '#000000'\n  };\n  \n  for (let x = 0; x <= worldWidth; x += gridSize * 2) {\n    for (let y = 0; y <= worldHeight; y += gridSize * 2) {\n      this.add.text(x + 5, y + 5, `${x},${y}`, textStyle);\n    }\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000659_v1", "prompt_id": "seed_000659", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8733333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按WASD键发射子弹，速度 160，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现WASD四方向射击系统，子弹速度160，击中敌人后敌人消失并统计击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建玩家精灵和敌人群组，使用Graphics绘制纹理\n2. 设置WASD键盘输入监听，按键时发射对应方向的子弹\n3. 创建子弹群组，设置速度为160，超出边界自动销毁\n4. 添加子弹与敌人的碰撞检测，命中时销毁敌人和子弹，增加击杀数\n5. 在屏幕上显示击杀数文本\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 生成初始敌人\n    this.spawnEnemies();\n\n    // 设置WASD键\n    this.keys = {\n      w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n      a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n      s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n      d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n    };\n\n    // 设置射击冷却时间\n    this.lastFireTime = 0;\n    this.fireDelay = 200; // 200ms冷却\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数文本\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.killText.setScrollFactor(0);\n    this.killText.setDepth(100);\n\n    // 添加说明文本\n    this.add.text(16, 50, 'WASD to shoot', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  update(time, delta) {\n    // 检测WASD键射击\n    if (time > this.lastFireTime + this.fireDelay) {\n      if (this.keys.w.isDown) {\n        this.fireBullet(0, -1); // 向上\n        this.lastFireTime = time;\n      } else if (this.keys.s.isDown) {\n        this.fireBullet(0, 1); // 向下\n        this.lastFireTime = time;\n      } else if (this.keys.a.isDown) {\n        this.fireBullet(-1, 0); // 向左\n        this.lastFireTime = time;\n      } else if (this.keys.d.isDown) {\n        this.fireBullet(1, 0); // 向右\n        this.lastFireTime = time;\n      }\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -10 || bullet.x > 810 || \n            bullet.y < -10 || bullet.y > 610) {\n          bullet.destroy();\n        }\n      }\n    });\n\n    // 随机生成新敌人\n    if (Phaser.Math.Between(0, 100) < 2 && this.enemies.countActive() < 10) {\n      this.spawnEnemy();\n    }\n  }\n\n  fireBullet(dirX, dirY) {\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y, 'bullet');\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 设置子弹速度为160\n      bullet.body.velocity.x = dirX * 160;\n      bullet.body.velocity.y = dirY * 160;\n    }\n  }\n\n  spawnEnemies() {\n    // 初始生成5个敌人\n    for (let i = 0; i < 5; i++) {\n      this.spawnEnemy();\n    }\n  }\n\n  spawnEnemy() {\n    // 随机位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 确保不在玩家附近生成\n    const distance = Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y);\n    if (distance < 100) {\n      return; // 太近则不生成\n    }\n    \n    const enemy = this.enemies.create(x, y, 'enemy');\n    enemy.setVelocity(\n      Phaser.Math.Between(-50, 50),\n      Phaser.Math.Between(-50, 50)\n    );\n    enemy.setBounce(1);\n    enemy.setCollideWorldBounds(true);\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 销毁子弹和敌人\n    bullet.destroy();\n    enemy.destroy();\n    \n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n    \n    // 生成新敌人保持数量\n    if (this.enemies.countActive() < 3) {\n      this.spawnEnemy();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000874_v3", "prompt_id": "seed_000874", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 200 像素/秒的速度移动\nAPI: this.input.keyboard.addKey, this.add.graphics, graphics.fillRect, graphics.generateTexture\nSTEPS:\n1. 创建 Graphics 对象并绘制方块纹理\n2. 使用 add.sprite 创建可移动的方块精灵\n3. 通过 addKey 绑定 WASD 四个按键\n4. 在 update 中根据按键状态更新方块位置（速度 200px/s）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keys = {};\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块精灵，放置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n\n  // 绑定 WASD 键\n  keys.W = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keys.A = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keys.S = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keys.D = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态移动方块\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n\n  // 限制方块在屏幕范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000525_v1", "prompt_id": "seed_000525", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色方块在 1 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色方块，使用 Tween 实现 1 秒抖动循环动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制灰色方块并生成纹理\n2. 创建 Sprite 对象作为抖动目标\n3. 使用 tweens.add 创建抖动动画（x/y 轴随机偏移）\n4. 设置 yoyo 和 repeat 实现循环抖动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x888888, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('grayBox', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建灰色方块精灵，放置在屏幕中央\n  const box = this.add.sprite(400, 300, 'grayBox');\n  \n  // 创建抖动动画\n  this.tweens.add({\n    targets: box,\n    // 在 x 和 y 方向上随机抖动\n    x: {\n      from: 400,\n      to: 400,\n      ease: 'Sine.easeInOut',\n      duration: 50,\n      yoyo: true,\n      repeat: 9, // 50ms * 2(yoyo) * 10(repeat+1) = 1000ms\n      onUpdate: function(tween, target) {\n        // 每次更新时添加随机偏移实现抖动效果\n        const progress = tween.progress;\n        if (progress > 0 && progress < 1) {\n          target.x = 400 + Phaser.Math.Between(-5, 5);\n          target.y = 300 + Phaser.Math.Between(-5, 5);\n        }\n      }\n    },\n    // 1 秒完成一次抖动循环\n    duration: 1000,\n    repeat: -1, // 无限循环\n    onRepeat: function(tween, target) {\n      // 每次循环重置位置\n      target.x = 400;\n      target.y = 300;\n    }\n  });\n  \n  // 更简洁的抖动实现方式\n  // 使用定时器每帧随机偏移\n  this.time.addEvent({\n    delay: 50, // 每 50ms 抖动一次\n    callback: () => {\n      // 在 1 秒周期内抖动\n      const elapsed = this.time.now % 1000;\n      if (elapsed < 1000) {\n        box.x = 400 + Phaser.Math.Between(-8, 8);\n        box.y = 300 + Phaser.Math.Between(-8, 8);\n      }\n    },\n    loop: true\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000711_v2", "prompt_id": "seed_000711", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8816666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的绿色三角形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的绿色三角形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillTriangle, Graphics#fillStyle, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环20次，每次生成随机坐标位置\n4. 使用 fillTriangle 绘制等边三角形，计算三个顶点坐标\n5. 设置绿色填充样式，每个三角形大小为32像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 三角形的大小（边长）\n  const triangleSize = 32;\n  \n  // 计算等边三角形的高度\n  const height = (Math.sqrt(3) / 2) * triangleSize;\n  \n  // 绘制20个随机位置的三角形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置，确保三角形完全在画布内\n    const x = Phaser.Math.Between(triangleSize, config.width - triangleSize);\n    const y = Phaser.Math.Between(triangleSize, config.height - triangleSize);\n    \n    // 计算等边三角形的三个顶点坐标（顶点朝上）\n    const x1 = x;                           // 顶点\n    const y1 = y - height / 2;\n    \n    const x2 = x - triangleSize / 2;        // 左下角\n    const y2 = y + height / 2;\n    \n    const x3 = x + triangleSize / 2;        // 右下角\n    const y3 = y + height / 2;\n    \n    // 绘制填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000303_v3", "prompt_id": "seed_000303", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色椭圆以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色椭圆以360速度移动并在画布边界反弹\nAPI: Graphics, arcade, physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser 游戏配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制橙色椭圆并生成纹理\n3. 创建物理精灵，设置初始速度为 360\n4. 设置物理边界碰撞和反弹属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillEllipse(40, 30, 80, 60); // 绘制椭圆\n  \n  // 生成纹理\n  graphics.generateTexture('orangeEllipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const ellipse = this.physics.add.sprite(400, 300, 'orangeEllipse');\n  \n  // 设置速度（360 像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 360);\n  ellipse.setVelocity(velocity.x, velocity.y);\n  \n  // 设置边界碰撞\n  ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, 'Orange Ellipse bouncing at 360 speed', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000432_v1", "prompt_id": "seed_000432", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色三角形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现粉色三角形在4秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Graphics 对象绘制粉色三角形\n2. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n3. 配置 duration 为 4000ms，yoyo 为 true 实现往返，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制粉色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制三角形（使用三个顶点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-25, 30);     // 左下角\n  graphics.lineTo(25, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置初始位置（左侧，垂直居中）\n  graphics.x = 100;\n  graphics.y = 300;\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: graphics,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 4000,            // 持续时间 4 秒\n    yoyo: true,                // 启用往返效果（到达终点后反向返回）\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    ease: 'Linear'             // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000728_v2", "prompt_id": "seed_000728", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画让 alpha 属性从 0 变化到 1，持续 1 秒\n4. 设置 Tween 的 yoyo 和 repeat 属性实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建 Sprite 并设置到屏幕中心\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 1000,            // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 反向播放（从 1 回到 0）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '方块透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000386_v2", "prompt_id": "seed_000386", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 200 像素/秒的速度移动\nAPI: Graphics.fillStyle, Graphics.fillPoints, Input.Keyboard.addKeys, GameObject.setPosition\nSTEPS:\n1. 创建 Graphics 对象绘制六边形形状\n2. 使用 addKeys 监听 WASD 键盘输入\n3. 在 update 中根据按键状态计算速度向量\n4. 根据 delta 时间更新六边形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建六边形 Graphics 对象\n  hexagon = this.add.graphics();\n  hexagon.x = 400;\n  hexagon.y = 300;\n  \n  // 绘制六边形\n  drawHexagon(hexagon, 0, 0, 40);\n  \n  // 设置 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算速度向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  if (keys.a.isDown) {\n    velocityX = -1;\n  } else if (keys.d.isDown) {\n    velocityX = 1;\n  }\n  \n  if (keys.w.isDown) {\n    velocityY = -1;\n  } else if (keys.s.isDown) {\n    velocityY = 1;\n  }\n  \n  // 归一化对角线移动速度（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 根据 delta 时间更新位置 (delta 单位是毫秒)\n  hexagon.x += velocityX * SPEED * (delta / 1000);\n  hexagon.y += velocityY * SPEED * (delta / 1000);\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} centerX - 中心 X 坐标\n * @param {number} centerY - 中心 Y 坐标\n * @param {number} radius - 半径\n */\nfunction drawHexagon(graphics, centerX, centerY, radius) {\n  const points = [];\n  \n  // 计算六边形的 6 个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60 度间隔\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制填充六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 绘制边框\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokePath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000387_v3", "prompt_id": "seed_000387", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形并以每秒120度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene\nSTEPS:\n1. 使用 Graphics 绘制一个菱形形状\n2. 将 Graphics 添加到 Container 中以便于旋转控制\n3. 在 update 方法中根据 delta 时间累加旋转角度（120度/秒 = 2.094弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色和边框\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制菱形（四个顶点）\n  const size = 80;\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 将 graphics 放入容器中，方便旋转\n  diamond = this.add.container(400, 300);\n  diamond.add(graphics);\n  \n  // 添加中心点标记（可选，便于观察旋转中心）\n  const center = this.add.graphics();\n  center.fillStyle(0xff0000, 1);\n  center.fillCircle(0, 0, 5);\n  diamond.add(center);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 120 度\n  // 120 度 = 120 * (Math.PI / 180) = 2.0944 弧度\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = Phaser.Math.DegToRad(120); // 弧度/秒\n  const deltaSeconds = delta / 1000; // 转换为秒\n  \n  // 累加旋转角度\n  diamond.rotation += rotationSpeed * deltaSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000645_v3", "prompt_id": "seed_000645", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 灰色玩家移出边界时从对侧出现，移动速度160\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), sprite.setVelocity(), Graphics.fillRect(), Graphics.generateTexture()\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制灰色方块并生成纹理作为玩家\n3. 创建物理精灵并设置键盘控制（方向键）\n4. 在 update 中检测边界，实现循环地图效果（左->右，右->左，上->下，下->上）\n5. 添加位置状态变量用于验证循环效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossCount = 0; // 穿越边界次数（状态信号）\n  }\n\n  preload() {\n    // 使用 Graphics 创建灰色玩家纹理\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建玩家精灵（使用物理系统）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n    \n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n    \n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n    \n    // 处理键盘输入\n    if (this.cursors.left.isDown || this.keys.a.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown || this.keys.d.isDown) {\n      this.player.setVelocityX(160);\n    }\n    \n    if (this.cursors.up.isDown || this.keys.w.isDown) {\n      this.player.setVelocityY(-160);\n    } else if (this.cursors.down.isDown || this.keys.s.isDown) {\n      this.player.setVelocityY(160);\n    }\n    \n    // 循环地图效果 - 检测边界并从对侧出现\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    \n    // 左边界 -> 右边界\n    if (this.player.x < -playerWidth / 2) {\n      this.player.x = this.game.config.width + playerWidth / 2;\n      this.crossCount++;\n      this.updateStatusText();\n    }\n    \n    // 右边界 -> 左边界\n    if (this.player.x > this.game.config.width + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      this.crossCount++;\n      this.updateStatusText();\n    }\n    \n    // 上边界 -> 下边界\n    if (this.player.y < -playerHeight / 2) {\n      this.player.y = this.game.config.height + playerHeight / 2;\n      this.crossCount++;\n      this.updateStatusText();\n    }\n    \n    // 下边界 -> 上边界\n    if (this.player.y > this.game.config.height + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      this.crossCount++;\n      this.updateStatusText();\n    }\n  }\n  \n  updateStatusText() {\n    this.statusText.setText([\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `Cross Count: ${this.crossCount}`,\n      `Speed: 160`,\n      ``,\n      `Controls: Arrow Keys or WASD`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000913_v1", "prompt_id": "seed_000913", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2秒内缩放到80%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状并生成纹理\n2. 创建 Sprite 对象使用生成的椭圆纹理\n3. 使用 Tween 动画控制 Sprite 的 scale 属性，从 1 缩放到 0.8\n4. 设置 Tween 的 yoyo 为 true 实现往返效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制椭圆（中心点在 0,0，宽度 120，高度 80）\n  graphics.fillEllipse(60, 40, 120, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建椭圆精灵对象，放置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    scaleX: 0.8,                // X 轴缩放到 80%\n    scaleY: 0.8,                // Y 轴缩放到 80%\n    duration: 2000,             // 动画持续时间 2 秒（单程）\n    ease: 'Sine.easeInOut',     // 缓动函数，使动画更平滑\n    yoyo: true,                 // 往返播放（缩小后再放大）\n    loop: -1                    // 无限循环（-1 表示永久循环）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Ellipse scaling animation (80% - 100%)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000511_v3", "prompt_id": "seed_000511", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色三角形在 1 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色三角形，使用 Tween 实现 1 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建抖动动画，通过快速改变 x 坐标实现抖动\n4. 设置 yoyo 和 loop 参数实现循环抖动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建青色三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制青色三角形\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.beginPath();\n  graphics.moveTo(50, 10); // 顶点\n  graphics.lineTo(10, 90); // 左下\n  graphics.lineTo(90, 90); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵，放置在屏幕中央\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建抖动动画\n  this.tweens.add({\n    targets: triangle,\n    x: '+=10', // 向右移动 10 像素\n    duration: 50, // 每次抖动 50 毫秒\n    ease: 'Linear',\n    yoyo: true, // 往返运动\n    repeat: 9, // 重复 9 次（加上初始 1 次，共 10 次往返 = 1 秒）\n    loop: -1 // 无限循环\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '青色三角形抖动动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000323_v1", "prompt_id": "seed_000323", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 2.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让星形在 2.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个使用该纹理的精灵对象，初始 alpha 设为 0\n3. 使用 tweens.add 创建透明度补间动画，从 0 到 1，持续 2.5 秒\n4. 设置 repeat: -1 使动画无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色星形\n  \n  // 绘制五角星\n  const centerX = 64;\n  const centerY = 64;\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const points = 5;\n  \n  const path = [];\n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    path.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  graphics.fillPoints(path, true);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 128, 128);\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 设置初始透明度为 0（完全透明）\n  star.setAlpha(0);\n  \n  // 创建透明度渐变补间动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    alpha: 1,                // 目标透明度：完全不透明\n    duration: 2500,          // 持续时间：2.5 秒（2500 毫秒）\n    ease: 'Linear',          // 线性缓动\n    repeat: -1,              // 无限循环\n    yoyo: true               // 往返播放（透明→不透明→透明）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000426_v3", "prompt_id": "seed_000426", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色六边形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色六边形以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#fillPoints, Phaser.GameObjects.Graphics#generateTexture, Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.World#setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制橙色六边形并生成纹理\n2. 创建启用物理的精灵并应用六边形纹理\n3. 设置精灵初始速度为360（随机方向）\n4. 启用世界边界碰撞和反弹\n5. 在 update 中保持速度恒定为360\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 使用 Graphics 创建六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 计算六边形的顶点（中心在 32,32，半径 30）\n  const radius = 30;\n  const centerX = 32;\n  const centerY = 32;\n  const points = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 6; // 从顶部开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 绘制六边形\n  graphics.fillPoints(points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 64, 64);\n  \n  // 清理 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建带物理属性的六边形精灵\n  hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置世界边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 设置初始速度（随机方向，速度为360）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 360);\n  hexagon.setVelocity(velocity.x, velocity.y);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为360\n  const currentVelocity = hexagon.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  // 如果速度不是360，进行归一化并重新设置\n  if (Math.abs(currentSpeed - 360) > 0.1) {\n    const normalizedX = (currentVelocity.x / currentSpeed) * 360;\n    const normalizedY = (currentVelocity.y / currentSpeed) * 360;\n    hexagon.setVelocity(normalizedX, normalizedY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000562_v2", "prompt_id": "seed_000562", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在0.5秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 系统创建缩放动画，设置 scale 从 1 到 0.32 再到 1\n4. 设置 Tween 的 duration 为 500ms，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 64）\n  const size = 64;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 上顶点\n  graphics.lineTo(size * 2, size);    // 右顶点\n  graphics.lineTo(size, size * 2);    // 下顶点\n  graphics.lineTo(0, size);           // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.32,\n    scaleY: 0.32,\n    duration: 500,      // 0.5秒缩小到32%\n    yoyo: true,         // 自动返回原始值\n    repeat: -1,         // 无限循环\n    ease: 'Linear'      // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Diamond scaling to 32% and back', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000408_v3", "prompt_id": "seed_000408", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色菱形在 4 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色菱形，使用 Tween 实现 4 秒抖动循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制灰色菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 创建抖动效果（快速往复位移）\n4. 设置 Tween 持续时间为 4 秒并循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建灰色菱形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（钻石形状）\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建抖动动画效果\n  // 抖动效果：快速左右和上下微小位移\n  this.tweens.add({\n    targets: diamond,\n    x: {\n      from: 400,\n      to: 400,\n      duration: 4000,\n      ease: 'Linear'\n    },\n    y: {\n      from: 300,\n      to: 300,\n      duration: 4000,\n      ease: 'Linear'\n    },\n    // 使用 yoyo 和 repeat 创建抖动效果\n    // 通过快速的位置变化模拟抖动\n    onUpdate: function(tween, target) {\n      // 在 4 秒内创建抖动效果\n      const progress = tween.progress;\n      const time = progress * 4000;\n      \n      // 使用正弦波创建抖动效果，频率逐渐增加\n      const frequency = 20; // 抖动频率\n      const amplitude = 5;  // 抖动幅度\n      \n      const offsetX = Math.sin(time * frequency * 0.01) * amplitude;\n      const offsetY = Math.cos(time * frequency * 0.01) * amplitude;\n      \n      target.x = 400 + offsetX;\n      target.y = 300 + offsetY;\n    },\n    loop: -1, // 无限循环\n    duration: 4000\n  });\n  \n  // 添加提示文字\n  const text = this.add.text(400, 500, '抖动动画 (4秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000411_v2", "prompt_id": "seed_000411", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色三角形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色三角形，大小约为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.graphics() 创建 Graphics 对象\n3. 使用 fillStyle 设置蓝色填充 (0x0000ff)\n4. 计算画布中心点坐标 (400, 300)\n5. 使用 fillTriangle 绘制等边三角形，顶点相对中心点偏移约16像素\n6. 可选：添加描边使三角形更清晰\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 绘制蓝色三角形\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  \n  // 设置三角形大小（从中心点的偏移距离）\n  const size = 16;\n  \n  // 计算等边三角形的三个顶点坐标\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - size;\n  \n  // 顶点2：左下角\n  const x2 = centerX - size;\n  const y2 = centerY + size;\n  \n  // 顶点3：右下角\n  const x3 = centerX + size;\n  const y3 = centerY + size;\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  \n  // 可选：添加白色描边使三角形轮廓更清晰\n  graphics.lineStyle(2, 0xffffff, 1);\n  graphics.strokeTriangle(x1, y1, x2, y2, x3, y3);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000616_v3", "prompt_id": "seed_000616", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色椭圆，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色椭圆，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充样式为红色\n4. 使用 fillEllipse 在画布中央 (400, 300) 绘制椭圆，半径约为 16 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心坐标\n  // width 和 height 是椭圆的宽度和高度（直径）\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  const ellipseWidth = 16;\n  const ellipseHeight = 16;\n  \n  graphics.fillEllipse(centerX, centerY, ellipseWidth, ellipseHeight);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000477_v3", "prompt_id": "seed_000477", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个基于 8x8 数组的简单 Tilemap：0 为空，1 为墙可碰撞，玩家用方向键移动且不能穿墙。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tilemaps.Tilemap\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现8x8瓦片地图，玩家方向键移动且不能穿墙\nAPI: Phaser.Tilemaps.Tilemap, Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建8x8数组地图数据，0为空地，1为墙\n2. 使用Graphics生成瓦片纹理（空地和墙）\n3. 创建Tilemap并设置碰撞属性\n4. 创建玩家精灵并启用物理系统\n5. 设置玩家与墙的碰撞检测\n6. 监听方向键输入控制玩家移动\n7. 添加状态变量记录玩家位置和移动次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.moveCount = 0; // 可验证的状态信号：移动次数\n    this.playerGridX = 1; // 可验证的状态信号：玩家网格X坐标\n    this.playerGridY = 1; // 可验证的状态信号：玩家网格Y坐标\n  }\n\n  preload() {\n    // 创建空地纹理（浅灰色）\n    const floorGraphics = this.add.graphics();\n    floorGraphics.fillStyle(0xcccccc, 1);\n    floorGraphics.fillRect(0, 0, 64, 64);\n    floorGraphics.lineStyle(2, 0x999999, 1);\n    floorGraphics.strokeRect(0, 0, 64, 64);\n    floorGraphics.generateTexture('floor', 64, 64);\n    floorGraphics.destroy();\n\n    // 创建墙纹理（深灰色）\n    const wallGraphics = this.add.graphics();\n    wallGraphics.fillStyle(0x333333, 1);\n    wallGraphics.fillRect(0, 0, 64, 64);\n    wallGraphics.lineStyle(2, 0x000000, 1);\n    wallGraphics.strokeRect(0, 0, 64, 64);\n    wallGraphics.generateTexture('wall', 64, 64);\n    wallGraphics.destroy();\n\n    // 创建玩家纹理（蓝色圆形）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillCircle(28, 28, 24);\n    playerGraphics.lineStyle(3, 0x0044cc, 1);\n    playerGraphics.strokeCircle(28, 28, 24);\n    playerGraphics.generateTexture('player', 56, 56);\n    playerGraphics.destroy();\n  }\n\n  create() {\n    // 定义8x8地图数据（0=空地，1=墙）\n    const mapData = [\n      [1, 1, 1, 1, 1, 1, 1, 1],\n      [1, 0, 0, 0, 0, 0, 0, 1],\n      [1, 0, 1, 1, 1, 0, 0, 1],\n      [1, 0, 0, 0, 1, 0, 0, 1],\n      [1, 0, 0, 0, 1, 1, 0, 1],\n      [1, 0, 1, 0, 0, 0, 0, 1],\n      [1, 0, 0, 0, 0, 0, 0, 1],\n      [1, 1, 1, 1, 1, 1, 1, 1]\n    ];\n\n    // 创建Tilemap\n    const map = this.make.tilemap({\n      data: mapData,\n      tileWidth: 64,\n      tileHeight: 64\n    });\n\n    // 添加瓦片集\n    const tiles = map.addTilesetImage('tiles', null, 64, 64, 0, 0);\n    \n    // 手动设置瓦片纹理\n    map.tiles.forEach((row, y) => {\n      row.forEach((tile, x) => {\n        if (tile.index === 0) {\n          this.add.image(x * 64 + 32, y * 64 + 32, 'floor');\n        } else if (tile.index === 1) {\n          this.add.image(x * 64 + 32, y * 64 + 32, 'wall');\n        }\n      });\n    });\n\n    // 创建图层（用于碰撞检测）\n    const layer = map.createLayer(0, tiles, 0, 0);\n    \n    // 设置索引为1的瓦片（墙）为可碰撞\n    layer.setCollisionByProperty({ collides: true });\n    map.setCollision(1);\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(96, 96, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(48, 48);\n    this.player.setDepth(10);\n\n    // 设置玩家与地图图层的碰撞\n    this.physics.add.collider(this.player, layer);\n\n    // 创建方向键输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加WASD键支持\n    this.keys = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(16, 520, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setDepth(100);\n\n    this.updateStatus();\n\n    // 添加说明文字\n    this.add.text(16, 16, 'Use Arrow Keys or WASD to move', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 8, y: 4 }\n    }).setDepth(100);\n  }\n\n  update(time, delta) {\n    const speed = 200;\n    \n    // 重置速度\n    this.player.setVelocity(0);\n\n    let moved = false;\n\n    // 处理左右移动\n    if (this.cursors.left.isDown || this.keys.left.isDown) {\n      this.player.setVelocityX(-speed);\n      moved = true;\n    } else if (this.cursors.right.isDown || this.keys.right.isDown) {\n      this.player.setVelocityX(speed);\n      moved = true;\n    }\n\n    // 处理上下移动\n    if (this.cursors.up.isDown || this.keys.up.isDown) {\n      this.player.setVelocityY(-speed);\n      moved = true;\n    } else if (this.cursors.down.isDown || this.keys.down.isDown) {\n      this.player.setVelocityY(speed);\n      moved = true;\n    }\n\n    // 更新玩家网格位置\n    const newGridX = Math.floor(this.player.x / 64);\n    const newGridY = Math.floor(this.player.y / 64);\n\n    if (newGridX !== this.playerGridX || newGridY !== this.playerGridY) {\n      this.playerGridX = newGridX;\n      this.playerGridY = newGridY;\n      this.moveCount++;\n      this.updateStatus();\n    }\n  }\n\n  updateStatus() {\n    this.statusText.setText(\n      `Position: (${this.playerGridX}, ${this.playerGridY}) | Moves: ${this.moveCount}`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 512,\n  height: 560,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001176_v2", "prompt_id": "seed_001176", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Tilemap", "Input", "Physics"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状并生成纹理\n2. 创建椭圆精灵对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 到 1，持续 1 秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 绘制椭圆（中心点在 0,0，宽度 120，高度 80）\n  graphics.fillEllipse(0, 0, 120, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建椭圆精灵，位置在屏幕中心\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始透明度为 0（完全透明）\n  ellipse.alpha = 0;\n  \n  // 创建 Tween 动画：从透明到不透明\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    alpha: 1,                   // 目标透明度值（完全不透明）\n    duration: 1000,             // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 反向播放（从 1 回到 0）\n    repeat: -1                  // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '椭圆淡入淡出动画（循环播放）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000237_v3", "prompt_id": "seed_000237", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现按WASD键发射灰色子弹的例子，子弹速度 200，离开边界回收（使用对象池）。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 按WASD键发射灰色子弹，速度200，离开边界自动回收到对象池\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard.addKey, Phaser.GameObjects.Graphics.generateTexture\nSTEPS:\n1. 创建物理场景配置，启用 arcade 物理引擎\n2. 在 create 中使用 Graphics 生成灰色子弹纹理\n3. 创建物理组作为子弹对象池，配置边界检测回收\n4. 监听 WASD 键输入，按键时从对象池获取子弹并设置速度方向\n5. 在 update 中检测子弹是否离开边界，离开则回收到对象池\n6. 添加状态变量 bulletsFired 记录发射子弹总数用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.bulletsFired = 0; // 状态信号：发射子弹总数\n    this.activeBullets = 0; // 状态信号：当前活跃子弹数\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建灰色子弹纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillCircle(8, 8, 8); // 圆形子弹，半径8\n    graphics.generateTexture('bullet', 16, 16);\n    graphics.destroy();\n\n    // 创建玩家（用于发射子弹的中心点）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(-16, -16, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹对象池（物理组）\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50, // 对象池最大容量\n      runChildUpdate: false\n    });\n\n    // 配置 WASD 键\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 防止连续发射的冷却时间\n    this.lastFired = 0;\n    this.fireRate = 200; // 毫秒\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 检查是否可以发射（冷却时间）\n    const canFire = time > this.lastFired + this.fireRate;\n\n    // WASD 键发射子弹\n    if (canFire) {\n      let velocityX = 0;\n      let velocityY = 0;\n\n      if (this.keyW.isDown) {\n        velocityY = -200; // 向上\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      } else if (this.keyS.isDown) {\n        velocityY = 200; // 向下\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      } else if (this.keyA.isDown) {\n        velocityX = -200; // 向左\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      } else if (this.keyD.isDown) {\n        velocityX = 200; // 向右\n        this.fireBullet(velocityX, velocityY);\n        this.lastFired = time;\n      }\n    }\n\n    // 检查并回收离开边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        const bounds = this.physics.world.bounds;\n        if (bullet.x < bounds.x - 20 || \n            bullet.x > bounds.x + bounds.width + 20 ||\n            bullet.y < bounds.y - 20 || \n            bullet.y > bounds.y + bounds.height + 20) {\n          this.recycleBullet(bullet);\n        }\n      }\n    });\n\n    this.updateStatusText();\n  }\n\n  fireBullet(velocityX, velocityY) {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.body.enable = true;\n      bullet.setVelocity(velocityX, velocityY);\n      \n      this.bulletsFired++;\n      this.activeBullets++;\n    }\n  }\n\n  recycleBullet(bullet) {\n    // 回收子弹到对象池\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    bullet.body.enable = false;\n    bullet.setVelocity(0, 0);\n    \n    this.activeBullets--;\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Bullets Fired: ${this.bulletsFired}`,\n      `Active Bullets: ${this.activeBullets}`,\n      `Pool Size: ${this.bullets.getLength()}`,\n      '',\n      'Press WASD to fire bullets'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000972_v3", "prompt_id": "seed_000972", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的方块在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个自动向左移动的方块，相机跟随并保持居中\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 创建游戏配置，设置场景和画布尺寸\n2. 在 create 中使用 Graphics 生成方块纹理\n3. 创建 Sprite 对象作为移动的方块\n4. 使用 camera.startFollow 让相机跟随方块\n5. 在 update 中让方块持续向左移动\n6. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet speed = 200; // 移动速度（像素/秒）\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  createGrid.call(this);\n  \n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n  \n  // 创建玩家方块，初始位置在画布中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n  player.setOrigin(0.5, 0.5);\n  \n  // 设置相机跟随玩家\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 可选：设置相机边界，让相机可以无限跟随\n  // 如果不设置，相机会受到世界边界限制\n  this.cameras.main.setBounds(-10000, -10000, 20000, 20000);\n  \n  // 扩展世界边界以匹配相机\n  this.physics.world.setBounds(-10000, -10000, 20000, 20000);\n  \n  // 添加说明文字（固定在相机上）\n  const text = this.add.text(10, 10, '方块自动向左移动\\n相机跟随方块', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n}\n\nfunction update(time, delta) {\n  // 让方块持续向左移动\n  // delta 是毫秒，需要转换为秒\n  const moveDistance = (speed * delta) / 1000;\n  player.x -= moveDistance;\n  \n  // 可选：添加边界检测，防止方块移动太远\n  // 这里我们允许无限移动以展示相机跟随效果\n}\n\n// 辅助函数：创建网格背景\nfunction createGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  const gridSize = 100;\n  const gridWidth = 20000;\n  const gridHeight = 20000;\n  const offsetX = -10000;\n  const offsetY = -10000;\n  \n  // 绘制垂直线\n  for (let x = 0; x <= gridWidth; x += gridSize) {\n    graphics.moveTo(offsetX + x, offsetY);\n    graphics.lineTo(offsetX + x, offsetY + gridHeight);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= gridHeight; y += gridSize) {\n    graphics.moveTo(offsetX, offsetY + y);\n    graphics.lineTo(offsetX + gridWidth, offsetY + y);\n  }\n  \n  graphics.strokePath();\n  \n  // 添加坐标标记\n  const textStyle = {\n    fontSize: '14px',\n    fill: '#888888'\n  };\n  \n  // 在关键位置添加坐标文字\n  for (let x = -2000; x <= 2000; x += 500) {\n    for (let y = -1000; y <= 1000; y += 500) {\n      if (x === 0 && y === 0) {\n        this.add.text(x, y, `(${x}, ${y})`, textStyle).setOrigin(0.5);\n      } else if (x % 1000 === 0 && y % 1000 === 0) {\n        this.add.text(x, y, `(${x}, ${y})`, textStyle).setOrigin(0.5);\n      }\n    }\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000214_v3", "prompt_id": "seed_000214", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形并使其以每秒120度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, GameObject.rotation\nSTEPS:\n1. 创建 Graphics 对象用于绘制菱形\n2. 使用 beginPath/moveTo/lineTo 绘制菱形路径（四个顶点）\n3. 在 update 方法中根据 delta 时间增量更新 rotation 属性\n4. 每秒旋转 120 度，即每毫秒旋转 120/1000 度，转换为弧度：(120 * Math.PI / 180) / 1000\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制菱形（中心在原点）\n  const size = 80; // 菱形的半径\n  graphics.beginPath();\n  graphics.moveTo(0, -size);      // 上顶点\n  graphics.lineTo(size, 0);       // 右顶点\n  graphics.lineTo(0, size);       // 下顶点\n  graphics.lineTo(-size, 0);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 设置菱形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 保存引用以便在 update 中使用\n  diamond = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 120 度\n  // 120 度 = 120 * (Math.PI / 180) 弧度 = 2.0944 弧度\n  // delta 是毫秒，所以每毫秒旋转的弧度为：(120 * Math.PI / 180) / 1000\n  const rotationSpeed = (120 * Math.PI / 180) / 1000; // 弧度/毫秒\n  \n  diamond.rotation += rotationSpeed * delta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000645_v1", "prompt_id": "seed_000645", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色星形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色星形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个外顶点和 5 个内顶点坐标（基于中心点和半径）\n4. 使用 Graphics API 绘制星形路径并填充红色\n5. 将星形定位在画布中央 (400, 300)\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 24; // 外半径 24 像素\n  const innerRadius = outerRadius * 0.4; // 内半径约为外半径的 40%\n  const points = 5; // 5 个角的星形\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 绘制星形的顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 计算角度（从顶部开始，逆时针）\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点移动到该位置，其余点连线\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000579_v2", "prompt_id": "seed_000579", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的黄色圆形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的黄色圆形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用循环20次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置黄色，fillCircle 绘制半径为12的圆形（直径24像素）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置黄色填充样式（0xFFFF00 为黄色，1 为完全不透明）\n  graphics.fillStyle(0xFFFF00, 1);\n  \n  // 绘制 20 个随机位置的圆形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机 x 坐标（留出圆形半径的边距）\n    const x = Math.random() * (this.scale.width - 48) + 24;\n    \n    // 生成随机 y 坐标（留出圆形半径的边距）\n    const y = Math.random() * (this.scale.height - 48) + 24;\n    \n    // 绘制圆形，半径为 12 像素（直径 24 像素）\n    graphics.fillCircle(x, y, 12);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000769_v2", "prompt_id": "seed_000769", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的绿色椭圆，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 绘制10个随机位置的绿色椭圆，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环10次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置绿色填充色（0x00ff00）\n4. 使用 fillEllipse 绘制椭圆，中心点为(0,0)，宽高均为80像素\n5. 使用 setRandomPosition 将每个椭圆随机放置在场景中\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 循环创建10个绿色椭圆\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置绿色填充\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制椭圆，中心点在(0, 0)，宽度和高度都是80像素\n    // fillEllipse(x, y, width, height)\n    graphics.fillEllipse(0, 0, 80, 80);\n    \n    // 随机放置在场景中\n    // 考虑椭圆半径，确保不会超出边界\n    const radius = 40; // 椭圆半径为80/2\n    graphics.setRandomPosition(\n      radius, \n      radius, \n      config.width - radius * 2, \n      config.height - radius * 2\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000247_v3", "prompt_id": "seed_000247", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色六边形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色六边形以160速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Scene.physics.add.sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制红色六边形并生成纹理\n2. 启用 Arcade 物理系统创建物理精灵\n3. 设置精灵速度为160，启用世界边界碰撞和反弹\n4. 配置物理世界边界与画布一致\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制六边形（中心点在 32, 32，半径 30）\n  const hexagonPath = [];\n  const radius = 30;\n  const centerX = 32;\n  const centerY = 32;\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    hexagonPath.push(x, y);\n  }\n  \n  graphics.fillPoints(hexagonPath, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置碰撞世界边界\n  hexagon.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 设置初始速度（160像素/秒，45度角方向）\n  const speed = 160;\n  const angle = Math.PI / 4; // 45度\n  hexagon.setVelocity(\n    speed * Math.cos(angle),\n    speed * Math.sin(angle)\n  );\n  \n  // 确保物理世界边界与画布一致\n  this.physics.world.setBounds(0, 0, 800, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000643_v3", "prompt_id": "seed_000643", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色星形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色星形以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.Physics.Arcade, Phaser.GameObjects.GameObject.setVelocity, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds\nSTEPS:\n1. 配置物理系统（arcade）并创建场景\n2. 使用 Graphics 绘制橙色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为 360（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    points.push({\n      x: 32 + Math.cos(angle) * radius,\n      y: 32 + Math.sin(angle) * radius\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（360像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 360;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 360;\n  star.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞和反弹\n  star.setCollideWorldBounds(true);\n  star.setBounce(1, 1); // 完全弹性碰撞\n  \n  // 可选：让星形旋转增加视觉效果\n  star.setAngularVelocity(100);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000798_v2", "prompt_id": "seed_000798", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右侧显示 \"Hello Phaser\" 文字，字体大小 80 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布宽度 800，高度 600\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小 80px\n4. 计算文本位置，使其显示在屏幕右侧（x 坐标靠近右边界）\n5. 设置文本原点为左上角，确保文本完整显示在画布内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右侧显示文字 \"Hello Phaser\"\n  // x 坐标设置为靠近右边界，y 坐标居中\n  const text = this.add.text(550, 260, 'Hello Phaser', {\n    fontSize: '80px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本原点为左上角（默认值），确保文本不会超出画布\n  text.setOrigin(0, 0);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000472_v1", "prompt_id": "seed_000472", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：12 个粉色小球以 200 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 12个粉色小球在封闭空间内以200速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.group, Body.setBounce, Physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，设置无重力环境\n2. 使用 Graphics 创建粉色圆形纹理\n3. 创建物理组，添加 12 个小球并设置随机位置和速度\n4. 设置小球与世界边界的碰撞和弹性\n5. 设置小球之间的碰撞检测\n6. 添加碰撞计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 碰撞计数器（可验证状态）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    const width = this.scale.width;\n    const height = this.scale.height;\n\n    // 创建粉色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff69b4, 1); // 粉色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('pinkBall', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.ballGroup = this.physics.add.group({\n      key: 'pinkBall',\n      repeat: 11, // 总共12个球（0-11）\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 为每个小球设置随机位置和速度\n    const balls = this.ballGroup.getChildren();\n    balls.forEach((ball, index) => {\n      // 随机位置（避免靠近边缘）\n      const x = Phaser.Math.Between(50, width - 50);\n      const y = Phaser.Math.Between(50, height - 50);\n      ball.setPosition(x, y);\n\n      // 随机方向，固定速度200\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 200;\n      const velocityY = Math.sin(angle) * 200;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体\n      ball.setCircle(16);\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.ballGroup, this.ballGroup, this.onBallCollision, null, this);\n\n    // 显示碰撞计数器\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示小球数量\n    this.ballCountText = this.add.text(10, 40, 'Balls: 12', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 绘制边界提示\n    const border = this.add.graphics();\n    border.lineStyle(2, 0xffffff, 0.5);\n    border.strokeRect(0, 0, width, height);\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 每次碰撞增加计数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保小球速度保持在200左右（考虑浮点误差）\n    const balls = this.ballGroup.getChildren();\n    balls.forEach(ball => {\n      const body = ball.body;\n      const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n      \n      // 如果速度偏差超过5%，重新归一化\n      if (Math.abs(currentSpeed - 200) > 10) {\n        const scale = 200 / currentSpeed;\n        body.setVelocity(body.velocity.x * scale, body.velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000879_v1", "prompt_id": "seed_000879", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块以每秒 360 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.setRotation, Phaser.Scene.update\nSTEPS:\n1. 创建 Graphics 对象绘制一个方块\n2. 在 update 方法中根据 delta 时间累加旋转角度\n3. 使用 setRotation 方法更新方块的旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制方块\n  square = this.add.graphics();\n  square.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个 100x100 的方块，中心点在 (0, 0)\n  square.fillRect(-50, -50, 100, 100);\n  \n  // 设置方块位置到屏幕中心\n  square.x = 400;\n  square.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 360 度 = 2π 弧度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 旋转速度：2 * Math.PI 弧度/秒\n  const rotationSpeed = 2 * Math.PI; // 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  square.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000683_v1", "prompt_id": "seed_000683", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个灰色三角形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形在2秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建 x 轴移动动画，设置 duration 为 2000ms\n4. 配置 yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为灰色\n  graphics.fillStyle(0x808080, 1);\n  \n  // 绘制三角形（使用 beginPath 和 fillTriangle）\n  // 三角形中心点在 (0, 0)，方便后续定位\n  graphics.fillTriangle(\n    0, -30,    // 顶点\n    -25, 30,   // 左下角\n    25, 30     // 右下角\n  );\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('triangle', 50, 60);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用该纹理的 Sprite，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 2000,              // 持续时间 2 秒\n    yoyo: true,                  // 启用往返效果（到达终点后反向播放）\n    loop: -1,                    // 无限循环（-1 表示永久循环）\n    ease: 'Linear'               // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000608_v3", "prompt_id": "seed_000608", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个青色小球以 200 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个青色小球在封闭空间内以200速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade.Group, setBounce, setCollideWorldBounds, setVelocity, collider\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成青色圆形纹理\n3. 创建物理组，添加5个小球精灵\n4. 为每个小球设置随机速度(200)、边界碰撞反弹、球体间碰撞反弹\n5. 添加碰撞检测器，实现小球间的弹性碰撞\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 状态信号：碰撞次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 设置世界边界\n    this.physics.world.setBounds(0, 0, 800, 600);\n\n    // 使用 Graphics 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: 4, // 创建5个小球（0-4）\n      setXY: {\n        x: Phaser.Math.Between(100, 700),\n        y: Phaser.Math.Between(100, 500),\n        stepX: 0,\n        stepY: 0\n      }\n    });\n\n    // 为每个小球设置属性\n    this.balls.children.iterate((ball) => {\n      // 设置随机速度方向，速度大小为200\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * 200;\n      const velocityY = Math.sin(angle) * 200;\n      \n      ball.setVelocity(velocityX, velocityY);\n      \n      // 设置边界碰撞反弹\n      ball.setCollideWorldBounds(true);\n      \n      // 设置弹性系数为1（完全弹性碰撞）\n      ball.setBounce(1);\n      \n      // 设置圆形碰撞体\n      ball.setCircle(16);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.handleBallCollision, null, this);\n\n    // 显示碰撞次数文本\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 显示说明文本\n    this.add.text(10, 40, 'Cyan balls bouncing at 200 speed', {\n      fontSize: '16px',\n      fill: '#00ffff'\n    });\n\n    // 添加边界可视化\n    const bounds = this.add.graphics();\n    bounds.lineStyle(2, 0xffffff, 0.5);\n    bounds.strokeRect(0, 0, 800, 600);\n  }\n\n  handleBallCollision(ball1, ball2) {\n    // 记录碰撞次数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保小球速度保持在200左右（由于浮点误差可能会有微小变化）\n    this.balls.children.iterate((ball) => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏差超过1%，重新归一化到200\n      if (Math.abs(currentSpeed - 200) > 2) {\n        const scale = 200 / currentSpeed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000895_v1", "prompt_id": "seed_000895", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左显示一段文字 \"Hello Phaser\"，字体大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左侧显示 \"Hello Phaser\" 文字，字体大小 24 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置在屏幕左侧，字体大小为 24 像素\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕左侧 (x: 50) 创建文本对象\n  // y 坐标设置为屏幕中央附近\n  this.add.text(50, 300, 'Hello Phaser', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000069_v3", "prompt_id": "seed_000069", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色圆形在 0.5 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色圆形的抖动循环动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色圆形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 Tween 实现抖动效果（快速左右或上下震动）\n4. 设置 Tween 循环播放，每次抖动持续 0.5 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillCircle(50, 50, 50); // 半径50的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('grayCircle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(400, 300, 'grayCircle');\n  \n  // 创建抖动动画\n  // 使用多个关键帧实现快速抖动效果\n  this.tweens.add({\n    targets: circle,\n    x: {\n      from: 400,\n      to: 400,\n      duration: 500,\n      ease: 'Linear'\n    },\n    props: {\n      x: {\n        value: '+=10',\n        duration: 50,\n        yoyo: true,\n        repeat: 4 // 在 0.5 秒内重复 5 次（共 10 个动作）\n      }\n    },\n    loop: -1, // 无限循环\n    onLoop: function() {\n      // 每次循环开始时重置位置\n      circle.x = 400;\n    }\n  });\n  \n  // 添加替代方案：使用时间轴实现更精确的抖动\n  this.tweens.timeline({\n    targets: circle,\n    loop: -1,\n    tweens: [\n      { x: 410, duration: 50, ease: 'Linear' },\n      { x: 390, duration: 50, ease: 'Linear' },\n      { x: 410, duration: 50, ease: 'Linear' },\n      { x: 390, duration: 50, ease: 'Linear' },\n      { x: 410, duration: 50, ease: 'Linear' },\n      { x: 390, duration: 50, ease: 'Linear' },\n      { x: 410, duration: 50, ease: 'Linear' },\n      { x: 390, duration: 50, ease: 'Linear' },\n      { x: 410, duration: 50, ease: 'Linear' },\n      { x: 400, duration: 50, ease: 'Linear' } // 回到中心位置\n    ]\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '灰色圆形抖动动画 (0.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000224_v2", "prompt_id": "seed_000224", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.915}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让粉色星形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色星形并使用 Tween 实现 1 秒旋转一次的循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setRotation\nSTEPS:\n1. 使用 Graphics 绘制粉色星形并生成纹理\n2. 创建使用该纹理的 Sprite 对象\n3. 使用 tweens.add 创建旋转动画，设置 duration 为 1000ms，rotation 从 0 到 2π\n4. 设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色星形\n  const graphics = this.add.graphics();\n  \n  // 绘制星形的函数\n  function drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillStyle(color, 1);\n    graphics.fillPath();\n  }\n\n  // 绘制粉色星形 (中心在 60, 60，方便生成纹理)\n  drawStar(graphics, 60, 60, 5, 50, 25, 0xFF69B4);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkStar', 120, 120);\n  graphics.destroy();\n\n  // 创建星形精灵并放置在屏幕中心\n  const star = this.add.sprite(400, 300, 'pinkStar');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: star,\n    rotation: Math.PI * 2, // 旋转 360 度 (2π 弧度)\n    duration: 1000, // 1 秒完成一次旋转\n    ease: 'Linear', // 线性缓动，保持匀速旋转\n    repeat: -1 // 无限循环\n  });\n}\n\nfunction update(time, delta) {\n  // 本例不需要每帧更新逻辑\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000350_v1", "prompt_id": "seed_000350", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让粉色方块在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色方块的淡入淡出循环动画\nAPI: Graphics, Tween, TweenManager\nSTEPS:\n1. 使用 Graphics 绘制粉色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建 alpha 属性动画，从1到0再到1\n4. 设置 yoyo 和 repeat 参数实现循环淡入淡出效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkSquare', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象\n  const square = this.add.sprite(400, 300, 'pinkSquare');\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: square,\n    alpha: 0, // 目标透明度为0（完全透明）\n    duration: 500, // 持续时间500毫秒（0.5秒）\n    yoyo: true, // 启用yoyo效果，动画会反向播放回到初始值\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Pink Square Fade In/Out Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000627_v3", "prompt_id": "seed_000627", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色星形以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色星形以120速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Star, Phaser.Physics.Arcade, Phaser.Physics.Arcade.Body.setBounce, Phaser.Physics.Arcade.Body.setCollideWorldBounds\nSTEPS:\n1. 创建带物理系统的Game配置\n2. 使用Graphics绘制红色星形纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为120\n5. 启用世界边界碰撞和反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制星形路径\n  const points = 5; // 五角星\n  const outerRadius = 30;\n  const innerRadius = 15;\n  const centerX = 32;\n  const centerY = 32;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  this.star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置初始速度（随机方向，速度为120）\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const velocityX = Math.cos(angle) * 120;\n  const velocityY = Math.sin(angle) * 120;\n  this.star.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  this.star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  this.star.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为120\n  const currentVelocity = this.star.body.velocity;\n  const speed = Math.sqrt(currentVelocity.x ** 2 + currentVelocity.y ** 2);\n  \n  if (speed > 0 && Math.abs(speed - 120) > 0.1) {\n    const scale = 120 / speed;\n    this.star.setVelocity(currentVelocity.x * scale, currentVelocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000668_v1", "prompt_id": "seed_000668", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色方块以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色方块以120速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带物理系统的Game配置\n2. 使用Graphics绘制紫色方块并生成纹理\n3. 创建物理精灵并设置速度为120\n4. 设置精灵与世界边界碰撞并反弹\n5. 在update中检测边界碰撞并反转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet square;\nlet velocity = { x: 120, y: 120 };\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用Graphics绘制紫色方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('purpleSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'purpleSquare');\n  \n  // 设置初始速度\n  square.setVelocity(velocity.x, velocity.y);\n  \n  // 设置与世界边界碰撞\n  square.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  square.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // Phaser的物理系统会自动处理边界碰撞和反弹\n  // 当setBounce设置为1且setCollideWorldBounds为true时\n  // 方块会在碰到边界时自动反弹\n  \n  // 可选：手动检测边界并反转速度（如果不使用物理引擎的bounce）\n  // 但由于已使用setBounce，这里不需要额外代码\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000228_v2", "prompt_id": "seed_000228", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 160 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现躲避游戏，敌人速度随时间从160逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Group\nSTEPS:\n1. 创建玩家角色（使用Graphics生成绿色方块纹理）\n2. 创建敌人组，初始速度160，使用红色圆形纹理\n3. 设置键盘输入控制玩家移动\n4. 实现敌人生成逻辑，定时从顶部随机位置掉落\n5. 添加碰撞检测，碰到敌人则游戏结束\n6. 实现速度递增机制，每秒增加速度\n7. 显示生存时间文本，实时更新\n8. 游戏结束显示最终生存时间\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.player = null;\n    this.enemies = null;\n    this.cursors = null;\n    this.survivalTime = 0;\n    this.timeText = null;\n    this.gameOver = false;\n    this.baseEnemySpeed = 160;\n    this.currentEnemySpeed = 160;\n    this.speedIncreaseRate = 10; // 每秒增加的速度\n    this.lastSpeedUpdate = 0;\n    this.enemySpawnTimer = null;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy',\n      maxSize: 20\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0.0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 添加速度显示文本\n    this.speedText = this.add.text(16, 50, 'Speed: 160', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 3\n    });\n\n    // 碰撞检测\n    this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 定时生成敌人（每0.8秒生成一个）\n    this.enemySpawnTimer = this.time.addEvent({\n      delay: 800,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 初始化时间\n    this.survivalTime = 0;\n    this.lastSpeedUpdate = 0;\n    this.gameOver = false;\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 更新生存时间\n    this.survivalTime += delta / 1000;\n    this.timeText.setText('Time: ' + this.survivalTime.toFixed(1) + 's');\n\n    // 每秒增加敌人速度\n    if (Math.floor(this.survivalTime) > this.lastSpeedUpdate) {\n      this.lastSpeedUpdate = Math.floor(this.survivalTime);\n      this.currentEnemySpeed = this.baseEnemySpeed + (this.lastSpeedUpdate * this.speedIncreaseRate);\n      this.speedText.setText('Speed: ' + Math.floor(this.currentEnemySpeed));\n      \n      // 更新现有敌人的速度\n      this.enemies.children.entries.forEach(enemy => {\n        if (enemy.active) {\n          enemy.setVelocityY(this.currentEnemySpeed);\n        }\n      });\n    }\n\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-300);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(300);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.active && enemy.y > 620) {\n        enemy.setActive(false);\n        enemy.setVisible(false);\n        enemy.body.enable = false;\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 从对象池获取或创建敌人\n    const enemy = this.enemies.get(Phaser.Math.Between(50, 750), -30, 'enemy');\n    \n    if (enemy) {\n      enemy.setActive(true);\n      enemy.setVisible(true);\n      enemy.body.enable = true;\n      enemy.setVelocityY(this.currentEnemySpeed);\n      enemy.setVelocityX(0);\n    }\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) {\n      return;\n    }\n\n    this.gameOver = true;\n\n    // 停止物理引擎\n    this.physics.pause();\n\n    // 玩家变红表示失败\n    player.setTint(0xff0000);\n\n    // 停止生成敌人\n    if (this.enemySpawnTimer) {\n      this.enemySpawnTimer.remove();\n    }\n\n    // 显示游戏结束文本\n    const gameOverText = this.add.text(400, 250, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 8\n    });\n    gameOverText.setOrigin(0.5);\n\n    const finalTimeText = this.add.text(400, 330, 'Survival Time: ' + this.survivalTime.toFixed(1) + 's', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 6\n    });\n    finalTimeText.setOrigin(0.5);\n\n    const restartText = this.add.text(400, 400, 'Click to Restart', {\n      fontSize: '24px',\n      fill: '#ffff00',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    restartText.setOrigin(0.5);\n\n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000908_v3", "prompt_id": "seed_000908", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.905}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒360度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Ellipse, Phaser.Scene#update\nSTEPS:\n1. 创建场景配置，包含 preload、create 和 update 生命周期方法\n2. 在 create 中使用 Graphics 绘制一个椭圆形状\n3. 在 update 中根据时间增量计算旋转角度（每秒360度 = 每毫秒0.36度）\n4. 持续更新椭圆的 rotation 属性实现旋转效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为蓝色\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 设置描边样式为白色\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  // 绘制椭圆（中心点在0,0，宽度120，高度60）\n  graphics.fillEllipse(0, 0, 120, 60);\n  graphics.strokeEllipse(0, 0, 120, 60);\n  \n  // 添加一个标记线，用于观察旋转效果\n  graphics.lineStyle(2, 0xff0000, 1);\n  graphics.lineBetween(0, 0, 60, 0);\n  \n  // 设置椭圆位置到屏幕中心\n  graphics.setPosition(400, 300);\n  \n  // 保存引用以便在 update 中使用\n  ellipse = graphics;\n  \n  // 添加说明文字\n  const text = this.add.text(400, 50, '椭圆以每秒360度旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转360度 = 每毫秒旋转 360/1000 度\n  // 转换为弧度：(360/1000) * (Math.PI/180) = 0.00628 弧度/毫秒\n  // 或者直接使用 Phaser.Math.DegToRad(360/1000)\n  \n  const rotationSpeed = Phaser.Math.DegToRad(360); // 每秒360度（弧度制）\n  const deltaSeconds = delta / 1000; // 将毫秒转换为秒\n  \n  // 更新旋转角度\n  ellipse.rotation += rotationSpeed * deltaSeconds;\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000584_v3", "prompt_id": "seed_000584", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 20 个金币，重力 800，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集20个金币，重力800，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理系统配置，设置重力为800\n2. 使用Graphics绘制玩家角色和平台纹理\n3. 创建20个金币随机分布在空中\n4. 添加键盘输入控制角色左右移动和跳跃\n5. 实现碰撞检测：角色与平台、角色与金币\n6. 显示分数文本，收集金币时更新分数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8b4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建金币纹理\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffd700, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0.1);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 地面平台\n    this.platforms.create(400, 584, 'platform').setScale(4, 1).refreshBody();\n    \n    // 中间平台\n    this.platforms.create(600, 450, 'platform');\n    this.platforms.create(50, 350, 'platform');\n    this.platforms.create(750, 320, 'platform');\n    this.platforms.create(300, 250, 'platform');\n    this.platforms.create(550, 180, 'platform');\n    this.platforms.create(150, 150, 'platform');\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在不同高度和位置创建20个金币\n    const coinPositions = [\n      { x: 100, y: 300 }, { x: 200, y: 200 }, { x: 350, y: 200 },\n      { x: 450, y: 400 }, { x: 650, y: 400 }, { x: 100, y: 100 },\n      { x: 250, y: 100 }, { x: 600, y: 270 }, { x: 750, y: 270 },\n      { x: 400, y: 520 }, { x: 500, y: 520 }, { x: 700, y: 520 },\n      { x: 50, y: 300 }, { x: 300, y: 200 }, { x: 550, y: 130 },\n      { x: 650, y: 130 }, { x: 150, y: 100 }, { x: 750, y: 270 },\n      { x: 200, y: 520 }, { x: 600, y: 520 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounceY(Phaser.Math.FloatBetween(0.2, 0.4));\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n    \n    // 金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#fff',\n      fontFamily: 'Arial',\n      stroke: '#000',\n      strokeThickness: 4\n    });\n    this.scoreText.setScrollFactor(0);\n\n    // 游戏完成提示文本（初始隐藏）\n    this.completeText = this.add.text(400, 300, 'All Coins Collected!\\nScore: 20', {\n      fontSize: '48px',\n      fill: '#ffd700',\n      fontFamily: 'Arial',\n      stroke: '#000',\n      strokeThickness: 6,\n      align: 'center'\n    });\n    this.completeText.setOrigin(0.5);\n    this.completeText.setVisible(false);\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 移除金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 1;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.score === 20) {\n      this.completeText.setVisible(true);\n      // 可以选择暂停游戏或继续\n      // this.physics.pause();\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001175_v3", "prompt_id": "seed_001175", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 600，移动速度 300，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现简易平台跳跃游戏，角色可左右移动与跳跃，与地面碰撞不穿透\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup, this.physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 600\n2. 使用 Graphics 创建玩家和地面的纹理\n3. 创建玩家精灵，设置物理属性和碰撞边界\n4. 创建地面静态物理组，添加多个平台\n5. 设置玩家与地面的碰撞检测\n6. 监听键盘输入（方向键），实现左右移动（速度 300）和跳跃\n7. 添加状态变量（jumpCount）用于验证游戏状态\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，不依赖外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 400, 32);\n    groundGraphics.generateTexture('ground', 400, 32);\n    groundGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x654321, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0);\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(28, 44); // 设置碰撞边界\n\n    // 创建地面和平台\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 主地面\n    this.platforms.create(200, 584, 'ground');\n    this.platforms.create(600, 584, 'ground');\n    \n    // 悬空平台\n    this.platforms.create(600, 450, 'platform');\n    this.platforms.create(50, 350, 'platform');\n    this.platforms.create(700, 320, 'platform');\n    this.platforms.create(300, 250, 'platform');\n\n    // 设置碰撞检测\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n    this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 550, 'Controls: Arrow Keys or WASD + Space to Jump', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n  }\n\n  update(time, delta) {\n    // 重置接地状态（每帧检测）\n    this.isGrounded = this.player.body.touching.down;\n\n    // 左右移动\n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-300);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(300);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃（只有在接触地面时才能跳跃）\n    if ((this.cursors.up.isDown || this.keyW.isDown || this.keySpace.isDown) && this.isGrounded) {\n      this.player.setVelocityY(-500);\n      this.jumpCount++;\n    }\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Jump Count: ${this.jumpCount}`,\n      `Position: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`,\n      `Velocity: (${Math.floor(this.player.body.velocity.x)}, ${Math.floor(this.player.body.velocity.y)})`,\n      `Grounded: ${this.isGrounded}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000990_v1", "prompt_id": "seed_000990", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 160 像素/秒速度移动\nAPI: Phaser.Game, Phaser.Scene, Graphics.fillStyle, Graphics.fillPath, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Scene 类，配置游戏尺寸和场景\n2. 在 create 中使用 Graphics 绘制菱形形状并生成纹理\n3. 创建 Sprite 对象使用生成的菱形纹理\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态更新菱形位置，速度为 160 像素/秒\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.diamond = null;\n    this.keys = null;\n    this.speed = 160; // 像素/秒\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 使用 Graphics 绘制菱形并生成纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制菱形路径（中心点为 25, 25，大小为 50x50）\n    const path = new Phaser.Geom.Polygon([\n      25, 0,    // 上顶点\n      50, 25,   // 右顶点\n      25, 50,   // 下顶点\n      0, 25     // 左顶点\n    ]);\n    \n    graphics.fillPoints(path.points, true);\n    \n    // 生成纹理\n    graphics.generateTexture('diamondTex', 50, 50);\n    graphics.destroy();\n    \n    // 创建菱形精灵，放置在屏幕中心\n    this.diamond = this.add.sprite(400, 300, 'diamondTex');\n    \n    // 设置键盘输入\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n  }\n\n  update(time, delta) {\n    // 计算每帧移动距离 = 速度 * 时间间隔（转换为秒）\n    const distance = this.speed * (delta / 1000);\n    \n    // 根据按键状态移动菱形\n    if (this.keys.w.isDown) {\n      this.diamond.y -= distance;\n    }\n    if (this.keys.s.isDown) {\n      this.diamond.y += distance;\n    }\n    if (this.keys.a.isDown) {\n      this.diamond.x -= distance;\n    }\n    if (this.keys.d.isDown) {\n      this.diamond.x += distance;\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000377_v1", "prompt_id": "seed_000377", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9042857142857141}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色方块，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个 80x80 像素的绿色方块\nAPI: Phaser.Game, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充颜色为绿色（0x00ff00）\n4. 计算画布中心位置（400, 300），绘制 80x80 的方块，使其中心对齐\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算中心位置\n  // 画布尺寸: 800x600\n  // 方块大小: 80x80\n  // 中心点: (400, 300)\n  // 方块左上角: (400 - 40, 300 - 40) = (360, 260)\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const squareSize = 80;\n  \n  // 绘制方块（左上角坐标，宽度，高度）\n  graphics.fillRect(\n    centerX - squareSize / 2,\n    centerY - squareSize / 2,\n    squareSize,\n    squareSize\n  );\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000308_v2", "prompt_id": "seed_000308", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让橙色椭圆在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建橙色椭圆并实现2秒抖动循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建抖动效果（快速左右或上下移动）\n4. 设置 Tween 循环播放，duration 为 2000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillEllipse(60, 40, 120, 80); // 在中心绘制椭圆\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建椭圆精灵并居中显示\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  \n  // 创建抖动动画效果\n  // 抖动效果：快速左右移动产生震动感\n  this.tweens.add({\n    targets: ellipse,\n    x: '+=10', // 向右移动10像素\n    duration: 50, // 每次移动50毫秒\n    yoyo: true, // 来回移动\n    repeat: 19, // 重复19次（加上初始1次 = 20次往返 = 2000ms）\n    ease: 'Linear',\n    loop: -1 // 无限循环\n  });\n  \n  // 可选：添加文字说明\n  this.add.text(400, 500, '橙色椭圆抖动动画（2秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000423_v1", "prompt_id": "seed_000423", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色圆形以300速度移动并在边界反弹\nAPI: Graphics, arcade.physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Phaser 游戏配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制紫色圆形并生成纹理\n3. 创建物理精灵，设置初始速度为 300\n4. 设置世界边界碰撞和反弹系数为 1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 创建紫色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillCircle(20, 20, 20); // 半径20的圆形\n  graphics.generateTexture('purpleCircle', 40, 40);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'purpleCircle');\n  \n  // 设置初始速度（随机方向，速度为300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  circle.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 游戏逻辑更新（本例中无需额外更新逻辑）\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000554_v3", "prompt_id": "seed_000554", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让红色矩形在 2 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色矩形的缩放循环动画，2秒完成一次缩放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建缩放动画，设置 yoyo 和 repeat 实现循环效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建红色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('redRect', 100, 100);\n  graphics.destroy();\n  \n  // 创建精灵对象，放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'redRect');\n  \n  // 创建缩放动画\n  // 从原始大小缩放到 1.5 倍，然后返回，持续 2 秒，无限循环\n  this.tweens.add({\n    targets: rect,\n    scaleX: 1.5,\n    scaleY: 1.5,\n    duration: 1000, // 1秒放大\n    yoyo: true,     // 动画结束后反向播放（缩回原大小）\n    repeat: -1,     // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000355_v2", "prompt_id": "seed_000355", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让紫色矩形在 2.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个紫色矩形，使用 Tween 实现 2.5 秒弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色矩形并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens.add 创建 y 轴弹跳动画，设置 ease 为 'Bounce.easeOut'\n4. 设置动画持续时间为 2500ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('purpleRect', 100, 100);\n  graphics.destroy();\n\n  // 创建紫色矩形精灵，放置在画面中央偏上位置\n  const rect = this.add.sprite(400, 200, 'purpleRect');\n\n  // 创建弹跳动画\n  // 使用 yoyo 和 Bounce.easeOut 实现弹跳效果\n  this.tweens.add({\n    targets: rect,\n    y: 400, // 从 200 弹跳到 400\n    duration: 2500, // 2.5 秒完成一次弹跳\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返运动\n    repeat: -1, // 无限循环\n    hold: 0, // 不在终点停留\n    repeatDelay: 0 // 重复之间无延迟\n  });\n\n  // 添加说明文字\n  this.add.text(400, 550, '紫色矩形弹跳动画 (2.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000461_v2", "prompt_id": "seed_000461", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左侧显示 \"Hello Phaser\" 文字，字体大小 64 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小 64px，位置在屏幕左侧\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕左侧显示文字\n  // x: 50 让文字距离左边有一定间距\n  // y: 300 垂直居中\n  this.add.text(50, 300, 'Hello Phaser', {\n    fontSize: '64px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000450_v2", "prompt_id": "seed_000450", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色椭圆，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色椭圆，大小约为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建基础 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为红色 (0xff0000)\n4. 使用 fillEllipse 在画布中央 (400, 300) 绘制椭圆，宽高设为 32 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 是椭圆的宽度，height 是椭圆的高度\n  graphics.fillEllipse(400, 300, 32, 32);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000749_v1", "prompt_id": "seed_000749", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在4秒内从透明渐变到完全不透明并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续 4 秒\n4. 设置 Tween 为循环模式（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 程序化生成圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 中心点(50,50)，半径50\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建圆形精灵，初始设为完全透明\n  const circle = this.add.sprite(400, 300, 'circle');\n  circle.alpha = 0;\n\n  // 创建 Tween 动画：4秒内从透明(0)到不透明(1)，循环播放\n  this.tweens.add({\n    targets: circle,\n    alpha: 1,           // 目标透明度为1（完全不透明）\n    duration: 4000,     // 持续时间4秒\n    ease: 'Linear',     // 线性渐变\n    yoyo: true,         // 往返播放（1->0->1）\n    repeat: -1          // 无限循环\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, '圆形透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000011_v2", "prompt_id": "seed_000011", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 120，重力 500。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可跳跃两次后才需落地，跳跃力度120，重力500\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建带物理系统的游戏配置，设置重力为500\n2. 使用Graphics绘制玩家角色和地面\n3. 添加键盘输入监听空格键控制跳跃\n4. 实现双跳逻辑：记录跳跃次数，落地后重置\n5. 添加状态显示文本，显示剩余跳跃次数和总跳跃计数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.jumpCount = 0; // 当前已使用的跳跃次数\n    this.totalJumps = 0; // 总跳跃计数（用于验证）\n    this.maxJumps = 2; // 最大跳跃次数\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建地面\n    this.ground = this.physics.add.staticSprite(400, 575, 'ground');\n    this.ground.setSize(800, 50);\n    this.ground.refreshBody();\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.ground, () => {\n      // 当玩家与地面碰撞时，重置跳跃次数\n      if (this.player.body.touching.down) {\n        this.jumpCount = 0;\n      }\n    });\n\n    // 添加键盘输入\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.instructionText = this.add.text(400, 100, '按空格键跳跃（可双跳）', {\n      fontSize: '24px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.instructionText.setOrigin(0.5);\n\n    // 更新状态显示\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 检测空格键按下（使用 justDown 避免连续触发）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {\n      this.handleJump();\n    }\n\n    // 更新状态文本\n    this.updateStatusText();\n\n    // 显示玩家状态（用于调试）\n    const onGround = this.player.body.touching.down;\n    if (onGround && this.jumpCount > 0) {\n      // 确保落地时重置跳跃次数\n      this.jumpCount = 0;\n    }\n  }\n\n  handleJump() {\n    // 检查是否还有跳跃次数\n    if (this.jumpCount < this.maxJumps) {\n      // 执行跳跃\n      this.player.setVelocityY(-120); // 跳跃力度120\n      this.jumpCount++;\n      this.totalJumps++;\n      \n      // 添加视觉反馈\n      this.tweens.add({\n        targets: this.player,\n        scaleX: 1.1,\n        scaleY: 0.9,\n        duration: 100,\n        yoyo: true,\n        ease: 'Power2'\n      });\n    }\n  }\n\n  updateStatusText() {\n    const remainingJumps = this.maxJumps - this.jumpCount;\n    const onGround = this.player.body.touching.down ? '是' : '否';\n    \n    this.statusText.setText([\n      `剩余跳跃次数: ${remainingJumps}/${this.maxJumps}`,\n      `总跳跃计数: ${this.totalJumps}`,\n      `在地面上: ${onGround}`,\n      `玩家Y坐标: ${Math.round(this.player.y)}`\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 }, // 重力500\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001129_v1", "prompt_id": "seed_001129", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, this.cameras.main\nSTEPS:\n1. 创建场景并设置较大的世界边界以便星形移动\n2. 使用 Graphics 绘制一个星形对象\n3. 在 update 中让星形自动向下移动\n4. 使用 camera.startFollow 让相机跟随星形并保持居中\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nlet moveSpeed = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使其比视口大很多\n  this.cameras.main.setBounds(0, 0, 1600, 3000);\n  this.physics.world.setBounds(0, 0, 1600, 3000);\n  \n  // 创建背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制网格\n  for (let x = 0; x <= 1600; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 3000);\n  }\n  for (let y = 0; y <= 3000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(1600, y);\n  }\n  graphics.strokePath();\n  \n  // 添加坐标标记\n  const style = { font: '16px Arial', fill: '#00ff00' };\n  for (let y = 0; y <= 3000; y += 500) {\n    this.add.text(10, y + 10, `Y: ${y}`, style);\n  }\n  \n  // 创建星形对象\n  star = this.add.graphics();\n  star.x = 800; // 世界中心\n  star.y = 300; // 起始位置\n  \n  // 绘制星形\n  star.fillStyle(0xffff00, 1);\n  star.lineStyle(3, 0xff6600, 1);\n  \n  // 绘制五角星\n  const points = [];\n  const outerRadius = 40;\n  const innerRadius = 16;\n  for (let i = 0; i < 10; i++) {\n    const angle = (i * Math.PI) / 5 - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    points.push({\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    });\n  }\n  \n  star.beginPath();\n  star.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    star.lineTo(points[i].x, points[i].y);\n  }\n  star.closePath();\n  star.fillPath();\n  star.strokePath();\n  \n  // 添加一个中心圆点以便更清楚地看到中心位置\n  star.fillStyle(0xff0000, 1);\n  star.fillCircle(0, 0, 5);\n  \n  // 让相机跟随星形对象，保持居中\n  this.cameras.main.startFollow(star, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（这里设置为0以保持完全居中）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加提示文本（固定在相机视口）\n  const infoText = this.add.text(10, 10, 'Camera following the star\\nStar moving down automatically', {\n    font: '20px Arial',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 10 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机视口，不随相机移动\n  \n  // 显示星形位置信息\n  this.posText = this.add.text(10, 100, '', {\n    font: '16px Arial',\n    fill: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.posText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 星形自动向下移动\n  star.y += moveSpeed;\n  \n  // 当星形到达世界底部时，重置到顶部\n  if (star.y > 2900) {\n    star.y = 100;\n  }\n  \n  // 更新位置信息显示\n  this.posText.setText(`Star Position: (${Math.floor(star.x)}, ${Math.floor(star.y)})`);\n  \n  // 可选：添加一些旋转效果使星形更生动\n  star.rotation += 0.02;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000205_v1", "prompt_id": "seed_000205", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 4 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Tween 动画让方块在 4 秒内缩放到 64% 并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens 创建缩放动画，设置 scale 从 1 到 0.64\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2000ms（单程 2 秒，往返共 4 秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('squareTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵\n  const square = this.add.sprite(400, 300, 'squareTexture');\n\n  // 创建缩放 Tween 动画\n  // 单程 2 秒，往返共 4 秒\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.64,\n    scaleY: 0.64,\n    duration: 2000,      // 单程 2 秒\n    yoyo: true,          // 启用往返效果（缩小后再放大）\n    loop: -1,            // 无限循环\n    ease: 'Linear'       // 线性缓动\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, '方块缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, '缩放范围: 100% -> 64% -> 100%\\n循环周期: 4 秒', {\n    fontSize: '16px',\n    color: '#cccccc',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000784_v3", "prompt_id": "seed_000784", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2.5秒内从透明到不透明循环渐变\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制椭圆形状并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为0\n3. 使用 Tween 动画控制 alpha 属性从0到1，持续2.5秒\n4. 设置 Tween 循环播放（yoyo 或 repeat -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色椭圆\n  graphics.fillEllipse(60, 40, 120, 80); // 在(60, 40)位置绘制椭圆，宽120，高80\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('ellipse', 120, 80);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成了纹理\n  \n  // 创建椭圆精灵并设置初始透明度为0\n  const ellipse = this.add.sprite(400, 300, 'ellipse');\n  ellipse.setAlpha(0);\n  \n  // 创建渐变动画：从透明(alpha=0)到不透明(alpha=1)\n  this.tweens.add({\n    targets: ellipse,\n    alpha: 1, // 目标透明度\n    duration: 2500, // 持续时间2.5秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（0->1->0）\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '椭圆循环渐变动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000326_v2", "prompt_id": "seed_000326", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色矩形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色矩形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 duration 为 4000ms，yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 60, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('yellowRect', 60, 60);\n  graphics.destroy();\n  \n  // 创建精灵对象，放置在左侧（留出边距）\n  const rect = this.add.sprite(100, 300, 'yellowRect');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: rect,\n    x: 700, // 移动到右侧（800 - 100 边距）\n    duration: 4000, // 4秒\n    yoyo: true, // 往返运动\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000095_v2", "prompt_id": "seed_000095", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在2秒内缩放到24%再恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建缩放动画，从 scale=1 到 scale=0.24 再回到 scale=1\n4. 设置 Tween 的 yoyo 和 loop 属性实现往返循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 三角形中心点在 (50, 50)，边长约 80\n  graphics.beginPath();\n  graphics.moveTo(50, 10);      // 顶点\n  graphics.lineTo(10, 80);       // 左下角\n  graphics.lineTo(90, 80);       // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 100);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  // 使用 yoyo 实现从 1 -> 0.24 -> 1 的效果\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 1000,        // 1秒缩小到24%\n    yoyo: true,            // 动画反向播放（回到原始大小）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加提示文字\n  const text = this.add.text(400, 500, '三角形循环缩放动画\\n1秒缩小到24% → 1秒恢复', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000117_v2", "prompt_id": "seed_000117", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个计数器 UI：每次点击画面，计数 +1，并在屏幕左上角显示当前计数。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Events.POINTER_DOWN\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现点击计数器，每次点击画面计数+1，左上角显示当前计数\nAPI: Phaser.GameObjects.Text, Phaser.Input.Events.POINTER_DOWN, Scene.input.on\nSTEPS:\n1. 创建 Scene 并初始化计数变量为 0\n2. 在 create 中使用 Text 对象在左上角显示计数\n3. 监听 POINTER_DOWN 事件，每次点击时计数+1 并更新文本显示\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n// 计数器变量\nlet counter = 0;\nlet counterText = null;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建计数器文本显示在左上角\n  counterText = this.add.text(20, 20, 'Count: 0', {\n    fontSize: '32px',\n    fontFamily: 'Arial',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: {\n      x: 10,\n      y: 5\n    }\n  });\n\n  // 监听整个画面的点击事件\n  this.input.on(Phaser.Input.Events.POINTER_DOWN, () => {\n    // 计数器加1\n    counter++;\n    \n    // 更新文本显示\n    counterText.setText('Count: ' + counter);\n    \n    // 可选：添加点击反馈效果\n    counterText.setScale(1.2);\n    this.tweens.add({\n      targets: counterText,\n      scaleX: 1,\n      scaleY: 1,\n      duration: 100,\n      ease: 'Power1'\n    });\n  });\n\n  // 添加提示文本\n  this.add.text(400, 300, 'Click anywhere to count!', {\n    fontSize: '24px',\n    fontFamily: 'Arial',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000046_v3", "prompt_id": "seed_000046", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色三角形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现橙色三角形左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2500 毫秒（2.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (0, 0)，方便后续定位\n  const triangleHeight = 60;\n  const triangleBase = 52;\n  \n  graphics.beginPath();\n  graphics.moveTo(0, -triangleHeight / 2);  // 顶点\n  graphics.lineTo(-triangleBase / 2, triangleHeight / 2);  // 左下角\n  graphics.lineTo(triangleBase / 2, triangleHeight / 2);   // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('orangeTriangle', triangleBase, triangleHeight);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'orangeTriangle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: triangle,\n    x: 700,  // 移动到右侧\n    duration: 2500,  // 2.5秒\n    ease: 'Linear',  // 线性运动\n    yoyo: true,  // 往返效果\n    loop: -1  // 无限循环\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000567_v1", "prompt_id": "seed_000567", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个圆形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制圆形以 200 像素/秒速度移动\nAPI: Graphics.fillCircle, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Scene 并使用 Graphics 绘制一个圆形作为玩家\n2. 在 create 中使用 addKeys 绑定 WASD 键盘输入\n3. 在 update 中根据按键状态和 delta 时间更新圆形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 玩家对象和按键引用\nlet player;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形玩家\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(0, 0, 20); // 半径 20 的圆形，中心点在 (0, 0)\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('playerTexture', 40, 40);\n  graphics.destroy(); // 销毁临时 Graphics 对象\n  \n  // 创建玩家精灵并设置初始位置\n  player = this.add.sprite(400, 300, 'playerTexture');\n  \n  // 绑定 WASD 键\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧移动距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    player.x += distance; // 向右移动\n  }\n  \n  // 边界限制（可选）\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000173_v1", "prompt_id": "seed_000173", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色三角形在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色三角形，使用 Tween 实现 2 秒抖动动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Sprite 对象承载三角形纹理\n3. 使用 tweens.add 创建抖动动画（x/y 轴随机偏移）\n4. 设置动画持续时间 2 秒，yoyo 模式，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -40);      // 顶点\n  graphics.lineTo(-35, 30);     // 左下\n  graphics.lineTo(35, 30);      // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 70, 70);\n  graphics.destroy();\n  \n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建抖动动画\n  this.tweens.add({\n    targets: triangle,\n    x: {\n      value: '+=10',\n      duration: 50,\n      ease: 'Linear',\n      yoyo: true,\n      repeat: -1\n    },\n    y: {\n      value: '+=8',\n      duration: 60,\n      ease: 'Linear',\n      yoyo: true,\n      repeat: -1\n    },\n    angle: {\n      value: '+=3',\n      duration: 70,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1\n    },\n    // 整体循环周期为 2 秒\n    duration: 2000,\n    ease: 'Sine.easeInOut',\n    yoyo: true,\n    repeat: -1\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '青色三角形抖动动画（2秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000325_v2", "prompt_id": "seed_000325", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并使用 fillTriangle 绘制一个三角形\n2. 在 update 方法中根据 delta 时间计算旋转角度增量\n3. 每帧更新 Graphics 对象的 rotation 属性，实现持续旋转效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象并绘制三角形\n  triangle = this.add.graphics();\n  \n  // 设置填充颜色\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形，中心点在原点\n  const size = 100;\n  const height = size * Math.sqrt(3) / 2;\n  \n  triangle.fillTriangle(\n    0, -height * 2 / 3,           // 顶点\n    -size / 2, height / 3,        // 左下角\n    size / 2, height / 3          // 右下角\n  );\n  \n  // 将三角形移动到屏幕中心\n  triangle.x = 400;\n  triangle.y = 300;\n}\n\nfunction update(time, delta) {\n  // 计算旋转角度增量\n  // 每秒 200 度 = 200 * (Math.PI / 180) 弧度/秒\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 200 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 更新三角形的旋转角度\n  triangle.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000168_v3", "prompt_id": "seed_000168", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 8 个蓝色敌人巡逻移动，在 160 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 8个蓝色敌人左右巡逻，玩家接近时追踪，速度160\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, this.physics.moveToObject\nSTEPS:\n1. 创建物理系统和Graphics纹理（玩家绿色、敌人蓝色）\n2. 创建玩家精灵，添加键盘控制\n3. 创建8个敌人组，随机分布在场景中\n4. 为每个敌人设置初始巡逻方向和边界\n5. 在update中检测玩家距离，近则追踪，远则巡逻\n6. 添加状态变量追踪敌人状态和玩家生命值\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesPatrolling = 8; // 状态信号：巡逻中的敌人数\n    this.enemiesChasing = 0; // 状态信号：追踪中的敌人数\n    this.playerHealth = 100; // 状态信号：玩家生命值\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（蓝色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 创建8个敌人，分布在不同位置\n    const positions = [\n      { x: 100, y: 100 },\n      { x: 700, y: 100 },\n      { x: 100, y: 500 },\n      { x: 700, y: 500 },\n      { x: 400, y: 100 },\n      { x: 200, y: 300 },\n      { x: 600, y: 300 },\n      { x: 400, y: 500 }\n    ];\n\n    positions.forEach((pos, index) => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(1, 1);\n      \n      // 设置敌人的自定义属性\n      enemy.patrolSpeed = 160;\n      enemy.chaseSpeed = 160;\n      enemy.detectionRange = 200; // 检测范围\n      enemy.isChasing = false;\n      \n      // 设置初始巡逻方向（随机左或右）\n      enemy.patrolDirection = index % 2 === 0 ? 1 : -1;\n      enemy.setVelocityX(enemy.patrolSpeed * enemy.patrolDirection);\n      \n      // 设置巡逻边界\n      enemy.patrolMinX = pos.x - 150;\n      enemy.patrolMaxX = pos.x + 150;\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加碰撞检测（玩家碰到敌人减血）\n    this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 添加状态文本显示\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setScrollFactor(0);\n    this.statusText.setDepth(100);\n\n    // 添加说明文本\n    this.add.text(16, 560, 'Arrow keys to move. Avoid enemies!', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const speed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 重置状态计数\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, \n        this.player.y, \n        enemy.x, \n        enemy.y\n      );\n\n      // 判断是否应该追踪玩家\n      if (distance < enemy.detectionRange) {\n        // 追踪模式\n        if (!enemy.isChasing) {\n          enemy.isChasing = true;\n        }\n        \n        this.physics.moveToObject(enemy, this.player, enemy.chaseSpeed);\n        this.enemiesChasing++;\n        \n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          enemy.isChasing = false;\n          enemy.setVelocityY(0);\n        }\n        \n        this.enemiesPatrolling++;\n\n        // 巡逻逻辑：在边界范围内左右移动\n        if (enemy.x <= enemy.patrolMinX) {\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(enemy.patrolSpeed * enemy.patrolDirection);\n        } else if (enemy.x >= enemy.patrolMaxX) {\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(enemy.patrolSpeed * enemy.patrolDirection);\n        }\n        \n        // 保持巡逻速度\n        if (Math.abs(enemy.body.velocity.x) < enemy.patrolSpeed - 10) {\n          enemy.setVelocityX(enemy.patrolSpeed * enemy.patrolDirection);\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.updateStatusText();\n  }\n\n  hitEnemy(player, enemy) {\n    // 玩家碰到敌人减少生命值\n    this.playerHealth -= 1;\n    \n    // 击退效果\n    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);\n    player.setVelocity(\n      Math.cos(angle) * 300,\n      Math.sin(angle) * 300\n    );\n\n    // 游戏结束检测\n    if (this.playerHealth <= 0) {\n      this.playerHealth = 0;\n      this.gameOver();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Health: ${this.playerHealth}`,\n      `Patrolling: ${this.enemiesPatrolling}`,\n      `Chasing: ${this.enemiesChasing}`\n    ]);\n  }\n\n  gameOver() {\n    this.physics.pause();\n    \n    const gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 }\n    });\n    gameOverText.setOrigin(0.5);\n    \n    const restartText = this.add.text(400, 380, 'Refresh to restart', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    restartText.setOrigin(0.5);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000974_v1", "prompt_id": "seed_000974", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#angle, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制矩形\n2. 设置矩形的原点为中心点以便围绕中心旋转\n3. 在 update 方法中根据 delta 时间累加角度（200度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制矩形，以中心为原点（-100, -75 到 100, 75，总尺寸 200x150）\n  graphics.fillRect(-100, -75, 200, 150);\n  \n  // 设置矩形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 数据中，以便在 update 中访问\n  this.rotatingRect = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 200 度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 每帧旋转的角度 = 200 * (delta / 1000)\n  const rotationSpeed = 200; // 度/秒\n  const deltaAngle = rotationSpeed * (delta / 1000);\n  \n  // 累加角度\n  this.rotatingRect.angle += deltaAngle;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000054_v2", "prompt_id": "seed_000054", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色三角形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色三角形以200速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制粉色三角形并生成纹理\n2. 创建物理精灵并应用三角形纹理\n3. 设置初始速度为200（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (25, 25)，边长约 40\n  graphics.fillTriangle(\n    25, 5,      // 顶点\n    5, 45,      // 左下\n    45, 45      // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象释放内存\n  \n  // 创建物理精灵\n  this.triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（斜向移动，总速度约为200）\n  // 使用勾股定理：vx² + vy² = 200²\n  // 设置45度角移动：vx = vy = 200 / √2 ≈ 141.4\n  this.triangle.setVelocity(141.4, 141.4);\n  \n  // 设置碰撞世界边界\n  this.triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  this.triangle.setBounce(1, 1);\n  \n  // 确保世界边界碰撞已启用\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为200\n  const velocity = this.triangle.body.velocity;\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - 200) > 1) {\n    // 归一化速度向量并乘以目标速度\n    const normalizedX = velocity.x / currentSpeed;\n    const normalizedY = velocity.y / currentSpeed;\n    this.triangle.setVelocity(normalizedX * 200, normalizedY * 200);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000164_v3", "prompt_id": "seed_000164", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色三角形以160速度移动并在边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制橙色三角形并生成纹理\n2. 创建启用物理的精灵对象并应用三角形纹理\n3. 设置初始速度为160（x和y方向各约113，使合速度为160）\n4. 启用世界边界碰撞和完全弹性反弹（bounce=1）\n5. 在update中保持速度恒定为160\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet triangle;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  \n  // 绘制一个等边三角形（中心在32,32，大小为64x64）\n  graphics.fillTriangle(\n    32, 10,    // 顶点\n    10, 54,    // 左下\n    54, 54     // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 64, 64);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  triangle = this.physics.add.sprite(400, 300, 'triangleTexture');\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置完全弹性碰撞（bounce = 1 表示无能量损失）\n  triangle.setBounce(1, 1);\n  \n  // 设置初始速度为160（使用勾股定理：160/√2 ≈ 113.137）\n  const speed = 160;\n  const angle = Phaser.Math.DegToRad(45); // 45度角\n  triangle.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n}\n\nfunction update(time, delta) {\n  // 保持恒定速度160\n  const currentVelocity = triangle.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  // 如果速度有偏差，重新归一化到160\n  if (Math.abs(currentSpeed - 160) > 0.1) {\n    const scale = 160 / currentSpeed;\n    triangle.setVelocity(\n      currentVelocity.x * scale,\n      currentVelocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000522_v3", "prompt_id": "seed_000522", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的六边形并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite, Graphics#generateTexture\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用生成的六边形纹理\n3. 在 update 中让六边形持续向下移动\n4. 使用 Camera.startFollow 让相机跟随六边形并保持居中\n5. 设置世界边界以便相机有足够的移动空间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst MOVE_SPEED = 100; // 每秒向下移动的像素\n\nfunction preload() {\n  // 使用 Graphics 生成六边形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制六边形\n  const hexRadius = 40;\n  const hexPoints = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = hexRadius + hexRadius * Math.cos(angle);\n    const y = hexRadius + hexRadius * Math.sin(angle);\n    hexPoints.push(x, y);\n  }\n  \n  // 填充六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0], hexPoints[1]);\n  for (let i = 2; i < hexPoints.length; i += 2) {\n    graphics.lineTo(hexPoints[i], hexPoints[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 绘制边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 设置世界边界，让相机有足够的空间跟随\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n  this.physics.world.setBounds(0, 0, 800, 3000);\n  \n  // 创建六边形 Sprite，初始位置在场景上方中央\n  hexagon = this.add.sprite(400, 100, 'hexagon');\n  \n  // 让相机跟随六边形\n  // startFollow(target, roundPixels, lerpX, lerpY, offsetX, offsetY)\n  // roundPixels: 是否四舍五入像素以避免抖动\n  // lerpX/lerpY: 平滑跟随系数 (0-1)，1表示立即跟随，较小值会有平滑效果\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 添加一些参考网格线以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制水平参考线\n  for (let y = 0; y < 3000; y += 100) {\n    graphics.moveTo(0, y);\n    graphics.lineTo(800, y);\n  }\n  \n  // 绘制垂直参考线\n  for (let x = 0; x < 800; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 3000);\n  }\n  \n  graphics.strokePath();\n  \n  // 添加文本提示（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随六边形\\n六边形自动向下移动', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让六边形持续向下移动\n  // delta 是以毫秒为单位的时间差，除以1000转换为秒\n  hexagon.y += MOVE_SPEED * (delta / 1000);\n  \n  // 如果六边形移动到世界底部，重置到顶部\n  if (hexagon.y > 2900) {\n    hexagon.y = 100;\n  }\n  \n  // 更新文本显示当前位置信息\n  const text = this.children.list.find(child => child.type === 'Text');\n  if (text) {\n    text.setText(\n      `相机跟随六边形\\n` +\n      `六边形自动向下移动\\n` +\n      `位置: (${Math.round(hexagon.x)}, ${Math.round(hexagon.y)})\\n` +\n      `相机Y: ${Math.round(this.cameras.main.scrollY)}`\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000383_v3", "prompt_id": "seed_000383", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8837499999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形在 2 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Triangle\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象，初始 alpha 设为 0\n3. 使用 Tween 动画让 alpha 从 0 变化到 1，持续 2 秒\n4. 设置 Tween 为循环模式（yoyo 或 loop）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -60);      // 顶点\n  graphics.lineTo(-52, 30);     // 左下角\n  graphics.lineTo(52, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 104, 90);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的 Sprite\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始透明度为 0（完全透明）\n  triangle.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: triangle,\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 2000,              // 持续时间 2 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 来回播放（1 -> 0 -> 1）\n    repeat: -1                   // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, 'Triangle fading in/out (2 seconds cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000532_v2", "prompt_id": "seed_000532", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让粉色椭圆在 2.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色椭圆并实现 2.5 秒闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制粉色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现闪烁效果（0->1->0）\n4. 设置 duration 为 2500ms，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillEllipse(80, 60, 160, 120); // 椭圆中心(80,60)，宽160，高120\n  \n  // 生成纹理\n  graphics.generateTexture('pinkEllipse', 160, 120);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建精灵对象放置在屏幕中央\n  const ellipseSprite = this.add.sprite(400, 300, 'pinkEllipse');\n  \n  // 创建闪烁动画\n  // 从完全可见(alpha=1) -> 完全透明(alpha=0) -> 完全可见(alpha=1)\n  this.tweens.add({\n    targets: ellipseSprite,\n    alpha: { from: 1, to: 0 }, // 淡出\n    duration: 1250, // 2.5秒的一半\n    yoyo: true, // 自动反向播放（淡入）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '粉色椭圆闪烁动画 (2.5秒/周期)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000677_v3", "prompt_id": "seed_000677", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：8 个矩形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 创建一个收集游戏，玩家控制角色收集8个随机分布的矩形，收集完成后显示通关文字\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Factory#overlap, Phaser.GameObjects.Text, Phaser.Input.Keyboard.createCursorKeys\nSTEPS:\n1. 创建玩家精灵，使用 Graphics 绘制蓝色方块作为纹理\n2. 使用物理组创建8个随机位置的收集品（黄色矩形）\n3. 添加键盘控制，让玩家可以移动\n4. 使用 overlap 检测玩家与收集品的碰撞，收集时销毁收集品并增加计数\n5. 当收集品计数达到8时，显示\"恭喜通关\"文字\n[/PLAN]\n\n```javascript\nclass CollectionGame extends Phaser.Scene {\n  constructor() {\n    super('CollectionGame');\n    this.collectedCount = 0;\n    this.totalCollectibles = 8;\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建收集品纹理\n    const collectibleGraphics = this.add.graphics();\n    collectibleGraphics.fillStyle(0xffdd00, 1);\n    collectibleGraphics.fillRect(0, 0, 30, 30);\n    collectibleGraphics.generateTexture('collectible', 30, 30);\n    collectibleGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建收集品物理组\n    this.collectibles = this.physics.add.group();\n\n    // 随机生成8个收集品\n    for (let i = 0; i < this.totalCollectibles; i++) {\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      const collectible = this.collectibles.create(x, y, 'collectible');\n      collectible.setImmovable(true);\n    }\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.collectibles,\n      this.collectItem,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建计数文本\n    this.scoreText = this.add.text(16, 16, `收集: ${this.collectedCount}/${this.totalCollectibles}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 创建通关文本（初始隐藏）\n    this.winText = this.add.text(400, 300, '恭喜通关！', {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.winText.setOrigin(0.5);\n    this.winText.setVisible(false);\n\n    // 添加控制提示\n    this.add.text(16, 560, '使用方向键移动', {\n      fontSize: '18px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  collectItem(player, collectible) {\n    // 销毁收集品\n    collectible.destroy();\n\n    // 增加计数\n    this.collectedCount++;\n\n    // 更新文本\n    this.scoreText.setText(`收集: ${this.collectedCount}/${this.totalCollectibles}`);\n\n    // 检查是否收集完成\n    if (this.collectedCount >= this.totalCollectibles) {\n      this.winText.setVisible(true);\n      this.player.setVelocity(0, 0);\n      \n      // 添加闪烁效果\n      this.tweens.add({\n        targets: this.winText,\n        scaleX: 1.2,\n        scaleY: 1.2,\n        duration: 500,\n        yoyo: true,\n        repeat: -1\n      });\n    }\n  }\n\n  update() {\n    // 只有在未通关时才允许移动\n    if (this.collectedCount < this.totalCollectibles) {\n      const speed = 200;\n\n      // 重置速度\n      this.player.setVelocity(0);\n\n      // 检测键盘输入\n      if (this.cursors.left.isDown) {\n        this.player.setVelocityX(-speed);\n      } else if (this.cursors.right.isDown) {\n        this.player.setVelocityX(speed);\n      }\n\n      if (this.cursors.up.isDown) {\n        this.player.setVelocityY(-speed);\n      } else if (this.cursors.down.isDown) {\n        this.player.setVelocityY(speed);\n      }\n\n      // 归一化对角线速度\n      if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n        this.player.body.velocity.normalize().scale(speed);\n      }\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: CollectionGame\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000884_v3", "prompt_id": "seed_000884", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9000000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形图形对象，使其以每秒200度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStar, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个星形\n2. 在 update 中根据 delta 时间增量计算旋转角度\n3. 将角度转换为弧度并应用到星形的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制星形\n  star = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  star.fillStyle(0xffff00, 1);\n  \n  // 绘制星形：中心点(400, 300)，5个角，外半径100，内半径50\n  star.fillStar(400, 300, 5, 100, 50);\n  \n  // 设置旋转中心点为星形的中心\n  star.setPosition(0, 0);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 每秒旋转 200 度 = 200 度/秒\n  // 转换为弧度：200 * (Math.PI / 180) = 3.49 弧度/秒\n  \n  // 计算本帧应该旋转的角度（弧度）\n  const rotationSpeed = 200 * (Math.PI / 180); // 每秒旋转的弧度数\n  const rotationDelta = rotationSpeed * (delta / 1000); // 本帧旋转的弧度数\n  \n  // 累加旋转角度\n  star.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000241_v1", "prompt_id": "seed_000241", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 80 像素/秒速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 创建 Scene 配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 生成椭圆纹理并创建椭圆对象\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新椭圆位置，应用 80 像素/秒速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40,30)，宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy();\n\n  // 创建椭圆精灵，放置在画布中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n\n  // 设置 WASD 键盘控制\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 添加提示文字\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算基于帧时间的实际移动距离\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态更新椭圆位置\n  if (keys.w.isDown) {\n    ellipse.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    ellipse.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    ellipse.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    ellipse.x += distance; // 向右移动\n  }\n\n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 40, 760);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 30, 570);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000203_v2", "prompt_id": "seed_000203", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 3 个金币，重力 1000，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集3个空中金币，重力1000，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力为 1000\n2. 使用 Graphics 生成角色、平台、金币的纹理\n3. 创建玩家精灵并添加物理属性，设置碰撞边界\n4. 创建静态平台组，放置地面和跳跃平台\n5. 创建金币组（3个），放置在空中不同位置\n6. 添加键盘输入监听（方向键控制移动和跳跃）\n7. 设置玩家与平台的碰撞检测\n8. 设置玩家与金币的重叠检测，收集时增加分数并销毁金币\n9. 创建分数文本显示，实时更新\n10. 在 update 中处理移动逻辑\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.player = null;\n    this.platforms = null;\n    this.coins = null;\n    this.cursors = null;\n    this.scoreText = null;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x666666, 1);\n    platformGraphics.fillRect(0, 0, 200, 32);\n    platformGraphics.generateTexture('platform', 200, 32);\n    platformGraphics.destroy();\n\n    // 创建地面纹理（深灰色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x444444, 1);\n    groundGraphics.fillRect(0, 0, 800, 32);\n    groundGraphics.generateTexture('ground', 800, 32);\n    groundGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffdd00, 1);\n    coinGraphics.fillCircle(16, 16, 16);\n    coinGraphics.generateTexture('coin', 32, 32);\n    coinGraphics.destroy();\n  }\n\n  create() {\n    // 创建静态平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加地面\n    const ground = this.platforms.create(400, 584, 'ground');\n    ground.setScale(1).refreshBody();\n\n    // 添加跳跃平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(600, 380, 'platform');\n    this.platforms.create(400, 280, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setGravityY(0); // 使用世界重力\n\n    // 创建金币组\n    this.coins = this.physics.add.group({\n      key: 'coin',\n      repeat: 2,\n      setXY: { x: 200, y: 350, stepX: 200 }\n    });\n\n    // 调整金币位置，使其更具挑战性\n    this.coins.children.entries[0].setPosition(200, 350);\n    this.coins.children.entries[1].setPosition(600, 280);\n    this.coins.children.entries[2].setPosition(400, 180);\n\n    // 设置金币的物理属性\n    this.coins.children.iterate((coin) => {\n      coin.setBounceY(Phaser.Math.FloatBetween(0.2, 0.4));\n      coin.setCollideWorldBounds(true);\n      coin.body.setAllowGravity(false); // 金币不受重力影响\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, this.platforms);\n\n    // 添加金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 添加游戏说明文本\n    this.add.text(16, 56, 'Arrow Keys: Move & Jump', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n\n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      // 显示胜利信息\n      const winText = this.add.text(400, 300, 'YOU WIN!', {\n        fontSize: '64px',\n        fill: '#ffdd00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6\n      });\n      winText.setOrigin(0.5);\n\n      // 暂停物理系统\n      this.physics.pause();\n    }\n  }\n\n  update(time, delta) {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000872_v1", "prompt_id": "seed_000872", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个蓝色菱形，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个蓝色菱形，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算菱形的四个顶点坐标（中心点在画布中央，菱形边长约 48 像素）\n4. 使用 beginPath、moveTo、lineTo 绘制菱形路径\n5. 使用蓝色填充菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x0000ff, 1);\n  \n  // 计算画布中心点\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 菱形大小（从中心到顶点的距离）\n  const size = 48;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 菱形的四个顶点（上、右、下、左）\n  graphics.moveTo(centerX, centerY - size / 2);  // 上顶点\n  graphics.lineTo(centerX + size / 2, centerY);  // 右顶点\n  graphics.lineTo(centerX, centerY + size / 2);  // 下顶点\n  graphics.lineTo(centerX - size / 2, centerY);  // 左顶点\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充菱形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000736_v2", "prompt_id": "seed_000736", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆形状\n2. 在 create 中初始化椭圆的位置和旋转角度\n3. 在 update 中根据 delta 时间增量计算旋转角度（160度/秒 = 160 * (delta/1000) 度/帧）\n4. 将角度转换为弧度并应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipseGraphics;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象并绘制椭圆\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置椭圆的填充颜色\n  ellipseGraphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制椭圆（中心在原点，宽度 200，高度 100）\n  ellipseGraphics.fillEllipse(0, 0, 200, 100);\n  \n  // 设置椭圆位置到屏幕中心\n  ellipseGraphics.x = 400;\n  ellipseGraphics.y = 300;\n  \n  // 初始化旋转角度\n  currentRotation = 0;\n  \n  // 添加文字提示\n  this.add.text(10, 10, '椭圆旋转速度: 160度/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧应该旋转的角度（度）\n  // 160 度/秒 * (delta 毫秒 / 1000) = 本帧旋转角度\n  const rotationDegrees = 160 * (delta / 1000);\n  \n  // 累加旋转角度\n  currentRotation += rotationDegrees;\n  \n  // 将角度转换为弧度并应用到 Graphics 对象\n  // Phaser 使用弧度制，1度 = Math.PI / 180 弧度\n  ellipseGraphics.rotation = Phaser.Math.DegToRad(currentRotation);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000281_v1", "prompt_id": "seed_000281", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 600。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次，跳跃力度200，重力600\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 创建物理系统配置，设置重力为600\n2. 使用Graphics绘制玩家角色和地面平台\n3. 添加键盘输入监听，检测空格键跳跃\n4. 实现双跳逻辑：记录跳跃次数，落地时重置，空中最多跳2次\n5. 添加状态显示文本，显示剩余跳跃次数和总跳跃计数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.jumpCount = 0; // 当前已使用的跳跃次数\n    this.totalJumps = 0; // 总跳跃统计（可验证状态）\n    this.maxJumps = 2; // 最大跳跃次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x8b4513, 1);\n    groundGraphics.fillRect(0, 0, 800, 60);\n    groundGraphics.generateTexture('ground', 800, 60);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(32, 48);\n\n    // 创建地面平台\n    this.ground = this.physics.add.staticSprite(400, 570, 'ground');\n    this.ground.refreshBody();\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.ground, () => {\n      // 当玩家接触地面时，重置跳跃次数\n      if (this.player.body.touching.down) {\n        this.jumpCount = 0;\n      }\n    });\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 监听空格键按下事件（使用 justDown 避免长按连续触发）\n    this.input.keyboard.on('keydown-SPACE', () => {\n      this.handleJump();\n    });\n\n    // 状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 说明文本\n    this.instructionText = this.add.text(16, 60, \n      'Press SPACE to jump (Double Jump Available)\\nArrow Keys to move', {\n      fontSize: '16px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 跳跃提示文本\n    this.jumpIndicator = this.add.text(400, 100, '', {\n      fontSize: '24px',\n      fill: '#00ff00',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    this.updateStatusText();\n  }\n\n  handleJump() {\n    // 检查是否可以跳跃\n    if (this.jumpCount < this.maxJumps) {\n      // 执行跳跃\n      this.player.setVelocityY(-200);\n      this.jumpCount++;\n      this.totalJumps++;\n\n      // 显示跳跃提示\n      const jumpText = this.jumpCount === 1 ? 'First Jump!' : 'Double Jump!';\n      this.jumpIndicator.setText(jumpText);\n      this.jumpIndicator.setAlpha(1);\n\n      // 淡出动画\n      this.tweens.add({\n        targets: this.jumpIndicator,\n        alpha: 0,\n        duration: 500,\n        ease: 'Power2'\n      });\n\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    const remainingJumps = this.maxJumps - this.jumpCount;\n    this.statusText.setText(\n      `Remaining Jumps: ${remainingJumps}/${this.maxJumps}\\n` +\n      `Total Jumps: ${this.totalJumps}`\n    );\n  }\n\n  update(time, delta) {\n    // 水平移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 检测是否在地面上（用于重置跳跃次数）\n    if (this.player.body.touching.down && this.jumpCount > 0) {\n      this.jumpCount = 0;\n      this.updateStatusText();\n    }\n\n    // 更新玩家颜色以指示跳跃状态\n    if (this.jumpCount === 0) {\n      this.player.setTint(0x00ff00); // 绿色：可以双跳\n    } else if (this.jumpCount === 1) {\n      this.player.setTint(0xffff00); // 黄色：还可以跳一次\n    } else {\n      this.player.setTint(0xff0000); // 红色：无法再跳\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 600 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000812_v3", "prompt_id": "seed_000812", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的矩形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Rectangle, Phaser.Cameras.Scene2D.Camera#setBounds\nSTEPS:\n1. 创建游戏场景，设置较大的世界边界以便矩形移动\n2. 使用 Graphics 或 Rectangle 创建一个可见的矩形对象\n3. 在 create 中调用 camera.startFollow() 让相机跟随矩形\n4. 在 update 中更新矩形的 x 坐标，实现自动向右移动\n5. 设置相机边界与世界边界一致，确保相机不会超出世界范围\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet speed = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，创建一个更大的游戏世界\n  this.cameras.main.setBounds(0, 0, 3000, 600);\n  this.physics.world.setBounds(0, 0, 3000, 600);\n\n  // 使用 Rectangle 创建一个红色矩形作为玩家对象\n  player = this.add.rectangle(100, 300, 50, 50, 0xff0000);\n  \n  // 添加一些参考点（网格），帮助观察相机跟随效果\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 3000; x += 100) {\n    graphics.lineBetween(x, 0, x, 600);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 600; y += 100) {\n    graphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加位置标记文本\n  for (let x = 0; x <= 3000; x += 500) {\n    this.add.text(x + 10, 10, `X: ${x}`, {\n      fontSize: '16px',\n      color: '#ffffff'\n    });\n  }\n\n  // 设置相机跟随玩家矩形，保持居中\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 可选：设置跟随偏移量（如果需要让对象不在正中心）\n  // this.cameras.main.setFollowOffset(0, 0);\n\n  // 添加提示文本（固定在相机上）\n  const instruction = this.add.text(10, 10, 'Red rectangle moving right\\nCamera follows automatically', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  instruction.setScrollFactor(0); // 固定在相机上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让矩形自动向右移动\n  player.x += speed;\n\n  // 当矩形到达世界边界时，可以选择停止或循环\n  if (player.x > 2950) {\n    // 到达边界后停止\n    speed = 0;\n    \n    // 或者循环回起点（取消下面的注释）\n    // player.x = 50;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000504_v2", "prompt_id": "seed_000504", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个星形在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个 Sprite 使用星形纹理，初始 alpha 设置为 0（透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 1 秒，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个五角星\n  const points = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const numPoints = 5;\n  \n  for (let i = 0; i < numPoints * 2; i++) {\n    const angle = (i * Math.PI) / numPoints - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = 50 + Math.cos(angle) * radius;\n    const y = 50 + Math.sin(angle) * radius;\n    points.push(x, y);\n  }\n  \n  // 填充星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 设置初始透明度为 0（完全透明）\n  star.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: star,\n    alpha: 1,              // 目标透明度为 1（完全不透明）\n    duration: 1000,        // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',        // 线性缓动\n    yoyo: true,            // 往返动画（从 0 到 1 再从 1 到 0）\n    repeat: -1             // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000258_v3", "prompt_id": "seed_000258", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色椭圆，大小约为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色椭圆，大小约为 48 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Phaser.Game\nSTEPS:\n1. 创建 Phaser 游戏配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为绿色\n4. 使用 fillEllipse 在画布中央绘制椭圆，中心点为 (400, 300)，半径为 48\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为绿色 (0x00ff00)，不透明度为 1\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 在画布中央绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆的中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  graphics.fillEllipse(400, 300, 48, 48);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000656_v3", "prompt_id": "seed_000656", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现射击敌人：按WASD键发射子弹，速度 200，命中敌人时敌人消失，显示击杀数。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现WASD四方向射击系统，子弹击中敌人后敌人消失并显示击杀数\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Keyboard, Phaser.Physics.Arcade.World#overlap, Phaser.GameObjects.Text, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建玩家精灵，使用Graphics绘制方块作为纹理\n2. 设置WASD键盘输入监听，按键时发射对应方向的子弹\n3. 创建子弹组和敌人组，使用Arcade物理系统\n4. 在create中生成若干敌人，使用Graphics绘制\n5. 设置子弹与敌人的碰撞检测，命中时销毁双方并增加击杀数\n6. 显示击杀数文本，实时更新\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.killCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xffff00, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 30, 30);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50\n    });\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group({\n      defaultKey: 'enemy'\n    });\n\n    // 生成初始敌人\n    this.spawnEnemies(8);\n\n    // 设置WASD键输入\n    this.keys = {\n      w: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n      a: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n      s: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n      d: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n    };\n\n    // 防止按键重复触发的冷却时间\n    this.lastFireTime = 0;\n    this.fireDelay = 200; // 毫秒\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.bullets,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 显示击杀数文本\n    this.killText = this.add.text(16, 16, 'Kills: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n    this.killText.setDepth(100);\n\n    // 显示操作提示\n    this.add.text(16, 50, 'Press WASD to shoot', {\n      fontSize: '16px',\n      fill: '#cccccc',\n      fontFamily: 'Arial'\n    });\n  }\n\n  update(time, delta) {\n    // 检测WASD按键并发射子弹\n    if (time > this.lastFireTime + this.fireDelay) {\n      if (this.keys.w.isDown) {\n        this.fireBullet(0, -1); // 向上\n        this.lastFireTime = time;\n      } else if (this.keys.s.isDown) {\n        this.fireBullet(0, 1); // 向下\n        this.lastFireTime = time;\n      } else if (this.keys.a.isDown) {\n        this.fireBullet(-1, 0); // 向左\n        this.lastFireTime = time;\n      } else if (this.keys.d.isDown) {\n        this.fireBullet(1, 0); // 向右\n        this.lastFireTime = time;\n      }\n    }\n\n    // 清理超出边界的子弹\n    this.bullets.children.entries.forEach(bullet => {\n      if (bullet.active) {\n        if (bullet.x < -10 || bullet.x > 810 || \n            bullet.y < -10 || bullet.y > 610) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      }\n    });\n\n    // 如果敌人数量少于3个，补充敌人\n    if (this.enemies.countActive(true) < 3) {\n      this.spawnEnemies(2);\n    }\n  }\n\n  fireBullet(dirX, dirY) {\n    // 从对象池获取或创建子弹\n    let bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      bullet.body.enable = true;\n      \n      // 设置子弹速度\n      bullet.setVelocity(dirX * 200, dirY * 200);\n      \n      // 设置子弹生命周期，3秒后自动回收\n      this.time.delayedCall(3000, () => {\n        if (bullet.active) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n        }\n      });\n    }\n  }\n\n  spawnEnemies(count) {\n    for (let i = 0; i < count; i++) {\n      // 随机生成敌人位置，避免与玩家太近\n      let x, y;\n      do {\n        x = Phaser.Math.Between(50, 750);\n        y = Phaser.Math.Between(50, 550);\n      } while (Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y) < 150);\n\n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setVelocity(\n        Phaser.Math.Between(-50, 50),\n        Phaser.Math.Between(-50, 50)\n      );\n      enemy.setBounce(1);\n      enemy.setCollideWorldBounds(true);\n    }\n  }\n\n  hitEnemy(bullet, enemy) {\n    // 子弹击中敌人\n    bullet.setActive(false);\n    bullet.setVisible(false);\n    \n    enemy.destroy();\n    \n    // 增加击杀数\n    this.killCount++;\n    this.killText.setText('Kills: ' + this.killCount);\n\n    // 创建击杀特效\n    const hitEffect = this.add.graphics();\n    hitEffect.fillStyle(0xffffff, 0.8);\n    hitEffect.fillCircle(enemy.x, enemy.y, 15);\n    \n    this.tweens.add({\n      targets: hitEffect,\n      alpha: 0,\n      scale: 2,\n      duration: 300,\n      onComplete: () => {\n        hitEffect.destroy();\n      }\n    });\n  }\n}\n\n// Phaser游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000809_v3", "prompt_id": "seed_000809", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8833333333333333}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个黄色小球以 240 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个黄色小球在封闭空间内以240速度移动，碰到边界和彼此时产生弹性碰撞\nAPI: Phaser.Physics.Arcade, Graphics.generateTexture, physics.add.group, collider, setBounce, setCollideWorldBounds\nSTEPS:\n1. 配置 Arcade 物理系统，启用世界边界\n2. 使用 Graphics 绘制黄色圆形并生成纹理\n3. 创建物理组，添加5个小球精灵并设置随机速度\n4. 设置小球的弹性系数（bounce=1）和世界边界碰撞\n5. 添加小球之间的碰撞检测\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n    this.ballCount = 5; // 小球数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建黄色小球纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1); // 黄色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('yellowBall', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'yellowBall',\n      repeat: this.ballCount - 1, // 创建5个小球\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 设置每个小球的随机位置和速度\n    const balls = this.balls.getChildren();\n    balls.forEach((ball, index) => {\n      // 随机位置（避免边缘）\n      const x = Phaser.Math.Between(100, 700);\n      const y = Phaser.Math.Between(100, 500);\n      ball.setPosition(x, y);\n\n      // 随机方向，固定速度240\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(angle * Math.PI / 180) * 240;\n      const velocityY = Math.sin(angle * Math.PI / 180) * 240;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体（更精确）\n      ball.setCircle(16);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示边界（可选，用于调试）\n    const bounds = this.add.graphics();\n    bounds.lineStyle(2, 0xffffff, 0.5);\n    bounds.strokeRect(0, 0, 800, 600);\n\n    this.updateStatus();\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调，增加计数\n    this.collisionCount++;\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    // 更新状态显示\n    const balls = this.balls.getChildren();\n    let totalSpeed = 0;\n    \n    balls.forEach(ball => {\n      const speed = Math.sqrt(ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2);\n      totalSpeed += speed;\n    });\n\n    const avgSpeed = (totalSpeed / this.ballCount).toFixed(1);\n\n    this.statusText.setText([\n      `Balls: ${this.ballCount}`,\n      `Collisions: ${this.collisionCount}`,\n      `Avg Speed: ${avgSpeed}`\n    ]);\n  }\n\n  update(time, delta) {\n    // 每秒更新一次状态显示\n    if (!this.lastUpdate || time - this.lastUpdate > 1000) {\n      this.updateStatus();\n      this.lastUpdate = time;\n    }\n\n    // 确保速度保持在240左右（补偿浮点误差）\n    const balls = this.balls.getChildren();\n    balls.forEach(ball => {\n      const currentSpeed = Math.sqrt(\n        ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2\n      );\n      \n      // 如果速度偏差超过5%，进行修正\n      if (Math.abs(currentSpeed - 240) > 12) {\n        const scale = 240 / currentSpeed;\n        ball.setVelocity(\n          ball.body.velocity.x * scale,\n          ball.body.velocity.y * scale\n        );\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false // 设置为true可查看碰撞体\n    }\n  },\n  scene: GameScene\n};\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000864_v3", "prompt_id": "seed_000864", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9133333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色圆形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色圆形以360速度移动并在画布边界反弹\nAPI: Graphics.fillCircle, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 Arcade 物理引擎\n2. 使用 Graphics 绘制灰色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为 360\n4. 设置物理体碰撞世界边界并反弹\n5. 确保圆形在边界反弹时保持速度大小不变\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },  // 无重力\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建灰色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1);  // 灰色\n  graphics.fillCircle(25, 25, 25);  // 半径25的圆形\n  graphics.generateTexture('circle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  this.ball = this.physics.add.sprite(400, 300, 'circle');\n  \n  // 设置物理属性\n  this.ball.setCollideWorldBounds(true);  // 与世界边界碰撞\n  this.ball.setBounce(1, 1);  // 完全弹性碰撞，反弹系数为1\n  \n  // 设置初始速度为 360（可以是任意方向，这里设置为斜向）\n  // 使用勾股定理计算：速度大小为360，方向为45度\n  const speed = 360;\n  const angle = Math.PI / 4;  // 45度\n  const vx = Math.cos(angle) * speed;\n  const vy = Math.sin(angle) * speed;\n  \n  this.ball.setVelocity(vx, vy);\n  \n  // 确保速度保持恒定（可选：防止浮点误差累积）\n  this.targetSpeed = speed;\n}\n\nfunction update(time, delta) {\n  // 可选：修正速度大小，确保始终保持360的速度\n  // 这可以防止由于浮点运算误差导致的速度变化\n  const body = this.ball.body;\n  const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n  \n  if (Math.abs(currentSpeed - this.targetSpeed) > 0.1) {\n    const ratio = this.targetSpeed / currentSpeed;\n    body.velocity.x *= ratio;\n    body.velocity.y *= ratio;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000114_v2", "prompt_id": "seed_000114", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的青色六边形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的青色六边形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中循环15次\n3. 每次循环创建一个 Graphics 对象\n4. 计算六边形的6个顶点坐标（正六边形，边长24像素，总宽度48像素）\n5. 使用 beginPath、lineTo 绘制六边形路径\n6. 填充青色并设置随机位置（x: 0-752, y: 0-552，确保六边形完全在画布内）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 六边形参数\n  const hexagonSize = 24; // 半径（中心到顶点的距离）\n  const hexagonCount = 15;\n  const cyan = 0x00ffff;\n  \n  // 绘制15个六边形\n  for (let i = 0; i < hexagonCount; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置填充颜色为青色\n    graphics.fillStyle(cyan, 1);\n    \n    // 计算六边形的6个顶点（正六边形，顶点在圆周上，间隔60度）\n    graphics.beginPath();\n    for (let j = 0; j < 6; j++) {\n      const angle = (Math.PI / 3) * j - Math.PI / 2; // 从顶部开始，每个顶点间隔60度\n      const x = Math.cos(angle) * hexagonSize;\n      const y = Math.sin(angle) * hexagonSize;\n      \n      if (j === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（确保六边形完全在画布内）\n    // 六边形的边界框大小约为 48x48（直径）\n    const padding = hexagonSize + 4; // 留一些边距\n    const randomX = padding + Math.random() * (800 - padding * 2);\n    const randomY = padding + Math.random() * (600 - padding * 2);\n    \n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000195_v3", "prompt_id": "seed_000195", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的黄色圆形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在场景中绘制20个随机位置的黄色圆形，每个直径24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布尺寸\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环20次，每次生成随机坐标\n4. 使用 fillStyle 设置黄色，fillCircle 绘制圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 圆形半径（直径24像素，半径12像素）\n  const radius = 12;\n  \n  // 绘制20个随机位置的圆形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机坐标，确保圆形完全在画布内\n    const x = Phaser.Math.Between(radius, config.width - radius);\n    const y = Phaser.Math.Between(radius, config.height - radius);\n    \n    // 绘制圆形\n    graphics.fillCircle(x, y, radius);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000769_v3", "prompt_id": "seed_000769", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色圆形以300速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制绿色圆形并生成纹理\n3. 创建物理精灵并设置初始速度为300\n4. 设置边界碰撞和反弹系数为1\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25); // 圆心在(25,25)，半径25\n  \n  // 生成纹理\n  graphics.generateTexture('greenCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'greenCircle');\n  \n  // 设置圆形为圆形物理体（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置初始速度（300速度，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  circle.setVelocity(velocityX, velocityY);\n  \n  // 设置与世界边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000557_v2", "prompt_id": "seed_000557", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个缩放动画效果：让粉色星形在 1.5 秒内完成一次缩放，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色星形并实现1.5秒循环缩放动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setScale\nSTEPS:\n1. 使用 Graphics 绘制粉色星形并生成纹理\n2. 创建使用该纹理的 Sprite 对象并居中显示\n3. 使用 Tween 系统创建缩放动画（scale 从 1 到 1.5 再回到 1）\n4. 设置动画循环播放（loop: -1）和持续时间 1500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制星形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制星形（五角星）\n  const starPoints = [];\n  const outerRadius = 50;\n  const innerRadius = 20;\n  const points = 5;\n  \n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const x = 60 + Math.cos(angle) * radius;\n    const y = 60 + Math.sin(angle) * radius;\n    starPoints.push(x, y);\n  }\n  \n  graphics.fillPoints(starPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkStar', 120, 120);\n  graphics.destroy();\n  \n  // 创建星形精灵并居中\n  const star = this.add.sprite(400, 300, 'pinkStar');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: star,\n    scaleX: 1.5,\n    scaleY: 1.5,\n    duration: 750, // 放大阶段 0.75 秒\n    yoyo: true,    // 自动反向播放（缩小回原大小）\n    repeat: -1,    // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Pink Star Scaling Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000282_v3", "prompt_id": "seed_000282", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制三角形\n2. 在 create 中设置三角形的位置和初始旋转\n3. 在 update 中根据 delta 时间增量更新旋转角度（160度/秒 = 160 * (Math.PI/180) 弧度/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心在原点）\n  const size = 80;\n  const height = size * Math.sqrt(3) / 2;\n  graphics.fillTriangle(\n    0, -height * 2/3,           // 顶点\n    -size/2, height * 1/3,      // 左下\n    size/2, height * 1/3        // 右下\n  );\n  \n  // 设置三角形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 存储到 scene 数据中，便于在 update 中访问\n  this.triangle = graphics;\n  \n  // 添加文字提示\n  this.add.text(10, 10, '三角形以每秒 160° 旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 每秒旋转 160 度，转换为弧度\n  const rotationSpeed = 160 * (Math.PI / 180); // 弧度/秒\n  \n  // 更新旋转角度\n  this.triangle.rotation += rotationSpeed * deltaSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000424_v3", "prompt_id": "seed_000424", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的六边形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的六边形\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Container\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建精灵对象并设置自动向右移动的逻辑\n3. 使用相机的 startFollow 方法让相机跟随六边形\n4. 在 update 中更新六边形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nconst moveSpeed = 100; // 每秒移动的像素数\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制六边形（中心点在 32, 32）\n  const hexRadius = 30;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    hexPoints.push({\n      x: 32 + hexRadius * Math.cos(angle),\n      y: 32 + hexRadius * Math.sin(angle)\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0].x, hexPoints[0].y);\n  for (let i = 1; i < hexPoints.length; i++) {\n    graphics.lineTo(hexPoints[i].x, hexPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 64, 64);\n  graphics.destroy();\n  \n  // 创建六边形精灵，初始位置在场景中心\n  hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置相机跟随六边形\n  this.cameras.main.startFollow(hexagon, true, 0.1, 0.1);\n  \n  // 设置世界边界，让六边形有足够的移动空间\n  this.cameras.main.setBounds(0, 0, 3000, 600);\n  \n  // 添加一些参考网格以便观察相机跟随效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直网格线\n  for (let x = 0; x <= 3000; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 600);\n  }\n  \n  // 绘制水平网格线\n  for (let y = 0; y <= 600; y += 100) {\n    gridGraphics.lineBetween(0, y, 3000, y);\n  }\n  \n  // 添加文字提示\n  const text = this.add.text(10, 10, 'Camera follows the hexagon', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 让文字固定在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 让六边形向右移动\n  hexagon.x += moveSpeed * (delta / 1000);\n  \n  // 当六边形移出世界边界时，重置位置\n  if (hexagon.x > 3000) {\n    hexagon.x = 0;\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000359_v3", "prompt_id": "seed_000359", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8716666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的红色六边形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的红色六边形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，根据中心点和半径计算6个顶点坐标\n4. 使用循环绘制20个六边形，每个位置随机，大小为24像素（半径12）\n5. 设置红色填充样式 0xff0000\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置红色填充\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制20个随机位置的六边形\n  for (let i = 0; i < 20; i++) {\n    // 随机位置，留出边距避免六边形被裁切\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const radius = 12; // 大小24像素，半径为12\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, radius);\n  }\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} radius - 六边形半径\n */\nfunction drawHexagon(graphics, x, y, radius) {\n  graphics.beginPath();\n  \n  // 六边形有6个顶点，从顶部开始顺时针绘制\n  for (let i = 0; i < 6; i++) {\n    // 计算角度（从-90度开始，使六边形顶点朝上）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const px = x + radius * Math.cos(angle);\n    const py = y + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(px, py);\n    } else {\n      graphics.lineTo(px, py);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000108_v3", "prompt_id": "seed_000108", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色圆形，大小约为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色圆形，大小约为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用 fillStyle 设置绿色填充色\n4. 使用 fillCircle 在画布中央 (400, 300) 绘制半径为 32 的圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#282c34'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色 (0x00ff00)，透明度为 1\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数: x坐标, y坐标, 半径\n  // 画布中央为 (400, 300)，半径为 32 像素（直径 64 像素）\n  graphics.fillCircle(400, 300, 32);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000717_v3", "prompt_id": "seed_000717", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的黄色圆形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的黄色圆形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillCircle, Graphics#setPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环12次\n3. 每次循环创建一个 Graphics 对象，设置黄色填充样式\n4. 使用 fillCircle 绘制半径为24像素的圆形（直径48像素）\n5. 使用 Math.random() 生成随机 x 和 y 坐标，确保圆形完全在画布内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 圆形半径\n  const radius = 24; // 直径48像素\n  \n  // 绘制12个随机位置的黄色圆形\n  for (let i = 0; i < 12; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置黄色填充样式\n    graphics.fillStyle(0xffff00, 1);\n    \n    // 绘制圆形（圆心在 (0, 0)）\n    graphics.fillCircle(0, 0, radius);\n    \n    // 生成随机位置，确保圆形完全在画布内\n    // x 范围: radius 到 width - radius\n    // y 范围: radius 到 height - radius\n    const randomX = radius + Math.random() * (this.game.config.width - 2 * radius);\n    const randomY = radius + Math.random() * (this.game.config.height - 2 * radius);\n    \n    // 设置圆形位置\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000092_v2", "prompt_id": "seed_000092", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在4秒内从透明到不透明循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个 Sprite 对象使用该纹理\n3. 设置初始透明度为0（完全透明）\n4. 使用 Tween 动画让 alpha 从0渐变到1，持续4秒\n5. 设置 Tween 循环播放（yoyo 或 repeat -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 程序化生成矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('rectangle', 200, 150);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建矩形精灵并放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'rectangle');\n  \n  // 设置初始透明度为0（完全透明）\n  rect.setAlpha(0);\n  \n  // 创建渐变动画：从透明(0)到不透明(1)，持续4秒，无限循环\n  this.tweens.add({\n    targets: rect,\n    alpha: 1,              // 目标透明度为1（完全不透明）\n    duration: 4000,        // 持续4秒\n    ease: 'Linear',        // 线性渐变\n    yoyo: true,            // 来回播放（1->0->1）\n    repeat: -1             // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '矩形透明度循环动画（4秒）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000296_v3", "prompt_id": "seed_000296", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个圆形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制圆形以 200 像素/秒速度移动\nAPI: Phaser.Game, Phaser.Scene, this.add.graphics, this.input.keyboard.addKeys, Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Game 配置和 Scene，设置 800x600 画布\n2. 在 create 中使用 Graphics 绘制一个圆形，并生成纹理\n3. 创建 Sprite 对象作为可移动的圆形角色\n4. 使用 addKeys 绑定 WASD 键盘输入\n5. 在 update 中检测按键状态，根据速度 200 和 delta 计算位移并更新圆形位置\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - WASD 控制圆形移动\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局变量存储游戏对象\nlet player;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 本游戏不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(25, 25, 25); // 半径 25 的圆形\n  graphics.generateTexture('playerCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建玩家圆形 Sprite，初始位置在画布中心\n  player = this.add.sprite(400, 300, 'playerCircle');\n\n  // 绑定 WASD 键\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the circle', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间（秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 检测 W 键（向上）\n  if (keys.w.isDown) {\n    player.y -= distance;\n  }\n\n  // 检测 S 键（向下）\n  if (keys.s.isDown) {\n    player.y += distance;\n  }\n\n  // 检测 A 键（向左）\n  if (keys.a.isDown) {\n    player.x -= distance;\n  }\n\n  // 检测 D 键（向右）\n  if (keys.d.isDown) {\n    player.x += distance;\n  }\n\n  // 边界限制（可选）- 防止圆形移出画布\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000173_v3", "prompt_id": "seed_000173", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现白色矩形在1秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色矩形并生成纹理\n2. 创建 Sprite 对象作为动画目标\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 60, 40);\n  graphics.generateTexture('whiteRect', 60, 40);\n  graphics.destroy();\n\n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n\n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（右侧）\n    duration: 1000,          // 持续时间 1 秒\n    yoyo: true,              // 启用往返效果（到达目标后反向运动）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动函数，匀速运动\n  });\n\n  // 添加提示文本\n  this.add.text(400, 100, '白色矩形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000336_v2", "prompt_id": "seed_000336", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色菱形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色菱形以300速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制粉色菱形并生成纹理\n2. 启用 Arcade 物理系统创建物理精灵\n3. 设置初始速度为300，启用世界边界碰撞和反弹\n4. 配置物理世界边界与画布大小一致\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  \n  // 绘制菱形（四个点构成的多边形）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);      // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const diamond = this.physics.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始速度（随机方向，速度为300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  diamond.setVelocity(velocityX, velocityY);\n  \n  // 设置与世界边界碰撞\n  diamond.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  diamond.setBounce(1, 1);\n  \n  // 确保物理世界边界与画布大小一致\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000453_v3", "prompt_id": "seed_000453", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色三角形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色三角形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.lineStyle, Graphics.strokeTriangle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置紫色填充样式（0x800080）\n4. 计算画布中心点坐标（400, 300）\n5. 使用 fillTriangle 绘制等边三角形，三个顶点相对中心点偏移约 12 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充样式\n  graphics.fillStyle(0x800080, 1);\n  \n  // 计算画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 三角形大小约为 24 像素，计算等边三角形的三个顶点\n  // 顶点1：顶部中心\n  const x1 = centerX;\n  const y1 = centerY - 12;\n  \n  // 顶点2：左下角\n  const x2 = centerX - 12;\n  const y2 = centerY + 12;\n  \n  // 顶点3：右下角\n  const x3 = centerX + 12;\n  const y3 = centerY + 12;\n  \n  // 绘制填充三角形\n  graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000201_v3", "prompt_id": "seed_000201", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的粉色三角形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的粉色三角形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置粉色填充色 (0xff69b4)\n4. 使用 fillTriangle 绘制等边三角形，边长64像素\n5. 使用 Phaser.Math.Between 生成随机 x, y 坐标位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 三角形的大小（边长）\n  const size = 64;\n  \n  // 计算等边三角形的高度\n  const height = (Math.sqrt(3) / 2) * size;\n  \n  // 绘制12个随机位置的粉色三角形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置（确保三角形完全在画布内）\n    const x = Phaser.Math.Between(size / 2, 800 - size / 2);\n    const y = Phaser.Math.Between(height, 600 - height / 2);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 绘制等边三角形（顶点朝上）\n    // 三个顶点坐标相对于中心点\n    const x1 = x;                    // 顶部顶点\n    const y1 = y - height / 2;\n    \n    const x2 = x - size / 2;         // 左下顶点\n    const y2 = y + height / 2;\n    \n    const x3 = x + size / 2;         // 右下顶点\n    const y3 = y + height / 2;\n    \n    // 填充三角形\n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000330_v1", "prompt_id": "seed_000330", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现白色血条 UI：显示 10 格生命值，按空格键扣血，血量为 0 时显示 Game Over。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现白色血条UI，10格生命值，空格键扣血，血量为0显示Game Over\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text, Phaser.Scene\nSTEPS:\n1. 创建 Scene 类，初始化 health 变量为 10\n2. 在 create 中使用 Graphics 绘制 10 个白色方格血条\n3. 监听空格键输入事件，每次按下扣除 1 点生命值\n4. 更新血条显示，根据当前生命值重绘血条（空血格显示为灰色边框）\n5. 当生命值为 0 时显示 Game Over 文本并停止接受输入\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.health = 10; // 可验证的状态信号\n    this.maxHealth = 10;\n    this.isGameOver = false;\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建标题文本\n    this.add.text(400, 100, 'Health Bar Demo', {\n      fontSize: '32px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建提示文本\n    this.add.text(400, 150, 'Press SPACE to take damage', {\n      fontSize: '20px',\n      color: '#cccccc',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 创建血条容器（用于绘制血条）\n    this.healthBarGraphics = this.add.graphics();\n    \n    // 创建生命值文本显示\n    this.healthText = this.add.text(400, 250, `Health: ${this.health}/${this.maxHealth}`, {\n      fontSize: '24px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // Game Over 文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 400, 'GAME OVER', {\n      fontSize: '48px',\n      color: '#ff0000',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setVisible(false);\n\n    // 监听空格键\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n    \n    // 绘制初始血条\n    this.drawHealthBar();\n  }\n\n  update() {\n    // 检测空格键按下（使用 justDown 避免连续触发）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && !this.isGameOver) {\n      this.takeDamage();\n    }\n  }\n\n  takeDamage() {\n    if (this.health > 0) {\n      this.health -= 1;\n      this.healthText.setText(`Health: ${this.health}/${this.maxHealth}`);\n      this.drawHealthBar();\n\n      // 检查是否死亡\n      if (this.health === 0) {\n        this.triggerGameOver();\n      }\n    }\n  }\n\n  drawHealthBar() {\n    // 清除之前的绘制\n    this.healthBarGraphics.clear();\n\n    const barWidth = 40; // 每格血条宽度\n    const barHeight = 50; // 血条高度\n    const barSpacing = 5; // 血条间距\n    const startX = 400 - (this.maxHealth * (barWidth + barSpacing)) / 2; // 居中起始位置\n    const startY = 300;\n\n    for (let i = 0; i < this.maxHealth; i++) {\n      const x = startX + i * (barWidth + barSpacing);\n      \n      if (i < this.health) {\n        // 有生命值的格子 - 白色填充\n        this.healthBarGraphics.fillStyle(0xffffff, 1);\n        this.healthBarGraphics.fillRect(x, startY, barWidth, barHeight);\n        \n        // 添加黑色边框\n        this.healthBarGraphics.lineStyle(2, 0x000000, 1);\n        this.healthBarGraphics.strokeRect(x, startY, barWidth, barHeight);\n      } else {\n        // 失去生命值的格子 - 灰色边框\n        this.healthBarGraphics.lineStyle(2, 0x666666, 1);\n        this.healthBarGraphics.strokeRect(x, startY, barWidth, barHeight);\n      }\n    }\n  }\n\n  triggerGameOver() {\n    this.isGameOver = true;\n    this.gameOverText.setVisible(true);\n    \n    // 添加重启提示\n    this.add.text(400, 470, 'Refresh to restart', {\n      fontSize: '20px',\n      color: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000910_v2", "prompt_id": "seed_000910", "source": "distill", "difficulty": "medium", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色星形以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色星形以120速度移动并在边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 配置物理系统(arcade)，创建800x600画布\n2. 使用Graphics绘制红色星形并生成纹理\n3. 创建物理精灵，设置初始速度(120, 120)\n4. 设置精灵与世界边界碰撞，反弹系数为1\n5. 在update中保持速度恒定为120\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet star;\n\nfunction preload() {\n  // 创建红色星形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillStar(32, 32, 5, 16, 32, 0);\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理精灵\n  star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（120像素/秒，角度约45度）\n  const speed = 120;\n  const angle = Math.PI / 4; // 45度\n  star.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置与世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置完全弹性碰撞（反弹系数为1）\n  star.setBounce(1, 1);\n  \n  // 禁用摩擦力，保持速度恒定\n  star.setDamping(false);\n}\n\nfunction update(time, delta) {\n  // 确保速度保持恒定为120\n  const currentSpeed = Math.sqrt(\n    star.body.velocity.x * star.body.velocity.x +\n    star.body.velocity.y * star.body.velocity.y\n  );\n  \n  if (currentSpeed > 0 && Math.abs(currentSpeed - 120) > 0.1) {\n    // 归一化速度向量并乘以目标速度\n    star.setVelocity(\n      (star.body.velocity.x / currentSpeed) * 120,\n      (star.body.velocity.y / currentSpeed) * 120\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000668_v2", "prompt_id": "seed_000668", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的粉色矩形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的粉色矩形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用循环生成10个矩形，每次循环随机生成 x、y 坐标\n4. 使用 fillStyle 设置粉色填充颜色（0xff69b4）\n5. 使用 fillRect 在随机位置绘制 64x64 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充颜色\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制10个随机位置的矩形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机 x 坐标（确保矩形完全在画布内）\n    const randomX = Phaser.Math.Between(0, config.width - 64);\n    \n    // 生成随机 y 坐标（确保矩形完全在画布内）\n    const randomY = Phaser.Math.Between(0, config.height - 64);\n    \n    // 绘制 64x64 的粉色矩形\n    graphics.fillRect(randomX, randomY, 64, 64);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000774_v2", "prompt_id": "seed_000774", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色三角形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色三角形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，设置 repeat 为 -1 实现无限循环\n5. 设置 duration 为 4000 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制三角形（中心点在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-25, 30);     // 左下角\n  graphics.lineTo(25, 30);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('pinkTriangle', 50, 60);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'pinkTriangle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 4000,              // 持续时间 4 秒\n    yoyo: true,                  // 往返效果（到达终点后反向播放）\n    repeat: -1,                  // 无限循环（-1 表示永久重复）\n    ease: 'Linear'               // 线性缓动，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '粉色三角形往返循环移动', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000728_v3", "prompt_id": "seed_000728", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在2秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 创建一个方块并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为0\n3. 使用 Tween 动画将 alpha 从0渐变到1，持续2秒\n4. 设置 Tween 循环播放（repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建精灵对象并设置到屏幕中心\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为0（完全透明）\n  square.setAlpha(0);\n\n  // 创建渐变动画：从透明(0)到不透明(1)，持续2秒，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值\n    duration: 2000,            // 持续时间2秒（2000毫秒）\n    ease: 'Linear',            // 线性缓动\n    repeat: -1,                // 无限循环（-1表示永久重复）\n    yoyo: false                // 不使用往返效果，只从0到1循环\n  });\n\n  // 添加文字说明\n  this.add.text(400, 500, 'Square fading from transparent to opaque (2s loop)', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000458_v2", "prompt_id": "seed_000458", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 2.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个星形在 2.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个星形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象，初始透明度设为 0\n3. 使用 Tween 系统创建 alpha 属性的补间动画，从 0 到 1，持续 2.5 秒\n4. 设置 Tween 的 loop 属性为 -1 实现无限循环，yoyo 为 true 实现来回渐变效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色星形\n  \n  // 绘制五角星\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 18;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建星形精灵，放置在屏幕中央\n  const star = this.add.sprite(400, 300, 'star');\n  star.setAlpha(0); // 初始设置为完全透明\n  \n  // 创建渐变动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: star,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 2500, // 持续时间 2.5 秒\n    ease: 'Linear', // 线性渐变\n    yoyo: true, // 来回播放（透明->不透明->透明）\n    loop: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000426_v2", "prompt_id": "seed_000426", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Arcade 物理精灵并应用三角形纹理\n3. 设置精灵初始速度为 160（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制一个等边三角形（中心对齐）\n  // 三角形顶点坐标（相对于中心点）\n  const triangleHeight = 40;\n  const triangleBase = 40;\n  \n  graphics.fillTriangle(\n    0, -triangleHeight / 2,           // 顶点（上）\n    -triangleBase / 2, triangleHeight / 2,  // 左下\n    triangleBase / 2, triangleHeight / 2    // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleBase, triangleHeight);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（斜向移动，总速度约为 160）\n  // 使用勾股定理：sqrt(113^2 + 113^2) ≈ 160\n  triangle.setVelocity(113, 113);\n  \n  // 设置边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, 'White triangle bouncing at speed 160', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000589_v1", "prompt_id": "seed_000589", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色三角形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色三角形以200速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用Graphics绘制灰色三角形并生成纹理\n2. 启用Arcade物理系统\n3. 创建物理精灵并应用三角形纹理\n4. 设置初始速度为200\n5. 启用世界边界碰撞和反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用Graphics绘制灰色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 顶点\n  graphics.lineTo(0, 56);      // 左下角\n  graphics.lineTo(64, 56);     // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 64, 56);\n  graphics.destroy(); // 销毁graphics对象，只保留纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 200);\n  triangle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000635_v2", "prompt_id": "seed_000635", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 360 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆形状\n2. 在 update 方法中根据 delta 时间累加旋转角度\n3. 每秒旋转 360 度，即每毫秒旋转 360/1000 度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制椭圆\n  ellipse = this.add.graphics();\n  \n  // 设置椭圆位置到屏幕中心\n  ellipse.x = 400;\n  ellipse.y = 300;\n  \n  // 设置填充样式并绘制椭圆\n  ellipse.fillStyle(0x00ff00, 1);\n  // 椭圆中心在 (0, 0)，宽度 200，高度 100\n  ellipse.fillEllipse(0, 0, 200, 100);\n  \n  // 添加一个标记点，用于观察旋转效果\n  ellipse.fillStyle(0xff0000, 1);\n  ellipse.fillCircle(100, 0, 10);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 360 度 = 2π 弧度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 每帧旋转角度 = (2 * Math.PI) * (delta / 1000)\n  const rotationSpeed = (2 * Math.PI) / 1000; // 弧度/毫秒\n  ellipse.rotation += rotationSpeed * delta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000584_v1", "prompt_id": "seed_000584", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 10 个金币，重力 400，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集10个金币，重力400，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 400\n2. 使用 Graphics 创建角色、平台和金币的纹理\n3. 创建玩家精灵，添加物理属性和碰撞体\n4. 创建静态平台组，添加多个平台\n5. 创建金币组（10个），随机分布在空中\n6. 添加键盘输入控制（左右移动和跳跃）\n7. 实现玩家与平台的碰撞检测\n8. 实现玩家与金币的重叠检测和收集逻辑\n9. 创建分数文本显示，实时更新\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet platforms;\nlet coins;\nlet cursors;\nlet score = 0;\nlet scoreText;\n\nfunction preload() {\n  // 创建玩家纹理（蓝色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x0088ff, 1);\n  playerGraphics.fillRect(0, 0, 32, 48);\n  playerGraphics.generateTexture('player', 32, 48);\n  playerGraphics.destroy();\n\n  // 创建平台纹理（灰色矩形）\n  const platformGraphics = this.add.graphics();\n  platformGraphics.fillStyle(0x666666, 1);\n  platformGraphics.fillRect(0, 0, 200, 20);\n  platformGraphics.generateTexture('platform', 200, 20);\n  platformGraphics.destroy();\n\n  // 创建金币纹理（黄色圆形）\n  const coinGraphics = this.add.graphics();\n  coinGraphics.fillStyle(0xffdd00, 1);\n  coinGraphics.fillCircle(16, 16, 16);\n  coinGraphics.lineStyle(2, 0xffaa00, 1);\n  coinGraphics.strokeCircle(16, 16, 16);\n  coinGraphics.generateTexture('coin', 32, 32);\n  coinGraphics.destroy();\n}\n\nfunction create() {\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#fff',\n    fontFamily: 'Arial'\n  });\n  scoreText.setDepth(10);\n\n  // 创建平台组\n  platforms = this.physics.add.staticGroup();\n\n  // 地面平台\n  platforms.create(400, 580, 'platform').setScale(4, 1).refreshBody();\n\n  // 中间平台\n  platforms.create(600, 450, 'platform');\n  platforms.create(200, 450, 'platform');\n  platforms.create(400, 350, 'platform');\n  platforms.create(100, 250, 'platform');\n  platforms.create(700, 250, 'platform');\n  platforms.create(400, 150, 'platform');\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 500, 'player');\n  player.setBounce(0.1);\n  player.setCollideWorldBounds(true);\n\n  // 玩家与平台碰撞\n  this.physics.add.collider(player, platforms);\n\n  // 创建金币组\n  coins = this.physics.add.group({\n    key: 'coin',\n    repeat: 9, // 创建10个金币\n    setXY: { x: 0, y: 0 }\n  });\n\n  // 手动设置金币位置（分布在各个平台上方）\n  const coinPositions = [\n    { x: 600, y: 400 },\n    { x: 200, y: 400 },\n    { x: 400, y: 300 },\n    { x: 100, y: 200 },\n    { x: 700, y: 200 },\n    { x: 400, y: 100 },\n    { x: 300, y: 500 },\n    { x: 500, y: 500 },\n    { x: 150, y: 350 },\n    { x: 650, y: 350 }\n  ];\n\n  coins.children.entries.forEach((coin, index) => {\n    coin.setPosition(coinPositions[index].x, coinPositions[index].y);\n    coin.setBounce(0.3);\n    coin.setCollideWorldBounds(true);\n  });\n\n  // 金币与平台碰撞\n  this.physics.add.collider(coins, platforms);\n\n  // 玩家与金币重叠检测\n  this.physics.add.overlap(player, coins, collectCoin, null, this);\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update() {\n  // 左右移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-200);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(200);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃控制（只有在地面或平台上才能跳跃）\n  if (cursors.up.isDown && player.body.touching.down) {\n    player.setVelocityY(-400);\n  }\n}\n\nfunction collectCoin(player, coin) {\n  // 移除金币\n  coin.disableBody(true, true);\n\n  // 增加分数\n  score += 10;\n  scoreText.setText('Score: ' + score);\n\n  // 检查是否收集完所有金币\n  if (score === 100) {\n    scoreText.setText('Score: ' + score + ' - YOU WIN!');\n    scoreText.setStyle({ fill: '#00ff00' });\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001210_v3", "prompt_id": "seed_001210", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现粉色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 粉色角色通过按键切换 idle/run 状态，使用帧动画和 tween 体现差异\nAPI: Graphics.generateTexture, AnimationManager.create, Input.Keyboard.addKey, Sprite.play, Tween.add\nSTEPS:\n1. 使用 Graphics 程序化生成粉色角色的多帧纹理（idle 和 run 各 4 帧）\n2. 创建 idle 和 run 的帧动画\n3. 监听按键输入（I 键切换 idle，R 键切换 run）\n4. 根据状态切换动画并添加 tween 效果（run 时左右移动）\n5. 显示当前状态文本作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle'; // 状态信号\n    this.stateChangeCount = 0; // 状态切换计数\n  }\n\n  preload() {\n    // 程序化生成粉色角色纹理\n    this.generateCharacterTextures();\n  }\n\n  generateCharacterTextures() {\n    const graphics = this.add.graphics();\n    \n    // 生成 idle 动画帧（4 帧，轻微上下浮动效果）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      \n      // 粉色身体（圆角矩形）\n      const offsetY = Math.sin(i * Math.PI / 2) * 2; // 轻微浮动\n      graphics.fillStyle(0xff69b4, 1);\n      graphics.fillRoundedRect(8, 16 + offsetY, 48, 64, 8);\n      \n      // 眼睛\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(24, 36 + offsetY, 4);\n      graphics.fillCircle(40, 36 + offsetY, 4);\n      \n      // 嘴巴\n      graphics.lineStyle(2, 0x000000, 1);\n      graphics.beginPath();\n      graphics.arc(32, 48 + offsetY, 8, 0, Math.PI, false);\n      graphics.strokePath();\n      \n      graphics.generateTexture(`idle_${i}`, 64, 96);\n    }\n    \n    // 生成 run 动画帧（4 帧，腿部摆动效果）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      \n      // 粉色身体\n      graphics.fillStyle(0xff69b4, 1);\n      graphics.fillRoundedRect(8, 16, 48, 64, 8);\n      \n      // 眼睛（跑步时更专注，眼睛稍微眯起）\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillEllipse(24, 36, 4, 3);\n      graphics.fillEllipse(40, 36, 4, 3);\n      \n      // 嘴巴（O 形表示喘气）\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(32, 48, 4);\n      \n      // 腿部动画（交替摆动）\n      const legOffset = Math.sin(i * Math.PI / 2) * 8;\n      graphics.fillStyle(0xff1493, 1);\n      \n      // 左腿\n      graphics.fillRect(16, 76, 8, 16 + legOffset);\n      \n      // 右腿\n      graphics.fillRect(40, 76, 8, 16 - legOffset);\n      \n      // 手臂摆动\n      graphics.fillRect(4, 40 - legOffset / 2, 8, 20);\n      graphics.fillRect(52, 40 + legOffset / 2, 8, 20);\n      \n      graphics.generateTexture(`run_${i}`, 64, 96);\n    }\n    \n    graphics.destroy();\n  }\n\n  create() {\n    // 添加背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x87ceeb, 1);\n    bg.fillRect(0, 0, 800, 600);\n    \n    // 添加地面\n    const ground = this.add.graphics();\n    ground.fillStyle(0x90ee90, 1);\n    ground.fillRect(0, 500, 800, 100);\n    \n    // 创建角色精灵\n    this.character = this.add.sprite(400, 450, 'idle_0');\n    this.character.setScale(1.5);\n    \n    // 创建 idle 动画\n    this.anims.create({\n      key: 'idle',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' },\n        { key: 'idle_2' },\n        { key: 'idle_3' }\n      ],\n      frameRate: 6,\n      repeat: -1\n    });\n    \n    // 创建 run 动画\n    this.anims.create({\n      key: 'run',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 10,\n      repeat: -1\n    });\n    \n    // 播放初始 idle 动画\n    this.character.play('idle');\n    \n    // 添加状态显示文本\n    this.stateText = this.add.text(400, 50, 'State: IDLE', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 4\n    }).setOrigin(0.5);\n    \n    // 添加计数显示\n    this.countText = this.add.text(400, 100, 'State Changes: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 3\n    }).setOrigin(0.5);\n    \n    // 添加提示文本\n    this.add.text(400, 550, 'Press [I] for IDLE | Press [R] for RUN', {\n      fontSize: '20px',\n      fill: '#333333'\n    }).setOrigin(0.5);\n    \n    // 绑定按键\n    this.keyI = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);\n    this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n    \n    // 按键事件监听\n    this.keyI.on('down', () => this.switchState('idle'));\n    this.keyR.on('down', () => this.switchState('run'));\n    \n    // 用于存储 tween 引用\n    this.runTween = null;\n  }\n\n  switchState(newState) {\n    if (this.currentState === newState) {\n      return; // 已经是当前状态，不切换\n    }\n    \n    this.currentState = newState;\n    this.stateChangeCount++;\n    \n    // 更新显示文本\n    this.stateText.setText(`State: ${newState.toUpperCase()}`);\n    this.countText.setText(`State Changes: ${this.stateChangeCount}`);\n    \n    // 停止之前的 tween\n    if (this.runTween) {\n      this.runTween.stop();\n      this.runTween = null;\n    }\n    \n    if (newState === 'idle') {\n      // 切换到 idle 动画\n      this.character.play('idle');\n      \n      // 重置位置（带缓动效果）\n      this.tweens.add({\n        targets: this.character,\n        x: 400,\n        duration: 500,\n        ease: 'Power2'\n      });\n      \n      // 添加轻微的上下浮动 tween\n      this.tweens.add({\n        targets: this.character,\n        y: 445,\n        duration: 1000,\n        yoyo: true,\n        repeat: -1,\n        ease: 'Sine.easeInOut'\n      });\n      \n    } else if (newState === 'run') {\n      // 切换到 run 动画\n      this.character.play('run');\n      \n      // 停止浮动效果\n      this.tweens.killTweensOf(this.character);\n      \n      // 添加左右移动 tween\n      this.runTween = this.tweens.add({\n        targets: this.character,\n        x: 700,\n        y: 450,\n        duration: 2000,\n        yoyo: true,\n        repeat: -1,\n        ease: 'Linear',\n        onYoyo: () => {\n          // 转向\n          this.character.setFlipX(true);\n        },\n        onRepeat: () => {\n          // 转向\n          this.character.setFlipX(false);\n        }\n      });\n    }\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  scene: GameScene,\n  parent: 'game-container'\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000805_v2", "prompt_id": "seed_000805", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现多方向射击：按鼠标右键向当前朝向发射子弹，子弹速度 240，玩家可旋转改变朝向。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现鼠标右键射击，子弹沿玩家朝向飞行，玩家可旋转改变朝向\nAPI: Phaser.Physics.Arcade.Group, Phaser.Input.Pointer, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统场景，初始化玩家精灵（三角形表示朝向）\n2. 监听鼠标移动事件，计算玩家朝向鼠标的角度并旋转\n3. 监听鼠标右键点击事件，在玩家位置创建子弹\n4. 根据玩家当前旋转角度设置子弹速度向量（速度240）\n5. 使用物理组管理子弹，超出边界自动销毁\n[/PLAN]\n\n```javascript\nclass ShootingScene extends Phaser.Scene {\n  constructor() {\n    super('ShootingScene');\n    this.bulletCount = 0; // 可验证状态：发射的子弹总数\n    this.activeBullets = 0; // 可验证状态：当前活跃子弹数\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（三角形，指示朝向）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.beginPath();\n    playerGraphics.moveTo(20, 0);  // 尖端指向右侧\n    playerGraphics.lineTo(-10, -10);\n    playerGraphics.lineTo(-10, 10);\n    playerGraphics.closePath();\n    playerGraphics.fill();\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建子弹纹理（小圆形）\n    const bulletGraphics = this.add.graphics();\n    bulletGraphics.fillStyle(0xff0000, 1);\n    bulletGraphics.fillCircle(4, 4, 4);\n    bulletGraphics.generateTexture('bullet', 8, 8);\n    bulletGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建子弹物理组\n    this.bullets = this.physics.add.group({\n      defaultKey: 'bullet',\n      maxSize: 50,\n      runChildUpdate: false\n    });\n\n    // 监听鼠标移动事件，旋转玩家朝向鼠标\n    this.input.on('pointermove', (pointer) => {\n      const angle = Phaser.Math.Angle.Between(\n        this.player.x,\n        this.player.y,\n        pointer.x,\n        pointer.y\n      );\n      this.player.rotation = angle;\n    });\n\n    // 监听鼠标右键点击事件\n    this.input.on('pointerdown', (pointer) => {\n      if (pointer.rightButtonDown()) {\n        this.shootBullet();\n      }\n    });\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      color: '#ffffff'\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, '移动鼠标旋转玩家 | 右键发射子弹', {\n      fontSize: '14px',\n      color: '#aaaaaa'\n    });\n  }\n\n  shootBullet() {\n    // 从对象池获取或创建子弹\n    const bullet = this.bullets.get(this.player.x, this.player.y);\n    \n    if (bullet) {\n      bullet.setActive(true);\n      bullet.setVisible(true);\n      \n      // 根据玩家旋转角度计算速度向量\n      const angle = this.player.rotation;\n      const velocityX = Math.cos(angle) * 240;\n      const velocityY = Math.sin(angle) * 240;\n      \n      bullet.setVelocity(velocityX, velocityY);\n      bullet.setRotation(angle);\n      \n      // 更新统计\n      this.bulletCount++;\n      this.activeBullets++;\n      \n      // 设置子弹生命周期（3秒后自动销毁）\n      this.time.delayedCall(3000, () => {\n        if (bullet.active) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n          bullet.setVelocity(0, 0);\n          this.activeBullets--;\n        }\n      });\n    }\n  }\n\n  update(time, delta) {\n    // 更新状态文本\n    this.statusText.setText([\n      `总发射子弹: ${this.bulletCount}`,\n      `当前活跃子弹: ${this.activeBullets}`,\n      `玩家角度: ${Math.round(Phaser.Math.RadToDeg(this.player.rotation))}°`\n    ]);\n\n    // 检查子弹是否超出边界\n    this.bullets.children.entries.forEach((bullet) => {\n      if (bullet.active) {\n        const bounds = this.physics.world.bounds;\n        if (\n          bullet.x < bounds.x - 20 ||\n          bullet.x > bounds.x + bounds.width + 20 ||\n          bullet.y < bounds.y - 20 ||\n          bullet.y > bounds.y + bounds.height + 20\n        ) {\n          bullet.setActive(false);\n          bullet.setVisible(false);\n          bullet.setVelocity(0, 0);\n          this.activeBullets--;\n        }\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: ShootingScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000827_v1", "prompt_id": "seed_000827", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8622222222222222}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics#fillTriangle, Graphics#rotation, Scene#update\nSTEPS:\n1. 创建 Graphics 对象用于绘制三角形\n2. 使用 fillTriangle 方法绘制一个三角形\n3. 在 update 方法中根据 delta 时间累加旋转角度（240度/秒 = 4.189弧度/秒）\n4. 将旋转角度应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  this.triangle = this.add.graphics();\n  \n  // 设置三角形的位置到屏幕中心\n  this.triangle.x = 400;\n  this.triangle.y = 300;\n  \n  // 设置填充颜色为蓝色\n  this.triangle.fillStyle(0x00aaff, 1);\n  \n  // 绘制一个等腰三角形（顶点相对于 Graphics 对象的原点）\n  // 参数：x1, y1, x2, y2, x3, y3\n  this.triangle.fillTriangle(\n    0, -60,    // 顶部顶点\n    -50, 60,   // 左下顶点\n    50, 60     // 右下顶点\n  );\n  \n  // 初始化旋转角度\n  this.currentRotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒 240 度 = 240 * (Math.PI / 180) 弧度/秒 ≈ 4.189 弧度/秒\n  const rotationSpeed = 240 * (Math.PI / 180); // 弧度/秒\n  \n  // 根据 delta（毫秒）计算本帧应该旋转的角度\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  this.currentRotation += rotationDelta;\n  \n  // 应用旋转到三角形\n  this.triangle.rotation = this.currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000451_v2", "prompt_id": "seed_000451", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的红色六边形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的红色六边形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景和画布尺寸\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 使用三角函数计算六边形的6个顶点坐标（半径12像素）\n4. 为每个六边形设置随机位置（x: 0-800, y: 0-600）\n5. 使用 Graphics API 绘制填充的红色六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个随机位置的红色六边形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 设置红色填充\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 绘制六边形\n    // 六边形半径为 12 像素（大小24像素）\n    const radius = 12;\n    const sides = 6;\n    \n    graphics.beginPath();\n    \n    // 计算六边形的每个顶点\n    for (let j = 0; j < sides; j++) {\n      // 从顶部开始绘制，所以初始角度为 -90 度（-Math.PI/2）\n      const angle = (Math.PI * 2 / sides) * j - Math.PI / 2;\n      const px = x + Math.cos(angle) * radius;\n      const py = y + Math.sin(angle) * radius;\n      \n      if (j === 0) {\n        graphics.moveTo(px, py);\n      } else {\n        graphics.lineTo(px, py);\n      }\n    }\n    \n    // 闭合路径并填充\n    graphics.closePath();\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000108_v2", "prompt_id": "seed_000108", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色矩形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个粉色的32x32像素矩形\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充颜色为粉色（0xFFC0CB）\n4. 计算画布中心位置并绘制 32x32 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为粉色\n  graphics.fillStyle(0xFFC0CB, 1);\n  \n  // 计算画布中心位置\n  const centerX = this.cameras.main.width / 2;\n  const centerY = this.cameras.main.height / 2;\n  \n  // 矩形大小\n  const rectSize = 32;\n  \n  // 在中心位置绘制矩形（需要减去一半大小使其居中）\n  graphics.fillRect(\n    centerX - rectSize / 2,\n    centerY - rectSize / 2,\n    rectSize,\n    rectSize\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000586_v2", "prompt_id": "seed_000586", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 3 秒内从原始大小缩放到 24%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形，使用 Tween 动画在 3 秒内缩放到 24%，然后恢复原始大小，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Star\nSTEPS:\n1. 使用 Graphics 绘制一个星形或使用 Star 游戏对象\n2. 创建 Tween 动画，设置 scale 从 1 到 0.24，持续 3 秒\n3. 设置 yoyo 为 true 使其自动恢复原始大小\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个星形图形对象\n  const graphics = this.add.graphics();\n  \n  // 设置星形的填充颜色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制星形（中心在 400, 300）\n  const centerX = 400;\n  const centerY = 300;\n  const outerRadius = 80;\n  const innerRadius = 40;\n  const points = 5;\n  \n  // 计算星形的顶点\n  const starPoints = [];\n  for (let i = 0; i < points * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    starPoints.push({\n      x: centerX + Math.cos(angle) * radius,\n      y: centerY + Math.sin(angle) * radius\n    });\n  }\n  \n  // 绘制星形路径\n  graphics.beginPath();\n  graphics.moveTo(starPoints[0].x, starPoints[0].y);\n  for (let i = 1; i < starPoints.length; i++) {\n    graphics.lineTo(starPoints[i].x, starPoints[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 创建缩放动画\n  // 从原始大小（scale: 1）缩放到 24%（scale: 0.24），持续 3 秒\n  // yoyo: true 使其自动恢复到原始大小\n  // repeat: -1 实现无限循环\n  this.tweens.add({\n    targets: graphics,\n    scaleX: 0.24,\n    scaleY: 0.24,\n    duration: 3000,        // 3 秒\n    yoyo: true,            // 动画结束后反向播放（恢复原始大小）\n    repeat: -1,            // 无限循环\n    ease: 'Linear'         // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '星形缩放动画（3秒循环）', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 24%', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000277_v2", "prompt_id": "seed_000277", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右上移动的圆形对象\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity, Phaser.Physics.Arcade\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置场景大小为 1600x1200 以便观察相机跟随效果\n2. 使用 Graphics 绘制圆形并生成纹理，创建物理精灵对象\n3. 设置精灵速度向右上方移动（velocity x: 100, y: -100）\n4. 使用 camera.startFollow() 方法让主相机跟随该精灵对象\n5. 设置相机边界与世界边界一致，确保相机平滑跟随\n[/PLAN]\n\n```javascript\n// Phaser3 相机跟随示例\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet infoText;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界为更大的区域，以便观察相机跟随效果\n  this.physics.world.setBounds(0, 0, 1600, 1200);\n  \n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('playerCircle', 50, 50);\n  graphics.destroy();\n  \n  // 创建物理精灵对象，初始位置在世界中心\n  player = this.physics.add.sprite(400, 300, 'playerCircle');\n  player.setCollideWorldBounds(true);\n  player.setBounce(1, 1); // 碰到边界后反弹\n  \n  // 设置速度：向右上方移动\n  player.setVelocity(100, -100);\n  \n  // 设置相机跟随玩家对象\n  this.cameras.main.startFollow(player, true, 0.1, 0.1);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 1600, 1200);\n  \n  // 添加背景网格以便观察相机移动\n  this.createBackgroundGrid();\n  \n  // 添加信息文本（固定在相机视图）\n  infoText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  infoText.setScrollFactor(0); // 固定在相机上，不随场景滚动\n  \n  // 添加说明文本\n  const instructionText = this.add.text(10, 550, '相机跟随绿色圆形移动\\n圆形碰到边界会反弹', {\n    fontSize: '14px',\n    color: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 8, y: 5 }\n  });\n  instructionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 更新信息显示\n  if (infoText && player) {\n    infoText.setText([\n      `圆形位置: (${Math.round(player.x)}, ${Math.round(player.y)})`,\n      `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`,\n      `速度: (${Math.round(player.body.velocity.x)}, ${Math.round(player.body.velocity.y)})`\n    ]);\n  }\n}\n\n// 创建背景网格辅助函数\nPhaser.Scene.prototype.createBackgroundGrid = function() {\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制垂直线\n  for (let x = 0; x <= 1600; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 1200);\n  }\n  \n  // 绘制水平线\n  for (let y = 0; y <= 1200; y += 100) {\n    gridGraphics.lineBetween(0, y, 1600, y);\n  }\n  \n  // 添加坐标标记\n  for (let x = 0; x <= 1600; x += 200) {\n    for (let y = 0; y <= 1200; y += 200) {\n      const marker = this.add.text(x + 5, y + 5, `${x},${y}`, {\n        fontSize: '12px',\n        color: '#666666'\n      });\n    }\n  }\n};\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000544_v3", "prompt_id": "seed_000544", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8942857142857144}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个白色物体以 360 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个白色物体以360速度随机移动，碰撞边界和彼此时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Body, this.physics.add.collider\nSTEPS:\n1. 创建物理系统配置，启用 Arcade 物理引擎\n2. 使用 Graphics 生成白色圆形纹理\n3. 创建物理组，添加 15 个物体并设置随机速度（360）\n4. 设置物体边界反弹和组内碰撞\n5. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 1. 程序化生成白色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('whiteBall', 32, 32);\n    graphics.destroy();\n\n    // 2. 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'whiteBall',\n      repeat: 14, // 总共15个物体（0-14）\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 3. 设置每个物体的随机位置和速度\n    const speed = 360;\n    this.balls.children.iterate((ball) => {\n      // 随机位置\n      ball.setPosition(\n        Phaser.Math.Between(50, 750),\n        Phaser.Math.Between(50, 550)\n      );\n\n      // 随机方向的速度，总速度为360\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const vx = Math.cos(angle) * speed;\n      const vy = Math.sin(angle) * speed;\n      ball.setVelocity(vx, vy);\n\n      // 设置圆形碰撞体\n      ball.body.setCircle(16);\n    });\n\n    // 4. 设置组内物体之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onCollision, null, this);\n\n    // 5. 添加调试文本显示碰撞次数\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n\n    // 添加物体数量显示\n    this.countText = this.add.text(10, 40, 'Objects: 15', {\n      fontSize: '20px',\n      fill: '#ffffff'\n    });\n  }\n\n  onCollision(ball1, ball2) {\n    // 碰撞回调，增加计数\n    this.collisionCount++;\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保所有物体保持恒定速度360\n    this.balls.children.iterate((ball) => {\n      const body = ball.body;\n      const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n      \n      // 如果速度偏离360，重新归一化\n      if (Math.abs(currentSpeed - 360) > 1) {\n        const scale = 360 / currentSpeed;\n        body.setVelocity(body.velocity.x * scale, body.velocity.y * scale);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000892_v1", "prompt_id": "seed_000892", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 3 秒内从原始大小缩放到 64%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在3秒内缩放到64%后恢复，循环播放\nAPI: this.add.graphics, graphics.fillStar, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制星形并生成纹理\n2. 创建星形精灵对象\n3. 使用 tweens 创建缩放动画，scale 从 1 到 0.64\n4. 设置 yoyo 为 true 使动画反向播放（恢复原始大小）\n5. 设置 repeat 为 -1 实现无限循环\n6. 设置 duration 为 3000 毫秒（3秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为金黄色\n  graphics.fillStyle(0xFFD700, 1);\n  \n  // 绘制星形（中心点在 100, 100，外半径 100，内半径 50，5个角）\n  graphics.fillStar(100, 100, 5, 100, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 200, 200);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 在屏幕中心创建星形精灵\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    scale: 0.64,            // 缩放到 64%（0.64 倍）\n    duration: 3000,         // 持续时间 3 秒\n    yoyo: true,             // 启用 yoyo 效果，动画结束后反向播放回到原始状态\n    repeat: -1,             // 无限循环（-1 表示永久重复）\n    ease: 'Sine.easeInOut'  // 使用正弦缓动函数，使动画更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000770_v3", "prompt_id": "seed_000770", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 4 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在4秒内缩放到32%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建缩放动画：scale 从 1 到 0.32，持续 2 秒\n4. 设置 yoyo 为 true 使动画反向播放（恢复原大小）\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const sides = 6;\n  const centerX = 100; // 临时中心点用于绘制\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i <= sides; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  const textureSize = hexRadius * 2 + 10;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建六边形精灵并放置在屏幕中心\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  // 4秒完成一个完整循环：2秒缩小到32%，2秒恢复到100%\n  this.tweens.add({\n    targets: hexagon,\n    scale: 0.32,           // 缩放到32%\n    duration: 2000,        // 2秒缩小\n    yoyo: true,            // 反向播放（恢复原大小）\n    repeat: -1,            // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Hexagon Scale Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% -> 32% -> 100% (4 seconds loop)', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000722_v3", "prompt_id": "seed_000722", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让方块在1.5秒内从透明渐变到完全不透明并循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, this.tweens.add\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 tweens.add 创建透明度补间动画，从 0 到 1，持续 1.5 秒\n4. 设置动画循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建方块精灵并设置初始位置\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n\n  // 创建透明度渐变补间动画\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度（完全不透明）\n    duration: 1500,            // 持续时间 1.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 来回播放（透明->不透明->透明）\n    repeat: -1                 // 无限循环\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, 'Square fading in/out (1.5s cycle)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000546_v3", "prompt_id": "seed_000546", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色星形在 2 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个青色星形在 2 秒内从左移动到右并往返循环的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#generateTexture, Phaser.GameObjects.Image, Phaser.Tweens.TweenManager#add, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.repeat\nSTEPS:\n1. 使用 Graphics 绘制青色星形并生成纹理\n2. 创建 Image 对象使用生成的星形纹理\n3. 使用 Tween 系统创建从左到右的移动动画，设置 yoyo 为 true 实现往返，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色星形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制星形（5个顶点）\n  const centerX = 50;\n  const centerY = 50;\n  const outerRadius = 40;\n  const innerRadius = 20;\n  const points = 5;\n  \n  graphics.beginPath();\n  \n  for (let i = 0; i < points * 2; i++) {\n    const angle = (i * Math.PI) / points - Math.PI / 2;\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('star', 100, 100);\n  graphics.destroy();\n  \n  // 创建星形精灵，初始位置在左侧\n  const star = this.add.image(100, 300, 'star');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: star,\n    x: 700,                // 目标 x 坐标（右侧）\n    duration: 2000,        // 持续 2 秒\n    yoyo: true,            // 往返（到达终点后返回起点）\n    repeat: -1,            // 无限循环（-1 表示永久重复）\n    ease: 'Linear'         // 线性缓动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000389_v1", "prompt_id": "seed_000389", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9066666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现追踪镜头与震屏：玩家与敌人碰撞时触发 camera shake 3 秒，并扣减生命值显示。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现追踪镜头与震屏效果，玩家碰撞敌人时触发3秒震屏并扣血\nAPI: Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.Cameras.Scene2D.Camera#shake, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text\nSTEPS:\n1. 创建带物理系统的场景配置\n2. 使用Graphics绘制玩家和敌人纹理\n3. 设置摄像机追踪玩家\n4. 添加玩家与敌人的碰撞检测\n5. 碰撞时触发震屏效果并扣减生命值\n6. 显示生命值UI并实时更新\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.health = 100; // 可验证的状态信号\n    this.isShaking = false;\n  }\n\n  preload() {\n    // 使用Graphics创建纹理，无需外部资源\n    this.createTextures();\n  }\n\n  createTextures() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建地面纹理（绿色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 设置世界边界（扩大世界以便摄像机追踪）\n    this.physics.world.setBounds(0, 0, 2400, 600);\n\n    // 创建地面平台\n    const platforms = this.physics.add.staticGroup();\n    platforms.create(400, 568, 'ground');\n    platforms.create(1200, 568, 'ground');\n    platforms.create(2000, 568, 'ground');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.2);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n    \n    // 在不同位置创建多个敌人\n    const enemyPositions = [\n      { x: 400, y: 450 },\n      { x: 800, y: 450 },\n      { x: 1200, y: 450 },\n      { x: 1600, y: 450 },\n      { x: 2000, y: 450 }\n    ];\n\n    enemyPositions.forEach(pos => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setBounce(0.5);\n      enemy.setCollideWorldBounds(true);\n      // 给敌人随机速度\n      enemy.setVelocityX(Phaser.Math.Between(-100, 100));\n    });\n\n    // 添加物理碰撞\n    this.physics.add.collider(this.player, platforms);\n    this.physics.add.collider(this.enemies, platforms);\n\n    // 添加玩家与敌人的碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 设置摄像机追踪玩家\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n    this.cameras.main.setBounds(0, 0, 2400, 600);\n\n    // 创建生命值显示（固定在屏幕上）\n    this.healthText = this.add.text(16, 16, `Health: ${this.health}`, {\n      fontSize: '32px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n    this.healthText.setScrollFactor(0); // 固定在屏幕上不随摄像机移动\n\n    // 创建状态提示文本\n    this.statusText = this.add.text(16, 60, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#fff',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setScrollFactor(0);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  handleCollision(player, enemy) {\n    // 如果正在震屏，避免重复触发\n    if (this.isShaking) {\n      return;\n    }\n\n    // 扣减生命值\n    this.health -= 10;\n    this.health = Math.max(0, this.health); // 确保不低于0\n\n    // 更新生命值显示\n    this.healthText.setText(`Health: ${this.health}`);\n\n    // 触发摄像机震屏效果（持续3秒）\n    this.isShaking = true;\n    this.cameras.main.shake(3000, 0.01); // 3000ms，强度0.01\n\n    // 更新状态提示\n    this.statusText.setText('Collision! Camera Shaking...');\n    this.statusText.setStyle({ fill: '#ff0000' });\n\n    // 让敌人反弹\n    enemy.setVelocityX(-enemy.body.velocity.x);\n    enemy.setVelocityY(-200);\n\n    // 让玩家反弹\n    if (player.x < enemy.x) {\n      player.setVelocityX(-200);\n    } else {\n      player.setVelocityX(200);\n    }\n\n    // 3秒后重置震屏状态\n    this.time.delayedCall(3000, () => {\n      this.isShaking = false;\n      this.statusText.setText('Use Arrow Keys to Move');\n      this.statusText.setStyle({ fill: '#fff' });\n    });\n\n    // 检查游戏结束\n    if (this.health <= 0) {\n      this.statusText.setText('Game Over! Health: 0');\n      this.statusText.setStyle({ fill: '#ff0000', fontSize: '28px' });\n      this.physics.pause();\n      this.player.setTint(0xff0000);\n    }\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n\n    // 让敌人在边界反弹\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.body.velocity.x === 0) {\n        enemy.setVelocityX(Phaser.Math.Between(-100, 100));\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000806_v3", "prompt_id": "seed_000806", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Physics"], "quality_score": 0.9066666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 三角形在4秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 系统创建缩放动画，从 1 缩放到 0.48，持续 2 秒\n4. 设置 yoyo 为 true 实现来回缩放效果（2秒缩小+2秒恢复=4秒）\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制三角形（等边三角形）\n  // 中心点在 (60, 60)，边长约 100\n  graphics.beginPath();\n  graphics.moveTo(60, 10);           // 顶点\n  graphics.lineTo(10, 110);          // 左下角\n  graphics.lineTo(110, 110);         // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 120, 120);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建三角形精灵，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,           // 动画目标\n    scaleX: 0.48,               // X 轴缩放到 48%\n    scaleY: 0.48,               // Y 轴缩放到 48%\n    duration: 2000,             // 单程持续 2 秒\n    yoyo: true,                 // 启用往返效果（缩小后自动恢复）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'      // 缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '三角形缩放动画 (4秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000381_v2", "prompt_id": "seed_000381", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色矩形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色矩形以240速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制黄色矩形并生成纹理\n3. 创建物理精灵并设置初始速度为240\n4. 在 update 中检测边界碰撞并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet rectangle;\nconst SPEED = 240;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建黄色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('yellowRect', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  rectangle = this.physics.add.sprite(400, 300, 'yellowRect');\n  \n  // 设置初始速度（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  this.physics.velocityFromAngle(angle, SPEED, rectangle.body.velocity);\n  \n  // 设置碰撞边界\n  rectangle.setCollideWorldBounds(true);\n  rectangle.setBounce(1, 1); // 完全弹性碰撞\n}\n\nfunction update(time, delta) {\n  // 检查边界碰撞并反转速度\n  const bounds = this.physics.world.bounds;\n  \n  // 左右边界\n  if (rectangle.x <= rectangle.width / 2 && rectangle.body.velocity.x < 0) {\n    rectangle.body.velocity.x = Math.abs(rectangle.body.velocity.x);\n  } else if (rectangle.x >= bounds.width - rectangle.width / 2 && rectangle.body.velocity.x > 0) {\n    rectangle.body.velocity.x = -Math.abs(rectangle.body.velocity.x);\n  }\n  \n  // 上下边界\n  if (rectangle.y <= rectangle.height / 2 && rectangle.body.velocity.y < 0) {\n    rectangle.body.velocity.y = Math.abs(rectangle.body.velocity.y);\n  } else if (rectangle.y >= bounds.height - rectangle.height / 2 && rectangle.body.velocity.y > 0) {\n    rectangle.body.velocity.y = -Math.abs(rectangle.body.velocity.y);\n  }\n  \n  // 保持速度恒定为240\n  const currentSpeed = Math.sqrt(\n    rectangle.body.velocity.x ** 2 + \n    rectangle.body.velocity.y ** 2\n  );\n  \n  if (currentSpeed !== 0 && Math.abs(currentSpeed - SPEED) > 1) {\n    rectangle.body.velocity.x = (rectangle.body.velocity.x / currentSpeed) * SPEED;\n    rectangle.body.velocity.y = (rectangle.body.velocity.y / currentSpeed) * SPEED;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000528_v3", "prompt_id": "seed_000528", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让红色方块在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色方块的弹跳动画，3秒完成一次循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色方块并生成纹理\n2. 创建 Sprite 对象作为弹跳主体\n3. 使用 Tween 动画实现 y 轴弹跳效果，配置 yoyo 和 loop 实现循环\n4. 设置 ease 为 'Bounce.easeOut' 实现弹跳效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 80, 80);\n  \n  // 生成纹理\n  graphics.generateTexture('redSquare', 80, 80);\n  graphics.destroy();\n  \n  // 创建精灵对象\n  const square = this.add.sprite(400, 300, 'redSquare');\n  \n  // 创建弹跳动画\n  // 从当前位置向上移动150像素，然后返回，整个过程3秒\n  this.tweens.add({\n    targets: square,\n    y: square.y - 150,  // 向上弹跳150像素\n    duration: 1500,      // 上升时间1.5秒\n    ease: 'Cubic.easeOut', // 上升时使用缓出效果\n    yoyo: true,          // 自动返回原位置\n    repeat: -1,          // 无限循环\n    repeatDelay: 0       // 无延迟\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, 'Bouncing Red Square', {\n    fontSize: '32px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '3-second bounce cycle (loop)', {\n    fontSize: '20px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000731_v1", "prompt_id": "seed_000731", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个蓝色敌人巡逻移动，在 120 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 15个蓝色敌人巡逻移动，玩家接近时追踪\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.Sprite, Phaser.Math.Distance.Between, this.physics.add.sprite\nSTEPS:\n1. 创建玩家和敌人的Graphics纹理（玩家绿色，敌人蓝色）\n2. 使用物理组创建15个敌人，设置初始位置和巡逻速度\n3. 在update中检测玩家与每个敌人的距离，近距离时切换为追踪模式\n4. 敌人巡逻时碰到边界自动反向，追踪时朝向玩家移动\n5. 添加键盘控制让玩家可移动，显示状态信息\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n    this.playerSpeed = 200;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillCircle(16, 16, 16);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x0000ff, 1);\n    enemyGraphics.fillCircle(12, 12, 12);\n    enemyGraphics.generateTexture('enemy', 24, 24);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建15个敌人，分布在不同位置\n    for (let i = 0; i < 15; i++) {\n      const x = 100 + (i % 5) * 150;\n      const y = 100 + Math.floor(i / 5) * 150;\n      const enemy = this.enemies.create(x, y, 'enemy');\n      \n      // 设置敌人属性\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 自定义属性：巡逻状态和方向\n      enemy.patrolling = true;\n      enemy.patrolDirection = i % 2 === 0 ? 1 : -1; // 交替方向\n      enemy.setVelocityX(120 * enemy.patrolDirection);\n      enemy.detectionRange = 150; // 检测范围\n      enemy.chaseSpeed = 150; // 追踪速度\n    }\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 状态文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 说明文本\n    this.add.text(10, 560, 'Arrow Keys: Move Player | Blue enemies patrol and chase when close', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-this.playerSpeed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(this.playerSpeed);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-this.playerSpeed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(this.playerSpeed);\n    }\n\n    // 重置计数器\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x, this.player.y,\n        enemy.x, enemy.y\n      );\n\n      // 检测玩家是否在范围内\n      if (distance < enemy.detectionRange) {\n        // 追踪模式\n        enemy.patrolling = false;\n        this.enemiesChasing++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        // 设置追踪速度\n        this.physics.velocityFromRotation(angle, enemy.chaseSpeed, enemy.body.velocity);\n\n        // 视觉反馈：追踪时稍微放大\n        enemy.setScale(1.2);\n        enemy.setTint(0x8888ff);\n      } else {\n        // 巡逻模式\n        if (!enemy.patrolling) {\n          // 从追踪切换回巡逻\n          enemy.patrolling = true;\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(120 * enemy.patrolDirection);\n        }\n        this.enemiesPatrolling++;\n\n        // 恢复原始大小和颜色\n        enemy.setScale(1);\n        enemy.clearTint();\n\n        // 巡逻边界检测\n        if (enemy.x <= 24 && enemy.body.velocity.x < 0) {\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(120);\n        } else if (enemy.x >= 776 && enemy.body.velocity.x > 0) {\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(-120);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText([\n      `Enemies: 15 total`,\n      `Patrolling: ${this.enemiesPatrolling}`,\n      `Chasing: ${this.enemiesChasing}`,\n      `Player Pos: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000900_v1", "prompt_id": "seed_000900", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 躲避游戏升级版：敌人速度随时间从 300 逐渐加快，显示生存时间。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 躲避游戏升级版，敌人速度随时间从300逐渐加快，显示生存时间\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Time.TimerEvent, Phaser.GameObjects.Text\nSTEPS:\n1. 创建玩家精灵，使用Graphics绘制方块纹理，添加物理属性和键盘控制\n2. 创建敌人组，定时生成从屏幕顶部下落的敌人，初始速度300\n3. 使用时间事件每秒增加敌人速度，实现难度递增\n4. 添加碰撞检测，玩家碰到敌人游戏结束\n5. 显示生存时间文本，每帧更新计时器\n6. 游戏结束时显示最终生存时间和重启提示\n[/PLAN]\n\n```javascript\nclass DodgeGame extends Phaser.Scene {\n  constructor() {\n    super('DodgeGame');\n    this.player = null;\n    this.enemies = null;\n    this.cursors = null;\n    this.survivalTime = 0;\n    this.timeText = null;\n    this.gameOver = false;\n    this.enemySpeed = 300;\n    this.spawnTimer = null;\n    this.speedIncreaseTimer = null;\n    this.gameStartTime = 0;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 碰撞检测\n    this.physics.add.overlap(this.player, this.enemies, this.hitEnemy, null, this);\n\n    // 生存时间文本\n    this.timeText = this.add.text(16, 16, 'Time: 0.0s', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    });\n\n    // 速度显示文本\n    this.speedText = this.add.text(16, 50, 'Speed: 300', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    });\n\n    // 记录游戏开始时间\n    this.gameStartTime = this.time.now;\n\n    // 定时生成敌人（每1.5秒）\n    this.spawnTimer = this.time.addEvent({\n      delay: 1500,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 定时增加敌人速度（每2秒增加50）\n    this.speedIncreaseTimer = this.time.addEvent({\n      delay: 2000,\n      callback: this.increaseSpeed,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 游戏说明\n    this.add.text(400, 100, 'Use Arrow Keys to Move', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    this.add.text(400, 130, 'Avoid the Red Enemies!', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  update(time, delta) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 更新生存时间\n    this.survivalTime = (time - this.gameStartTime) / 1000;\n    this.timeText.setText('Time: ' + this.survivalTime.toFixed(1) + 's');\n\n    // 玩家移动\n    const speed = 300;\n    \n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n\n    // 清理超出屏幕的敌人\n    this.enemies.children.entries.forEach(enemy => {\n      if (enemy.y > 650) {\n        enemy.destroy();\n      }\n    });\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 随机X位置\n    const x = Phaser.Math.Between(30, 770);\n    \n    // 创建敌人\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    enemy.setVelocityY(this.enemySpeed);\n  }\n\n  increaseSpeed() {\n    if (this.gameOver) {\n      return;\n    }\n\n    // 每次增加50速度\n    this.enemySpeed += 50;\n    \n    // 更新速度显示\n    this.speedText.setText('Speed: ' + this.enemySpeed);\n\n    // 更新现有敌人的速度\n    this.enemies.children.entries.forEach(enemy => {\n      enemy.setVelocityY(this.enemySpeed);\n    });\n  }\n\n  hitEnemy(player, enemy) {\n    if (this.gameOver) {\n      return;\n    }\n\n    this.gameOver = true;\n\n    // 停止所有计时器\n    if (this.spawnTimer) {\n      this.spawnTimer.remove();\n    }\n    if (this.speedIncreaseTimer) {\n      this.speedIncreaseTimer.remove();\n    }\n\n    // 停止所有物理对象\n    this.physics.pause();\n\n    // 玩家变红\n    this.player.setTint(0xff0000);\n\n    // 显示游戏结束信息\n    const gameOverText = this.add.text(400, 250, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000',\n      fontFamily: 'Arial',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n\n    const finalTimeText = this.add.text(400, 330, 'Survival Time: ' + this.survivalTime.toFixed(1) + 's', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    const finalSpeedText = this.add.text(400, 380, 'Final Speed: ' + this.enemySpeed, {\n      fontSize: '28px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    const restartText = this.add.text(400, 450, 'Click to Restart', {\n      fontSize: '24px',\n      fill: '#00ff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 点击重启\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: DodgeGame\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000894_v3", "prompt_id": "seed_000894", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.825}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让灰色圆形在 2 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色圆形，使用 Tween 动画实现 2 秒闪烁循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制灰色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建 alpha 透明度动画（1 -> 0 -> 1）\n4. 设置 duration 为 2000ms，yoyo 为 true，repeat 为 -1 实现循环闪烁\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径 50 的圆\n  graphics.generateTexture('circleTexture', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n\n  // 创建使用该纹理的精灵对象\n  const circle = this.add.sprite(400, 300, 'circleTexture');\n\n  // 创建闪烁动画（透明度从 1 到 0 再回到 1）\n  this.tweens.add({\n    targets: circle,\n    alpha: 0, // 目标透明度\n    duration: 1000, // 单程 1 秒\n    yoyo: true, // 自动返回初始值\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 平滑过渡\n  });\n\n  // 添加文字说明\n  this.add.text(400, 500, '灰色圆形闪烁动画 (2秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000077_v1", "prompt_id": "seed_000077", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.Scene.update, Phaser.GameObjects.Graphics.rotation\nSTEPS:\n1. 创建 Graphics 对象并绘制一个圆形\n2. 在圆形上添加一条半径线作为视觉参考，便于观察旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度\n4. 将角度转换为弧度并应用到 Graphics 的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\nconst rotationSpeed = 160; // 每秒旋转 160 度\n\nfunction preload() {\n  // 无需加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  circle = this.add.graphics();\n  \n  // 设置圆形位置在屏幕中心\n  circle.x = 400;\n  circle.y = 300;\n  \n  // 绘制圆形主体\n  circle.fillStyle(0x00aaff, 1);\n  circle.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的线，用于观察旋转\n  circle.lineStyle(4, 0xffffff, 1);\n  circle.beginPath();\n  circle.moveTo(0, 0);\n  circle.lineTo(80, 0);\n  circle.strokePath();\n  \n  // 在圆心绘制一个小点作为参考\n  circle.fillStyle(0xffffff, 1);\n  circle.fillCircle(0, 0, 5);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形旋转速度: 160°/秒', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // delta 是毫秒，转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 计算本帧应旋转的角度（度）\n  const rotationDegrees = rotationSpeed * deltaInSeconds;\n  \n  // 将角度转换为弧度并累加到当前旋转值\n  circle.rotation += Phaser.Math.DegToRad(rotationDegrees);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000492_v2", "prompt_id": "seed_000492", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个星形以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#fillPoints, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个星形\n2. 将星形的原点设置到中心位置\n3. 在 update 中根据 delta 时间增量更新 rotation 属性，实现每秒 300 度的旋转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制星形\n  const graphics = this.add.graphics();\n  \n  // 设置星形的中心位置\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 生成星形的顶点坐标\n  const starPoints = createStarPoints(0, 0, 5, 80, 40);\n  \n  // 绘制星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillPoints(starPoints, true);\n  \n  // 设置 Graphics 对象的位置（作为旋转中心）\n  graphics.x = centerX;\n  graphics.y = centerY;\n  \n  // 将 graphics 对象存储到 scene 中，以便在 update 中访问\n  this.star = graphics;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 300 度\n  // delta 是毫秒，需要转换为秒\n  // 300 度 = 300 * (Math.PI / 180) 弧度\n  const rotationSpeed = 300 * (Math.PI / 180); // 弧度/秒\n  const deltaSeconds = delta / 1000; // 转换为秒\n  \n  // 更新旋转角度\n  this.star.rotation += rotationSpeed * deltaSeconds;\n}\n\n/**\n * 创建星形的顶点坐标\n * @param {number} cx - 中心 X 坐标\n * @param {number} cy - 中心 Y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n * @returns {Array} 顶点坐标数组\n */\nfunction createStarPoints(cx, cy, spikes, outerRadius, innerRadius) {\n  const points = [];\n  const step = Math.PI / spikes;\n  \n  for (let i = 0; i < spikes * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = i * step - Math.PI / 2; // 从顶部开始\n    const x = cx + Math.cos(angle) * radius;\n    const y = cy + Math.sin(angle) * radius;\n    points.push({ x, y });\n  }\n  \n  return points;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000537_v2", "prompt_id": "seed_000537", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 80 像素/秒的速度移动\nAPI: Graphics.fillTriangle, input.keyboard.addKey, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制三角形\n2. 使用 addKey 监听 W/A/S/D 键盘输入\n3. 在 update 中根据按键状态和 delta 时间更新三角形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建三角形 Graphics 对象\n  triangle = this.add.graphics();\n  triangle.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（顶点坐标相对于 Graphics 对象的位置）\n  triangle.fillTriangle(\n    0, -20,    // 顶部顶点\n    -15, 20,   // 左下顶点\n    15, 20     // 右下顶点\n  );\n  \n  // 设置三角形初始位置（屏幕中心）\n  triangle.x = 400;\n  triangle.y = 300;\n  \n  // 添加 WASD 键监听\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 根据按键状态更新三角形位置\n  if (keys.W.isDown) {\n    triangle.y -= moveDistance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    triangle.y += moveDistance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    triangle.x -= moveDistance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    triangle.x += moveDistance; // 向右移动\n  }\n  \n  // 可选：限制三角形在屏幕范围内\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000729_v2", "prompt_id": "seed_000729", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让绿色六边形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个绿色六边形，在 1.5 秒内完成弹跳动画并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建 Y 轴弹跳动画（ease: 'Bounce.easeOut'）\n4. 设置 Tween 循环播放（yoyo + repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建六边形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制绿色六边形\n  const hexRadius = 50;\n  const hexCenterX = 60;\n  const hexCenterY = 60;\n  \n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(3, 0x00aa00, 1);\n  \n  // 绘制六边形路径\n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = hexCenterX + hexRadius * Math.cos(angle);\n    const y = hexCenterY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 120, 120);\n  graphics.destroy();\n  \n  // 创建六边形精灵\n  const hexagon = this.add.sprite(400, 200, 'hexagon');\n  \n  // 创建弹跳动画\n  // 使用 Tween 实现弹跳效果\n  this.tweens.add({\n    targets: hexagon,\n    y: 450, // 弹跳到的目标位置\n    duration: 750, // 下落时间 0.75 秒\n    ease: 'Quad.easeIn', // 下落时加速\n    yoyo: true, // 返回原位置\n    yoyoEase: 'Bounce.easeOut', // 返回时使用弹跳缓动\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 550, '绿色六边形弹跳动画（1.5秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000541_v1", "prompt_id": "seed_000541", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 1.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在1.5秒内缩放到80%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.8\n4. 配置 yoyo 为 true 实现恢复效果，duration 为 1500ms\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建矩形精灵，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setOrigin(0.5, 0.5);\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.8,        // 缩放到 80%\n    scaleY: 0.8,        // 缩放到 80%\n    duration: 1500,     // 持续 1.5 秒\n    yoyo: true,         // 动画结束后反向播放（恢复到原始大小）\n    loop: -1,           // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'  // 使用正弦缓动函数使动画更平滑\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, '矩形缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000758_v2", "prompt_id": "seed_000758", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让紫色圆形在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建紫色圆形，使用 Tween 实现 1.5 秒闪烁循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setAlpha\nSTEPS:\n1. 使用 Graphics 绘制紫色圆形并生成纹理\n2. 创建 Sprite 对象应用该纹理\n3. 使用 tweens.add 创建 alpha 透明度动画，从 1 到 0 再到 1\n4. 设置动画持续时间为 1.5 秒，yoyo 模式实现闪烁，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9b59b6, 1); // 紫色\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径 50 的圆\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('purpleCircle', 100, 100);\n  graphics.destroy(); // 销毁 Graphics 对象，因为已经生成纹理\n  \n  // 在屏幕中心创建紫色圆形精灵\n  const circle = this.add.sprite(400, 300, 'purpleCircle');\n  \n  // 创建闪烁动画\n  // 使用 yoyo 模式：透明度从 1 降到 0，再从 0 升到 1，完成一次完整闪烁\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    alpha: 0,                  // 目标透明度值\n    duration: 750,             // 单程持续时间 750ms（总共 1.5 秒）\n    yoyo: true,                // 启用 yoyo 模式，动画会反向播放\n    repeat: -1,                // -1 表示无限循环\n    ease: 'Sine.easeInOut'     // 缓动函数，使闪烁更自然\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '紫色圆形闪烁动画 (1.5秒/次)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000496_v3", "prompt_id": "seed_000496", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个圆形移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制圆形以 160 像素/秒速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Graphics 对象绘制圆形作为玩家\n2. 使用 addKey 监听 WASD 四个按键\n3. 在 update 中根据按键状态和 delta 时间计算位置增量并更新圆形位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet player;\nlet keys;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建圆形玩家\n  player = this.add.graphics();\n  player.fillStyle(0x00ff00, 1);\n  player.fillCircle(0, 0, 20); // 半径 20 的圆形\n  \n  // 设置初始位置为屏幕中心\n  player.x = 400;\n  player.y = 300;\n  \n  // 设置 WASD 键\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间增量(秒)\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.W.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keys.S.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keys.A.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keys.D.isDown) {\n    player.x += distance; // 向右移动\n  }\n  \n  // 限制在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 20, 780);\n  player.y = Phaser.Math.Clamp(player.y, 20, 580);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000676_v1", "prompt_id": "seed_000676", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的红色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的红色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算6个顶点坐标\n4. 循环20次，每次在随机位置绘制一个红色六边形\n5. 确保六边形完全在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 六边形大小（从中心到顶点的距离）\n  const hexSize = 16;\n  \n  // 绘制20个随机位置的六边形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const x = Phaser.Math.Between(hexSize + 10, config.width - hexSize - 10);\n    const y = Phaser.Math.Between(hexSize + 10, config.height - hexSize - 10);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, hexSize);\n  }\n}\n\n/**\n * 绘制正六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} size - 六边形大小（中心到顶点的距离）\n */\nfunction drawHexagon(graphics, x, y, size) {\n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点坐标\n  // 从顶部开始，顺时针绘制\n  for (let i = 0; i < 6; i++) {\n    // 每个顶点的角度（60度间隔，从-90度开始使顶点朝上）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const vertexX = x + size * Math.cos(angle);\n    const vertexY = y + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vertexX, vertexY);\n    } else {\n      graphics.lineTo(vertexX, vertexY);\n    }\n  }\n  \n  // 闭合路径并填充\n  graphics.closePath();\n  graphics.fillPath();\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000499_v2", "prompt_id": "seed_000499", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让蓝色方块在 1.5 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建蓝色方块闪烁动画，1.5秒完成一次循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制蓝色方块并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 Tween 动画控制 alpha 属性实现闪烁效果（0->1->0）\n4. 设置循环参数使动画持续重复\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成蓝色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('blueSquare', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建蓝色方块精灵，放置在屏幕中央\n  const blueSquare = this.add.sprite(400, 300, 'blueSquare');\n  \n  // 创建闪烁动画\n  // 使用 Tween 控制 alpha 透明度实现闪烁效果\n  this.tweens.add({\n    targets: blueSquare,           // 动画目标对象\n    alpha: 0,                       // 目标透明度值（从1渐变到0）\n    duration: 750,                  // 单程持续时间 0.75秒\n    yoyo: true,                     // 启用往返效果（0->1->0）\n    repeat: -1,                     // 无限循环 (-1 表示永久重复)\n    ease: 'Sine.easeInOut'         // 缓动函数，使闪烁更平滑自然\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '蓝色方块闪烁动画 (1.5秒/周期)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000678_v3", "prompt_id": "seed_000678", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.fillEllipse, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 创建 Graphics 对象并绘制一个椭圆\n2. 在 create 中初始化椭圆的位置和样式\n3. 在 update 中根据 delta 时间累加旋转角度（240度/秒 = 4.189弧度/秒）\n4. 将累加的角度应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 存储椭圆图形对象\nlet ellipseGraphics;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置椭圆的位置（中心点）\n  ellipseGraphics.x = 400;\n  ellipseGraphics.y = 300;\n  \n  // 设置填充样式并绘制椭圆\n  // 椭圆中心在 (0, 0)，这样旋转时会围绕中心点旋转\n  ellipseGraphics.fillStyle(0x00ff00, 1);\n  ellipseGraphics.fillEllipse(0, 0, 150, 80); // 宽150，高80的椭圆\n  \n  // 添加描边以更清晰地看到旋转效果\n  ellipseGraphics.lineStyle(3, 0xffffff, 1);\n  ellipseGraphics.strokeEllipse(0, 0, 150, 80);\n  \n  // 在椭圆上添加一个标记点，便于观察旋转\n  ellipseGraphics.fillStyle(0xff0000, 1);\n  ellipseGraphics.fillCircle(75, 0, 8); // 在右侧边缘添加红色圆点\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 240 度\n  // 240 度 = 240 * (Math.PI / 180) = 4.189 弧度\n  const rotationSpeed = 240 * (Math.PI / 180); // 弧度/秒\n  \n  // delta 是毫秒，需要转换为秒\n  const deltaInSeconds = delta / 1000;\n  \n  // 累加旋转角度\n  ellipseGraphics.rotation += rotationSpeed * deltaInSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000446_v1", "prompt_id": "seed_000446", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色圆形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的粉色圆形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillCircle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽度800、高度600\n2. 在 create 方法中循环5次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 设置粉色填充样式（0xff69b4）\n4. 使用 fillCircle 绘制半径24像素的圆形（直径48）\n5. 使用 setRandomPosition 设置随机位置，确保圆形完全在画布内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const radius = 24; // 半径24像素，直径48像素\n  const pinkColor = 0xff69b4; // 粉色\n  \n  // 创建5个随机位置的粉色圆形\n  for (let i = 0; i < 5; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式\n    graphics.fillStyle(pinkColor, 1);\n    \n    // 绘制圆形（圆心在0,0，半径24）\n    graphics.fillCircle(0, 0, radius);\n    \n    // 设置随机位置，确保圆形完全在画布内\n    // x范围: radius 到 width - radius\n    // y范围: radius 到 height - radius\n    const randomX = Phaser.Math.Between(radius, this.scale.width - radius);\n    const randomY = Phaser.Math.Between(radius, this.scale.height - radius);\n    \n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000089_v1", "prompt_id": "seed_000089", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 360 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制椭圆以 360 像素/秒速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, this.input.keyboard.addKey\nSTEPS:\n1. 创建 Game 配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 绘制椭圆并生成纹理\n3. 创建 Sprite 使用生成的椭圆纹理，设置初始位置\n4. 使用 addKey 监听 W/A/S/D 键\n5. 在 update 中根据按键状态更新椭圆位置，速度 360 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 360; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(40, 40, 80, 60); // 中心点(40,40)，宽80，高60\n  graphics.generateTexture('ellipseTex', 80, 80);\n  graphics.destroy();\n\n  // 创建椭圆精灵，放置在屏幕中央\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n\n  // 添加 WASD 键监听\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间差(秒)\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态移动椭圆\n  if (keyW.isDown) {\n    ellipse.y -= distance;\n  }\n  if (keyS.isDown) {\n    ellipse.y += distance;\n  }\n  if (keyA.isDown) {\n    ellipse.x -= distance;\n  }\n  if (keyD.isDown) {\n    ellipse.x += distance;\n  }\n\n  // 边界限制（可选）\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 0, 800);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000200_v3", "prompt_id": "seed_000200", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的红色矩形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的红色矩形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 生命周期中循环8次\n3. 每次循环创建一个 Graphics 对象，设置红色填充样式\n4. 使用 Phaser.Math.Between 生成随机 x、y 坐标\n5. 使用 fillRect 绘制 32x32 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建8个红色矩形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充样式\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 生成随机位置（确保矩形完全在画布内）\n    const x = Phaser.Math.Between(0, 800 - 32);\n    const y = Phaser.Math.Between(0, 600 - 32);\n    \n    // 绘制 32x32 的矩形\n    graphics.fillRect(x, y, 32, 32);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000175_v3", "prompt_id": "seed_000175", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向下移动的椭圆在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向下移动的椭圆对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite#setVelocity\nSTEPS:\n1. 创建 Graphics 绘制椭圆并生成纹理\n2. 创建 Sprite 对象使用椭圆纹理\n3. 设置物理属性让椭圆自动向下移动\n4. 使用相机的 startFollow 方法跟随椭圆对象\n5. 设置世界边界以便椭圆有足够的移动空间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet ellipse;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1);\n  graphics.fillEllipse(40, 40, 80, 60);\n  graphics.generateTexture('ellipseTex', 80, 80);\n  graphics.destroy();\n\n  // 设置世界边界，让场景有足够的移动空间\n  this.physics.world.setBounds(0, 0, 800, 3000);\n\n  // 创建椭圆精灵对象，初始位置在场景上方中心\n  ellipse = this.physics.add.sprite(400, 100, 'ellipseTex');\n  \n  // 设置椭圆向下移动的速度\n  ellipse.setVelocityY(150);\n\n  // 设置相机跟随椭圆对象\n  this.cameras.main.startFollow(ellipse);\n  \n  // 设置相机边界与世界边界一致\n  this.cameras.main.setBounds(0, 0, 800, 3000);\n\n  // 添加提示文本（固定在相机视图上）\n  const text = this.add.text(10, 10, '相机跟随椭圆移动', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n  text.setScrollFactor(0); // 固定在相机视图，不随相机移动\n\n  // 添加一些参考网格线，帮助观察移动效果\n  const gridGraphics = this.add.graphics();\n  gridGraphics.lineStyle(1, 0x444444, 0.5);\n  \n  for (let y = 0; y < 3000; y += 100) {\n    gridGraphics.lineBetween(0, y, 800, y);\n  }\n  \n  for (let x = 0; x < 800; x += 100) {\n    gridGraphics.lineBetween(x, 0, x, 3000);\n  }\n}\n\nfunction update(time, delta) {\n  // 当椭圆到达底部时，重置到顶部\n  if (ellipse.y > 2900) {\n    ellipse.setPosition(400, 100);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000196_v3", "prompt_id": "seed_000196", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色圆形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色圆形，直径24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为紫色（0x800080）\n4. 使用 fillCircle 在画布中央（400, 300）绘制半径为 12 的圆形\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 绘制紫色圆形\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为紫色\n  graphics.fillStyle(0x800080, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数：x坐标, y坐标, 半径\n  // 直径24像素，半径为12像素\n  const centerX = config.width / 2;  // 400\n  const centerY = config.height / 2; // 300\n  const radius = 12;\n  \n  graphics.fillCircle(centerX, centerY, radius);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000697_v3", "prompt_id": "seed_000697", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个紫色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 紫色圆形以300速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制紫色圆形并生成纹理\n3. 创建物理精灵并应用纹理\n4. 设置初始速度为300（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制紫色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9966ff, 1); // 紫色\n  graphics.fillCircle(25, 25, 25); // 半径25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('purpleCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'purpleCircle');\n  \n  // 设置圆形碰撞体为圆形（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置随机初始速度，速度大小为300\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  circle.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000554_v1", "prompt_id": "seed_000554", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让绿色菱形在 0.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建绿色菱形淡入淡出循环动画\nAPI: Graphics, Tween, TweenManager\nSTEPS:\n1. 使用 Graphics 绘制绿色菱形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 loop 属性实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制菱形（四个顶点）\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建使用菱形纹理的精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建淡入淡出 Tween 动画\n  this.tweens.add({\n    targets: diamond,        // 动画目标对象\n    alpha: 0,                // 目标透明度（从当前的 1 渐变到 0）\n    duration: 500,           // 持续时间 0.5 秒\n    yoyo: true,              // 启用悠悠球效果（淡出后自动淡入）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    ease: 'Linear'           // 线性缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000007_v3", "prompt_id": "seed_000007", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Scene.update\nSTEPS:\n1. 创建 Graphics 对象绘制圆形\n2. 将 Graphics 添加到 Container 中以便旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（240度/秒 = 240 * delta/1000）\n4. 应用旋转到 Container 对象\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(0, 0, 50); // 圆心在 (0,0)，半径 50\n  \n  // 添加一个标记线，用于观察旋转效果\n  graphics.lineStyle(3, 0xff0000, 1);\n  graphics.lineBetween(0, 0, 50, 0);\n  \n  // 创建容器并将 Graphics 添加进去\n  circle = this.add.container(400, 300);\n  circle.add(graphics);\n  \n  // 添加说明文字\n  this.add.text(10, 10, '圆形以每秒 240 度的速度旋转', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 240 度\n  // delta 是毫秒，需要转换为秒\n  // 240 度 = 240 * (Math.PI / 180) 弧度\n  const rotationSpeed = 240 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 本帧旋转量\n  \n  // 累加旋转角度\n  circle.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000238_v2", "prompt_id": "seed_000238", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色矩形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现黄色矩形左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 80, 60); // 绘制 80x60 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('yellowRect', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'yellowRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（右侧）\n    duration: 1000,          // 持续时间 1 秒\n    ease: 'Linear',          // 线性缓动\n    yoyo: true,              // 启用往返效果（到达终点后反向播放）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    repeat: 0                // yoyo 模式下不需要额外的 repeat\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '黄色矩形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000305_v1", "prompt_id": "seed_000305", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 3 个红色敌人巡逻移动，在 160 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 3个红色敌人在160速度下左右巡逻，玩家靠近时切换为追踪模式\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Graphics.generateTexture\nSTEPS:\n1. 创建玩家和敌人的纹理（使用Graphics绘制红色和蓝色方块）\n2. 初始化玩家精灵，添加键盘控制\n3. 创建3个敌人精灵，设置初始位置和巡逻方向\n4. 在update中检测玩家与每个敌人的距离，距离<200时切换为追踪模式\n5. 追踪模式下计算方向向量并设置敌人速度指向玩家\n6. 巡逻模式下检测边界碰撞并反转方向\n7. 添加状态信号变量记录敌人状态\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemyStates = []; // 状态信号：记录每个敌人的状态\n    this.detectionRange = 200; // 检测范围\n    this.patrolSpeed = 160; // 巡逻速度\n    this.chaseSpeed = 200; // 追踪速度\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色方块）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 32, 32);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 添加背景提示文字\n    this.add.text(10, 10, 'Arrow Keys to Move\\nEnemies patrol and chase when near', {\n      fontSize: '16px',\n      fill: '#ffffff'\n    });\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 500, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建3个敌人，分布在不同位置\n    const enemyPositions = [\n      { x: 150, y: 150, direction: 1 },\n      { x: 400, y: 250, direction: -1 },\n      { x: 650, y: 350, direction: 1 }\n    ];\n\n    enemyPositions.forEach((pos, index) => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 为每个敌人添加自定义属性\n      enemy.patrolDirection = pos.direction; // 巡逻方向：1向右，-1向左\n      enemy.isChasing = false; // 是否正在追踪\n      enemy.patrolMinX = 50; // 巡逻左边界\n      enemy.patrolMaxX = 750; // 巡逻右边界\n      \n      // 设置初始巡逻速度\n      enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n\n      // 初始化状态信号\n      this.enemyStates[index] = {\n        id: index,\n        mode: 'patrol',\n        direction: pos.direction,\n        distanceToPlayer: 0\n      };\n    });\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 560, '', {\n      fontSize: '14px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    }\n\n    // 更新每个敌人的行为\n    this.enemies.getChildren().forEach((enemy, index) => {\n      const distance = Phaser.Math.Distance.Between(\n        this.player.x,\n        this.player.y,\n        enemy.x,\n        enemy.y\n      );\n\n      // 更新状态信号\n      this.enemyStates[index].distanceToPlayer = Math.floor(distance);\n\n      // 判断是否应该追踪玩家\n      if (distance < this.detectionRange) {\n        // 进入追踪模式\n        if (!enemy.isChasing) {\n          enemy.isChasing = true;\n          this.enemyStates[index].mode = 'chase';\n        }\n\n        // 计算追踪方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x,\n          enemy.y,\n          this.player.x,\n          this.player.y\n        );\n\n        // 设置速度指向玩家\n        this.physics.velocityFromRotation(angle, this.chaseSpeed, enemy.body.velocity);\n\n      } else {\n        // 进入巡逻模式\n        if (enemy.isChasing) {\n          enemy.isChasing = false;\n          this.enemyStates[index].mode = 'patrol';\n          // 恢复巡逻速度\n          enemy.setVelocity(0);\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        // 巡逻边界检测\n        if (enemy.x <= enemy.patrolMinX && enemy.patrolDirection === -1) {\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(this.patrolSpeed);\n          this.enemyStates[index].direction = 1;\n        } else if (enemy.x >= enemy.patrolMaxX && enemy.patrolDirection === 1) {\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(-this.patrolSpeed);\n          this.enemyStates[index].direction = -1;\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.updateStatusDisplay();\n  }\n\n  updateStatusDisplay() {\n    let statusInfo = 'Enemy States:\\n';\n    this.enemyStates.forEach((state, index) => {\n      statusInfo += `E${state.id}: ${state.mode.toUpperCase()} | `;\n      statusInfo += `Dist: ${state.distanceToPlayer} | `;\n      statusInfo += `Dir: ${state.direction > 0 ? 'RIGHT' : 'LEFT'}\\n`;\n    });\n    this.statusText.setText(statusInfo);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000901_v3", "prompt_id": "seed_000901", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 1.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 方块在1.5秒内缩放到48%然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果：scale 从 1 到 0.48 再回到 1\n4. 设置 Tween 的 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 1500ms（1.5秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('squareTexture', 100, 100);\n  graphics.destroy();\n\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'squareTexture');\n  square.setOrigin(0.5, 0.5);\n\n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: square,\n    scaleX: 0.48,  // 缩放到 48%\n    scaleY: 0.48,\n    duration: 1500, // 1.5 秒\n    yoyo: true,     // 往返效果（缩小后再放大）\n    loop: -1,       // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Square scaling to 48% and back', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n\n  this.add.text(400, 550, 'Loop animation: 1.5s to 48%, 1.5s back to 100%', {\n    fontSize: '18px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000607_v1", "prompt_id": "seed_000607", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右移动的圆形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向右移动的圆形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Sprite, Graphics#fillCircle, Graphics#generateTexture\nSTEPS:\n1. 使用 Graphics 绘制圆形并生成纹理\n2. 创建 Sprite 对象并设置为该纹理\n3. 在 update 中让 Sprite 自动向右移动\n4. 使用 Camera.startFollow 让相机跟随该对象\n5. 添加背景网格以便观察相机移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet moveSpeed = 2;\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建背景网格以便观察相机移动\n  createBackgroundGrid.call(this);\n  \n  // 使用 Graphics 生成圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25); // 中心点 (25, 25)，半径 25\n  graphics.generateTexture('playerCircle', 50, 50);\n  graphics.destroy();\n  \n  // 创建玩家对象（圆形）\n  player = this.add.sprite(400, 300, 'playerCircle');\n  \n  // 设置相机跟随玩家\n  this.cameras.main.startFollow(player);\n  \n  // 可选：设置相机跟随的平滑度（lerp 值，0-1 之间）\n  // 值越小越平滑，值为 1 则立即跟随\n  this.cameras.main.setLerp(0.1, 0.1);\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, 'Circle moves right, camera follows', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 让圆形自动向右移动\n  player.x += moveSpeed;\n  \n  // 可选：当圆形移动到一定距离后重置位置（演示循环效果）\n  if (player.x > 3000) {\n    player.x = 0;\n  }\n}\n\n// 辅助函数：创建背景网格\nfunction createBackgroundGrid() {\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格线（扩大范围以便观察相机移动）\n  const gridSize = 50;\n  const gridWidth = 4000;\n  const gridHeight = 1000;\n  \n  // 垂直线\n  for (let x = 0; x <= gridWidth; x += gridSize) {\n    graphics.lineBetween(x, 0, x, gridHeight);\n  }\n  \n  // 水平线\n  for (let y = 0; y <= gridHeight; y += gridSize) {\n    graphics.lineBetween(0, y, gridWidth, y);\n  }\n  \n  // 添加坐标标记\n  const textStyle = {\n    fontSize: '12px',\n    color: '#888888'\n  };\n  \n  for (let x = 0; x <= gridWidth; x += 200) {\n    this.add.text(x + 5, 5, `x:${x}`, textStyle);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000010_v1", "prompt_id": "seed_000010", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让灰色方块在 1.5 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个灰色方块，使用 Tween 动画实现 1.5 秒旋转一圈并循环\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setRotation\nSTEPS:\n1. 使用 Graphics 绘制灰色方块并生成纹理\n2. 在场景中心创建使用该纹理的精灵对象\n3. 使用 tweens.add 创建旋转动画，设置 rotation 属性从 0 到 2π\n4. 配置动画持续时间 1500ms，设置 repeat: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色方块\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理\n  graphics.generateTexture('graySquare', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 在场景中心创建方块精灵\n  const square = this.add.sprite(400, 300, 'graySquare');\n  \n  // 设置精灵的原点为中心（默认就是 0.5, 0.5）\n  square.setOrigin(0.5, 0.5);\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    rotation: Math.PI * 2,     // 旋转角度：2π 弧度（360度）\n    duration: 1500,            // 持续时间：1.5秒\n    ease: 'Linear',            // 线性缓动，匀速旋转\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    yoyo: false                // 不使用往返效果\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000356_v2", "prompt_id": "seed_000356", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色菱形在 3 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个青色菱形在3秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制青色菱形并生成纹理\n2. 创建 Sprite 对象并应用菱形纹理\n3. 使用 tweens 创建 x 轴移动补间动画，设置 duration 为 3000ms\n4. 配置 yoyo 为 true 实现往返效果，设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制菱形（中心点在 32, 32，边长约 64）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 上顶点\n  graphics.lineTo(64, 32);     // 右顶点\n  graphics.lineTo(32, 64);     // 下顶点\n  graphics.lineTo(0, 32);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形精灵，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: diamond,           // 动画目标\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 3000,             // 持续时间 3 秒\n    yoyo: true,                 // 往返效果（到达终点后返回起点）\n    repeat: -1,                 // 无限循环（-1 表示永远重复）\n    ease: 'Linear'              // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000170_v2", "prompt_id": "seed_000170", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的菱形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#moveTo, Phaser.GameObjects.Graphics#lineTo\nSTEPS:\n1. 创建场景并设置较大的世界边界以便菱形移动\n2. 使用 Graphics 绘制菱形并生成纹理\n3. 创建精灵对象使用生成的菱形纹理\n4. 设置相机跟随该精灵对象\n5. 在 update 中让菱形持续向上移动\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.diamond = null;\n    this.moveSpeed = 100; // 每秒移动像素\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 设置世界边界，使其足够大以便菱形移动\n    this.cameras.main.setBounds(0, 0, 800, 2000);\n    this.physics.world.setBounds(0, 0, 800, 2000);\n\n    // 使用 Graphics 绘制菱形并生成纹理\n    const graphics = this.add.graphics();\n    \n    // 绘制菱形（中心点在 32, 32）\n    graphics.fillStyle(0xff6b6b, 1);\n    graphics.beginPath();\n    graphics.moveTo(32, 0);    // 上顶点\n    graphics.lineTo(64, 32);   // 右顶点\n    graphics.lineTo(32, 64);   // 下顶点\n    graphics.lineTo(0, 32);    // 左顶点\n    graphics.closePath();\n    graphics.fillPath();\n\n    // 生成纹理\n    graphics.generateTexture('diamondTexture', 64, 64);\n    graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n    // 创建菱形精灵，初始位置在屏幕中央偏下\n    this.diamond = this.add.sprite(400, 1800, 'diamondTexture');\n\n    // 设置相机跟随菱形对象，居中显示\n    this.cameras.main.startFollow(this.diamond, true, 0.1, 0.1);\n\n    // 添加一些参考背景网格以便观察移动\n    this.createBackgroundGrid();\n\n    // 添加提示文本（固定在相机上）\n    const text = this.add.text(10, 10, '菱形自动向上移动\\n相机跟随居中', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机上，不随世界移动\n  }\n\n  update(time, delta) {\n    // 让菱形持续向上移动\n    if (this.diamond) {\n      this.diamond.y -= this.moveSpeed * (delta / 1000);\n\n      // 如果菱形移动到世界顶部，重置到底部\n      if (this.diamond.y < 0) {\n        this.diamond.y = 2000;\n      }\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建背景网格以便观察相机移动\n    const gridGraphics = this.add.graphics();\n    gridGraphics.lineStyle(1, 0x333333, 0.5);\n\n    // 绘制水平线\n    for (let y = 0; y <= 2000; y += 100) {\n      gridGraphics.moveTo(0, y);\n      gridGraphics.lineTo(800, y);\n    }\n\n    // 绘制垂直线\n    for (let x = 0; x <= 800; x += 100) {\n      gridGraphics.moveTo(x, 0);\n      gridGraphics.lineTo(x, 2000);\n    }\n\n    gridGraphics.strokePath();\n\n    // 添加坐标标记\n    for (let y = 0; y <= 2000; y += 200) {\n      const label = this.add.text(10, y, `Y: ${y}`, {\n        fontSize: '14px',\n        fill: '#666666'\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a1a',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000197_v1", "prompt_id": "seed_000197", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.860952380952381}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形以每秒 360 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#moveTo, Phaser.GameObjects.Graphics#lineTo, Phaser.GameObjects.Graphics#closePath, Phaser.GameObjects.Graphics#fillPath, Phaser.GameObjects.Graphics#setRotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制菱形路径（使用 beginPath/moveTo/lineTo 绘制四个顶点）\n2. 设置菱形的原点为中心点，以便旋转效果正确\n3. 在 update 方法中根据 delta 时间累加旋转角度，每秒旋转 360 度（2π 弧度）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置填充颜色\n  diamond.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心在原点）\n  diamond.beginPath();\n  diamond.moveTo(0, -60);    // 上顶点\n  diamond.lineTo(50, 0);     // 右顶点\n  diamond.lineTo(0, 60);     // 下顶点\n  diamond.lineTo(-50, 0);    // 左顶点\n  diamond.closePath();\n  diamond.fillPath();\n  \n  // 将菱形位置设置到屏幕中心\n  diamond.x = 400;\n  diamond.y = 300;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 360 度 = 2π 弧度\n  // delta 是毫秒，转换为秒：delta / 1000\n  // 旋转速度：2 * Math.PI 弧度/秒\n  const rotationSpeed = 2 * Math.PI; // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  diamond.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000379_v1", "prompt_id": "seed_000379", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的白色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的白色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中创建 Graphics 对象\n3. 编写六边形绘制函数，计算六个顶点坐标（半径16像素）\n4. 循环12次，每次生成随机坐标并绘制白色六边形\n5. 确保六边形完全在画布范围内（边界处理）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置白色填充\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 六边形大小为32像素，半径为16像素\n  const hexSize = 16;\n  \n  // 绘制六边形的函数\n  function drawHexagon(graphics, x, y, radius) {\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点（从顶部开始，顺时针）\n    for (let i = 0; i < 6; i++) {\n      const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度起始，使顶点朝上\n      const px = x + radius * Math.cos(angle);\n      const py = y + radius * Math.sin(angle);\n      \n      if (i === 0) {\n        graphics.moveTo(px, py);\n      } else {\n        graphics.lineTo(px, py);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  }\n  \n  // 绘制12个随机位置的六边形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机坐标，确保六边形完全在画布内\n    // 留出边距避免六边形被裁切（半径16像素 + 额外边距）\n    const margin = hexSize + 10;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    \n    drawHexagon(graphics, randomX, randomY, hexSize);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000321_v3", "prompt_id": "seed_000321", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让六边形在 0.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建使用该纹理的 Sprite 对象，初始透明度设为 0\n3. 使用 Tween 动画控制 alpha 属性从 0 到 1，持续 500ms\n4. 设置 Tween 为循环模式（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形参数\n  const hexRadius = 80;\n  const hexCenterX = 100;\n  const hexCenterY = 100;\n  const sides = 6;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = hexCenterX + hexRadius * Math.cos(angle);\n    const y = hexCenterY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy();\n  \n  // 创建六边形 Sprite 并放置在屏幕中央\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexagon.setAlpha(0);\n  \n  // 创建循环渐变动画\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 500, // 持续 0.5 秒\n    ease: 'Linear',\n    yoyo: true, // 来回循环（透明->不透明->透明）\n    repeat: -1 // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000029_v2", "prompt_id": "seed_000029", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形并以每秒160度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#fillPoints, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个星形\n2. 在 update 中根据 delta 时间增量计算旋转角度\n3. 使用 setRotation 方法更新星形的旋转角度，实现每秒160度的旋转速度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet star;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置星形的中心位置\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 绘制星形\n  drawStar(graphics, centerX, centerY, 5, 80, 40, 0xffff00);\n  \n  // 将 graphics 对象保存到全局变量以便在 update 中使用\n  star = graphics;\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量：每秒160度\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 160; // 度/秒\n  const rotationIncrement = Phaser.Math.DegToRad(rotationSpeed * (delta / 1000));\n  \n  // 更新星形的旋转角度\n  star.rotation += rotationIncrement;\n}\n\n/**\n * 绘制星形的辅助函数\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心 X 坐标\n * @param {number} cy - 中心 Y 坐标\n * @param {number} spikes - 星形的尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n * @param {number} color - 填充颜色\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n  const points = [];\n  const step = Math.PI / spikes;\n  \n  // 生成星形的顶点坐标\n  for (let i = 0; i < spikes * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = i * step - Math.PI / 2;\n    points.push(new Phaser.Geom.Point(\n      cx + Math.cos(angle) * radius,\n      cy + Math.sin(angle) * radius\n    ));\n  }\n  \n  // 设置填充样式并绘制星形\n  graphics.fillStyle(color, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  \n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000319_v1", "prompt_id": "seed_000319", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：12 个粉色小球以 200 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 12个粉色小球在封闭空间内以200速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade.Group, setBounce, setCollideWorldBounds, this.physics.add.collider, Graphics.generateTexture\nSTEPS:\n1. 创建物理系统配置，启用 Arcade 物理引擎\n2. 使用 Graphics 绘制粉色圆形并生成纹理\n3. 创建物理精灵组，添加12个小球并设置随机初始速度\n4. 设置小球的边界碰撞和彼此碰撞\n5. 添加状态信号变量记录碰撞次数\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 状态信号：碰撞次数\n    this.ballCount = 12; // 状态信号：小球数量\n  }\n\n  preload() {\n    // 使用 Graphics 创建粉色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF69B4, 1); // 粉色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('pinkBall', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 设置世界边界\n    this.physics.world.setBoundsCollision(true, true, true, true);\n\n    // 创建物理精灵组\n    this.balls = this.physics.add.group({\n      key: 'pinkBall',\n      repeat: this.ballCount - 1, // 总共12个小球\n      setXY: {\n        x: 100,\n        y: 100,\n        stepX: 60,\n        stepY: 60\n      }\n    });\n\n    // 为每个小球设置属性\n    this.balls.children.entries.forEach((ball, index) => {\n      // 设置随机位置（避免重叠）\n      ball.setPosition(\n        Phaser.Math.Between(50, 750),\n        Phaser.Math.Between(50, 550)\n      );\n\n      // 设置碰撞边界反弹\n      ball.setCollideWorldBounds(true);\n      \n      // 设置完全弹性碰撞（反弹系数为1）\n      ball.setBounce(1, 1);\n\n      // 设置随机速度，速度大小为200\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 200;\n      const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 200;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体（更精确的碰撞检测）\n      ball.body.setCircle(16);\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n\n    // 添加边界碰撞监听（用于统计）\n    this.physics.world.on('worldbounds', () => {\n      this.collisionCount++;\n      this.updateStatusText();\n    });\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调：记录碰撞次数\n    this.collisionCount++;\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Balls: ${this.ballCount}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 200 px/s`\n    ]);\n  }\n\n  update(time, delta) {\n    // 确保速度保持在200左右（补偿浮点误差）\n    this.balls.children.entries.forEach(ball => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏差超过5%，进行修正\n      if (Math.abs(currentSpeed - 200) > 10) {\n        const scale = 200 / currentSpeed;\n        ball.setVelocity(velocity.x * scale, velocity.y * scale);\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000879_v2", "prompt_id": "seed_000879", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让红色方块在 3 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色方块的弹跳循环动画，3秒完成一次弹跳\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 生成红色方块纹理\n2. 创建 Sprite 对象并应用纹理\n3. 使用 Tween 创建 y 轴弹跳动画，配置 yoyo 和 loop 实现循环弹跳\n4. 设置缓动函数模拟真实弹跳效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成红色方块纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 64, 64);\n  graphics.generateTexture('redSquare', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建红色方块精灵\n  const square = this.add.sprite(400, 300, 'redSquare');\n  \n  // 创建弹跳动画\n  // 从中心位置向上弹跳 150 像素，然后回到原位\n  this.tweens.add({\n    targets: square,\n    y: 150, // 弹跳到的最高点\n    duration: 1500, // 上升时间 1.5 秒\n    ease: 'Quad.easeOut', // 上升时减速\n    yoyo: true, // 自动返回原位\n    yoyoEase: 'Bounce.easeOut', // 下落时使用弹跳缓动\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟立即重复\n  });\n  \n  // 添加地面参考线\n  const ground = this.add.graphics();\n  ground.lineStyle(2, 0x666666, 1);\n  ground.lineBetween(0, 332, 800, 332);\n  \n  // 添加说明文字\n  const text = this.add.text(400, 500, '红色方块弹跳动画 (3秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000731_v2", "prompt_id": "seed_000731", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的橙色方块，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的橙色方块，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用循环15次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置橙色，fillRect 绘制 64x64 的方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制方块\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充 (0xFFA500 是标准橙色)\n  graphics.fillStyle(0xFFA500, 1);\n  \n  // 方块大小\n  const squareSize = 64;\n  \n  // 绘制15个随机位置的方块\n  for (let i = 0; i < 15; i++) {\n    // 生成随机坐标，确保方块完全在画布内\n    const x = Math.random() * (config.width - squareSize);\n    const y = Math.random() * (config.height - squareSize);\n    \n    // 绘制方块\n    graphics.fillRect(x, y, squareSize, squareSize);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000078_v1", "prompt_id": "seed_000078", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色三角形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 实现 x 坐标从左到右的移动动画\n4. 设置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右，往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 2500,            // 持续时间 2.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000013_v1", "prompt_id": "seed_000013", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1.5 秒内从原始大小缩放到 16%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形在1.5秒内缩放到16%后恢复，循环播放\nAPI: Graphics.fillStar, this.tweens.add, Tween.yoyo, Tween.loop\nSTEPS:\n1. 使用Graphics绘制星形并生成纹理\n2. 创建星形精灵对象\n3. 使用tweens创建缩放动画，设置scale从1到0.16\n4. 设置yoyo为true实现往返动画，duration为1500ms\n5. 设置loop为-1实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 设置星形的填充颜色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 绘制星形（中心点在 (100, 100)，5个角，外半径50，内半径25）\n  graphics.fillStar(100, 100, 5, 25, 50);\n  \n  // 将绘制的图形生成为纹理\n  graphics.generateTexture('starTexture', 200, 200);\n  \n  // 销毁临时的 graphics 对象\n  graphics.destroy();\n  \n  // 在场景中心创建星形精灵\n  const star = this.add.sprite(400, 300, 'starTexture');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: star,           // 动画目标\n    scaleX: 0.16,           // X轴缩放到16%\n    scaleY: 0.16,           // Y轴缩放到16%\n    duration: 1500,         // 动画持续1.5秒\n    yoyo: true,             // 启用往返效果（缩放后恢复）\n    loop: -1,               // 无限循环（-1表示永久循环）\n    ease: 'Sine.easeInOut'  // 使用平滑的缓动函数\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 550, '星形缩放动画：1.5秒缩放到16%后恢复，循环播放', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000406_v2", "prompt_id": "seed_000406", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色方块在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色方块，使用补间动画实现左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('whiteSquare', 50, 50);\n  graphics.destroy();\n\n  // 创建方块精灵，初始位置在左侧\n  const square = this.add.sprite(100, 300, 'whiteSquare');\n\n  // 创建补间动画：从左到右移动，1秒完成，往返循环\n  this.tweens.add({\n    targets: square,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 1000, // 动画时长 1 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000407_v1", "prompt_id": "seed_000407", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个青色物体以 200 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个青色物体以200速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, setBounce, setVelocity\nSTEPS:\n1. 创建物理引擎配置，启用 arcade 物理系统\n2. 使用 Graphics 生成青色圆形纹理\n3. 创建物理组，添加 15 个青色物体\n4. 为每个物体设置随机速度（200）和反弹属性\n5. 设置物体间的碰撞检测\n6. 添加状态信号（活跃物体数量）用于验证\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet activeObjectsCount = 0;\nlet collisionCount = 0;\n\nfunction preload() {\n  // 创建青色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(16, 16, 16); // 半径16的圆\n  graphics.generateTexture('cyanBall', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理组\n  const objectsGroup = this.physics.add.group({\n    key: 'cyanBall',\n    repeat: 14, // 创建15个物体（0-14）\n    bounceX: 1,\n    bounceY: 1,\n    collideWorldBounds: true\n  });\n\n  // 为每个物体设置随机位置和速度\n  objectsGroup.children.entries.forEach((obj, index) => {\n    // 随机位置\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    obj.setPosition(x, y);\n\n    // 随机方向，固定速度200\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const velocityX = Math.cos(angle) * 200;\n    const velocityY = Math.sin(angle) * 200;\n    obj.setVelocity(velocityX, velocityY);\n\n    // 设置圆形物理体\n    obj.setCircle(16);\n  });\n\n  // 设置物体间的碰撞\n  this.physics.add.collider(objectsGroup, objectsGroup, handleCollision, null, this);\n\n  // 更新状态信号\n  activeObjectsCount = objectsGroup.children.entries.length;\n\n  // 显示状态信息\n  const statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  statusText.setDepth(100);\n\n  // 存储到场景数据中供 update 使用\n  this.statusText = statusText;\n  this.objectsGroup = objectsGroup;\n}\n\nfunction update() {\n  // 更新状态显示\n  if (this.statusText && this.objectsGroup) {\n    activeObjectsCount = this.objectsGroup.children.entries.length;\n    this.statusText.setText([\n      `Active Objects: ${activeObjectsCount}`,\n      `Collisions: ${collisionCount}`,\n      `Speed: 200 px/s`\n    ]);\n  }\n}\n\nfunction handleCollision(obj1, obj2) {\n  // 碰撞计数\n  collisionCount++;\n  \n  // 碰撞后保持速度大小为200\n  // Arcade Physics 的 bounce 会自动处理反弹方向\n  // 这里确保速度大小保持在200左右\n  const velocity1 = obj1.body.velocity;\n  const speed1 = Math.sqrt(velocity1.x * velocity1.x + velocity1.y * velocity1.y);\n  if (speed1 > 0 && Math.abs(speed1 - 200) > 10) {\n    const scale = 200 / speed1;\n    obj1.setVelocity(velocity1.x * scale, velocity1.y * scale);\n  }\n\n  const velocity2 = obj2.body.velocity;\n  const speed2 = Math.sqrt(velocity2.x * velocity2.x + velocity2.y * velocity2.y);\n  if (speed2 > 0 && Math.abs(speed2 - 200) > 10) {\n    const scale = 200 / speed2;\n    obj2.setVelocity(velocity2.x * scale, velocity2.y * scale);\n  }\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000844_v1", "prompt_id": "seed_000844", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 120 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 绘制星形，在 update 中以每秒 120 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStar, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个星形\n2. 将星形定位到画布中心\n3. 在 update 中根据 delta 时间增量计算旋转角度（120度/秒 = Phaser.Math.DegToRad(120) 弧度/秒）\n4. 每帧更新 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet star;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制星形\n  star = this.add.graphics();\n  \n  // 设置填充颜色为金黄色\n  star.fillStyle(0xFFD700, 1);\n  \n  // 绘制星形：中心点 (400, 300)，5个角，外半径 100，内半径 50\n  star.fillStar(400, 300, 5, 100, 50);\n  \n  // 设置旋转中心点为星形的中心\n  // Graphics 的旋转是围绕其原点 (0, 0) 进行的\n  // 由于我们在 (400, 300) 绘制了星形，需要调整\n  // 更好的方式是先在原点绘制，然后移动 Graphics 对象\n  star.clear();\n  star.fillStyle(0xFFD700, 1);\n  star.fillStar(0, 0, 5, 100, 50);\n  star.setPosition(400, 300);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 每秒旋转 120 度 = 120 * (delta / 1000) 度每帧\n  const rotationSpeed = Phaser.Math.DegToRad(120); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 本帧旋转量\n  \n  // 更新星形的旋转角度\n  star.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000018_v2", "prompt_id": "seed_000018", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#lineTo, Phaser.GameObjects.Graphics#closePath, Phaser.GameObjects.Graphics#fillPath, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制六边形路径（通过计算六个顶点坐标）\n2. 设置六边形的中心位置到画布中央\n3. 在 update 方法中根据 delta 时间累加旋转角度（80度/秒 = 80 * (Math.PI/180) 弧度/秒）\n4. 将计算的旋转角度应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  hexagon = this.add.graphics();\n  \n  // 设置填充颜色\n  hexagon.fillStyle(0x00ff00, 1);\n  \n  // 六边形参数\n  const radius = 100; // 半径\n  const sides = 6;    // 边数\n  \n  // 开始绘制路径\n  hexagon.beginPath();\n  \n  // 计算六边形的各个顶点并连接\n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每60度一个顶点，从顶部开始\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      hexagon.moveTo(x, y);\n    } else {\n      hexagon.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径并填充\n  hexagon.closePath();\n  hexagon.fillPath();\n  \n  // 设置六边形位置到画布中心\n  hexagon.x = config.width / 2;\n  hexagon.y = config.height / 2;\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量：80度/秒 转换为弧度/毫秒\n  // delta 是毫秒，80度/秒 = 80 * (Math.PI / 180) 弧度/秒 = 80 * (Math.PI / 180) / 1000 弧度/毫秒\n  const rotationSpeed = 80 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 弧度/帧\n  \n  // 累加旋转角度\n  hexagon.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000113_v3", "prompt_id": "seed_000113", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 10 个青色物体以 80 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 10个青色物体以80速度随机移动，碰撞边界和彼此时反弹\nAPI: Phaser.Physics.Arcade.Group, Graphics.fillCircle, Physics.add.collider, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成青色圆形纹理\n3. 创建物理组，添加10个使用该纹理的精灵\n4. 为每个物体设置随机速度(80)、反弹系数(1)和世界边界碰撞\n5. 添加组内碰撞检测实现物体间反弹\n6. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态变量\nlet collisionCount = 0;\nlet objects;\nlet collisionText;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 生成青色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  graphics.fillCircle(20, 20, 20); // 半径20的圆\n  graphics.generateTexture('cyanCircle', 40, 40);\n  graphics.destroy();\n\n  // 创建物理组\n  objects = this.physics.add.group({\n    key: 'cyanCircle',\n    repeat: 9, // 创建10个对象 (0-9)\n    setXY: {\n      x: Phaser.Math.Between(50, 750),\n      y: Phaser.Math.Between(50, 550),\n      stepX: 0,\n      stepY: 0\n    }\n  });\n\n  // 为每个物体设置属性\n  objects.children.iterate((child) => {\n    // 设置随机方向的速度，总速度为80\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const velocityX = Math.cos(angle) * 80;\n    const velocityY = Math.sin(angle) * 80;\n    \n    child.setVelocity(velocityX, velocityY);\n    \n    // 设置完全反弹\n    child.setBounce(1, 1);\n    \n    // 设置与世界边界碰撞\n    child.setCollideWorldBounds(true);\n    \n    // 随机初始位置，避免重叠\n    child.setPosition(\n      Phaser.Math.Between(50, 750),\n      Phaser.Math.Between(50, 550)\n    );\n  });\n\n  // 添加组内碰撞检测\n  this.physics.add.collider(objects, objects, handleCollision, null, this);\n\n  // 显示碰撞计数（状态验证）\n  collisionText = this.add.text(10, 10, 'Collisions: 0', {\n    fontSize: '20px',\n    fill: '#00ffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加速度信息文本\n  this.add.text(10, 45, 'Speed: 80 pixels/sec', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加对象数量文本\n  this.add.text(10, 75, 'Objects: 10', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n}\n\nfunction handleCollision(obj1, obj2) {\n  // 增加碰撞计数\n  collisionCount++;\n  \n  // 更新显示\n  if (collisionText) {\n    collisionText.setText('Collisions: ' + collisionCount);\n  }\n}\n\nfunction update(time, delta) {\n  // 确保所有物体保持恒定速度80\n  objects.children.iterate((child) => {\n    const currentSpeed = Math.sqrt(\n      child.body.velocity.x * child.body.velocity.x + \n      child.body.velocity.y * child.body.velocity.y\n    );\n    \n    // 如果速度偏差较大，重新归一化到80\n    if (Math.abs(currentSpeed - 80) > 0.1) {\n      const scale = 80 / currentSpeed;\n      child.setVelocity(\n        child.body.velocity.x * scale,\n        child.body.velocity.y * scale\n      );\n    }\n  });\n}\n\n// 启动游戏\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000983_v2", "prompt_id": "seed_000983", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让紫色方块在 4 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建紫色方块在4秒内完成淡入淡出循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制紫色方块并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 loop 参数实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建紫色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x9932cc, 1); // 紫色\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('purpleSquare', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建紫色方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'purpleSquare');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果（从1到0再回到1）\n  // duration: 2000ms 表示单程时间，yoyo 会让总时间变为 4000ms（2秒淡出 + 2秒淡入）\n  this.tweens.add({\n    targets: square,\n    alpha: 0,           // 目标透明度为0（完全透明）\n    duration: 2000,     // 单程持续2秒\n    yoyo: true,         // 启用往返效果（淡出后再淡入）\n    repeat: -1,         // 无限循环（-1表示永久重复）\n    ease: 'Sine.easeInOut' // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加文本说明\n  this.add.text(400, 500, '紫色方块淡入淡出循环动画（4秒一次）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000438_v1", "prompt_id": "seed_000438", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色三角形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形以160速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建物理精灵并应用三角形纹理\n3. 设置初始速度为 160（斜向移动）\n4. 启用世界边界碰撞和反弹系数为 1\n5. 在 update 中保持速度恒定\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制一个指向上方的三角形（中心在 32, 32）\n  graphics.fillTriangle(\n    32, 10,   // 顶点\n    10, 54,   // 左下角\n    54, 54    // 右下角\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 64, 64);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  this.triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（斜向移动，总速度约为 160）\n  const speed = 160;\n  const angle = Math.PI / 4; // 45度角\n  this.triangle.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置碰撞世界边界\n  this.triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  this.triangle.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 保持速度恒定为 160\n  const currentVelocity = this.triangle.body.velocity;\n  const currentSpeed = Math.sqrt(\n    currentVelocity.x * currentVelocity.x + \n    currentVelocity.y * currentVelocity.y\n  );\n  \n  // 如果速度发生变化（由于浮点误差），重新归一化\n  if (Math.abs(currentSpeed - 160) > 0.1) {\n    const scale = 160 / currentSpeed;\n    this.triangle.setVelocity(\n      currentVelocity.x * scale,\n      currentVelocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000060_v3", "prompt_id": "seed_000060", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色三角形并生成纹理\n2. 创建 Sprite 对象放置在左侧起始位置\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色三角形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制三角形（等边三角形，中心在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建三角形精灵，放置在左侧起始位置\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 500,             // 持续时间 0.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000523_v1", "prompt_id": "seed_000523", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形在 1.5 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 星形缩放动画，1.5秒缩放到48%后恢复，循环播放\nAPI: this.add.graphics(), graphics.fillStar(), this.tweens.add(), tween.loop, scale\nSTEPS:\n1. 使用 Graphics 绘制星形并生成纹理\n2. 创建 Sprite 对象使用星形纹理\n3. 使用 Tweens 创建缩放动画，从1.0缩放到0.48再恢复到1.0\n4. 设置动画循环播放，持续时间1.5秒，使用 yoyo 效果实现往返\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制星形\n  const graphics = this.add.graphics();\n  \n  // 设置星形样式\n  graphics.fillStyle(0xffff00, 1); // 黄色填充\n  graphics.lineStyle(3, 0xffa500, 1); // 橙色描边\n  \n  // 绘制星形（中心点在 64, 64，外半径 60，内半径 30，5个角）\n  graphics.fillStar(64, 64, 5, 30, 60, 0);\n  graphics.strokeStar(64, 64, 5, 30, 60, 0);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 128, 128);\n  \n  // 清除 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建星形精灵，放置在屏幕中心\n  const star = this.add.sprite(400, 300, 'star');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: star,           // 动画目标对象\n    scaleX: 0.48,           // X轴缩放到48%\n    scaleY: 0.48,           // Y轴缩放到48%\n    duration: 1500,         // 持续时间1.5秒\n    ease: 'Sine.easeInOut', // 缓动函数，使动画更平滑\n    yoyo: true,             // 启用往返效果（缩放到48%后自动恢复）\n    loop: -1                // 无限循环（-1表示永久循环）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, 'Star scaling animation (48% - 100%)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000286_v2", "prompt_id": "seed_000286", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 360 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个菱形图形并使其以每秒360度（即每秒旋转一圈）的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPath, Graphics.rotation, Scene.update\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中使用 Graphics 绘制菱形（通过四个点构成的路径）\n3. 在 update 方法中根据时间增量更新 Graphics 的 rotation 属性\n4. 计算旋转速度：360度/秒 = 2π弧度/秒，根据 delta 时间累加旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet diamond;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置菱形的中心位置\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 设置填充颜色\n  diamond.fillStyle(0xff6b6b, 1);\n  \n  // 绘制菱形（以原点为中心）\n  // 菱形的四个顶点坐标\n  const size = 80;\n  diamond.beginPath();\n  diamond.moveTo(0, -size);      // 上顶点\n  diamond.lineTo(size, 0);       // 右顶点\n  diamond.lineTo(0, size);       // 下顶点\n  diamond.lineTo(-size, 0);      // 左顶点\n  diamond.closePath();\n  diamond.fillPath();\n  \n  // 添加描边使菱形更明显\n  diamond.lineStyle(3, 0xffffff, 1);\n  diamond.strokePath();\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 360 度 = 2π 弧度\n  // delta 是以毫秒为单位的时间增量\n  // 旋转速度：2π 弧度/秒 = 2π / 1000 弧度/毫秒\n  const rotationSpeed = (Math.PI * 2) / 1000; // 弧度/毫秒\n  \n  // 更新旋转角度\n  diamond.rotation += rotationSpeed * delta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000379_v2", "prompt_id": "seed_000379", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让红色方块在 2 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色方块在2秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 创建红色方块纹理\n2. 创建 Sprite 对象并设置初始位置\n3. 使用 Tween 创建 y 轴弹跳动画，设置 ease 为 'Bounce.easeOut'\n4. 设置动画循环播放，duration 为 2000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建红色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, 0, 64, 64);\n  graphics.generateTexture('redSquare', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建红色方块精灵\n  const square = this.add.sprite(400, 100, 'redSquare');\n  \n  // 定义弹跳的目标位置\n  const bounceHeight = 500; // 地面位置\n  const startHeight = 100;  // 起始高度\n  \n  // 创建弹跳动画\n  this.tweens.add({\n    targets: square,\n    y: bounceHeight,           // 目标 y 坐标（向下弹跳）\n    duration: 1000,            // 下落时间 1 秒\n    ease: 'Quad.easeIn',       // 下落加速\n    yoyo: true,                // 来回运动\n    repeat: -1,                // 无限循环\n    repeatDelay: 0,            // 无延迟\n    onYoyo: function() {\n      // 当开始向上运动时，使用弹跳缓动\n      this.ease = 'Bounce.easeOut';\n      this.duration = 1000;\n    },\n    onRepeat: function() {\n      // 当重新开始下落时，使用加速缓动\n      this.ease = 'Quad.easeIn';\n      this.duration = 1000;\n    }\n  });\n  \n  // 添加地面参考线\n  const ground = this.add.graphics();\n  ground.lineStyle(2, 0xffffff, 0.5);\n  ground.lineBetween(0, bounceHeight + 32, 800, bounceHeight + 32);\n  \n  // 添加说明文字\n  this.add.text(400, 30, '红色方块弹跳动画 (2秒循环)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000595_v3", "prompt_id": "seed_000595", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9466666666666668}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 紫色玩家移出边界时从对侧出现（循环地图效果），移动速度 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 紫色玩家通过键盘控制移动，移出边界时从对侧出现，移动速度300\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Graphics.generateTexture, sprite.setVelocity\nSTEPS:\n1. 创建紫色玩家精灵，使用Graphics生成紫色纹理\n2. 启用Arcade物理系统，设置玩家速度为300\n3. 添加键盘输入监听（WASD或方向键）\n4. 在update中检测边界，实现循环地图效果\n5. 添加位置状态变量用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerX = 0;\n    this.playerY = 0;\n    this.crossedBoundaryCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建紫色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x9b59b6, 1); // 紫色\n    graphics.fillCircle(16, 16, 16); // 圆形玩家\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n\n    // 创建玩家精灵并启用物理\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 关闭世界边界碰撞，允许移出\n    \n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 添加调试文本显示状态\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界提示\n    const boundaryGraphics = this.add.graphics();\n    boundaryGraphics.lineStyle(2, 0xffffff, 0.3);\n    boundaryGraphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0, 0);\n\n    // 处理键盘输入\n    const speed = 300;\n    \n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 处理对角线移动时的速度归一化\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(speed);\n    }\n\n    // 循环地图效果 - 边界检测\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    \n    // 左右边界\n    if (this.player.x < -playerWidth / 2) {\n      this.player.x = 800 + playerWidth / 2;\n      this.crossedBoundaryCount++;\n    } else if (this.player.x > 800 + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      this.crossedBoundaryCount++;\n    }\n\n    // 上下边界\n    if (this.player.y < -playerHeight / 2) {\n      this.player.y = 600 + playerHeight / 2;\n      this.crossedBoundaryCount++;\n    } else if (this.player.y > 600 + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      this.crossedBoundaryCount++;\n    }\n\n    // 更新状态变量\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Position: (${this.playerX}, ${this.playerY})`,\n      `Speed: ${speed}`,\n      `Boundary Crossed: ${this.crossedBoundaryCount}`,\n      `Velocity: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`,\n      '',\n      'Controls: Arrow Keys or WASD'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000861_v3", "prompt_id": "seed_000861", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 1 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setAlpha\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建使用该纹理的精灵对象\n3. 使用 Tween 动画控制精灵的 alpha 属性从 0 到 1\n4. 设置 Tween 为循环播放模式\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100; // 绘制中心点\n  const centerY = 100;\n  \n  // 绘制填充的六边形\n  graphics.fillStyle(0x00ff00, 1); // 绿色填充\n  graphics.lineStyle(4, 0xffffff, 1); // 白色边框\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算六边形的六个顶点并绘制\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexSprite.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: hexSprite,\n    alpha: 1, // 目标透明度：完全不透明\n    duration: 1000, // 持续时间：1 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（透明->不透明->透明）\n    repeat: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '六边形透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000073_v3", "prompt_id": "seed_000073", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的绿色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的绿色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中使用循环创建8个 Graphics 对象\n3. 每个 Graphics 对象使用 fillStyle 设置绿色，用 fillTriangle 绘制三角形\n4. 使用 setRandomPosition 为每个三角形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建8个随机位置的绿色三角形\n  for (let i = 0; i < 8; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置绿色填充\n    graphics.fillStyle(0x00ff00, 1);\n    \n    // 绘制等边三角形（大小为16像素）\n    // 三角形的三个顶点坐标（以中心为原点）\n    const size = 16;\n    const height = size * Math.sqrt(3) / 2; // 等边三角形的高\n    \n    // 顶点坐标（相对于图形中心）\n    const x1 = 0;           // 顶部顶点\n    const y1 = -height * 2 / 3;\n    const x2 = -size / 2;   // 左下顶点\n    const y2 = height / 3;\n    const x3 = size / 2;    // 右下顶点\n    const y3 = height / 3;\n    \n    graphics.fillTriangle(x1, y1, x2, y2, x3, y3);\n    \n    // 设置随机位置（确保三角形完全在画布内）\n    const margin = size;\n    const randomX = Phaser.Math.Between(margin, config.width - margin);\n    const randomY = Phaser.Math.Between(margin, config.height - margin);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000764_v3", "prompt_id": "seed_000764", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让红色三角形在 2.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色三角形，使用 Tween 动画实现 2.5 秒淡入淡出循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色三角形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建 alpha 属性动画，从 1 到 0 再到 1\n4. 设置 duration 为 2500ms，yoyo 为 true，repeat 为 -1 实现循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -50);      // 顶点\n  graphics.lineTo(-43, 25);     // 左下\n  graphics.lineTo(43, 25);      // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTexture', 86, 75);\n  graphics.destroy();\n  \n  // 创建三角形精灵并居中显示\n  const triangle = this.add.sprite(400, 300, 'triangleTexture');\n  \n  // 创建淡入淡出动画\n  this.tweens.add({\n    targets: triangle,\n    alpha: 0,                    // 目标透明度\n    duration: 1250,              // 单程时间 1.25 秒\n    yoyo: true,                  // 往返效果（淡出后淡入）\n    repeat: -1,                  // 无限循环\n    ease: 'Sine.easeInOut'       // 缓动函数，使过渡更平滑\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '红色三角形淡入淡出循环动画', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000535_v2", "prompt_id": "seed_000535", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现紫色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 紫色角色按键切换 idle/run 状态，使用 tween 或帧动画体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Tweens.TweenManager, Phaser.Animations.AnimationManager\nSTEPS:\n1. 使用 Graphics 绘制紫色角色纹理（idle 和 run 两种形态）\n2. 创建 idle 和 run 两个帧动画\n3. 监听键盘输入（I 键切换 idle，R 键切换 run）\n4. 根据状态切换动画和 tween 效果（idle 时缓慢上下浮动，run 时快速左右摆动）\n5. 显示当前状态文本和状态切换计数器作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle';\n    this.stateChangeCount = 0;\n  }\n\n  preload() {\n    // 创建紫色角色的 idle 状态纹理（站立姿态）\n    this.createIdleTextures();\n    // 创建紫色角色的 run 状态纹理（跑步姿态）\n    this.createRunTextures();\n  }\n\n  createIdleTextures() {\n    // 创建 idle 动画的两帧\n    for (let i = 0; i < 2; i++) {\n      const graphics = this.add.graphics();\n      \n      // 身体（紫色矩形）\n      graphics.fillStyle(0x9b59b6, 1);\n      graphics.fillRect(16, 20, 32, 40);\n      \n      // 头部（紫色圆形）\n      graphics.fillStyle(0x8e44ad, 1);\n      graphics.fillCircle(32, 15, 12);\n      \n      // 眼睛\n      graphics.fillStyle(0xffffff, 1);\n      graphics.fillCircle(28, 13, 3);\n      graphics.fillCircle(36, 13, 3);\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(28, 13, 1.5);\n      graphics.fillCircle(36, 13, 1.5);\n      \n      // 手臂（根据帧数微调位置）\n      const armOffset = i === 0 ? 0 : 2;\n      graphics.fillStyle(0x9b59b6, 1);\n      graphics.fillRect(10, 25 + armOffset, 6, 20);\n      graphics.fillRect(48, 25 + armOffset, 6, 20);\n      \n      // 腿部\n      graphics.fillStyle(0x8e44ad, 1);\n      graphics.fillRect(20, 60, 8, 20);\n      graphics.fillRect(36, 60, 8, 20);\n      \n      graphics.generateTexture(`idle_${i}`, 64, 80);\n      graphics.destroy();\n    }\n  }\n\n  createRunTextures() {\n    // 创建 run 动画的四帧\n    for (let i = 0; i < 4; i++) {\n      const graphics = this.add.graphics();\n      \n      // 身体（稍微倾斜）\n      graphics.fillStyle(0x9b59b6, 1);\n      graphics.fillRect(16, 18, 32, 40);\n      \n      // 头部\n      graphics.fillStyle(0x8e44ad, 1);\n      graphics.fillCircle(32, 13, 12);\n      \n      // 眼睛（跑步时更专注）\n      graphics.fillStyle(0xffffff, 1);\n      graphics.fillCircle(29, 12, 3);\n      graphics.fillCircle(37, 12, 3);\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(29, 12, 1.5);\n      graphics.fillCircle(37, 12, 1.5);\n      \n      // 手臂（跑步摆动）\n      const armAngle = Math.sin(i * Math.PI / 2) * 10;\n      graphics.fillStyle(0x9b59b6, 1);\n      graphics.fillRect(8, 22 + armAngle, 8, 22);\n      graphics.fillRect(48, 22 - armAngle, 8, 22);\n      \n      // 腿部（跑步姿态）\n      const legOffset = i % 2 === 0 ? 5 : -5;\n      graphics.fillStyle(0x8e44ad, 1);\n      graphics.fillRect(18, 58 + legOffset, 10, 22);\n      graphics.fillRect(36, 58 - legOffset, 10, 22);\n      \n      graphics.generateTexture(`run_${i}`, 64, 80);\n      graphics.destroy();\n    }\n  }\n\n  create() {\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x34495e, 1);\n    bg.fillRect(0, 0, 800, 600);\n\n    // 创建地面\n    const ground = this.add.graphics();\n    ground.fillStyle(0x2c3e50, 1);\n    ground.fillRect(0, 500, 800, 100);\n\n    // 创建角色精灵\n    this.player = this.add.sprite(400, 450, 'idle_0');\n    this.player.setScale(2);\n\n    // 创建 idle 动画\n    this.anims.create({\n      key: 'idle',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' }\n      ],\n      frameRate: 2,\n      repeat: -1\n    });\n\n    // 创建 run 动画\n    this.anims.create({\n      key: 'run',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 10,\n      repeat: -1\n    });\n\n    // 播放初始 idle 动画\n    this.player.play('idle');\n\n    // 创建 idle 状态的浮动 tween\n    this.idleTween = this.tweens.add({\n      targets: this.player,\n      y: 440,\n      duration: 1500,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n      paused: false\n    });\n\n    // 创建 run 状态的摆动 tween（初始暂停）\n    this.runTween = this.tweens.add({\n      targets: this.player,\n      angle: -5,\n      duration: 200,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1,\n      paused: true\n    });\n\n    // 状态显示文本\n    this.stateText = this.add.text(20, 20, '', {\n      fontSize: '28px',\n      fill: '#fff',\n      fontFamily: 'Arial',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 计数器显示\n    this.counterText = this.add.text(20, 60, '', {\n      fontSize: '24px',\n      fill: '#fff',\n      fontFamily: 'Arial',\n      backgroundColor: '#000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 提示文本\n    this.add.text(400, 550, 'Press [I] for IDLE  |  Press [R] for RUN', {\n      fontSize: '22px',\n      fill: '#ecf0f1',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n\n    // 键盘输入\n    this.keyI = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);\n    this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n\n    // 监听按键按下\n    this.keyI.on('down', () => this.switchState('idle'));\n    this.keyR.on('down', () => this.switchState('run'));\n\n    // 初始化状态显示\n    this.updateStateDisplay();\n  }\n\n  switchState(newState) {\n    if (this.currentState === newState) return;\n\n    this.currentState = newState;\n    this.stateChangeCount++;\n\n    if (newState === 'idle') {\n      // 切换到 idle 状态\n      this.player.play('idle');\n      this.player.setAngle(0);\n      \n      // 启动 idle tween，停止 run tween\n      this.idleTween.resume();\n      this.runTween.pause();\n      \n      // 添加切换效果\n      this.tweens.add({\n        targets: this.player,\n        scaleX: 2.2,\n        scaleY: 1.8,\n        duration: 100,\n        yoyo: true,\n        ease: 'Quad.easeOut'\n      });\n\n    } else if (newState === 'run') {\n      // 切换到 run 状态\n      this.player.play('run');\n      \n      // 停止 idle tween，启动 run tween\n      this.idleTween.pause();\n      this.player.y = 450; // 重置 y 位置\n      this.runTween.resume();\n      \n      // 添加切换效果\n      this.tweens.add({\n        targets: this.player,\n        scaleX: 1.8,\n        scaleY: 2.2,\n        duration: 100,\n        yoyo: true,\n        ease: 'Quad.easeOut'\n      });\n    }\n\n    this.updateStateDisplay();\n  }\n\n  updateStateDisplay() {\n    const stateColor = this.currentState === 'idle' ? '#3498db' : '#e74c3c';\n    this.stateText.setText(`State: ${this.currentState.toUpperCase()}`);\n    this.stateText.setBackgroundColor(stateColor);\n    \n    this.counterText.setText(`Switches: ${this.stateChangeCount}`);\n  }\n\n  update(time, delta) {\n    // 每帧更新逻辑（如果需要）\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2c3e50',\n  scene: GameScene,\n  pixelArt: false\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000808_v2", "prompt_id": "seed_000808", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.9649999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 200。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 灰色玩家移出边界时从对侧出现，移动速度 200\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), sprite.setVelocity(), Phaser.Graphics\nSTEPS:\n1. 创建 800x600 的游戏场景，启用 Arcade 物理系统\n2. 使用 Graphics 绘制灰色方块纹理作为玩家\n3. 创建物理精灵并设置键盘控制（方向键）\n4. 在 update 中检测玩家位置，超出边界时从对侧重新进入\n5. 添加位置状态变量用于验证循环效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.playerX = 0;\n    this.playerY = 0;\n    this.wrapCount = 0; // 循环次数计数器（用于验证）\n  }\n\n  preload() {\n    // 使用 Graphics 创建灰色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建玩家精灵（屏幕中心）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 关闭世界边界碰撞，允许移出\n    \n    // 创建方向键控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界提示\n    const graphics = this.add.graphics();\n    graphics.lineStyle(2, 0xff0000, 0.5);\n    graphics.strokeRect(0, 0, 800, 600);\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0);\n\n    // 键盘控制（方向键或 WASD）\n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setVelocityX(200);\n    }\n\n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setVelocityY(200);\n    }\n\n    // 处理边界循环（玩家从一边移出，从对侧出现）\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    const worldWidth = this.scale.width;\n    const worldHeight = this.scale.height;\n\n    let wrapped = false;\n\n    // 左右边界循环\n    if (this.player.x < -playerWidth / 2) {\n      this.player.x = worldWidth + playerWidth / 2;\n      wrapped = true;\n    } else if (this.player.x > worldWidth + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      wrapped = true;\n    }\n\n    // 上下边界循环\n    if (this.player.y < -playerHeight / 2) {\n      this.player.y = worldHeight + playerHeight / 2;\n      wrapped = true;\n    } else if (this.player.y > worldHeight + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      wrapped = true;\n    }\n\n    // 循环时增加计数\n    if (wrapped) {\n      this.wrapCount++;\n    }\n\n    // 更新状态变量\n    this.playerX = Math.round(this.player.x);\n    this.playerY = Math.round(this.player.y);\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Position: (${this.playerX}, ${this.playerY})`,\n      `Velocity: (${Math.round(this.player.body.velocity.x)}, ${Math.round(this.player.body.velocity.y)})`,\n      `Wrap Count: ${this.wrapCount}`,\n      '',\n      'Controls: Arrow Keys or WASD',\n      'Speed: 200 px/s'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000842_v3", "prompt_id": "seed_000842", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 160，重力 500。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现角色双跳功能，跳跃力度160，重力500\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，设置重力为500\n2. 使用Graphics生成角色和地面的纹理\n3. 创建物理精灵作为角色，添加碰撞检测\n4. 监听空格键输入，实现双跳逻辑（跟踪跳跃次数）\n5. 在碰撞地面时重置跳跃次数，显示跳跃状态信息\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet jumpCount = 0; // 跳跃次数计数器\nconst MAX_JUMPS = 2; // 最大跳跃次数\nlet statusText;\nlet jumpForce = -160; // 跳跃力度\n\nfunction preload() {\n  // 创建角色纹理（蓝色方块）\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('player', 32, 32);\n  graphics.destroy();\n\n  // 创建地面纹理（绿色长方形）\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x00ff00, 1);\n  groundGraphics.fillRect(0, 0, 800, 50);\n  groundGraphics.generateTexture('ground', 800, 50);\n  groundGraphics.destroy();\n}\n\nfunction create() {\n  // 创建地面\n  ground = this.physics.add.sprite(400, 575, 'ground');\n  ground.setImmovable(true);\n  ground.body.allowGravity = false;\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 添加碰撞检测\n  this.physics.add.collider(player, ground, onGroundCollision, null, this);\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 创建状态文本显示\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 空格键按下事件\n  spaceKey.on('down', () => {\n    performJump();\n  });\n\n  updateStatusText();\n}\n\nfunction update() {\n  // 左右移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 检测是否在空中（用于调试显示）\n  updateStatusText();\n}\n\nfunction performJump() {\n  // 双跳逻辑：只要跳跃次数未达到最大值就可以跳\n  if (jumpCount < MAX_JUMPS) {\n    player.setVelocityY(jumpForce);\n    jumpCount++;\n    updateStatusText();\n  }\n}\n\nfunction onGroundCollision() {\n  // 当玩家接触地面时，重置跳跃次数\n  if (player.body.touching.down && ground.body.touching.up) {\n    jumpCount = 0;\n    updateStatusText();\n  }\n}\n\nfunction updateStatusText() {\n  const isOnGround = player.body.touching.down;\n  const remainingJumps = MAX_JUMPS - jumpCount;\n  \n  statusText.setText([\n    `Jump Count: ${jumpCount}/${MAX_JUMPS}`,\n    `Remaining Jumps: ${remainingJumps}`,\n    `On Ground: ${isOnGround}`,\n    `Velocity Y: ${Math.round(player.body.velocity.y)}`,\n    '',\n    'Controls:',\n    'SPACE - Jump (can jump twice)',\n    'LEFT/RIGHT - Move'\n  ]);\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000957_v1", "prompt_id": "seed_000957", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个六边形并生成纹理\n2. 创建一个使用该纹理的精灵对象\n3. 使用 Tween 创建缩放动画，从 1 缩放到 0.8，然后回到 1\n4. 设置 Tween 循环播放（loop: -1）和 yoyo 效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const hexRadius = 80;\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 绘制六边形边框\n  graphics.lineStyle(4, 0xffffff, 1);\n  graphics.strokePath();\n  \n  // 生成纹理\n  const textureSize = hexRadius * 2 + 10;\n  graphics.generateTexture('hexagon', textureSize, textureSize);\n  graphics.destroy();\n  \n  // 创建六边形精灵并居中显示\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: hexSprite,\n    scaleX: 0.8,\n    scaleY: 0.8,\n    duration: 2000, // 2秒\n    yoyo: true, // 自动回到原始值\n    loop: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动效果\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '六边形缩放动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 80% (循环播放)', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000475_v3", "prompt_id": "seed_000475", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个绿色矩形，大小约为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个绿色矩形，大小约为 80 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置绿色填充样式（0x00ff00）\n4. 计算画布中心位置并绘制 80x80 的矩形\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#282c34'\n};\n\nfunction preload() {\n  // 本示例不需要预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为绿色，透明度为 1（完全不透明）\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算矩形左上角位置，使其在画布中央\n  // 画布中心：(400, 300)\n  // 矩形大小：80x80\n  // 左上角位置：(400 - 40, 300 - 40) = (360, 260)\n  const rectSize = 80;\n  const centerX = config.width / 2;\n  const centerY = config.height / 2;\n  const rectX = centerX - rectSize / 2;\n  const rectY = centerY - rectSize / 2;\n  \n  // 绘制矩形\n  graphics.fillRect(rectX, rectY, rectSize, rectSize);\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000024_v1", "prompt_id": "seed_000024", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 80 像素/秒的速度移动\nAPI: Graphics.fillTriangle, Input.Keyboard.addKeys, GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制三角形并生成纹理\n2. 创建精灵对象使用该三角形纹理\n3. 通过 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态和 delta 时间计算位移并更新精灵位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 创建三角形纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个向上的三角形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(32, 8);  // 顶点\n  graphics.lineTo(8, 56);   // 左下\n  graphics.lineTo(56, 56);  // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵，放置在屏幕中央\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 添加 WASD 键监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 显示提示文字\n  this.add.text(10, 10, 'Use WASD to move the triangle', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离 = 速度 * 时间(秒)\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态移动三角形\n  if (keys.w.isDown) {\n    triangle.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    triangle.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    triangle.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    triangle.x += distance; // 向右移动\n  }\n  \n  // 边界限制（可选，防止三角形移出屏幕）\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000729_v1", "prompt_id": "seed_000729", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色六边形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现粉色六边形在4秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色六边形并生成纹理\n2. 创建使用该纹理的 Sprite 对象并定位到左侧\n3. 使用 tweens 创建补间动画，设置 4 秒移动到右侧，yoyo 模式实现往返，loop -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制六边形\n  const hexagonSize = 40;\n  const hexagonPoints = [];\n  \n  // 计算六边形的六个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个角60度\n    const x = hexagonSize + hexagonSize * Math.cos(angle);\n    const y = hexagonSize + hexagonSize * Math.sin(angle);\n    hexagonPoints.push(x, y);\n  }\n  \n  // 绘制多边形\n  graphics.fillPoints(hexagonPoints, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexagonSize * 2, hexagonSize * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexagonSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，4秒完成，往返循环\n  this.tweens.add({\n    targets: hexagonSprite,\n    x: 700, // 移动到右侧（考虑精灵宽度，留出边距）\n    duration: 4000, // 4秒\n    ease: 'Linear', // 线性移动\n    yoyo: true, // 启用往返（到达终点后反向播放）\n    loop: -1 // 无限循环\n  });\n  \n  // 添加文字说明\n  this.add.text(10, 10, '粉色六边形左右往返循环动画\\n单程时间: 4秒', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000704_v2", "prompt_id": "seed_000704", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的青色三角形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的青色三角形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 使用 fillStyle 设置青色（0x00ffff），使用 fillTriangle 绘制三角形\n4. 使用 setRandomPosition 将每个三角形随机放置在场景中\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建12个随机位置的青色三角形\n  for (let i = 0; i < 12; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置青色填充\n    graphics.fillStyle(0x00ffff, 1);\n    \n    // 绘制等边三角形（大小16像素）\n    // 三角形顶点坐标，以中心为原点\n    const height = 16;\n    const halfBase = height * Math.sqrt(3) / 2;\n    \n    graphics.fillTriangle(\n      0, -height / 2,           // 顶点\n      -halfBase, height / 2,    // 左下角\n      halfBase, height / 2      // 右下角\n    );\n    \n    // 随机位置（考虑边界，避免三角形超出屏幕）\n    const randomX = Phaser.Math.Between(20, 780);\n    const randomY = Phaser.Math.Between(20, 580);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000185_v2", "prompt_id": "seed_000185", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Scene.update\nSTEPS:\n1. 创建 Graphics 对象绘制圆形\n2. 将 Graphics 添加到 Container 中以便旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（80度/秒 = 80 * delta/1000 度/帧）\n4. 使用 Container.setRotation 或 Container.angle 属性更新旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circleContainer;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(0, 0, 50); // 在容器中心绘制半径为50的圆\n  \n  // 在圆形上添加一个标记，使旋转效果更明显\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(0, -40, 10); // 在圆的上方绘制红色小圆作为标记\n  \n  // 创建容器并添加 Graphics\n  circleContainer = this.add.container(400, 300);\n  circleContainer.add(graphics);\n  \n  // 初始化旋转角度\n  currentRotation = 0;\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 80 度\n  // delta 是毫秒，所以需要转换：80 度/秒 = 80 * (delta/1000) 度/帧\n  const rotationSpeed = 80; // 度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000); // 本帧旋转的度数\n  \n  // 累加旋转角度\n  currentRotation += rotationIncrement;\n  \n  // 将角度转换为弧度并应用到容器\n  circleContainer.setAngle(currentRotation);\n  \n  // 可选：防止角度无限增长（虽然 Phaser 会自动处理）\n  if (currentRotation >= 360) {\n    currentRotation -= 360;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000001_v2", "prompt_id": "seed_000001", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 300。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 橙色玩家移出边界时从对侧出现（循环地图效果），移动速度 300\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard.createCursorKeys, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色方块并生成纹理作为玩家\n3. 创建物理精灵，设置移动速度 300\n4. 监听键盘输入控制玩家移动\n5. 在 update 中检测边界，实现循环地图效果（左出右进，右出左进，上出下进，下出上进）\n6. 添加状态信号记录玩家穿越边界次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossBoundaryCount = 0; // 状态信号：记录穿越边界次数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建橙色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8C00, 1); // 橙色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('playerTexture', 32, 32);\n    graphics.destroy();\n\n    // 创建玩家精灵（物理对象）\n    this.player = this.physics.add.sprite(400, 300, 'playerTexture');\n    this.player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加 WASD 控制\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 绘制边界提示\n    const border = this.add.graphics();\n    border.lineStyle(2, 0xFFFFFF, 0.5);\n    border.strokeRect(0, 0, 800, 600);\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0, 0);\n\n    // 处理键盘输入\n    const speed = 300;\n\n    if (this.cursors.left.isDown || this.keys.a.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keys.d.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.keys.w.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.keys.s.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 处理对角线移动时的速度归一化\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(speed);\n    }\n\n    // 循环地图效果：检测边界并从对侧出现\n    const halfWidth = this.player.width / 2;\n    const halfHeight = this.player.height / 2;\n\n    // 左右边界\n    if (this.player.x < -halfWidth) {\n      this.player.x = this.cameras.main.width + halfWidth;\n      this.crossBoundaryCount++;\n      this.updateStatusText();\n    } else if (this.player.x > this.cameras.main.width + halfWidth) {\n      this.player.x = -halfWidth;\n      this.crossBoundaryCount++;\n      this.updateStatusText();\n    }\n\n    // 上下边界\n    if (this.player.y < -halfHeight) {\n      this.player.y = this.cameras.main.height + halfHeight;\n      this.crossBoundaryCount++;\n      this.updateStatusText();\n    } else if (this.player.y > this.cameras.main.height + halfHeight) {\n      this.player.y = -halfHeight;\n      this.crossBoundaryCount++;\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,\n      `Boundary Crosses: ${this.crossBoundaryCount}`,\n      `Speed: 300`,\n      '',\n      'Controls: Arrow Keys or WASD'\n    ]);\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000969_v3", "prompt_id": "seed_000969", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：12 个青色小球以 300 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 12个青色小球在封闭空间内以300速度移动，碰撞边界和彼此时弹开\nAPI: Phaser.Physics.Arcade.Group, setBounce, setCollideWorldBounds, collider, setVelocity\nSTEPS:\n1. 配置 Arcade 物理系统，设置世界边界\n2. 使用 Graphics 创建青色圆形纹理\n3. 创建物理组，添加 12 个小球精灵\n4. 为每个小球设置随机初始速度（总速度约300）和弹性系数\n5. 设置小球与世界边界碰撞反弹\n6. 设置小球之间的碰撞检测\n7. 添加碰撞计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 可验证的状态信号\n    this.ballCount = 12;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 添加 12 个小球\n    for (let i = 0; i < this.ballCount; i++) {\n      // 随机位置（避免太靠近边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      const ball = this.balls.create(x, y, 'ball');\n      \n      // 设置随机速度方向，总速度约为 300\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const speed = 300;\n      const vx = Math.cos(angle) * speed;\n      const vy = Math.sin(angle) * speed;\n      \n      ball.setVelocity(vx, vy);\n      ball.setBounce(1, 1); // 完全弹性碰撞\n      ball.setCollideWorldBounds(true);\n    }\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 显示碰撞计数\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n\n    // 显示小球数量\n    this.ballCountText = this.add.text(10, 40, `Balls: ${this.ballCount}`, {\n      fontSize: '24px',\n      fill: '#00ffff'\n    });\n\n    // 显示平均速度（用于验证）\n    this.speedText = this.add.text(10, 70, 'Avg Speed: 0', {\n      fontSize: '24px',\n      fill: '#ffffff'\n    });\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞计数器递增\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    // 更新碰撞计数显示\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n\n    // 计算平均速度（用于验证小球保持约300的速度）\n    let totalSpeed = 0;\n    let ballsArray = this.balls.getChildren();\n    \n    ballsArray.forEach(ball => {\n      const velocity = ball.body.velocity;\n      const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      totalSpeed += speed;\n    });\n\n    const avgSpeed = totalSpeed / this.ballCount;\n    this.speedText.setText(`Avg Speed: ${avgSpeed.toFixed(1)}`);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001172_v1", "prompt_id": "seed_001172", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的灰色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的灰色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽度800x600\n2. 在 create 方法中循环10次，每次创建一个 Graphics 对象\n3. 使用数学计算六边形的6个顶点坐标（半径16像素）\n4. 为每个六边形设置随机位置（x: 50-750, y: 50-550，确保不超出边界）\n5. 使用 Graphics API 绘制填充的灰色六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制10个随机位置的灰色六边形\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置灰色填充\n    graphics.fillStyle(0x808080, 1);\n    \n    // 六边形参数\n    const radius = 16; // 半径16像素，总大小32像素\n    const sides = 6;\n    \n    // 随机位置（确保六边形完全在画布内）\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    // 开始绘制路径\n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    for (let j = 0; j < sides; j++) {\n      // 从顶部开始，顺时针绘制（-90度起始）\n      const angle = (Math.PI / 3) * j - Math.PI / 2;\n      const vertexX = x + radius * Math.cos(angle);\n      const vertexY = y + radius * Math.sin(angle);\n      \n      if (j === 0) {\n        graphics.moveTo(vertexX, vertexY);\n      } else {\n        graphics.lineTo(vertexX, vertexY);\n      }\n    }\n    \n    // 闭合路径\n    graphics.closePath();\n    \n    // 填充六边形\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000246_v3", "prompt_id": "seed_000246", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9042857142857141}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现躲避游戏：橙色敌人从上方以 240 速度落下，玩家左右移动躲避，碰到游戏结束。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现橙色敌人从上方以240速度落下，玩家左右移动躲避，碰撞则游戏结束\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider\nSTEPS:\n1. 创建带有 Arcade 物理引擎的游戏配置\n2. 使用 Graphics 绘制玩家（蓝色方块）和敌人（橙色圆形）纹理\n3. 在 create 中创建玩家精灵，设置键盘输入监听\n4. 创建敌人组，定时生成从顶部落下的敌人\n5. 在 update 中处理玩家左右移动，检测敌人超出屏幕并回收\n6. 添加碰撞检测，碰撞时设置 gameOver 状态并停止物理系统\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.gameOver = false;\n    this.score = 0;\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 40, 40);\n    playerGraphics.generateTexture('player', 40, 40);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（橙色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff8800, 1);\n    enemyGraphics.fillCircle(15, 15, 15);\n    enemyGraphics.generateTexture('enemy', 30, 30);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 550, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(40, 40);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.hitEnemy,\n      null,\n      this\n    );\n\n    // 定时生成敌人（每1秒生成一个）\n    this.enemyTimer = this.time.addEvent({\n      delay: 1000,\n      callback: this.spawnEnemy,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '24px',\n      fill: '#fff'\n    });\n\n    // 游戏结束文本（初始隐藏）\n    this.gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000'\n    });\n    this.gameOverText.setOrigin(0.5);\n    this.gameOverText.setVisible(false);\n  }\n\n  spawnEnemy() {\n    if (this.gameOver) return;\n\n    // 在顶部随机位置生成敌人\n    const x = Phaser.Math.Between(50, 750);\n    const enemy = this.enemies.create(x, -30, 'enemy');\n    \n    // 设置敌人下落速度为 240\n    enemy.setVelocityY(240);\n    enemy.body.setSize(30, 30);\n  }\n\n  hitEnemy(player, enemy) {\n    // 游戏结束\n    this.gameOver = true;\n    this.physics.pause();\n    this.player.setTint(0xff0000);\n    this.gameOverText.setVisible(true);\n    this.enemyTimer.remove();\n  }\n\n  update(time, delta) {\n    if (this.gameOver) return;\n\n    // 玩家左右移动\n    const speed = 300;\n    \n    if (this.cursors.left.isDown || this.keyA.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keyD.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 清理超出屏幕的敌人并增加分数\n    this.enemies.children.entries.forEach((enemy) => {\n      if (enemy.y > 620) {\n        enemy.destroy();\n        this.score += 10;\n        this.scoreText.setText('Score: ' + this.score);\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000877_v2", "prompt_id": "seed_000877", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9191666666666667}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 80 像素/秒的速度移动\nAPI: this.add.graphics(), this.input.keyboard.addKey(), Phaser.Input.Keyboard.KeyCodes, graphics.fillRect()\nSTEPS:\n1. 创建 Scene 配置，设置 800x600 画布\n2. 在 create 中使用 Graphics 绘制方块并生成纹理\n3. 创建精灵对象作为可移动的方块\n4. 使用 addKey 绑定 WASD 四个按键\n5. 在 update 中检测按键状态，根据速度 80 像素/秒更新方块位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 80; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillRect(0, 0, 32, 32);\n  graphics.generateTexture('playerBlock', 32, 32);\n  graphics.destroy();\n\n  // 创建玩家方块精灵，初始位置在画布中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n\n  // 绑定 WASD 按键\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the block', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧的移动距离 = 速度 * 时间间隔（秒）\n  const distance = SPEED * (delta / 1000);\n\n  // 检测按键并移动方块\n  if (keyW.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keyS.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keyA.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keyD.isDown) {\n    player.x += distance; // 向右移动\n  }\n\n  // 限制方块在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 16, 784);\n  player.y = Phaser.Math.Clamp(player.y, 16, 584);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000035_v1", "prompt_id": "seed_000035", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕上显示一段文字 \"Hello Phaser\"，字体大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕上显示 \"Hello Phaser\" 文字，字体大小 24 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸和场景\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 24 像素\n4. 将文本定位在屏幕中央位置\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 显示 \"Hello Phaser\" 文字\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载任何资源\n}\n\nfunction create() {\n  // 在屏幕中央创建文本对象\n  const text = this.add.text(400, 300, 'Hello Phaser', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本的原点为中心，使其在指定坐标居中显示\n  text.setOrigin(0.5, 0.5);\n}\n\n// 创建并启动游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000593_v3", "prompt_id": "seed_000593", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：12 个白色小球以 80 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 12个白色小球在封闭空间内以80速度移动，碰到边界和彼此时弹性碰撞\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.Body#setBounce, Phaser.Physics.Arcade.World#setBoundsCollision, Phaser.Physics.Arcade.ArcadePhysics#add.collider\nSTEPS:\n1. 创建物理系统配置，启用 Arcade Physics\n2. 使用 Graphics 生成白色圆形纹理\n3. 创建物理组，添加12个小球并设置随机位置和速度\n4. 设置小球与世界边界的碰撞和弹性\n5. 设置小球之间的碰撞检测\n6. 添加状态信号（碰撞计数器）用于验证\n[/PLAN]\n\n```javascript\nclass BallBounceScene extends Phaser.Scene {\n  constructor() {\n    super('BallBounceScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n    this.ballCount = 12; // 小球数量\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建白色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ballTexture', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'ballTexture',\n      repeat: this.ballCount - 1, // 创建12个小球\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 设置每个小球的随机位置和速度\n    const ballSpeed = 80;\n    this.balls.children.iterate((ball) => {\n      // 随机位置（避免太靠近边缘）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      ball.setPosition(x, y);\n\n      // 随机速度方向\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const vx = Math.cos(angle) * ballSpeed;\n      const vy = Math.sin(angle) * ballSpeed;\n      ball.setVelocity(vx, vy);\n\n      // 设置圆形碰撞体\n      ball.setCircle(16);\n    });\n\n    // 设置小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 添加信息文本显示\n    this.infoText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界可视化\n    const bounds = this.add.graphics();\n    bounds.lineStyle(2, 0x00ff00, 1);\n    bounds.strokeRect(0, 0, 800, 600);\n\n    this.updateInfo();\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 碰撞回调，增加计数器\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    this.updateInfo();\n  }\n\n  updateInfo() {\n    // 更新状态信息\n    const info = [\n      `Balls: ${this.ballCount}`,\n      `Collisions: ${this.collisionCount}`,\n      `Speed: 80 px/s`\n    ];\n    this.infoText.setText(info.join('\\n'));\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallBounceScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001231_v1", "prompt_id": "seed_001231", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色圆形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现粉色圆形在4秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色圆形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左移动到右\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n5. 设置 duration: 4000 控制单程时间为4秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillCircle(25, 25, 25); // 绘制半径为25的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('pinkCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'pinkCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧位置）\n    duration: 4000,            // 单程持续时间 4 秒\n    yoyo: true,                // 启用往返效果（到达终点后返回起点）\n    loop: -1,                  // 无限循环（-1 表示永久循环）\n    ease: 'Linear'             // 线性缓动，匀速移动\n  });\n  \n  // 添加提示文本\n  this.add.text(300, 50, 'Pink Circle Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000570_v1", "prompt_id": "seed_000570", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让灰色三角形在 2.5 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建灰色三角形，使用 Tween 实现 2.5 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.Between\nSTEPS:\n1. 使用 Graphics 绘制灰色三角形并生成纹理\n2. 创建 Sprite 对象承载三角形纹理\n3. 使用 Tween 系统创建 x/y 位置的随机抖动效果\n4. 设置 Tween 循环播放，duration 为 2500ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建三角形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制等边三角形（中心点为原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -40);      // 顶点\n  graphics.lineTo(-35, 30);     // 左下\n  graphics.lineTo(35, 30);      // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 70, 70);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 保存原始位置\n  const originalX = triangle.x;\n  const originalY = triangle.y;\n  \n  // 创建抖动动画\n  this.tweens.add({\n    targets: triangle,\n    duration: 2500,\n    repeat: -1, // 无限循环\n    yoyo: false,\n    onUpdate: (tween, target) => {\n      // 在每帧更新时产生随机偏移，模拟抖动效果\n      const progress = tween.progress;\n      const intensity = 10; // 抖动强度\n      \n      // 使用正弦波叠加随机值创建抖动\n      const shake = Math.sin(progress * Math.PI * 20) * intensity;\n      target.x = originalX + shake + Phaser.Math.Between(-3, 3);\n      target.y = originalY + shake + Phaser.Math.Between(-3, 3);\n    },\n    onRepeat: () => {\n      // 每次循环重置位置\n      triangle.x = originalX;\n      triangle.y = originalY;\n    }\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 500, '灰色三角形抖动动画 (2.5秒循环)', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000469_v3", "prompt_id": "seed_000469", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色矩形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色矩形在0.5秒内左右往返循环移动\nAPI: this.add.graphics(), this.tweens.add(), yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制白色矩形\n2. 使用 tweens.add 创建补间动画，设置从左到右的 x 坐标变化\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建白色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 将 graphics 转换为纹理以便于补间动画控制\n  graphics.generateTexture('whiteRect', 50, 50);\n  graphics.destroy();\n  \n  // 创建精灵对象用于动画\n  const rect = this.add.sprite(100, 300, 'whiteRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    x: 700,                  // 目标 x 坐标（从左到右）\n    duration: 500,           // 持续时间 0.5 秒\n    yoyo: true,              // 启用往返效果（到达终点后反向播放）\n    repeat: -1,              // 无限循环（-1 表示永远重复）\n    ease: 'Linear'           // 线性缓动函数，保证匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000658_v2", "prompt_id": "seed_000658", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色菱形以 80 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色菱形以80速度移动并在边界反弹\nAPI: Graphics, Phaser.Game, Scene.create, Scene.update, Graphics.fillStyle, Graphics.fillPath, Phaser.Geom.Polygon\nSTEPS:\n1. 使用 Graphics 绘制黄色菱形并生成纹理\n2. 创建精灵对象并设置初始速度(80, 80)\n3. 在 update 中检测边界碰撞并反转速度方向\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet diamond;\nlet velocityX = 80;\nlet velocityY = 80;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 定义菱形的四个顶点（中心在32,32，边长约45像素）\n  const points = [\n    { x: 32, y: 2 },   // 上顶点\n    { x: 62, y: 32 },  // 右顶点\n    { x: 32, y: 62 },  // 下顶点\n    { x: 2, y: 32 }    // 左顶点\n  ];\n  \n  // 创建多边形并填充\n  const polygon = new Phaser.Geom.Polygon(points);\n  graphics.fillPoints(polygon.points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('diamondTexture', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形精灵并设置初始位置\n  diamond = this.add.sprite(400, 300, 'diamondTexture');\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离（delta 是毫秒，需要转换为秒）\n  const deltaSeconds = delta / 1000;\n  const moveX = velocityX * deltaSeconds;\n  const moveY = velocityY * deltaSeconds;\n  \n  // 更新位置\n  diamond.x += moveX;\n  diamond.y += moveY;\n  \n  // 获取菱形的边界（考虑纹理大小）\n  const halfWidth = diamond.width / 2;\n  const halfHeight = diamond.height / 2;\n  \n  // 检测左右边界碰撞\n  if (diamond.x - halfWidth <= 0) {\n    diamond.x = halfWidth;\n    velocityX = Math.abs(velocityX); // 向右反弹\n  } else if (diamond.x + halfWidth >= config.width) {\n    diamond.x = config.width - halfWidth;\n    velocityX = -Math.abs(velocityX); // 向左反弹\n  }\n  \n  // 检测上下边界碰撞\n  if (diamond.y - halfHeight <= 0) {\n    diamond.y = halfHeight;\n    velocityY = Math.abs(velocityY); // 向下反弹\n  } else if (diamond.y + halfHeight >= config.height) {\n    diamond.y = config.height - halfHeight;\n    velocityY = -Math.abs(velocityY); // 向上反弹\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000144_v2", "prompt_id": "seed_000144", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9328571428571427}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色六边形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色六边形，大小约为 24 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的六个顶点坐标（中心点在画布中央，半径 24 像素）\n4. 使用 Graphics API 绘制紫色填充的六边形路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9400D3, 1);\n  \n  // 画布中心点\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 六边形半径（24 像素）\n  const radius = 24;\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制六边形的六个顶点\n  // 六边形的顶点角度间隔为 60 度（Math.PI / 3 弧度）\n  for (let i = 0; i < 6; i++) {\n    // 从顶部开始（-90度），顺时针绘制\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充路径\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000542_v3", "prompt_id": "seed_000542", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的方块在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随一个自动向右上移动的方块\nAPI: Phaser.Scene, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle\nSTEPS:\n1. 创建场景并使用 Graphics 绘制一个方块作为玩家对象\n2. 在 create 中获取主相机并调用 startFollow 方法跟随方块\n3. 在 update 中让方块持续向右上方移动（x++, y--）\n4. 设置相机边界和世界边界，确保有足够的移动空间\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.player = null;\n    this.speed = 2;\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 设置世界边界，让场景足够大以便移动\n    this.physics.world.setBounds(0, 0, 2000, 2000);\n\n    // 使用 Graphics 创建一个红色方块\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xff0000, 1);\n    graphics.fillRect(0, 0, 40, 40);\n    graphics.generateTexture('playerSquare', 40, 40);\n    graphics.destroy();\n\n    // 创建玩家对象（方块）\n    this.player = this.add.rectangle(400, 300, 40, 40, 0xff0000);\n    \n    // 设置相机跟随玩家\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n    \n    // 设置相机边界与世界边界一致\n    this.cameras.main.setBounds(0, 0, 2000, 2000);\n\n    // 添加背景网格以便观察移动效果\n    this.createGrid();\n\n    // 添加提示文本（固定在相机上）\n    const text = this.add.text(10, 10, '红色方块自动向右上移动\\n相机跟随中...', {\n      fontSize: '16px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n  }\n\n  update(time, delta) {\n    // 让方块持续向右上移动\n    this.player.x += this.speed;\n    this.player.y -= this.speed;\n\n    // 边界检测，到达边界后反向移动\n    if (this.player.x >= 1980 || this.player.x <= 20) {\n      this.speed = -this.speed;\n    }\n    if (this.player.y <= 20 || this.player.y >= 1980) {\n      this.speed = -this.speed;\n    }\n  }\n\n  createGrid() {\n    // 创建网格背景以便观察相机移动\n    const graphics = this.add.graphics();\n    graphics.lineStyle(1, 0x00ff00, 0.3);\n\n    // 绘制垂直线\n    for (let x = 0; x <= 2000; x += 100) {\n      graphics.lineBetween(x, 0, x, 2000);\n    }\n\n    // 绘制水平线\n    for (let y = 0; y <= 2000; y += 100) {\n      graphics.lineBetween(0, y, 2000, y);\n    }\n\n    // 添加坐标标记\n    for (let x = 0; x <= 2000; x += 200) {\n      for (let y = 0; y <= 2000; y += 200) {\n        const label = this.add.text(x + 5, y + 5, `${x},${y}`, {\n          fontSize: '12px',\n          color: '#00ff00'\n        });\n      }\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000517_v3", "prompt_id": "seed_000517", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8692857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色圆形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色圆形，半径为 16 像素\nAPI: Phaser.Game, Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为红色 (0xff0000)\n4. 使用 fillCircle 在画布中央 (400, 300) 绘制半径为 16 的圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数：x坐标, y坐标, 半径\n  graphics.fillCircle(400, 300, 16);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000612_v3", "prompt_id": "seed_000612", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个蓝色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理20个蓝色可复用对象，离开屏幕后自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, Group.get, Group.killAndHide\nSTEPS:\n1. 创建蓝色方块纹理使用Graphics\n2. 使用Physics.Arcade.Group创建对象池，设置maxSize为20\n3. 在create中初始化对象池并设置runChildUpdate为true\n4. 定时从对象池获取对象并发射\n5. 在update中检测对象是否离开屏幕，离开则回收到对象池\n6. 添加状态变量跟踪活跃对象数和总发射数\n[/PLAN]\n\n```javascript\nclass PooledObject extends Phaser.Physics.Arcade.Sprite {\n  constructor(scene, x, y) {\n    super(scene, x, y, 'blueBox');\n  }\n\n  fire(x, y) {\n    this.setPosition(x, y);\n    this.setActive(true);\n    this.setVisible(true);\n    this.body.enable = true;\n    \n    // 设置随机速度\n    const angle = Phaser.Math.Between(-30, 30);\n    const speed = Phaser.Math.Between(100, 200);\n    this.setVelocity(\n      Math.cos(Phaser.Math.DegToRad(angle)) * speed,\n      Math.sin(Phaser.Math.DegToRad(angle)) * speed\n    );\n  }\n\n  preUpdate(time, delta) {\n    super.preUpdate(time, delta);\n    \n    // 检测是否离开屏幕\n    const bounds = this.scene.physics.world.bounds;\n    if (this.x < bounds.x - 50 || \n        this.x > bounds.right + 50 || \n        this.y < bounds.y - 50 || \n        this.y > bounds.bottom + 50) {\n      this.setActive(false);\n      this.setVisible(false);\n      this.body.enable = false;\n    }\n  }\n}\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;\n    this.totalFired = 0;\n    this.recycledCount = 0;\n  }\n\n  preload() {\n    // 创建蓝色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0066ff, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.lineStyle(2, 0x0044cc, 1);\n    graphics.strokeRect(0, 0, 32, 32);\n    graphics.generateTexture('blueBox', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建对象池，最大20个对象\n    this.objectPool = this.physics.add.group({\n      classType: PooledObject,\n      maxSize: 20,\n      runChildUpdate: true\n    });\n\n    // 定时发射对象\n    this.time.addEvent({\n      delay: 500,\n      callback: this.launchObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 60, 'Objects are pooled and recycled\\nwhen they leave the screen', {\n      fontSize: '14px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 5 }\n    });\n  }\n\n  launchObject() {\n    // 从对象池获取对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 从屏幕底部中央发射\n      obj.fire(400, 550);\n      this.totalFired++;\n    }\n  }\n\n  update(time, delta) {\n    // 统计活跃对象数\n    this.activeCount = this.objectPool.countActive(true);\n    \n    // 计算回收数\n    this.recycledCount = this.totalFired - this.activeCount;\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Pool Size: ${this.objectPool.getLength()} / 20`,\n      `Active: ${this.activeCount}`,\n      `Total Fired: ${this.totalFired}`,\n      `Recycled: ${this.recycledCount}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#222222',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000960_v1", "prompt_id": "seed_000960", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#beginPath, Phaser.GameObjects.Graphics#lineTo, Phaser.GameObjects.Graphics#closePath, Phaser.GameObjects.Graphics#fillPath, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个六边形\n2. 将六边形的原点设置到中心位置\n3. 在 update 中根据 delta 时间累加旋转角度（300度/秒 = 300 * delta / 1000）\n4. 使用 setRotation 方法更新六边形的旋转角度\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  hexagon = this.add.graphics();\n  \n  // 设置填充颜色\n  hexagon.fillStyle(0x00ff00, 1);\n  \n  // 绘制六边形\n  const radius = 80;\n  const sides = 6;\n  const centerX = 400;\n  const centerY = 300;\n  \n  hexagon.beginPath();\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      hexagon.moveTo(x, y);\n    } else {\n      hexagon.lineTo(x, y);\n    }\n  }\n  \n  hexagon.closePath();\n  hexagon.fillPath();\n  \n  // 设置旋转中心为六边形的中心\n  hexagon.x = centerX;\n  hexagon.y = centerY;\n  \n  // 由于我们已经在 centerX, centerY 位置绘制了六边形\n  // 需要重新绘制，使其相对于原点 (0, 0) 绘制\n  hexagon.clear();\n  hexagon.fillStyle(0x00ff00, 1);\n  hexagon.beginPath();\n  \n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      hexagon.moveTo(x, y);\n    } else {\n      hexagon.lineTo(x, y);\n    }\n  }\n  \n  hexagon.closePath();\n  hexagon.fillPath();\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 300 度\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 300; // 度/秒\n  const rotationRadians = Phaser.Math.DegToRad(rotationSpeed * delta / 1000);\n  \n  // 累加旋转角度\n  hexagon.rotation += rotationRadians;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000706_v1", "prompt_id": "seed_000706", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色矩形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色矩形以200速度移动并在画布边界反弹\nAPI: Graphics, Rectangle, Physics.Arcade, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制橙色矩形并生成纹理\n3. 创建物理精灵并应用纹理\n4. 设置初始速度为 200（斜向移动）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFF8800, 1); // 橙色\n  graphics.fillRect(0, 0, 50, 50); // 50x50 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('orangeRect', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const rect = this.physics.add.sprite(400, 300, 'orangeRect');\n  \n  // 设置初始速度（斜向移动，速度约为 200）\n  // 使用勾股定理：√(141²+141²) ≈ 200\n  rect.setVelocity(141, 141);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  rect.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  rect.setCollideWorldBounds(true);\n  \n  // 可选：添加文字说明\n  this.add.text(10, 10, 'Orange rectangle bouncing at speed ~200', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000311_v1", "prompt_id": "seed_000311", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色矩形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现黄色矩形4秒左右往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n5. 设置 duration: 4000 实现4秒移动时间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 创建黄色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 80, 60); // 绘制80x60的矩形\n  graphics.generateTexture('yellowRect', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建黄色矩形精灵\n  const rect = this.add.sprite(100, 300, 'yellowRect');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: rect,\n    x: 700, // 目标x坐标（右侧）\n    duration: 4000, // 4秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向回到起点）\n    loop: -1, // 无限循环（-1表示永久循环）\n    repeat: 0 // yoyo模式下repeat设为0，循环由loop控制\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '黄色矩形4秒往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000095_v3", "prompt_id": "seed_000095", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色星形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色星形以160速度移动并在画布边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 Arcade 物理引擎\n2. 使用 Graphics 绘制蓝色星形并生成纹理\n3. 创建物理精灵并应用星形纹理\n4. 设置初始速度为 160（随机方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0066ff, 1); // 蓝色\n  \n  // 绘制星形（中心点在 50, 50，半径 50）\n  graphics.fillStar(50, 50, 5, 20, 50);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置初始速度（160 像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 160;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 160;\n  star.setVelocity(velocityX, velocityY);\n  \n  // 设置边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  star.setBounce(1, 1);\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Blue star bouncing at 160 speed', {\n    fontSize: '16px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000788_v3", "prompt_id": "seed_000788", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个蓝色圆形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色圆形以300速度移动并在边界反弹\nAPI: Graphics, arcade.sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 arcade 物理精灵并应用纹理\n3. 设置初始速度为300（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径为25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('blueCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建物理精灵\n  const circle = this.physics.add.sprite(400, 300, 'blueCircle');\n  \n  // 设置圆形为圆形碰撞体（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置初始速度（斜向移动，速度约为300）\n  // 使用勾股定理：sqrt(212^2 + 212^2) ≈ 300\n  circle.setVelocity(212, 212);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  circle.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000184_v2", "prompt_id": "seed_000184", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个绿色六边形在2.5秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置绘制样式\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0x00aa00, 1);\n  \n  // 绘制六边形（中心点在 50, 50，半径 40）\n  const hexRadius = 40;\n  const centerX = 50;\n  const centerY = 50;\n  const sides = 6;\n  \n  // 计算六边形的顶点\n  const points = [];\n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 * i) / sides - Math.PI / 2; // -PI/2 让顶点朝上\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push(x, y);\n  }\n  \n  // 绘制多边形\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象，初始位置在左侧\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右，2.5秒，往返循环\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700, // 移动到右侧\n    duration: 2500, // 2.5秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 往返效果\n    repeat: -1 // 无限循环 (-1 表示永久重复)\n  });\n  \n  // 添加文字提示\n  this.add.text(400, 50, '绿色六边形往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000482_v2", "prompt_id": "seed_000482", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向右上移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随一个自动向右上移动的矩形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.Scene.cameras\nSTEPS:\n1. 创建一个 Graphics 对象绘制矩形作为跟随目标\n2. 在 create 中使用 this.cameras.main.startFollow() 让主相机跟随矩形\n3. 在 update 中让矩形持续向右上方移动（x++, y--）\n4. 添加世界边界和背景网格以便观察相机跟随效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使场景更大以便观察相机跟随\n  this.cameras.main.setBounds(0, 0, 2000, 2000);\n  this.physics.world.setBounds(0, 0, 2000, 2000);\n\n  // 创建背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x444444, 0.5);\n  \n  // 绘制网格\n  for (let x = 0; x <= 2000; x += 100) {\n    graphics.lineBetween(x, 0, x, 2000);\n  }\n  for (let y = 0; y <= 2000; y += 100) {\n    graphics.lineBetween(0, y, 2000, y);\n  }\n\n  // 创建移动的矩形对象\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(-25, -25, 50, 50); // 以中心点绘制\n  \n  // 生成纹理并创建精灵\n  playerGraphics.generateTexture('player', 50, 50);\n  playerGraphics.destroy(); // 销毁临时 graphics\n  \n  this.player = this.add.sprite(400, 1500, 'player');\n  \n  // 设置相机跟随玩家，并保持居中\n  this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（这里设为0保持完全居中）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加说明文字（固定在相机上）\n  const text = this.add.text(10, 10, '绿色方块自动向右上移动\\n相机跟随并保持居中', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 10 }\n  });\n  text.setScrollFactor(0); // 固定在相机视图上\n  \n  // 存储移动速度\n  this.moveSpeed = 2;\n}\n\nfunction update(time, delta) {\n  // 让矩形向右上方移动\n  this.player.x += this.moveSpeed;\n  this.player.y -= this.moveSpeed;\n  \n  // 可选：当矩形到达世界边界时重置位置\n  if (this.player.x > 1900 || this.player.y < 100) {\n    this.player.x = 100;\n    this.player.y = 1900;\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000287_v1", "prompt_id": "seed_000287", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8920833333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 48px\n4. 将文本定位到屏幕下方中央位置\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本示例不需要预加载外部资源\n}\n\nfunction create() {\n  // 创建文本对象\n  const text = this.add.text(0, 0, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本原点为中心点，便于居中定位\n  text.setOrigin(0.5, 0.5);\n  \n  // 将文本定位到屏幕下方中央\n  // x: 屏幕宽度的一半（水平居中）\n  // y: 屏幕高度 - 80 像素（距离底部有一定间距）\n  text.setPosition(this.cameras.main.width / 2, this.cameras.main.height - 80);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000022_v2", "prompt_id": "seed_000022", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个紫色圆形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个紫色圆形，直径24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充颜色为紫色（0x800080）\n4. 使用 fillCircle 在画布中央（400, 300）绘制半径为 12 的圆形\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码 - 在画布中央绘制紫色圆形\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为紫色\n  graphics.fillStyle(0x800080, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数：x坐标, y坐标, 半径\n  // 圆形大小约24像素，因此半径为12像素\n  const centerX = this.cameras.main.width / 2;  // 400\n  const centerY = this.cameras.main.height / 2; // 300\n  const radius = 12;\n  \n  graphics.fillCircle(centerX, centerY, radius);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000697_v2", "prompt_id": "seed_000697", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色六边形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色六边形，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.lineStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.strokePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的 6 个顶点坐标（中心点为画布中心，半径为 16 像素）\n4. 使用 Graphics API 绘制六边形路径并填充白色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 六边形半径\n  const radius = 16;\n  \n  // 计算六边形的 6 个顶点坐标\n  // 六边形从顶部开始，顺时针绘制\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // -90度开始，每次旋转60度\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    points.push({ x, y });\n  }\n  \n  // 设置填充样式为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制六边形\n  graphics.beginPath();\n  graphics.moveTo(points[0].x, points[0].y);\n  \n  for (let i = 1; i < points.length; i++) {\n    graphics.lineTo(points[i].x, points[i].y);\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000123_v3", "prompt_id": "seed_000123", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色圆形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色圆形，直径16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建基础 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用 fillStyle 设置红色填充色\n4. 使用 fillCircle 在画布中央 (400, 300) 绘制半径为 8 的圆形\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n/**\n * 预加载资源\n * 本示例不需要加载外部资源\n */\nfunction preload() {\n  // 无需加载外部资源\n}\n\n/**\n * 创建游戏对象\n * 在画布中央绘制红色圆形\n */\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色 (0xff0000)，透明度为 1\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 在画布中央绘制圆形\n  // 参数：x坐标, y坐标, 半径\n  // 画布尺寸 800x600，中心点为 (400, 300)\n  // 直径 16 像素，半径为 8 像素\n  graphics.fillCircle(400, 300, 8);\n}\n\n// 创建并启动 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000612_v1", "prompt_id": "seed_000612", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 2.5 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个圆形，使用 Tween 动画在 2.5 秒内缩放到 80% 后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 创建 Graphics 对象绘制圆形\n2. 使用 tweens.add 创建缩放动画，设置 scale 从 1 到 0.8\n3. 配置 yoyo 为 true 实现恢复效果，duration 为 1250ms（总计 2.5 秒）\n4. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 设置圆形样式（蓝色填充）\n  graphics.fillStyle(0x4a90e2, 1);\n  \n  // 在中心位置绘制圆形，半径为 80 像素\n  graphics.fillCircle(0, 0, 80);\n  \n  // 设置圆形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    scale: 0.8,                  // 缩放到 80%\n    duration: 1250,              // 单程时长 1.25 秒\n    yoyo: true,                  // 启用往返效果（缩小后恢复）\n    loop: -1,                    // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut'       // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 500, '圆形缩放动画（2.5秒循环）', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000410_v3", "prompt_id": "seed_000410", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 3 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在3秒内缩放到32%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 动画实现缩放效果（scale: 1 -> 0.32 -> 1）\n4. 设置 Tween 循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.lineStyle(4, 0xffffff, 1);\n  \n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个顶点间隔60度\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建六边形精灵\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: hexagon,\n    scaleX: 0.32, // 缩放到32%\n    scaleY: 0.32,\n    duration: 3000, // 3秒\n    yoyo: true, // 自动反向播放（恢复到原始大小）\n    loop: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  const text = this.add.text(400, 550, '六边形循环缩放动画 (3秒缩放到32%，然后恢复)', {\n    fontSize: '20px',\n    color: '#ffffff',\n    align: 'center'\n  });\n  text.setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000015_v2", "prompt_id": "seed_000015", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的粉色矩形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的粉色矩形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建基础 Game 配置和 Scene\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环10次，每次生成随机坐标\n4. 使用 fillStyle 设置粉色，fillRect 绘制 64x64 矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充颜色 (0xff69b4 是粉色的十六进制值)\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制10个随机位置的矩形\n  for (let i = 0; i < 10; i++) {\n    // 生成随机坐标，确保矩形完全在画布内\n    // x: 0 到 (800 - 64)，y: 0 到 (600 - 64)\n    const x = Phaser.Math.Between(0, 736);\n    const y = Phaser.Math.Between(0, 536);\n    \n    // 绘制 64x64 的矩形\n    graphics.fillRect(x, y, 64, 64);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000774_v3", "prompt_id": "seed_000774", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让红色六边形在 4 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建红色六边形并使用 Tween 实现 4 秒旋转一次的循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.DegToRad\nSTEPS:\n1. 使用 Graphics 绘制红色六边形\n2. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n3. 设置动画时长为 4000ms，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 六边形参数\n  const centerX = 400;\n  const centerY = 300;\n  const radius = 80;\n  const sides = 6;\n  \n  // 绘制红色六边形\n  graphics.fillStyle(0xff0000, 1);\n  graphics.lineStyle(3, 0xffffff, 1);\n  \n  // 计算六边形顶点\n  graphics.beginPath();\n  for (let i = 0; i < sides; i++) {\n    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 创建旋转动画\n  // 使用 tweens 让六边形旋转\n  this.tweens.add({\n    targets: graphics,\n    angle: 360, // 旋转到 360 度\n    duration: 4000, // 4 秒完成一次旋转\n    ease: 'Linear', // 线性缓动，保持匀速旋转\n    repeat: -1, // 无限循环\n    onRepeat: () => {\n      // 每次循环重置角度，避免数值累积\n      graphics.angle = 0;\n    }\n  });\n  \n  // 添加文字提示\n  this.add.text(400, 50, '红色六边形旋转动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '4 秒完成一次旋转，无限循环', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000629_v2", "prompt_id": "seed_000629", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色圆形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现蓝色圆形左右往返循环补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 为 true 实现往返效果\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0000ff, 1); // 蓝色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径为 25 的圆\n  \n  // 生成纹理\n  graphics.generateTexture('blueCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建精灵对象\n  const circle = this.add.sprite(100, 300, 'blueCircle');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: circle,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 500, // 持续时间 0.5 秒\n    yoyo: true, // 往返效果\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Linear' // 线性缓动\n  });\n  \n  // 添加文字说明\n  this.add.text(300, 50, '蓝色圆形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000145_v2", "prompt_id": "seed_000145", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的白色矩形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的白色矩形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环15次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置白色，fillRect 绘制 48x48 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 矩形大小\n  const rectSize = 48;\n  \n  // 绘制15个随机位置的白色矩形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机坐标，确保矩形完全在画布内\n    const x = Phaser.Math.Between(0, config.width - rectSize);\n    const y = Phaser.Math.Between(0, config.height - rectSize);\n    \n    // 绘制矩形\n    graphics.fillRect(x, y, rectSize, rectSize);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000206_v2", "prompt_id": "seed_000206", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 15 个黄色物体以 160 速度随机移动，碰撞时反弹。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 15个黄色物体以160速度随机移动，碰撞时反弹\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World#setBoundsCollision, Phaser.Physics.Arcade.Body#setVelocity, Phaser.Physics.Arcade.Body#setBounce, Phaser.Physics.Arcade.World#collide\nSTEPS:\n1. 创建物理系统配置，启用 Arcade 物理引擎\n2. 使用 Graphics 生成黄色圆形纹理\n3. 创建物理组，添加 15 个黄色物体\n4. 为每个物体设置随机方向的速度（速率为 160）\n5. 设置物体碰撞边界反弹和物体间碰撞检测\n6. 添加状态信号变量记录活跃物体数量\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 状态信号变量\nlet activeObjects = 0;\nlet collisionCount = 0;\n\nfunction preload() {\n  // 创建黄色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(16, 16, 16);\n  graphics.generateTexture('yellowCircle', 32, 32);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建物理组\n  const objectsGroup = this.physics.add.group({\n    key: 'yellowCircle',\n    repeat: 14, // 创建15个物体（1个初始 + 14个重复）\n    setXY: {\n      x: Phaser.Math.Between(50, 750),\n      y: Phaser.Math.Between(50, 550),\n      stepX: 0,\n      stepY: 0\n    }\n  });\n\n  // 为每个物体设置属性\n  objectsGroup.children.iterate((child) => {\n    // 随机生成速度方向（角度）\n    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n    const velocityX = Math.cos(angle) * 160;\n    const velocityY = Math.sin(angle) * 160;\n    \n    // 设置速度\n    child.setVelocity(velocityX, velocityY);\n    \n    // 设置边界碰撞反弹\n    child.setBounce(1, 1);\n    child.setCollideWorldBounds(true);\n    \n    // 设置随机初始位置，避免重叠\n    child.x = Phaser.Math.Between(50, 750);\n    child.y = Phaser.Math.Between(50, 550);\n  });\n\n  // 设置物体间的碰撞检测\n  this.physics.add.collider(objectsGroup, objectsGroup, handleCollision, null, this);\n\n  // 更新状态信号\n  activeObjects = objectsGroup.getLength();\n\n  // 显示状态信息\n  const statusText = this.add.text(10, 10, '', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 保存引用以便在 update 中使用\n  this.statusText = statusText;\n}\n\nfunction update() {\n  // 更新状态显示\n  if (this.statusText) {\n    this.statusText.setText(\n      `Active Objects: ${activeObjects}\\n` +\n      `Collisions: ${collisionCount}`\n    );\n  }\n}\n\nfunction handleCollision(obj1, obj2) {\n  // 记录碰撞次数\n  collisionCount++;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000997_v3", "prompt_id": "seed_000997", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形在 1.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个矩形\n2. 设置矩形初始透明度为 0（完全透明）\n3. 使用 Tween 动画让矩形的 alpha 属性从 0 变化到 1\n4. 设置 Tween 持续时间为 1500 毫秒，并配置循环播放（yoyo 或 repeat）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个矩形\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式（蓝色矩形）\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 在屏幕中心绘制一个 200x150 的矩形\n  const rectX = (this.cameras.main.width - 200) / 2;\n  const rectY = (this.cameras.main.height - 150) / 2;\n  graphics.fillRect(rectX, rectY, 200, 150);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明（alpha: 0）到不透明（alpha: 1）\n  this.tweens.add({\n    targets: graphics,           // 动画目标对象\n    alpha: 1,                    // 目标透明度值\n    duration: 1500,              // 持续时间 1.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 反向播放（1 -> 0）\n    repeat: -1                   // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '矩形渐变动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '透明 ↔ 不透明 (1.5秒循环)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000503_v2", "prompt_id": "seed_000503", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个六边形移动，速度为 240 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制六边形以 240 像素/秒的速度移动\nAPI: Graphics.fillStyle, Graphics.fillPath, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 创建 Graphics 对象并绘制六边形形状\n2. 使用 input.keyboard.addKeys 监听 WASD 键位\n3. 在 update 中根据按键状态和 delta 时间计算位移\n4. 更新六边形的 x 和 y 坐标实现移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet hexagon;\nlet keys;\nconst SPEED = 240; // 像素/秒\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建六边形 Graphics 对象\n  hexagon = this.add.graphics();\n  hexagon.x = 400;\n  hexagon.y = 300;\n  \n  // 绘制六边形\n  drawHexagon(hexagon);\n  \n  // 添加 WASD 键位监听\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the hexagon', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算移动距离 = 速度 * 时间（转换为秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新位置\n  if (keys.w.isDown) {\n    hexagon.y -= distance;\n  }\n  if (keys.s.isDown) {\n    hexagon.y += distance;\n  }\n  if (keys.a.isDown) {\n    hexagon.x -= distance;\n  }\n  if (keys.d.isDown) {\n    hexagon.x += distance;\n  }\n  \n  // 边界限制（可选）\n  hexagon.x = Phaser.Math.Clamp(hexagon.x, 0, 800);\n  hexagon.y = Phaser.Math.Clamp(hexagon.y, 0, 600);\n}\n\n/**\n * 绘制六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n */\nfunction drawHexagon(graphics) {\n  const radius = 40; // 六边形半径\n  const points = [];\n  \n  // 计算六边形的六个顶点\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 创建多边形路径\n  const polygon = new Phaser.Geom.Polygon(points);\n  \n  // 填充六边形\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillPoints(polygon.points, true);\n  \n  // 添加边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokePoints(polygon.points, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000318_v3", "prompt_id": "seed_000318", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕底部显示 \"Hello Phaser\" 文字，字体大小 32px\nAPI: Phaser.GameObjects.Text, Scene.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小 32px\n4. 将文本定位到屏幕底部中央位置\n[/PLAN]\n\n```javascript\n// Phaser3 配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本示例不需要预加载任何资源\n}\n\nfunction create() {\n  // 创建文本对象\n  const text = this.add.text(\n    400,  // x 坐标：屏幕中央\n    550,  // y 坐标：屏幕底部附近\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#ffffff'\n    }\n  );\n  \n  // 设置文本的原点为中心，使其居中对齐\n  text.setOrigin(0.5, 0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000227_v3", "prompt_id": "seed_000227", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形在1.5秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建一个 Sprite 使用该纹理，初始 alpha 设为 0（完全透明）\n3. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续 1.5 秒\n4. 设置 Tween 的 yoyo 和 repeat 参数实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建圆形精灵，放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'circle');\n  \n  // 设置初始透明度为 0（完全透明）\n  circle.setAlpha(0);\n\n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 1500,            // 持续时间 1.5 秒（1500 毫秒）\n    yoyo: true,                // 启用 yoyo 效果（到达终点后反向播放）\n    repeat: -1,                // 无限循环（-1 表示永久重复）\n    ease: 'Linear'             // 线性缓动函数，匀速变化\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000667_v1", "prompt_id": "seed_000667", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在2秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 实现缩放动画：scale 从 1 到 0.48 再到 1\n4. 设置 Tween 的 yoyo 和 loop 属性实现循环往返\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillEllipse(100, 75, 200, 150); // 中心点(100, 75)，宽200，高150\n  \n  // 生成纹理\n  graphics.generateTexture('ellipseTex', 200, 150);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建椭圆精灵，放置在屏幕中央\n  const ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: ellipse,\n    scaleX: 0.48,  // 缩放到 48%\n    scaleY: 0.48,\n    duration: 2000,  // 2秒\n    yoyo: true,      // 启用往返效果（缩小后恢复）\n    loop: -1,        // 无限循环（-1 表示永久循环）\n    ease: 'Linear'   // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆缩放动画 (48% ↔ 100%)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000466_v3", "prompt_id": "seed_000466", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 3 个红色敌人巡逻移动，在 160 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 3个红色敌人巡逻移动，在160速度下左右往返，玩家接近时追踪\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, Phaser.Physics.Arcade.Body\nSTEPS:\n1. 创建玩家精灵（蓝色方块），使用键盘控制移动\n2. 创建3个红色敌人精灵，添加到物理组中\n3. 为每个敌人设置初始巡逻方向和边界检测\n4. 在update中检测玩家与敌人距离，距离<150时切换为追踪模式\n5. 追踪模式下计算玩家方向并设置敌人速度，巡逻模式下左右往返\n6. 添加状态信号：enemiesPatrolling（巡逻敌人数）、enemiesChasing（追踪敌人数）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesPatrolling = 3;\n    this.enemiesChasing = 0;\n    this.detectionRange = 150;\n    this.patrolSpeed = 160;\n    this.chaseSpeed = 200;\n  }\n\n  preload() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    playerGraphics.fillStyle(0x0000ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（红色方块）\n    const enemyGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillRect(0, 0, 28, 28);\n    enemyGraphics.generateTexture('enemy', 28, 28);\n    enemyGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建3个敌人，分布在不同位置\n    const enemyPositions = [\n      { x: 150, y: 150, direction: 1 },\n      { x: 650, y: 300, direction: -1 },\n      { x: 400, y: 500, direction: 1 }\n    ];\n\n    enemyPositions.forEach(pos => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 自定义属性：巡逻方向和状态\n      enemy.patrolDirection = pos.direction;\n      enemy.isChasing = false;\n      enemy.patrolMinX = 50;\n      enemy.patrolMaxX = 750;\n      \n      // 设置初始巡逻速度\n      enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n    });\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-200);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(200);\n    }\n\n    // 重置计数器\n    this.enemiesPatrolling = 0;\n    this.enemiesChasing = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.children.entries.forEach(enemy => {\n      const distance = Phaser.Math.Distance.Between(\n        enemy.x, enemy.y,\n        this.player.x, this.player.y\n      );\n\n      // 判断是否应该追踪玩家\n      if (distance < this.detectionRange) {\n        // 追踪模式\n        if (!enemy.isChasing) {\n          enemy.isChasing = true;\n        }\n\n        // 计算追踪方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        // 设置追踪速度\n        enemy.setVelocity(\n          Math.cos(angle) * this.chaseSpeed,\n          Math.sin(angle) * this.chaseSpeed\n        );\n\n        this.enemiesChasing++;\n      } else {\n        // 巡逻模式\n        if (enemy.isChasing) {\n          enemy.isChasing = false;\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        // 巡逻边界检测和方向反转\n        if (enemy.x <= enemy.patrolMinX && enemy.patrolDirection === -1) {\n          enemy.patrolDirection = 1;\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        } else if (enemy.x >= enemy.patrolMaxX && enemy.patrolDirection === 1) {\n          enemy.patrolDirection = -1;\n          enemy.setVelocityX(this.patrolSpeed * enemy.patrolDirection);\n        }\n\n        this.enemiesPatrolling++;\n      }\n    });\n\n    // 更新状态文本\n    this.updateStatusText();\n  }\n\n  updateStatusText() {\n    this.statusText.setText([\n      `Patrolling Enemies: ${this.enemiesPatrolling}`,\n      `Chasing Enemies: ${this.enemiesChasing}`,\n      `Detection Range: ${this.detectionRange}px`,\n      '',\n      'Use Arrow Keys to Move'\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000901_v2", "prompt_id": "seed_000901", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制8个随机位置的红色菱形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制8个随机位置的红色菱形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环8次，每次创建一个 Graphics 对象\n3. 使用 Graphics API 绘制菱形路径（moveTo 到顶点，lineTo 连接四个顶点）\n4. 使用 fillStyle 设置红色，fillPath 填充菱形\n5. 使用 setRandomPosition 将每个菱形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建8个红色菱形\n  for (let i = 0; i < 8; i++) {\n    const graphics = this.add.graphics();\n    \n    // 设置红色填充\n    graphics.fillStyle(0xff0000, 1);\n    \n    // 绘制菱形（大小16像素，即从中心点到边缘8像素）\n    // 菱形的四个顶点：上、右、下、左\n    graphics.beginPath();\n    graphics.moveTo(0, -8);  // 上顶点\n    graphics.lineTo(8, 0);   // 右顶点\n    graphics.lineTo(0, 8);   // 下顶点\n    graphics.lineTo(-8, 0);  // 左顶点\n    graphics.closePath();\n    graphics.fillPath();\n    \n    // 设置随机位置（考虑菱形大小，避免超出边界）\n    const randomX = Phaser.Math.Between(8, 792);\n    const randomY = Phaser.Math.Between(8, 592);\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000551_v2", "prompt_id": "seed_000551", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 80 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形移动，速度 80 像素/秒\nAPI: this.add.graphics(), this.input.keyboard.addKeys(), graphics.fillStyle(), graphics.beginPath(), graphics.moveTo(), graphics.lineTo(), graphics.closePath(), graphics.fillPath()\nSTEPS:\n1. 创建 Graphics 对象绘制菱形形状\n2. 使用 addKeys 绑定 WASD 键盘输入\n3. 在 update 中检测按键状态，根据 delta 时间计算位移\n4. 更新菱形位置实现移动效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\n// 菱形对象\nlet diamond;\n// 键盘输入\nlet keys;\n// 移动速度（像素/秒）\nconst SPEED = 80;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建菱形 Graphics 对象\n  diamond = this.add.graphics();\n  diamond.x = 400;\n  diamond.y = 300;\n  \n  // 绘制菱形（中心点为原点）\n  diamond.fillStyle(0x00ff00, 1);\n  diamond.beginPath();\n  diamond.moveTo(0, -30);    // 上顶点\n  diamond.lineTo(25, 0);     // 右顶点\n  diamond.lineTo(0, 30);     // 下顶点\n  diamond.lineTo(-25, 0);    // 左顶点\n  diamond.closePath();\n  diamond.fillPath();\n  \n  // 绑定 WASD 键\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 将 delta 从毫秒转换为秒\n  const deltaSeconds = delta / 1000;\n  \n  // 计算本帧的移动距离\n  const moveDistance = SPEED * deltaSeconds;\n  \n  // 根据按键状态移动菱形\n  if (keys.w.isDown) {\n    diamond.y -= moveDistance;  // 向上移动\n  }\n  if (keys.s.isDown) {\n    diamond.y += moveDistance;  // 向下移动\n  }\n  if (keys.a.isDown) {\n    diamond.x -= moveDistance;  // 向左移动\n  }\n  if (keys.d.isDown) {\n    diamond.x += moveDistance;  // 向右移动\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000051_v2", "prompt_id": "seed_000051", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个红色椭圆，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个红色椭圆，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 设置填充样式为红色\n4. 使用 fillEllipse 在画布中央 (400, 300) 绘制椭圆，半径设为 16 像素\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为红色 (0xff0000)，透明度为 1\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 在画布中央 (400, 300) 绘制椭圆\n  // fillEllipse(x, y, width, height)\n  // x, y 是椭圆中心点坐标\n  // width 和 height 是椭圆的宽度和高度\n  graphics.fillEllipse(400, 300, 16, 16);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000477_v1", "prompt_id": "seed_000477", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左上移动的菱形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个自动向左上移动的菱形，相机跟随该对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.GameObject#setPosition\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 对象作为可移动的菱形\n3. 使用 Camera.startFollow 让相机跟随菱形对象\n4. 在 update 中让菱形持续向左上方移动（x减小，y减小）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nconst moveSpeed = 2; // 移动速度（像素/帧）\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个更大的世界边界，让菱形有足够的移动空间\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff6b6b, 1); // 红色菱形\n  graphics.lineStyle(3, 0xffffff, 1); // 白色边框\n  \n  // 绘制菱形（中心点为 32, 32）\n  const size = 32;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);      // 上顶点\n  graphics.lineTo(size * 2, size); // 右顶点\n  graphics.lineTo(size, size * 2); // 下顶点\n  graphics.lineTo(0, size);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamondTexture', size * 2, size * 2);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建菱形精灵，初始位置在场景中心\n  diamond = this.add.sprite(400, 300, 'diamondTexture');\n  \n  // 设置相机跟随菱形\n  this.cameras.main.startFollow(diamond, true, 0.1, 0.1);\n  \n  // 可选：设置相机跟随的偏移量（保持菱形在屏幕中心）\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 添加提示文字（固定在相机视图上）\n  const text = this.add.text(10, 10, '菱形自动向左上移动\\n相机跟随中...', {\n    fontSize: '18px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界移动\n  \n  // 添加位置信息文字\n  this.positionText = this.add.text(10, 80, '', {\n    fontSize: '14px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.positionText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让菱形向左上方移动\n  // 左上方：x 减小，y 减小\n  diamond.x -= moveSpeed;\n  diamond.y -= moveSpeed;\n  \n  // 更新位置信息显示\n  this.positionText.setText(\n    `菱形位置: (${Math.round(diamond.x)}, ${Math.round(diamond.y)})\\n` +\n    `相机位置: (${Math.round(this.cameras.main.scrollX)}, ${Math.round(this.cameras.main.scrollY)})`\n  );\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000179_v3", "prompt_id": "seed_000179", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8876190476190476}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让青色六边形在 1 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个青色六边形，使用 Tween 动画实现 1 秒闪烁循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制青色六边形并生成纹理\n2. 创建 Sprite 对象使用生成的六边形纹理\n3. 使用 Tween 动画控制 alpha 值在 0-1 之间循环变化，实现闪烁效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制六边形\n  const hexRadius = 60;\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建六边形 Sprite 并放置在屏幕中央\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 创建闪烁动画 - 使用 Tween 控制透明度\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 0,              // 目标透明度为 0（完全透明）\n    duration: 500,         // 淡出持续 0.5 秒\n    yoyo: true,            // 反向播放（淡入）\n    repeat: -1,            // 无限循环\n    ease: 'Sine.easeInOut' // 平滑的缓动函数\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000602_v1", "prompt_id": "seed_000602", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让青色三角形在 1 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建青色三角形，使用 Tween 实现 1 秒循环抖动动画效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Scene.tweens\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建使用该纹理的 Sprite 对象并居中显示\n3. 使用 tweens.add 创建抖动动画，通过快速改变 x 坐标实现抖动效果\n4. 设置 yoyo 和 loop 参数实现循环抖动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 创建青色三角形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(50, 10);  // 顶点\n  graphics.lineTo(10, 80);  // 左下\n  graphics.lineTo(90, 80);  // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 100, 90);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵并居中\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建抖动动画\n  this.tweens.add({\n    targets: triangle,\n    x: '+=10',  // 向右移动10像素\n    duration: 50,  // 快速移动（50毫秒）\n    yoyo: true,  // 返回原位\n    repeat: -1,  // 无限循环\n    ease: 'Linear',\n    // 通过 repeatDelay 控制每次抖动循环的间隔\n    // 一次完整抖动：50ms(去) + 50ms(回) = 100ms\n    // 要达到1秒一次循环，需要等待 900ms\n    repeatDelay: 900\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 500, '青色三角形每秒抖动一次', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000323_v3", "prompt_id": "seed_000323", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个橙色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色六边形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制橙色六边形并生成纹理\n2. 创建使用该纹理的 Sprite 对象，初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动，duration 为 2500ms\n4. 设置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xff8800, 1);\n  \n  // 绘制六边形（正六边形）\n  const hexRadius = 40;\n  const hexagonPath = [];\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = hexRadius + hexRadius * Math.cos(angle);\n    const y = hexRadius + hexRadius * Math.sin(angle);\n    hexagonPath.push(x, y);\n  }\n  \n  graphics.fillPoints(hexagonPath, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建使用六边形纹理的精灵\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右移动，然后往返循环\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 2500, // 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果\n    loop: -1 // 无限循环（-1 表示永久循环）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000691_v3", "prompt_id": "seed_000691", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色椭圆以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色椭圆以240速度移动并在画布边界反弹\nAPI: Graphics, arcade.physics, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制灰色椭圆并生成纹理\n2. 创建带物理属性的精灵对象\n3. 设置初始速度为240（x和y方向）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制灰色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  \n  // 绘制椭圆（中心点在 50, 30，宽度100，高度60）\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 100, 60);\n  graphics.destroy();\n  \n  // 创建物理精灵对象，位置在画布中心\n  const ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度为240（斜向移动）\n  ellipse.setVelocity(240, 240);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  ellipse.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  ellipse.setCollideWorldBounds(true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000637_v3", "prompt_id": "seed_000637", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左上显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左上显示 \"Hello Phaser\" 文字，字体大小 48px\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左上角，字体大小为 48px\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 代码\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 本任务无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕左上角创建文本对象\n  // 参数：x坐标, y坐标, 文本内容, 样式配置\n  this.add.text(20, 20, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n}\n\n// 创建并启动游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000763_v1", "prompt_id": "seed_000763", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个黄色矩形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现黄色矩形从左到右往返循环的补间动画\nAPI: this.add.graphics(), this.tweens.add(), Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制黄色矩形并生成纹理\n2. 创建 Sprite 对象作为动画目标\n3. 使用 tweens.add() 创建补间动画，设置 x 坐标从左到右\n4. 配置 yoyo 实现往返效果，loop: -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色矩形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  graphics.fillRect(0, 0, 60, 40); // 绘制 60x40 的矩形\n  \n  // 生成纹理\n  graphics.generateTexture('yellowRect', 60, 40);\n  graphics.destroy(); // 销毁 graphics 对象，节省资源\n  \n  // 创建精灵对象，初始位置在左侧\n  const rect = this.add.sprite(100, 300, 'yellowRect');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: rect,           // 动画目标\n    x: 700,                  // 移动到右侧（800 - 100 = 700）\n    duration: 1000,          // 持续时间 1 秒\n    ease: 'Linear',          // 线性缓动\n    yoyo: true,              // 往返效果（到达终点后反向播放）\n    loop: -1,                // 无限循环（-1 表示永久循环）\n    repeat: 0                // yoyo 模式下不需要额外的 repeat\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Yellow Rectangle Tween Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'The rectangle moves left to right and loops forever', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000305_v2", "prompt_id": "seed_000305", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色三角形以 300 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色三角形以300速度移动并在画布边界反弹\nAPI: Graphics, fillTriangle, setVelocity, setBounce, setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建带物理引擎的精灵对象，应用三角形纹理\n3. 设置初始速度为300，启用世界边界碰撞和反弹\n4. 配置 Arcade 物理引擎确保边界检测生效\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形（等边三角形）\n  graphics.fillTriangle(\n    30, 0,    // 顶点\n    0, 50,    // 左下\n    60, 50    // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 50);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度为300）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 300;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 300;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：让三角形根据移动方向旋转\n  this.physics.world.on('worldbounds', (body) => {\n    // 可以在这里添加边界碰撞的额外逻辑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000640_v2", "prompt_id": "seed_000640", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的黄色菱形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的黄色菱形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 使用 Graphics API 绘制菱形：从顶点开始，依次连接四个顶点（上、右、下、左）\n4. 使用 Math.random 为每个菱形生成随机位置（确保菱形完全在画布内）\n5. 设置黄色填充色（0xFFFF00）并填充路径\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const diamondSize = 48; // 菱形大小\n  const halfSize = diamondSize / 2; // 菱形半径\n  const diamondCount = 12; // 菱形数量\n  \n  // 绘制12个随机位置的黄色菱形\n  for (let i = 0; i < diamondCount; i++) {\n    // 生成随机位置，确保菱形完全在画布内\n    const x = halfSize + Math.random() * (config.width - diamondSize);\n    const y = halfSize + Math.random() * (config.height - diamondSize);\n    \n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置黄色填充\n    graphics.fillStyle(0xFFFF00, 1);\n    \n    // 绘制菱形路径\n    graphics.beginPath();\n    graphics.moveTo(x, y - halfSize); // 上顶点\n    graphics.lineTo(x + halfSize, y); // 右顶点\n    graphics.lineTo(x, y + halfSize); // 下顶点\n    graphics.lineTo(x - halfSize, y); // 左顶点\n    graphics.closePath();\n    \n    // 填充路径\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000626_v2", "prompt_id": "seed_000626", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 300 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 300 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillRect, Phaser.GameObjects.Graphics#setRotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象绘制矩形\n2. 在 create 中初始化矩形的位置和旋转角度\n3. 在 update 中根据 delta 时间累加旋转角度（300度/秒 = 300 * delta / 1000）\n4. 使用 setRotation 更新矩形旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet rectangle;\nlet currentRotation = 0;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  rectangle = this.add.graphics();\n  rectangle.fillStyle(0x00ff00, 1);\n  \n  // 以中心点为原点绘制矩形（便于旋转）\n  rectangle.fillRect(-75, -50, 150, 100);\n  \n  // 设置矩形位置到屏幕中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n  \n  // 初始化旋转角度\n  currentRotation = 0;\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量：300度/秒 * (delta毫秒 / 1000)\n  // 转换为弧度：度数 * Math.PI / 180\n  const rotationSpeed = 300; // 度/秒\n  const rotationDelta = (rotationSpeed * delta / 1000) * (Math.PI / 180);\n  \n  // 累加旋转角度\n  currentRotation += rotationDelta;\n  \n  // 应用旋转\n  rectangle.setRotation(currentRotation);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000310_v1", "prompt_id": "seed_000310", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的白色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的白色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环20次，每次创建一个 Graphics 对象\n3. 使用三角函数计算六边形的6个顶点坐标（半径32像素）\n4. 为每个 Graphics 设置随机位置并绘制白色填充的六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制20个随机位置的白色六边形\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置随机位置（留出边距避免六边形被裁切）\n    const x = Phaser.Math.Between(64, 736);\n    const y = Phaser.Math.Between(64, 536);\n    graphics.setPosition(x, y);\n    \n    // 设置白色填充\n    graphics.fillStyle(0xffffff, 1);\n    \n    // 绘制六边形（大小64像素，半径32像素）\n    const radius = 32;\n    const sides = 6;\n    \n    graphics.beginPath();\n    \n    // 计算六边形的6个顶点\n    for (let j = 0; j < sides; j++) {\n      const angle = (Math.PI / 3) * j - Math.PI / 2; // 从顶部开始，每60度一个顶点\n      const px = Math.cos(angle) * radius;\n      const py = Math.sin(angle) * radius;\n      \n      if (j === 0) {\n        graphics.moveTo(px, py);\n      } else {\n        graphics.lineTo(px, py);\n      }\n    }\n    \n    graphics.closePath();\n    graphics.fillPath();\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000363_v1", "prompt_id": "seed_000363", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向上移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向上移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Phaser.Scene.cameras\nSTEPS:\n1. 创建场景配置，设置足够大的世界边界以容纳移动空间\n2. 使用 Graphics 绘制星形或使用内置 Star 几何体\n3. 在 create 中创建星形对象并设置初始位置\n4. 使用 camera.startFollow() 让相机跟随星形对象\n5. 在 update 中让星形持续向上移动\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.star = null;\n    this.speed = 100; // 每秒向上移动的像素数\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 设置世界边界，让世界比相机视图大很多\n    this.cameras.main.setBounds(0, 0, 800, 3000);\n    this.physics.world.setBounds(0, 0, 800, 3000);\n\n    // 创建星形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffff00, 1); // 黄色\n    graphics.lineStyle(2, 0xff6600, 1); // 橙色边框\n    \n    // 绘制星形\n    const points = 5;\n    const outerRadius = 30;\n    const innerRadius = 15;\n    const centerX = 40;\n    const centerY = 40;\n    \n    graphics.beginPath();\n    for (let i = 0; i < points * 2; i++) {\n      const angle = (i * Math.PI) / points - Math.PI / 2;\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n      \n      if (i === 0) {\n        graphics.moveTo(x, y);\n      } else {\n        graphics.lineTo(x, y);\n      }\n    }\n    graphics.closePath();\n    graphics.fillPath();\n    graphics.strokePath();\n    \n    // 生成纹理\n    graphics.generateTexture('star', 80, 80);\n    graphics.destroy();\n\n    // 创建星形精灵，初始位置在底部中央\n    this.star = this.add.sprite(400, 2800, 'star');\n    \n    // 设置相机跟随星形，保持居中\n    this.cameras.main.startFollow(this.star, true, 0.1, 0.1);\n    \n    // 可选：设置相机跟随的偏移量（这里设置为0,0表示居中）\n    this.cameras.main.setFollowOffset(0, 0);\n\n    // 添加背景网格以便观察移动效果\n    this.createBackgroundGrid();\n\n    // 添加提示文本（固定在相机上）\n    const text = this.add.text(10, 10, '星形自动向上移动\\n相机跟随并保持居中', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    text.setScrollFactor(0); // 固定在相机上，不随世界移动\n  }\n\n  update(time, delta) {\n    // 让星形持续向上移动\n    if (this.star) {\n      this.star.y -= (this.speed * delta) / 1000;\n      \n      // 如果星形移动到世界顶部，重置到底部\n      if (this.star.y < 50) {\n        this.star.y = 2950;\n      }\n    }\n  }\n\n  createBackgroundGrid() {\n    // 创建网格背景以便观察相机移动\n    const gridGraphics = this.add.graphics();\n    gridGraphics.lineStyle(1, 0x333333, 0.5);\n    \n    const gridSize = 100;\n    const worldHeight = 3000;\n    const worldWidth = 800;\n    \n    // 绘制垂直线\n    for (let x = 0; x <= worldWidth; x += gridSize) {\n      gridGraphics.lineBetween(x, 0, x, worldHeight);\n    }\n    \n    // 绘制水平线\n    for (let y = 0; y <= worldHeight; y += gridSize) {\n      gridGraphics.lineBetween(0, y, worldWidth, y);\n    }\n    \n    // 添加坐标标记\n    for (let y = 0; y <= worldHeight; y += 200) {\n      const label = this.add.text(10, y, `Y: ${y}`, {\n        fontSize: '14px',\n        fill: '#666666'\n      });\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  scene: GameScene,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  }\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000497_v1", "prompt_id": "seed_000497", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8737500000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 1.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.alpha\nSTEPS:\n1. 创建一个 Graphics 对象绘制椭圆形状\n2. 将椭圆的初始 alpha 值设置为 0（完全透明）\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续时间 1.5 秒\n4. 设置 Tween 的 yoyo 为 true 实现往返效果，repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload,\n    create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为蓝色\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制椭圆（中心点在画布中央，宽度 200，高度 120）\n  graphics.fillEllipse(400, 300, 200, 120);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.alpha = 0;\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1,                // 目标透明度为 1（完全不透明）\n    duration: 1500,          // 持续时间 1.5 秒\n    ease: 'Linear',          // 线性缓动\n    yoyo: true,              // 往返播放（1->0->1）\n    repeat: -1               // 无限循环\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '椭圆透明度循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000346_v3", "prompt_id": "seed_000346", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的紫色六边形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在随机位置绘制3个紫色六边形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置 800x600 画布\n2. 在 create 方法中创建 Graphics 对象\n3. 编写绘制六边形的辅助函数，计算六边形的6个顶点坐标\n4. 循环3次，每次生成随机位置坐标，绘制紫色六边形\n5. 使用 fillStyle 设置紫色，使用 beginPath/moveTo/lineTo/closePath/fillPath 绘制填充六边形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x9966ff, 1);\n  \n  // 绘制3个随机位置的六边形\n  for (let i = 0; i < 3; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    const x = Phaser.Math.Between(64, 800 - 64);\n    const y = Phaser.Math.Between(64, 600 - 64);\n    \n    // 绘制六边形\n    drawHexagon(graphics, x, y, 32); // 半径32，直径64\n  }\n}\n\n/**\n * 绘制正六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} radius - 六边形半径（中心到顶点的距离）\n */\nfunction drawHexagon(graphics, x, y, radius) {\n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点\n  // 从顶部开始，顺时针绘制（角度从-90度开始）\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 每个顶点间隔60度\n    const vx = x + radius * Math.cos(angle);\n    const vy = y + radius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vx, vy);\n    } else {\n      graphics.lineTo(vx, vy);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000647_v2", "prompt_id": "seed_000647", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9024999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个黄色圆形，大小约为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个黄色圆形，直径24像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 设置填充样式为黄色（0xffff00）\n4. 使用 fillCircle 在画布中央（400, 300）绘制半径为 12 的圆形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制形状\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  graphics.fillStyle(0xffff00, 1);\n  \n  // 在画布中央绘制圆形\n  // 画布尺寸为 800x600，中心点为 (400, 300)\n  // 圆形大小为 24 像素，半径为 12\n  graphics.fillCircle(400, 300, 12);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000762_v3", "prompt_id": "seed_000762", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右侧显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser 游戏配置，设置画布宽高\n2. 在 create 生命周期中使用 this.add.text 创建文字对象\n3. 设置文字内容为 \"Hello Phaser\"，字体大小 48px\n4. 将文字定位到屏幕右侧，使用 setOrigin 调整对齐方式\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕右侧显示文字\n  // x 坐标设置为 750（距离右边缘 50 像素）\n  // y 坐标设置为屏幕中央\n  const text = this.add.text(750, 300, 'Hello Phaser', {\n    fontSize: '48px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文字原点为右中，使其右对齐\n  text.setOrigin(1, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000101_v1", "prompt_id": "seed_000101", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现黄色角色状态切换：按下不同按键切换 idle/run 状态，通过 tween 或帧动画体现差异。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现黄色角色按键切换 idle/run 状态，通过 tween 和帧动画体现差异\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.Tweens, Phaser.Animations, Phaser.GameObjects.Sprite\nSTEPS:\n1. 使用 Graphics 创建黄色角色纹理（idle 和 run 两种状态的帧）\n2. 创建帧动画（idle 动画：轻微上下浮动，run 动画：快速左右晃动）\n3. 监听键盘输入（I 键切换 idle，R 键切换 run）\n4. 根据状态播放对应动画，并用 tween 实现额外的缩放/旋转效果\n5. 显示当前状态文本作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.currentState = 'idle'; // 可验证的状态信号\n    this.stateChangeCount = 0; // 状态切换次数\n  }\n\n  preload() {\n    // 创建黄色角色的纹理帧\n    this.createCharacterTextures();\n  }\n\n  createCharacterTextures() {\n    const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    \n    // 创建 idle 状态的 4 帧（轻微变化）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      \n      // 身体（黄色矩形，高度略有变化）\n      const bodyHeight = 60 + Math.sin(i * Math.PI / 2) * 5;\n      graphics.fillStyle(0xFFD700, 1);\n      graphics.fillRect(20, 70 - bodyHeight, 40, bodyHeight);\n      \n      // 头部（黄色圆形）\n      graphics.fillStyle(0xFFDD00, 1);\n      graphics.fillCircle(40, 15, 15);\n      \n      // 眼睛\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(35, 13, 3);\n      graphics.fillCircle(45, 13, 3);\n      \n      // 嘴巴（微笑）\n      graphics.lineStyle(2, 0x000000, 1);\n      graphics.beginPath();\n      graphics.arc(40, 15, 8, 0.2, Math.PI - 0.2);\n      graphics.strokePath();\n      \n      graphics.generateTexture(`idle_${i}`, 80, 80);\n    }\n    \n    // 创建 run 状态的 4 帧（明显的左右倾斜）\n    for (let i = 0; i < 4; i++) {\n      graphics.clear();\n      \n      const tilt = Math.sin(i * Math.PI / 2) * 10; // 左右倾斜\n      \n      // 身体（倾斜的矩形）\n      graphics.fillStyle(0xFFD700, 1);\n      graphics.save();\n      graphics.translateCanvas(40, 40);\n      graphics.rotateCanvas(tilt * Math.PI / 180);\n      graphics.fillRect(-20, -30, 40, 60);\n      graphics.restore();\n      \n      // 头部（跟随倾斜）\n      graphics.fillStyle(0xFFDD00, 1);\n      graphics.fillCircle(40 + tilt * 0.5, 15, 15);\n      \n      // 眼睛（兴奋的表情）\n      graphics.fillStyle(0x000000, 1);\n      graphics.fillCircle(35 + tilt * 0.5, 13, 4);\n      graphics.fillCircle(45 + tilt * 0.5, 13, 4);\n      \n      // 嘴巴（张开）\n      graphics.fillStyle(0xFF0000, 1);\n      graphics.fillCircle(40 + tilt * 0.5, 18, 5);\n      \n      // 运动线条\n      graphics.lineStyle(3, 0xFFFFFF, 0.6);\n      graphics.lineBetween(10, 40, 25, 40);\n      graphics.lineBetween(55, 40, 70, 40);\n      \n      graphics.generateTexture(`run_${i}`, 80, 80);\n    }\n    \n    graphics.destroy();\n  }\n\n  create() {\n    // 创建背景\n    const bg = this.add.graphics();\n    bg.fillStyle(0x87CEEB, 1);\n    bg.fillRect(0, 0, 800, 600);\n    \n    // 创建地面\n    const ground = this.add.graphics();\n    ground.fillStyle(0x90EE90, 1);\n    ground.fillRect(0, 500, 800, 100);\n    \n    // 创建角色精灵\n    this.player = this.add.sprite(400, 450, 'idle_0');\n    this.player.setScale(2);\n    \n    // 创建 idle 动画\n    this.anims.create({\n      key: 'idle',\n      frames: [\n        { key: 'idle_0' },\n        { key: 'idle_1' },\n        { key: 'idle_2' },\n        { key: 'idle_3' }\n      ],\n      frameRate: 4,\n      repeat: -1,\n      yoyo: true\n    });\n    \n    // 创建 run 动画\n    this.anims.create({\n      key: 'run',\n      frames: [\n        { key: 'run_0' },\n        { key: 'run_1' },\n        { key: 'run_2' },\n        { key: 'run_3' }\n      ],\n      frameRate: 10,\n      repeat: -1\n    });\n    \n    // 播放初始动画\n    this.player.play('idle');\n    \n    // 添加 idle 状态的浮动 tween\n    this.idleTween = this.tweens.add({\n      targets: this.player,\n      y: 440,\n      duration: 1000,\n      ease: 'Sine.easeInOut',\n      yoyo: true,\n      repeat: -1\n    });\n    \n    // 创建状态显示文本\n    this.stateText = this.add.text(400, 100, 'State: IDLE', {\n      fontSize: '32px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 20, y: 10 }\n    });\n    this.stateText.setOrigin(0.5);\n    \n    // 创建计数器文本\n    this.counterText = this.add.text(400, 150, 'State Changes: 0', {\n      fontSize: '24px',\n      fontFamily: 'Arial',\n      color: '#ffffff',\n      backgroundColor: '#333333',\n      padding: { x: 15, y: 8 }\n    });\n    this.counterText.setOrigin(0.5);\n    \n    // 创建提示文本\n    this.add.text(400, 550, 'Press [I] for IDLE | Press [R] for RUN', {\n      fontSize: '20px',\n      fontFamily: 'Arial',\n      color: '#000000',\n      backgroundColor: '#ffffff',\n      padding: { x: 15, y: 8 }\n    }).setOrigin(0.5);\n    \n    // 设置键盘输入\n    this.keyI = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);\n    this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);\n    \n    // 监听按键事件\n    this.keyI.on('down', () => this.switchState('idle'));\n    this.keyR.on('down', () => this.switchState('run'));\n  }\n\n  switchState(newState) {\n    if (this.currentState === newState) return;\n    \n    this.currentState = newState;\n    this.stateChangeCount++;\n    \n    // 更新文本\n    this.stateText.setText(`State: ${newState.toUpperCase()}`);\n    this.counterText.setText(`State Changes: ${this.stateChangeCount}`);\n    \n    // 停止所有 tweens\n    this.tweens.killTweensOf(this.player);\n    \n    if (newState === 'idle') {\n      // 切换到 idle 动画\n      this.player.play('idle');\n      \n      // 重置位置和缩放\n      this.tweens.add({\n        targets: this.player,\n        y: 450,\n        scaleX: 2,\n        scaleY: 2,\n        duration: 300,\n        ease: 'Back.easeOut'\n      });\n      \n      // 添加浮动效果\n      this.tweens.add({\n        targets: this.player,\n        y: 440,\n        duration: 1000,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1,\n        delay: 300\n      });\n      \n      // 状态文本颜色变化\n      this.tweens.add({\n        targets: this.stateText,\n        alpha: 0.7,\n        duration: 200,\n        yoyo: true\n      });\n      \n    } else if (newState === 'run') {\n      // 切换到 run 动画\n      this.player.play('run');\n      \n      // 缩放变化（跑步时略大）\n      this.tweens.add({\n        targets: this.player,\n        scaleX: 2.3,\n        scaleY: 2.3,\n        duration: 200,\n        ease: 'Back.easeOut'\n      });\n      \n      // 快速左右移动\n      this.tweens.add({\n        targets: this.player,\n        x: 450,\n        duration: 500,\n        ease: 'Sine.easeInOut',\n        yoyo: true,\n        repeat: -1\n      });\n      \n      // 轻微跳跃\n      this.tweens.add({\n        targets: this.player,\n        y: 430,\n        duration: 250,\n        ease: 'Quad.easeOut',\n        yoyo: true,\n        repeat: -1\n      });\n      \n      // 状态文本闪烁\n      this.tweens.add({\n        targets: this.stateText,\n        alpha: 0.5,\n        duration: 150,\n        yoyo: true,\n        repeat: -1\n      });\n    }\n    \n    // 播放切换音效（视觉反馈）\n    this.cameras.main.shake(100, 0.002);\n  }\n\n  update(time, delta) {\n    // 可以在这里添加额外的更新逻辑\n    // 例如：根据状态改变背景颜色\n    if (this.currentState === 'run' && Math.floor(time / 100) % 2 === 0) {\n      // 跑步时背景略微闪烁\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#000000',\n  scene: GameScene,\n  pixelArt: false,\n  antialias: true\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000898_v3", "prompt_id": "seed_000898", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Animations", "Input"], "quality_score": 0.95}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：5 个青色小球以 200 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 5个青色小球以200速度在封闭空间内移动，碰到边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Group, Body.setBounce, Body.setCollideWorldBounds, Physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，启用世界边界\n2. 使用 Graphics 创建青色圆形纹理\n3. 创建物理精灵组，添加5个小球并设置随机初始速度\n4. 设置小球与世界边界碰撞反弹（bounce=1）\n5. 添加小球之间的碰撞检测，实现弹性碰撞\n6. 添加碰撞计数器作为可验证状态信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 可验证的状态信号\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建青色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x00ffff, 1); // 青色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('ball', 32, 32);\n    graphics.destroy();\n\n    // 创建物理精灵组\n    this.balls = this.physics.add.group({\n      key: 'ball',\n      repeat: 4, // 创建5个小球（1个默认 + 4个重复）\n      setXY: { \n        x: 100, \n        y: 100, \n        stepX: 150 // 横向间隔分布\n      }\n    });\n\n    // 配置每个小球\n    this.balls.children.iterate((ball, index) => {\n      // 设置随机速度（200左右的速度）\n      const angle = Phaser.Math.Between(0, 360);\n      const speed = 200;\n      this.physics.velocityFromAngle(angle, speed, ball.body.velocity);\n\n      // 设置碰撞属性\n      ball.setCollideWorldBounds(true); // 与世界边界碰撞\n      ball.setBounce(1); // 完全弹性碰撞（bounce=1）\n      ball.body.setCircle(16); // 设置圆形碰撞体\n      \n      // 设置阻力为0，保持恒定速度\n      ball.body.setDamping(false);\n      ball.body.setDrag(0);\n    });\n\n    // 添加小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.handleBallCollision, null, this);\n\n    // 显示碰撞计数\n    this.collisionText = this.add.text(16, 16, 'Collisions: 0', {\n      fontSize: '24px',\n      color: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示说明\n    this.add.text(16, 560, '5个青色小球在封闭空间内弹性碰撞', {\n      fontSize: '18px',\n      color: '#00ffff'\n    });\n  }\n\n  handleBallCollision(ball1, ball2) {\n    // 碰撞回调：增加碰撞计数\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n  }\n\n  update(time, delta) {\n    // 确保小球速度保持在200左右\n    this.balls.children.iterate((ball) => {\n      const velocity = ball.body.velocity;\n      const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n      \n      // 如果速度偏离200太多，进行修正\n      if (Math.abs(currentSpeed - 200) > 10) {\n        const scale = 200 / currentSpeed;\n        ball.body.velocity.x *= scale;\n        ball.body.velocity.y *= scale;\n      }\n    });\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#1a1a2e',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000895_v3", "prompt_id": "seed_000895", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9066666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制3个随机位置的橙色圆形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制3个随机位置的橙色圆形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillCircle, Graphics#setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中使用 Graphics 对象绘制橙色圆形\n3. 使用循环创建3个 Graphics 对象，每个绘制半径为8的圆形（直径16像素）\n4. 使用 setRandomPosition 方法为每个圆形设置随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 橙色的十六进制颜色值\n  const orangeColor = 0xFFA500;\n  \n  // 圆形半径（直径16像素，半径为8像素）\n  const radius = 8;\n  \n  // 创建3个随机位置的橙色圆形\n  for (let i = 0; i < 3; i++) {\n    // 创建 Graphics 对象\n    const circle = this.add.graphics();\n    \n    // 设置填充颜色为橙色\n    circle.fillStyle(orangeColor, 1);\n    \n    // 绘制圆形（圆心在原点）\n    circle.fillCircle(0, 0, radius);\n    \n    // 设置随机位置（考虑边界，避免圆形被裁剪）\n    const randomX = Phaser.Math.Between(radius, config.width - radius);\n    const randomY = Phaser.Math.Between(radius, config.height - radius);\n    circle.setPosition(randomX, randomY);\n  }\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000747_v2", "prompt_id": "seed_000747", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 0.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.GameObjects.GameObject#setAlpha\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建使用该纹理的精灵对象\n3. 设置初始透明度为 0（完全透明）\n4. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续 0.5 秒\n5. 设置 Tween 为循环播放（yoyo + repeat -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制菱形（使用四个点构成的多边形）\n  const size = 80;\n  const centerX = size;\n  const centerY = size;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size); // 上顶点\n  graphics.lineTo(centerX + size, centerY); // 右顶点\n  graphics.lineTo(centerX, centerY + size); // 下顶点\n  graphics.lineTo(centerX - size, centerY); // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建使用菱形纹理的精灵\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0\n  diamond.setAlpha(0);\n  \n  // 创建渐变动画\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 500, // 持续时间 0.5 秒\n    yoyo: true, // 来回播放（从 0 到 1 再从 1 到 0）\n    repeat: -1, // 无限循环\n    ease: 'Linear' // 线性渐变\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000435_v3", "prompt_id": "seed_000435", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 0.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建使用该纹理的 Sprite 对象，初始 alpha 设为 0\n3. 使用 Tween 动画让 alpha 从 0 到 1，持续 500ms，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（四个顶点）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建使用菱形纹理的精灵，放置在屏幕中心\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 500,               // 持续时间 0.5 秒\n    ease: 'Linear',              // 线性缓动\n    yoyo: true,                  // 反向播放（从 1 回到 0）\n    repeat: -1                   // 无限循环\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000435_v1", "prompt_id": "seed_000435", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的绿色星形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 绘制 15 个随机位置的绿色星形，每个大小为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Scene 配置，设置画布大小为 800x600\n2. 在 create 方法中创建一个绘制星形的辅助函数\n3. 使用循环生成 15 个随机位置坐标\n4. 在每个位置使用 Graphics 绘制绿色星形（5 个尖角）\n5. 确保星形大小为 32 像素（外半径 16，内半径 8）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制星形的辅助函数\n  const drawStar = (graphics, cx, cy, spikes, outerRadius, innerRadius) => {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    const step = Math.PI / spikes;\n\n    graphics.beginPath();\n    graphics.moveTo(cx, cy - outerRadius);\n\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      graphics.lineTo(x, y);\n      rot += step;\n    }\n\n    graphics.lineTo(cx, cy - outerRadius);\n    graphics.closePath();\n    graphics.fillPath();\n  };\n\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色填充\n\n  // 绘制 15 个随机位置的星形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机位置（确保星形完全在画布内）\n    const x = Phaser.Math.Between(32, 800 - 32);\n    const y = Phaser.Math.Between(32, 600 - 32);\n    \n    // 绘制星形：5个尖角，外半径16，内半径8（总大小约32像素）\n    drawStar(graphics, x, y, 5, 16, 8);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000357_v1", "prompt_id": "seed_000357", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9042857142857141}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制15个随机位置的绿色矩形，每个大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制15个随机位置的绿色矩形，每个大小为48像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillRect, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 使用循环15次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置绿色，fillRect 绘制 48x48 的矩形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制矩形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充样式\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制15个随机位置的矩形\n  for (let i = 0; i < 15; i++) {\n    // 生成随机位置，确保矩形完全在画布内\n    // x 范围: 0 到 (800 - 48)\n    // y 范围: 0 到 (600 - 48)\n    const x = Phaser.Math.Between(0, config.width - 48);\n    const y = Phaser.Math.Between(0, config.height - 48);\n    \n    // 绘制 48x48 的矩形\n    graphics.fillRect(x, y, 48, 48);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000225_v1", "prompt_id": "seed_000225", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个星形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillStyle, Phaser.GameObjects.Graphics#fillPoints, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个星形\n2. 在 update 中根据 delta 时间增量更新星形的 rotation 属性\n3. 将角速度设置为每秒 200 度（转换为弧度：200 * Math.PI / 180）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建星形图形对象\n  const star = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  star.fillStyle(0xffff00, 1);\n  \n  // 生成星形的顶点坐标\n  const starPoints = createStarPoints(0, 0, 5, 80, 40);\n  \n  // 填充星形路径\n  star.fillPoints(starPoints, true);\n  \n  // 将星形移动到屏幕中心\n  star.x = 400;\n  star.y = 300;\n  \n  // 将星形对象保存到场景数据中，以便在 update 中访问\n  this.star = star;\n  \n  // 添加文字说明\n  this.add.text(10, 10, '星形旋转速度: 200°/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧应旋转的角度（弧度）\n  // delta 是以毫秒为单位，转换为秒：delta / 1000\n  // 200 度转换为弧度：200 * Math.PI / 180\n  const rotationSpeed = 200 * Math.PI / 180; // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 更新星形的旋转角度\n  this.star.rotation += rotationDelta;\n}\n\n/**\n * 生成星形的顶点坐标\n * @param {number} cx - 中心 x 坐标\n * @param {number} cy - 中心 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n * @returns {Phaser.Geom.Point[]} 星形顶点数组\n */\nfunction createStarPoints(cx, cy, spikes, outerRadius, innerRadius) {\n  const points = [];\n  const step = Math.PI / spikes;\n  \n  for (let i = 0; i < spikes * 2; i++) {\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    const angle = i * step - Math.PI / 2; // 从顶部开始\n    const x = cx + Math.cos(angle) * radius;\n    const y = cy + Math.sin(angle) * radius;\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  return points;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000241_v2", "prompt_id": "seed_000241", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 160 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Scene.update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形，并在圆形上添加一个标记（如矩形）以便观察旋转\n2. 将 Graphics 对象添加到 Container 中，利用 Container 的 rotation 属性实现旋转\n3. 在 update 方法中根据 delta 时间增量计算旋转角度（160度/秒 = Phaser.Math.DegToRad(160) 弧度/秒）\n4. 每帧更新 Container 的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet rotatingContainer;\nconst ROTATION_SPEED = Phaser.Math.DegToRad(160); // 每秒 160 度转换为弧度\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个容器用于旋转\n  rotatingContainer = this.add.container(400, 300);\n  \n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制主圆形（蓝色）\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一个标记矩形，用于观察旋转效果（红色）\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillRect(0, -10, 60, 20);\n  \n  // 绘制圆形边框\n  graphics.lineStyle(3, 0xffffff, 1);\n  graphics.strokeCircle(0, 0, 80);\n  \n  // 将 graphics 添加到容器中\n  rotatingContainer.add(graphics);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形旋转速度: 160°/秒', {\n    fontSize: '24px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '红色矩形标记用于观察旋转效果', {\n    fontSize: '18px',\n    color: '#cccccc',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的时间增量\n  // 将其转换为秒并乘以旋转速度\n  const deltaInSeconds = delta / 1000;\n  rotatingContainer.rotation += ROTATION_SPEED * deltaInSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000492_v3", "prompt_id": "seed_000492", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让粉色菱形在 1.5 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色菱形弹跳动画，1.5秒循环一次\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Math.Easing.Bounce\nSTEPS:\n1. 使用 Graphics 绘制粉色菱形并生成纹理\n2. 创建 Sprite 对象使用菱形纹理\n3. 使用 Tween 创建 y 轴弹跳动画，设置 1.5 秒循环，应用 Bounce 缓动函数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建粉色菱形图形\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制菱形（使用四个点构成菱形）\n  const size = 40;\n  graphics.beginPath();\n  graphics.moveTo(size, 0);           // 顶点\n  graphics.lineTo(size * 2, size);    // 右点\n  graphics.lineTo(size, size * 2);    // 底点\n  graphics.lineTo(0, size);           // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', size * 2, size * 2);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中央偏上位置\n  const diamond = this.add.sprite(400, 200, 'diamond');\n  \n  // 创建弹跳动画\n  // 从初始位置向下弹跳 200 像素，然后返回\n  this.tweens.add({\n    targets: diamond,\n    y: 400,                           // 目标 y 坐标（向下移动 200 像素）\n    duration: 750,                    // 下落时间 0.75 秒\n    ease: 'Bounce.easeOut',           // 弹跳缓动效果（落地时弹跳）\n    yoyo: true,                       // 返回原位置\n    repeat: -1,                       // 无限循环\n    repeatDelay: 0                    // 无延迟\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, 'Pink Diamond Bouncing Animation', {\n    fontSize: '24px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 540, '1.5s loop cycle', {\n    fontSize: '16px',\n    color: '#aaaaaa',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000333_v3", "prompt_id": "seed_000333", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色六边形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色六边形以200速度移动并在画布边界反弹\nAPI: Graphics.fillStyle, Graphics.fillPolygon, Physics.Arcade.Sprite, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建物理引擎配置，启用 arcade 物理系统\n2. 使用 Graphics 绘制绿色六边形并生成纹理\n3. 创建物理精灵并应用六边形纹理\n4. 设置精灵速度为200（x和y方向各141.4，合成速度约200）\n5. 启用世界边界碰撞和反弹系数为1实现完美反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 计算六边形的顶点（半径为30）\n  const radius = 30;\n  const hexagonPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个顶点间隔60度\n    const x = radius + radius * Math.cos(angle);\n    const y = radius + radius * Math.sin(angle);\n    hexagonPoints.push(x, y);\n  }\n  \n  // 绘制六边形\n  graphics.fillPolygon(hexagonPoints);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', radius * 2, radius * 2);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置速度（200速度，分解为x和y方向）\n  // 使用45度角，速度分量为 200/√2 ≈ 141.4\n  const speed = 200 / Math.sqrt(2);\n  hexagon.setVelocity(speed, speed);\n  \n  // 设置反弹系数为1（完美弹性碰撞）\n  hexagon.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  hexagon.setCollideWorldBounds(true);\n  \n  // 添加说明文字\n  this.add.text(10, 10, '绿色六边形以200速度移动\\n碰到边界时反弹', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000710_v2", "prompt_id": "seed_000710", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个弹跳动画效果：让蓝色圆形在 2 秒内完成一次弹跳，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个蓝色圆形在2秒内完成弹跳循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制蓝色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 实现 y 轴弹跳动画，配置 ease 为 'Bounce.easeOut'\n4. 设置 Tween 为循环模式，duration 为 2000ms\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建蓝色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x0088ff, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('blueCircle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建蓝色圆形精灵\n  const circle = this.add.sprite(400, 200, 'blueCircle');\n  \n  // 添加地面参考线（可选，用于视觉效果）\n  const ground = this.add.graphics();\n  ground.lineStyle(2, 0xffffff, 0.3);\n  ground.lineBetween(0, 500, 800, 500);\n  \n  // 创建弹跳动画\n  // 使用 yoyo 实现上升和下降，配合 Bounce.easeOut 实现弹跳效果\n  this.tweens.add({\n    targets: circle,\n    y: 475, // 弹跳到地面位置（500 - 圆形半径25）\n    duration: 1000, // 下落时间1秒\n    ease: 'Bounce.easeOut', // 弹跳缓动效果\n    yoyo: true, // 往返运动\n    repeat: -1, // 无限循环\n    hold: 0, // 到达底部后立即返回\n    repeatDelay: 0 // 循环之间无延迟\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '弹跳动画循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '2秒完成一次完整弹跳循环', {\n    fontSize: '16px',\n    color: '#888888'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000594_v1", "prompt_id": "seed_000594", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的粉色菱形，每个大小为 24 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的粉色菱形，每个大小为24像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#fillPath, Phaser.Geom.Polygon, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser Game 配置，设置场景宽高\n2. 在 create 方法中循环10次\n3. 每次循环创建一个 Graphics 对象\n4. 使用 fillStyle 设置粉色填充\n5. 使用 Polygon 定义菱形路径（4个顶点），大小为24像素\n6. 使用 fillPath 填充菱形\n7. 使用 Math.Between 生成随机位置坐标\n8. 将 Graphics 对象定位到随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 绘制10个随机位置的粉色菱形\n  for (let i = 0; i < 10; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充 (FFC0CB 是粉色的十六进制值)\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 定义菱形的4个顶点（大小为24像素）\n    // 菱形中心在原点，向上下左右各延伸12像素\n    const diamond = new Phaser.Geom.Polygon([\n      0, -12,    // 顶部顶点\n      12, 0,     // 右侧顶点\n      0, 12,     // 底部顶点\n      -12, 0     // 左侧顶点\n    ]);\n    \n    // 填充菱形路径\n    graphics.fillPoints(diamond.points, true);\n    \n    // 生成随机位置（留出边距，避免菱形超出画布）\n    const randomX = Phaser.Math.Between(20, 780);\n    const randomY = Phaser.Math.Between(20, 580);\n    \n    // 设置 Graphics 对象位置\n    graphics.setPosition(randomX, randomY);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000543_v3", "prompt_id": "seed_000543", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色三角形在 0.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色三角形在0.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色三角形并生成纹理\n2. 创建 Sprite 对象并设置初始位置在左侧\n3. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo: true 实现往返效果，loop: -1 实现无限循环\n5. 设置 duration: 500 实现0.5秒移动时间\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 绘制白色三角形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置白色填充\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(30, 0);      // 顶点\n  graphics.lineTo(60, 52);     // 右下角\n  graphics.lineTo(0, 52);      // 左下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 52);\n  \n  // 销毁 graphics 对象，因为纹理已生成\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建三角形精灵\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: triangle,           // 动画目标对象\n    x: 700,                      // 目标 x 坐标（右侧）\n    duration: 500,               // 持续时间 0.5 秒\n    yoyo: true,                  // 往返效果（到达目标后反向播放）\n    loop: -1,                    // 无限循环（-1 表示永久循环）\n    ease: 'Linear'               // 线性缓动，匀速移动\n  });\n  \n  // 添加说明文字\n  this.add.text(10, 10, 'White triangle moving left-right in 0.5s loop', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000793_v2", "prompt_id": "seed_000793", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个抖动动画效果：让橙色椭圆在 2 秒内完成一次抖动，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色椭圆，使用 Tween 实现 2 秒抖动循环动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.GameObject.setPosition\nSTEPS:\n1. 使用 Graphics 绘制橙色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 Tween 创建抖动效果（快速左右/上下微小位移）\n4. 设置 Tween 循环播放，持续时间 2 秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillEllipse(50, 40, 100, 80); // 绘制椭圆（中心点，宽度，高度）\n  \n  // 生成纹理\n  graphics.generateTexture('orangeEllipse', 100, 80);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成纹理\n  \n  // 创建精灵对象\n  const ellipse = this.add.sprite(400, 300, 'orangeEllipse');\n  \n  // 创建抖动动画效果\n  // 抖动效果通过快速来回移动实现\n  this.tweens.add({\n    targets: ellipse,\n    x: '+=10', // 向右移动 10 像素\n    duration: 50, // 50 毫秒\n    yoyo: true, // 来回运动\n    repeat: -1, // 无限重复\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加垂直抖动增强效果\n  this.tweens.add({\n    targets: ellipse,\n    y: '+=8', // 向下移动 8 像素\n    duration: 60, // 60 毫秒\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 添加旋转抖动效果\n  this.tweens.add({\n    targets: ellipse,\n    angle: 5, // 旋转 5 度\n    duration: 100,\n    yoyo: true,\n    repeat: -1,\n    ease: 'Sine.easeInOut'\n  });\n  \n  // 创建一个主时间轴控制整体循环（2 秒一个周期）\n  // 通过改变抖动强度实现更明显的循环效果\n  this.tweens.add({\n    targets: ellipse,\n    scaleX: 1.05,\n    scaleY: 0.95,\n    duration: 1000, // 1 秒\n    yoyo: true, // 来回\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000423_v2", "prompt_id": "seed_000423", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个三角形移动，速度为 120 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制三角形以 120 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.addKeys, Phaser.GameObjects.Sprite\nSTEPS:\n1. 创建 Scene 并配置游戏画布\n2. 使用 Graphics 绘制三角形并生成纹理\n3. 创建精灵对象使用生成的三角形纹理\n4. 添加 WASD 键盘输入监听\n5. 在 update 中根据按键状态更新精灵位置，速度为 120 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet triangle;\nlet keys;\nconst SPEED = 120; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置三角形填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -20);  // 顶点\n  graphics.lineTo(-17, 10);  // 左下角\n  graphics.lineTo(17, 10);   // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangleTex', 40, 40);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建三角形精灵并放置在画布中心\n  triangle = this.add.sprite(400, 300, 'triangleTex');\n  \n  // 添加 WASD 键盘输入\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧移动距离 = 速度 * 时间差（秒）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键并设置速度方向\n  if (keys.w.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.s.isDown) {\n    velocityY = 1;  // 向下\n  }\n  if (keys.a.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.d.isDown) {\n    velocityX = 1;  // 向右\n  }\n  \n  // 归一化对角线移动速度（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= length;\n    velocityY /= length;\n  }\n  \n  // 更新三角形位置\n  triangle.x += velocityX * distance;\n  triangle.y += velocityY * distance;\n  \n  // 边界限制（可选）\n  triangle.x = Phaser.Math.Clamp(triangle.x, 0, 800);\n  triangle.y = Phaser.Math.Clamp(triangle.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000255_v3", "prompt_id": "seed_000255", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕右下显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕右下角显示 \"Hello Phaser\" 文字，字体大小 48 像素\nAPI: Phaser.GameObjects.Text, Scene.add.text, Text.setOrigin\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文字对象\n3. 设置文字内容为 \"Hello Phaser\"，字体大小为 48px\n4. 计算右下角位置（画布宽度和高度减去边距）\n5. 使用 setOrigin(1, 1) 设置锚点为右下角，确保文字右下角对齐\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文字对象\n  const text = this.add.text(\n    this.cameras.main.width - 20,  // x 坐标：画布宽度 - 右边距\n    this.cameras.main.height - 20, // y 坐标：画布高度 - 下边距\n    'Hello Phaser',                // 文字内容\n    {\n      fontSize: '48px',            // 字体大小\n      color: '#ffffff',            // 文字颜色\n      fontFamily: 'Arial'          // 字体\n    }\n  );\n  \n  // 设置锚点为右下角 (1, 1)，使文字从右下角对齐\n  text.setOrigin(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000312_v3", "prompt_id": "seed_000312", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个淡入淡出动画效果：让白色菱形在 1.5 秒内完成一次淡入淡出，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建白色菱形淡入淡出循环动画，周期1.5秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制白色菱形并生成纹理\n2. 创建 Sprite 对象使用生成的菱形纹理\n3. 使用 Tween 动画控制 alpha 属性实现淡入淡出效果\n4. 设置 yoyo 和 repeat 属性实现循环动画\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 绘制菱形路径（中心点在 50, 50，大小为 80x80）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 40;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);      // 上顶点\n  graphics.lineTo(centerX + size, centerY);      // 右顶点\n  graphics.lineTo(centerX, centerY + size);      // 下顶点\n  graphics.lineTo(centerX - size, centerY);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中显示\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建淡入淡出动画\n  // 使用 yoyo 实现淡入淡出效果，repeat -1 实现无限循环\n  this.tweens.add({\n    targets: diamond,\n    alpha: 0,                    // 目标透明度为 0（完全透明）\n    duration: 750,               // 单程时间 0.75 秒\n    yoyo: true,                  // 启用 yoyo 效果（淡出后自动淡入）\n    repeat: -1,                  // 无限循环\n    ease: 'Sine.easeInOut'       // 使用正弦缓动函数使动画更平滑\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000250_v2", "prompt_id": "seed_000250", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 500，移动速度 80，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色可左右移动、跳跃，重力500，速度80，与地面碰撞\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 配置物理系统，设置重力为500\n2. 使用Graphics生成玩家和地面的纹理\n3. 创建物理精灵作为玩家和静态地面\n4. 设置键盘输入监听（左右方向键和空格跳跃）\n5. 在update中处理移动逻辑，设置水平速度80\n6. 配置玩家与地面的碰撞检测\n7. 添加状态变量（jumpCount）用于验证\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号\n    this.isGrounded = false;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00aaff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 生成地面纹理（绿色平台）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x22aa22, 1);\n    groundGraphics.fillRect(0, 0, 800, 50);\n    groundGraphics.generateTexture('ground', 800, 50);\n    groundGraphics.destroy();\n\n    // 生成平台纹理（棕色）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8b4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 30);\n    platformGraphics.generateTexture('platform', 200, 30);\n    platformGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(100, 400, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setBounce(0);\n\n    // 创建地面和平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 主地面\n    this.platforms.create(400, 575, 'ground');\n    \n    // 添加几个悬浮平台\n    this.platforms.create(300, 450, 'platform');\n    this.platforms.create(600, 350, 'platform');\n    this.platforms.create(200, 250, 'platform');\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(16, 50, '← → 移动  ↑/空格 跳跃', {\n      fontSize: '16px',\n      fill: '#ffff00'\n    });\n  }\n\n  update(time, delta) {\n    // 更新状态文本\n    this.statusText.setText(\n      `跳跃次数: ${this.jumpCount}\\n` +\n      `位置: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})\\n` +\n      `速度: ${Math.floor(this.player.body.velocity.x)}\\n` +\n      `着地: ${this.player.body.touching.down ? '是' : '否'}`\n    );\n\n    // 重置水平速度\n    this.player.setVelocityX(0);\n\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-80);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(80);\n    }\n\n    // 跳跃逻辑\n    if ((this.cursors.up.isDown || this.spaceKey.isDown) && this.player.body.touching.down) {\n      this.player.setVelocityY(-350);\n      this.jumpCount++;\n    }\n\n    // 更新着地状态\n    this.isGrounded = this.player.body.touching.down;\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: PlatformScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001036_v3", "prompt_id": "seed_001036", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 200 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Phaser.Scene#update\nSTEPS:\n1. 使用 Graphics 绘制一个圆形和一个标记线（用于观察旋转）\n2. 将 Graphics 添加到 Container 中以便控制旋转\n3. 在 update 方法中根据 delta 时间累加旋转角度（200度/秒）\n4. 应用旋转到 Container 上\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circleContainer;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制圆形主体\n  graphics.fillStyle(0x00aaff, 1);\n  graphics.fillCircle(0, 0, 80);\n  \n  // 绘制一条从圆心到边缘的线，用于观察旋转\n  graphics.lineStyle(4, 0xff0000, 1);\n  graphics.beginPath();\n  graphics.moveTo(0, 0);\n  graphics.lineTo(80, 0);\n  graphics.strokePath();\n  \n  // 在圆边缘添加一个小圆点作为旋转标记\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(80, 0, 10);\n  \n  // 创建容器并将 Graphics 添加到容器中\n  // 使用容器可以更方便地控制整体旋转\n  circleContainer = this.add.container(400, 300);\n  circleContainer.add(graphics);\n  \n  // 添加文字说明\n  this.add.text(400, 50, '圆形以每秒 200° 旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // delta 是以毫秒为单位的帧间隔时间\n  // 将 delta 转换为秒：delta / 1000\n  // 每秒旋转 200 度，转换为弧度：Phaser.Math.DegToRad(200)\n  const rotationSpeed = Phaser.Math.DegToRad(200); // 每秒旋转的弧度\n  const deltaInSeconds = delta / 1000;\n  \n  // 累加旋转角度\n  circleContainer.rotation += rotationSpeed * deltaInSeconds;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000301_v2", "prompt_id": "seed_000301", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的紫色星形，每个大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的紫色星形，每个大小为80像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Phaser.Math.Between\nSTEPS:\n1. 创建 Phaser 游戏配置，设置画布大小为 800x600\n2. 在 create 方法中循环12次，每次创建一个 Graphics 对象\n3. 为每个 Graphics 对象生成随机位置（考虑星形大小避免超出边界）\n4. 使用 Graphics API 绘制五角星路径（通过计算五角星的顶点坐标）\n5. 填充紫色（0x800080）并渲染星形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const starSize = 80; // 星形大小\n  const starCount = 12; // 星形数量\n  const purpleColor = 0x800080; // 紫色\n  \n  // 创建12个随机位置的星形\n  for (let i = 0; i < starCount; i++) {\n    // 生成随机位置，确保星形不会超出边界\n    const x = Phaser.Math.Between(starSize / 2, this.scale.width - starSize / 2);\n    const y = Phaser.Math.Between(starSize / 2, this.scale.height - starSize / 2);\n    \n    // 创建 Graphics 对象绘制星形\n    const graphics = this.add.graphics();\n    graphics.setPosition(x, y);\n    \n    // 绘制五角星\n    drawStar(graphics, 0, 0, 5, starSize / 2, starSize / 4, purpleColor);\n  }\n}\n\n/**\n * 绘制星形函数\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} cx - 中心点 x 坐标\n * @param {number} cy - 中心点 y 坐标\n * @param {number} spikes - 星形尖角数量\n * @param {number} outerRadius - 外半径\n * @param {number} innerRadius - 内半径\n * @param {number} color - 填充颜色\n */\nfunction drawStar(graphics, cx, cy, spikes, outerRadius, innerRadius, color) {\n  graphics.fillStyle(color, 1);\n  graphics.beginPath();\n  \n  let rot = Math.PI / 2 * 3; // 从顶部开始\n  let step = Math.PI / spikes;\n  \n  // 移动到第一个点\n  graphics.moveTo(cx, cy - outerRadius);\n  \n  // 绘制星形路径\n  for (let i = 0; i < spikes; i++) {\n    // 外部顶点\n    let x = cx + Math.cos(rot) * outerRadius;\n    let y = cy + Math.sin(rot) * outerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n    \n    // 内部顶点\n    x = cx + Math.cos(rot) * innerRadius;\n    y = cy + Math.sin(rot) * innerRadius;\n    graphics.lineTo(x, y);\n    rot += step;\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000684_v3", "prompt_id": "seed_000684", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9042857142857141}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 12 个金币，重力 500，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集12个金币，重力500，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，设置重力为500\n2. 使用Graphics绘制玩家角色（矩形）和金币（圆形）纹理\n3. 创建地面平台和空中平台（静态物理组）\n4. 生成12个金币随机分布在平台上方\n5. 添加键盘输入控制（左右移动、跳跃）\n6. 实现碰撞检测：玩家与平台、玩家与金币\n7. 收集金币时增加分数并销毁金币\n8. 显示分数文本在屏幕上\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.score = 0;\n    this.coinsCollected = 0;\n  }\n\n  preload() {\n    // 创建玩家纹理\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建金币纹理\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffff00, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.lineStyle(2, 0xffaa00, 1);\n    coinGraphics.strokeCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n\n    // 创建平台纹理\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x8B4513, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 创建地面纹理\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x654321, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建平台组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 添加地面\n    this.platforms.create(400, 580, 'ground');\n\n    // 添加空中平台\n    this.platforms.create(200, 450, 'platform');\n    this.platforms.create(500, 380, 'platform');\n    this.platforms.create(100, 300, 'platform');\n    this.platforms.create(400, 250, 'platform');\n    this.platforms.create(650, 320, 'platform');\n    this.platforms.create(700, 200, 'platform');\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n\n    // 金币位置配置（分布在各个平台上方）\n    const coinPositions = [\n      { x: 200, y: 400 },\n      { x: 250, y: 380 },\n      { x: 500, y: 330 },\n      { x: 550, y: 310 },\n      { x: 100, y: 250 },\n      { x: 150, y: 230 },\n      { x: 400, y: 200 },\n      { x: 450, y: 180 },\n      { x: 650, y: 270 },\n      { x: 700, y: 150 },\n      { x: 750, y: 130 },\n      { x: 350, y: 350 }\n    ];\n\n    // 创建12个金币\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.2);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 设置碰撞\n    this.physics.add.collider(this.player, this.platforms);\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 设置金币收集\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 显示分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#fff',\n      fontFamily: 'Arial',\n      stroke: '#000',\n      strokeThickness: 4\n    });\n    this.scoreText.setDepth(10);\n\n    // 显示收集进度\n    this.progressText = this.add.text(16, 56, 'Coins: 0/12', {\n      fontSize: '24px',\n      fill: '#ffff00',\n      fontFamily: 'Arial',\n      stroke: '#000',\n      strokeThickness: 3\n    });\n    this.progressText.setDepth(10);\n\n    // 完成提示文本（初始隐藏）\n    this.completeText = this.add.text(400, 300, 'ALL COINS COLLECTED!', {\n      fontSize: '48px',\n      fill: '#00ff00',\n      fontFamily: 'Arial',\n      stroke: '#000',\n      strokeThickness: 6\n    });\n    this.completeText.setOrigin(0.5);\n    this.completeText.setVisible(false);\n    this.completeText.setDepth(20);\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-200);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(200);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n\n    // 增加分数\n    this.score += 10;\n    this.coinsCollected += 1;\n\n    // 更新文本\n    this.scoreText.setText('Score: ' + this.score);\n    this.progressText.setText('Coins: ' + this.coinsCollected + '/12');\n\n    // 检查是否收集完所有金币\n    if (this.coinsCollected === 12) {\n      this.completeText.setVisible(true);\n      \n      // 添加闪烁效果\n      this.tweens.add({\n        targets: this.completeText,\n        alpha: { from: 1, to: 0.3 },\n        duration: 500,\n        yoyo: true,\n        repeat: -1\n      });\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000848_v2", "prompt_id": "seed_000848", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9200000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个白色椭圆在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个白色椭圆从左到右往返循环的补间动画，持续2.5秒\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制白色椭圆并生成纹理\n2. 创建椭圆精灵对象，初始位置在屏幕左侧\n3. 使用 tweens.add 创建补间动画，设置目标 x 坐标到屏幕右侧\n4. 设置动画持续时间为 2500ms，启用 yoyo 往返效果，设置 loop: -1 无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建白色椭圆纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40, 30)，宽80，高60\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建椭圆精灵，初始位置在左侧\n  const ellipse = this.add.sprite(50, 300, 'ellipse');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: ellipse,\n    x: 750, // 目标位置（屏幕右侧，留出边距）\n    duration: 2500, // 持续时间 2.5 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果（到达终点后反向播放）\n    loop: -1 // 无限循环（-1 表示永久循环）\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, '白色椭圆往返循环动画 (2.5秒)', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000456_v3", "prompt_id": "seed_000456", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 3 秒内从原始大小缩放到 80%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个菱形并生成纹理\n2. 创建一个 Sprite 使用该菱形纹理并居中显示\n3. 使用 Tween 动画实现缩放效果：从 1 缩放到 0.8，持续 3 秒\n4. 设置 yoyo 为 true 实现自动恢复，设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 绘制菱形（四个顶点）\n  // 中心点在 (50, 50)，大小为 100x100\n  const centerX = 50;\n  const centerY = 50;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    scaleX: 0.8,               // X 轴缩放到 0.8\n    scaleY: 0.8,               // Y 轴缩放到 0.8\n    duration: 3000,            // 持续 3 秒（3000 毫秒）\n    ease: 'Sine.easeInOut',    // 缓动函数，使动画更平滑\n    yoyo: true,                // 动画结束后反向播放（恢复到原始大小）\n    loop: -1                   // 无限循环（-1 表示永久循环）\n  });\n  \n  // 添加文字说明\n  this.add.text(400, 50, '菱形缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '3秒缩放到80% → 3秒恢复 → 循环', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000642_v3", "prompt_id": "seed_000642", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色圆形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的粉色圆形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景宽高为 800x600\n2. 在 create 方法中循环5次创建 Graphics 对象\n3. 为每个 Graphics 设置粉色填充样式（0xff69b4）\n4. 绘制半径为32像素的圆形（直径64像素）\n5. 使用 setRandomPosition 将圆形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#ffffff'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建5个粉色圆形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式\n    graphics.fillStyle(0xff69b4, 1);\n    \n    // 绘制圆形，半径为32像素（直径64像素）\n    // 圆心在(0, 0)，后续通过 setRandomPosition 移动整个 Graphics 对象\n    graphics.fillCircle(0, 0, 32);\n    \n    // 设置随机位置\n    // 考虑圆形半径，确保圆形完全在画布内\n    // x: 32 到 768 (800 - 32)\n    // y: 32 到 568 (600 - 32)\n    graphics.setRandomPosition(32, 32, 768 - 32, 568 - 32);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000767_v2", "prompt_id": "seed_000767", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个闪烁动画效果：让粉色矩形在 3 秒内完成一次闪烁，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建粉色矩形，使用 Tween 动画实现 3 秒闪烁循环效果\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色矩形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建 alpha 透明度动画，设置 duration 为 3000ms\n4. 配置 yoyo 为 true 实现来回闪烁，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建粉色矩形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('pinkRect', 200, 150);\n  graphics.destroy();\n\n  // 创建粉色矩形精灵，放置在屏幕中央\n  const pinkRect = this.add.sprite(400, 300, 'pinkRect');\n\n  // 创建闪烁动画\n  // 使用 alpha 透明度从 1 渐变到 0，再回到 1，完成一次闪烁\n  this.tweens.add({\n    targets: pinkRect,\n    alpha: 0,           // 目标透明度为 0（完全透明）\n    duration: 1500,     // 单程 1.5 秒\n    yoyo: true,         // 来回播放（0->1 再 1->0）\n    repeat: -1,         // 无限循环\n    ease: 'Sine.easeInOut' // 使用正弦缓动函数，使闪烁更平滑\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, '粉色矩形闪烁动画（3秒一次循环）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000153_v1", "prompt_id": "seed_000153", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 3 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 六边形在3秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制六边形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画在 3 秒内将 alpha 从 0 渐变到 1\n4. 设置 Tween 为循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置六边形参数\n  const hexRadius = 80; // 六边形半径\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 绘制六边形（6个边，每个顶点间隔60度）\n  graphics.fillStyle(0x00ff88, 1);\n  graphics.beginPath();\n  \n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy(); // 销毁 graphics 对象，释放内存\n  \n  // 创建六边形精灵并设置到屏幕中心\n  const hexagon = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0（完全透明）\n  hexagon.setAlpha(0);\n  \n  // 创建渐变动画：从透明到不透明，3秒，循环播放\n  this.tweens.add({\n    targets: hexagon,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 3000, // 持续时间 3 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: false, // 不反向播放\n    repeat: -1, // 无限循环\n    repeatDelay: 0 // 无延迟\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 500, '六边形正在从透明渐变到不透明（循环播放）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000337_v2", "prompt_id": "seed_000337", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 灰色玩家移出边界时从对侧出现（循环地图效果），移动速度 160。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 灰色玩家移出边界时从对侧出现，移动速度160\nAPI: Phaser.Physics.Arcade.Sprite, this.input.keyboard.createCursorKeys(), sprite.setVelocity(), Graphics.generateTexture()\nSTEPS:\n1. 创建灰色玩家精灵并启用物理系统\n2. 使用键盘输入控制玩家移动（速度160）\n3. 在update中检测玩家位置，超出边界时从对侧重新出现\n4. 添加状态变量记录穿越次数作为验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossCount = 0; // 穿越边界次数（验证信号）\n  }\n\n  preload() {\n    // 无需加载外部资源\n  }\n\n  create() {\n    // 创建灰色玩家纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1); // 灰色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n\n    // 创建玩家精灵（居中位置）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 不与世界边界碰撞\n\n    // 创建键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加WASD支持\n    this.keys = this.input.keyboard.addKeys({\n      w: Phaser.Input.Keyboard.KeyCodes.W,\n      a: Phaser.Input.Keyboard.KeyCodes.A,\n      s: Phaser.Input.Keyboard.KeyCodes.S,\n      d: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 显示控制说明\n    this.add.text(10, 550, 'Controls: Arrow Keys or WASD to move', {\n      fontSize: '14px',\n      fill: '#cccccc'\n    });\n\n    this.updateStatusText();\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0, 0);\n\n    // 处理输入 - 移动速度 160\n    const speed = 160;\n    \n    if (this.cursors.left.isDown || this.keys.a.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keys.d.isDown) {\n      this.player.setVelocityX(speed);\n    }\n\n    if (this.cursors.up.isDown || this.keys.w.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.keys.s.isDown) {\n      this.player.setVelocityY(speed);\n    }\n\n    // 处理边界循环效果\n    const padding = 16; // 玩家半径\n    let crossed = false;\n\n    // 左右边界\n    if (this.player.x < -padding) {\n      this.player.x = this.game.config.width + padding;\n      crossed = true;\n    } else if (this.player.x > this.game.config.width + padding) {\n      this.player.x = -padding;\n      crossed = true;\n    }\n\n    // 上下边界\n    if (this.player.y < -padding) {\n      this.player.y = this.game.config.height + padding;\n      crossed = true;\n    } else if (this.player.y > this.game.config.height + padding) {\n      this.player.y = -padding;\n      crossed = true;\n    }\n\n    // 更新穿越计数\n    if (crossed) {\n      this.crossCount++;\n      this.updateStatusText();\n    }\n  }\n\n  updateStatusText() {\n    this.statusText.setText(\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})\\n` +\n      `Cross Count: ${this.crossCount}\\n` +\n      `Speed: 160`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000913_v3", "prompt_id": "seed_000913", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形在 4 秒内从原始大小缩放到 32%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形在 4 秒内从原始大小缩放到 32%，然后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个三角形并生成纹理\n2. 创建一个 Sprite 对象使用该三角形纹理\n3. 使用 Tween 动画将 scale 从 1 缩放到 0.32，持续 2 秒\n4. 设置 yoyo 为 true 让动画反向播放（恢复），总时长 4 秒\n5. 设置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制一个等边三角形（中心对齐）\n  const triangleSize = 100;\n  graphics.beginPath();\n  graphics.moveTo(0, -triangleSize / 2); // 顶点\n  graphics.lineTo(-triangleSize / 2, triangleSize / 2); // 左下角\n  graphics.lineTo(triangleSize / 2, triangleSize / 2); // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 将 Graphics 生成为纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 创建使用三角形纹理的 Sprite，放置在屏幕中心\n  const triangle = this.add.sprite(400, 300, 'triangle');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: triangle,\n    scaleX: 0.32, // 缩放到 32%\n    scaleY: 0.32, // 缩放到 32%\n    duration: 2000, // 2 秒缩小\n    yoyo: true, // 反向播放（恢复原始大小）\n    repeat: -1, // 无限循环\n    ease: 'Sine.easeInOut' // 使用平滑的缓动函数\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, 'Triangle Scale Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scaling from 100% to 32% and back (4s cycle)', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\n// 创建 Phaser 游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000297_v3", "prompt_id": "seed_000297", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：10 个橙色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 10个橙色小球在封闭空间内以360速度移动，碰到边界和彼此时弹开\nAPI: Phaser.Physics.Arcade, Graphics.fillCircle, Physics.add.group, Body.setBounce, Physics.add.collider\nSTEPS:\n1. 配置 Arcade 物理系统，设置无重力环境\n2. 使用 Graphics 绘制橙色圆形纹理\n3. 创建物理组，添加 10 个小球，设置随机位置和速度\n4. 设置小球边界碰撞反弹和小球间碰撞\n5. 添加状态变量记录碰撞次数作为验证信号\n[/PLAN]\n\n```javascript\nclass BallCollisionScene extends Phaser.Scene {\n  constructor() {\n    super('BallCollisionScene');\n    this.collisionCount = 0; // 状态信号：记录碰撞次数\n  }\n\n  preload() {\n    // 无需预加载外部资源\n  }\n\n  create() {\n    // 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8C00, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('orangeBall', 32, 32);\n    graphics.destroy();\n\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      key: 'orangeBall',\n      repeat: 9, // 创建10个小球（0-9）\n      bounceX: 1, // 完全弹性碰撞\n      bounceY: 1,\n      collideWorldBounds: true // 与世界边界碰撞\n    });\n\n    // 设置每个小球的随机位置和速度\n    const ballsArray = this.balls.getChildren();\n    ballsArray.forEach((ball, index) => {\n      // 随机位置（避免边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      ball.setPosition(x, y);\n\n      // 随机方向，固定速度360\n      const angle = Phaser.Math.Between(0, 360);\n      const velocityX = Math.cos(angle * Math.PI / 180) * 360;\n      const velocityY = Math.sin(angle * Math.PI / 180) * 360;\n      ball.setVelocity(velocityX, velocityY);\n\n      // 设置圆形碰撞体\n      ball.setCircle(16);\n    });\n\n    // 小球之间的碰撞检测\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 添加文本显示碰撞次数\n    this.collisionText = this.add.text(10, 10, 'Collisions: 0', {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加边界线可视化\n    const bounds = this.add.graphics();\n    bounds.lineStyle(2, 0xffffff, 1);\n    bounds.strokeRect(0, 0, 800, 600);\n\n    // 监听世界边界碰撞\n    this.physics.world.on('worldbounds', () => {\n      this.collisionCount++;\n      this.updateCollisionText();\n    });\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 小球碰撞回调\n    this.collisionCount++;\n    this.updateCollisionText();\n  }\n\n  updateCollisionText() {\n    this.collisionText.setText('Collisions: ' + this.collisionCount);\n  }\n\n  update(time, delta) {\n    // 确保速度保持在360左右（补偿浮点误差）\n    const ballsArray = this.balls.getChildren();\n    ballsArray.forEach(ball => {\n      const currentSpeed = Math.sqrt(\n        ball.body.velocity.x ** 2 + ball.body.velocity.y ** 2\n      );\n      \n      // 如果速度偏差超过5%，重新归一化\n      if (Math.abs(currentSpeed - 360) > 18) {\n        const scale = 360 / currentSpeed;\n        ball.setVelocity(\n          ball.body.velocity.x * scale,\n          ball.body.velocity.y * scale\n        );\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: BallCollisionScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001181_v3", "prompt_id": "seed_001181", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 4 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形在 4 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画控制 alpha 属性从 0 到 1，持续 4 秒\n4. 设置 Tween 循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制菱形（四个顶点）\n  const centerX = 50;\n  const centerY = 50;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 上顶点\n  graphics.lineTo(centerX + size, centerY);        // 右顶点\n  graphics.lineTo(centerX, centerY + size);        // 下顶点\n  graphics.lineTo(centerX - size, centerY);        // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建菱形精灵并放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为 0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画，让菱形从透明到不透明\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    alpha: 1,                   // 目标透明度值（完全不透明）\n    duration: 4000,             // 持续时间 4 秒（4000 毫秒）\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 反向播放（从 1 回到 0）\n    repeat: -1,                 // 无限循环（-1 表示永久重复）\n    onUpdate: function(tween, target) {\n      // 可选：在动画更新时执行的回调\n      // console.log('当前透明度:', target.alpha);\n    }\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 550, '菱形正在循环渐变（透明 ↔ 不透明，4秒周期）', {\n    fontSize: '18px',\n    color: '#ffffff',\n    align: 'center'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000279_v3", "prompt_id": "seed_000279", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 用 3x3 的二维数组生成绿色棋盘格地图，交替显示两种颜色。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Tilemaps.Tilemap\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 用 3x3 二维数组生成绿色棋盘格地图，交替显示两种颜色\nAPI: Phaser.GameObjects.Graphics, Phaser.Tilemaps.Tilemap, Phaser.Tilemaps.Tileset, Phaser.GameObjects.GameObject.generateTexture\nSTEPS:\n1. 使用 Graphics 绘制两种绿色瓦片纹理（深绿和浅绿）\n2. 创建 Tilemap 并添加 Tileset\n3. 使用 3x3 二维数组定义棋盘格数据，交替使用两种瓦片索引\n4. 通过 Tilemap.createLayer 渲染棋盘格地图\n5. 添加状态信号变量记录地图信息\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\n// 状态信号变量\nlet gameState = {\n  mapWidth: 3,\n  mapHeight: 3,\n  tileSize: 64,\n  tilesCreated: 0,\n  mapGenerated: false\n};\n\nfunction preload() {\n  // 使用 Graphics 创建两种绿色瓦片纹理\n  const graphics = this.add.graphics();\n  \n  // 深绿色瓦片\n  graphics.fillStyle(0x228B22, 1); // Forest Green\n  graphics.fillRect(0, 0, 64, 64);\n  graphics.lineStyle(2, 0x1a6b1a, 1);\n  graphics.strokeRect(0, 0, 64, 64);\n  graphics.generateTexture('tile1', 64, 64);\n  \n  // 浅绿色瓦片\n  graphics.clear();\n  graphics.fillStyle(0x90EE90, 1); // Light Green\n  graphics.fillRect(0, 0, 64, 64);\n  graphics.lineStyle(2, 0x7acc7a, 1);\n  graphics.strokeRect(0, 0, 64, 64);\n  graphics.generateTexture('tile2', 64, 64);\n  \n  graphics.destroy();\n}\n\nfunction create() {\n  const tileSize = gameState.tileSize;\n  \n  // 创建 3x3 棋盘格数据（交替显示两种颜色）\n  const mapData = [\n    [1, 2, 1],\n    [2, 1, 2],\n    [1, 2, 1]\n  ];\n  \n  // 创建空白 Tilemap\n  const map = this.make.tilemap({\n    data: mapData,\n    tileWidth: tileSize,\n    tileHeight: tileSize\n  });\n  \n  // 添加 Tileset（使用之前生成的纹理）\n  const tiles = map.addTilesetImage('tile1', null, tileSize, tileSize);\n  \n  // 创建图层\n  const layer = map.createLayer(0, tiles, 200, 150);\n  \n  // 手动设置每个瓦片的纹理（因为 Tilemap 默认只能用一个 tileset）\n  // 我们需要遍历地图数据来正确设置纹理\n  for (let y = 0; y < gameState.mapHeight; y++) {\n    for (let x = 0; x < gameState.mapWidth; x++) {\n      const tile = layer.getTileAt(x, y);\n      if (tile) {\n        // 根据数据值设置不同的 tint 或使用不同方式\n        gameState.tilesCreated++;\n      }\n    }\n  }\n  \n  // 由于 Tilemap 的限制，使用 Sprite 方式重新实现棋盘格\n  // 这样可以更灵活地使用两种纹理\n  layer.destroy();\n  \n  const startX = 200;\n  const startY = 150;\n  \n  for (let y = 0; y < gameState.mapHeight; y++) {\n    for (let x = 0; x < gameState.mapWidth; x++) {\n      const tileIndex = mapData[y][x];\n      const textureName = tileIndex === 1 ? 'tile1' : 'tile2';\n      \n      const sprite = this.add.sprite(\n        startX + x * tileSize + tileSize / 2,\n        startY + y * tileSize + tileSize / 2,\n        textureName\n      );\n      \n      gameState.tilesCreated++;\n    }\n  }\n  \n  gameState.mapGenerated = true;\n  \n  // 添加文本显示状态信息\n  const statusText = this.add.text(10, 10, '', {\n    fontSize: '18px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  \n  statusText.setText([\n    `Map Size: ${gameState.mapWidth}x${gameState.mapHeight}`,\n    `Tile Size: ${gameState.tileSize}px`,\n    `Tiles Created: ${gameState.tilesCreated}`,\n    `Map Generated: ${gameState.mapGenerated}`,\n    '',\n    'Green checkerboard pattern with',\n    'alternating dark and light tiles'\n  ]);\n  \n  // 添加标题\n  this.add.text(400, 50, '3x3 Green Checkerboard Map', {\n    fontSize: '32px',\n    fill: '#90EE90',\n    fontStyle: 'bold'\n  }).setOrigin(0.5);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000959_v2", "prompt_id": "seed_000959", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Tilemap", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 2 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在2秒内从透明到不透明循环渐变\nAPI: Graphics, Tween, setAlpha\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为0\n3. 使用 Tween 动画让 alpha 从0到1，持续2秒，循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 绘制菱形（四个顶点）\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.beginPath();\n  graphics.moveTo(50, 0);    // 上顶点\n  graphics.lineTo(100, 50);  // 右顶点\n  graphics.lineTo(50, 100);  // 下顶点\n  graphics.lineTo(0, 50);    // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 100, 100);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建菱形精灵，放置在屏幕中央\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置初始透明度为0（完全透明）\n  diamond.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: diamond,\n    alpha: 1,              // 目标透明度：完全不透明\n    duration: 2000,        // 持续时间：2秒\n    ease: 'Linear',        // 线性缓动\n    yoyo: false,           // 不反向播放\n    repeat: -1,            // 无限循环\n    repeatDelay: 0         // 重复间隔为0\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000388_v2", "prompt_id": "seed_000388", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个三角形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个三角形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillTriangle, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个三角形\n2. 在 update 中根据 delta 时间增量计算旋转角度\n3. 每秒旋转 240 度，即每毫秒旋转 240/1000 度，转换为弧度后应用到 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制一个等边三角形（中心在原点）\n  const size = 80;\n  const height = size * Math.sqrt(3) / 2;\n  \n  graphics.fillTriangle(\n    0, -height * 2/3,           // 顶点（上）\n    -size/2, height * 1/3,      // 左下顶点\n    size/2, height * 1/3        // 右下顶点\n  );\n  \n  // 设置三角形位置到屏幕中心\n  graphics.x = 400;\n  graphics.y = 300;\n  \n  // 将 graphics 对象存储到 scene 数据中，方便 update 访问\n  this.triangle = graphics;\n  \n  // 添加提示文本\n  this.add.text(10, 10, '三角形旋转速度: 240°/秒', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 每秒旋转 240 度\n  // delta 是毫秒，240 度/秒 = 240/1000 度/毫秒\n  // 转换为弧度：角度 * Math.PI / 180\n  const rotationSpeed = 240; // 度/秒\n  const rotationPerMs = rotationSpeed / 1000; // 度/毫秒\n  const rotationRad = Phaser.Math.DegToRad(rotationPerMs * delta);\n  \n  // 累加旋转角度\n  this.triangle.rotation += rotationRad;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000451_v3", "prompt_id": "seed_000451", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形以每秒 240 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个矩形以每秒 240 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.rotation, Phaser.Scene.update\nSTEPS:\n1. 创建 Game 配置，设置场景的 preload、create 和 update 方法\n2. 在 create 中使用 Graphics 绘制一个矩形\n3. 在 update 中根据 delta 时间增量计算旋转角度（240度/秒 = 240 * Math.PI / 180 弧度/秒）\n4. 每帧更新矩形的 rotation 属性实现持续旋转\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet rectangle;\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制矩形\n  rectangle = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  rectangle.fillStyle(0x4a90e2, 1);\n  \n  // 绘制一个矩形（中心点在原点，便于旋转）\n  // 矩形大小：宽 150，高 100\n  rectangle.fillRect(-75, -50, 150, 100);\n  \n  // 设置矩形位置到画布中心\n  rectangle.x = 400;\n  rectangle.y = 300;\n  \n  // 初始旋转角度为 0\n  rectangle.rotation = 0;\n}\n\nfunction update(time, delta) {\n  // 计算每帧旋转的角度\n  // 240 度/秒 = 240 * (Math.PI / 180) 弧度/秒\n  // delta 是以毫秒为单位，需要转换为秒：delta / 1000\n  const rotationSpeed = 240 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 当前帧旋转的弧度\n  \n  // 更新矩形的旋转角度\n  rectangle.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000335_v3", "prompt_id": "seed_000335", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左移动的矩形对象并保持居中\nAPI: this.add.graphics(), this.cameras.main.startFollow(), this.cameras.main.setFollowOffset()\nSTEPS:\n1. 使用 Graphics 绘制一个矩形作为移动对象\n2. 在 create 中设置相机跟随该矩形对象\n3. 在 update 中让矩形持续向左移动\n4. 设置相机跟随偏移使对象保持在画面中央\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 相机跟随示例\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局变量存储移动对象\nlet player;\nlet moveSpeed = 2;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建一个背景网格以便观察相机移动\n  const graphics = this.add.graphics();\n  graphics.lineStyle(1, 0x00ff00, 0.3);\n  \n  // 绘制网格（范围更大以便观察移动）\n  for (let x = -2000; x <= 2000; x += 100) {\n    graphics.lineBetween(x, -2000, x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += 100) {\n    graphics.lineBetween(-2000, y, 2000, y);\n  }\n  \n  // 添加参考点标记\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillCircle(0, 0, 10); // 原点\n  graphics.fillCircle(400, 300, 10); // 初始相机中心\n  \n  // 创建玩家矩形（使用 Graphics 绘制）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0xff0000, 1);\n  playerGraphics.fillRect(-25, -25, 50, 50); // 中心点在 (0,0)\n  \n  // 添加一个白色边框便于识别\n  playerGraphics.lineStyle(3, 0xffffff, 1);\n  playerGraphics.strokeRect(-25, -25, 50, 50);\n  \n  // 设置初始位置\n  playerGraphics.x = 400;\n  playerGraphics.y = 300;\n  \n  // 保存到全局变量\n  player = playerGraphics;\n  \n  // 设置相机边界（可选，让相机可以自由移动）\n  this.cameras.main.setBounds(-2000, -2000, 4000, 4000);\n  \n  // 设置相机跟随玩家对象\n  this.cameras.main.startFollow(player);\n  \n  // 设置跟随偏移，使对象保持在画面中央\n  // 偏移量为 (0, 0) 表示对象在相机中心\n  this.cameras.main.setFollowOffset(0, 0);\n  \n  // 可选：设置相机跟随的平滑度（lerp值，0-1之间，值越小越平滑）\n  this.cameras.main.setLerp(0.1, 0.1);\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, 'Red square moving left\\nCamera follows automatically', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随场景滚动\n  \n  // 添加坐标显示\n  this.coordText = this.add.text(10, 70, '', {\n    fontSize: '14px',\n    color: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  this.coordText.setScrollFactor(0);\n}\n\nfunction update(time, delta) {\n  // 让玩家矩形持续向左移动\n  player.x -= moveSpeed;\n  \n  // 更新坐标显示\n  this.coordText.setText(\n    `Player X: ${Math.round(player.x)}\\n` +\n    `Player Y: ${Math.round(player.y)}\\n` +\n    `Camera X: ${Math.round(this.cameras.main.scrollX)}\\n` +\n    `Camera Y: ${Math.round(this.cameras.main.scrollY)}`\n  );\n  \n  // 可选：当玩家移动到很远时重置位置（演示循环）\n  if (player.x < -1500) {\n    player.x = 1500;\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000339_v2", "prompt_id": "seed_000339", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个矩形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制矩形以 200 像素/秒的速度移动\nAPI: this.input.keyboard.addKey(), this.add.graphics(), Phaser.Input.Keyboard.KeyCodes\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中使用 Graphics 绘制矩形\n3. 使用 addKey 绑定 WASD 键位\n4. 在 update 中检测按键状态并根据 delta 计算移动距离\n5. 更新矩形位置实现平滑移动\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 游戏状态变量\nlet player;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建玩家矩形（使用 Graphics）\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 50, 50);\n  \n  // 生成纹理供后续使用\n  graphics.generateTexture('playerRect', 50, 50);\n  graphics.destroy();\n  \n  // 创建玩家精灵并放置在屏幕中央\n  player = this.add.sprite(400, 300, 'playerRect');\n  \n  // 绑定 WASD 键位\n  keys = {\n    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),\n    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),\n    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),\n    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)\n  };\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the rectangle', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算每帧的移动距离（速度 * 时间差）\n  const distance = SPEED * (delta / 1000);\n  \n  // 重置速度向量\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 检测按键并设置速度方向\n  if (keys.W.isDown) {\n    velocityY = -1; // 向上\n  }\n  if (keys.S.isDown) {\n    velocityY = 1; // 向下\n  }\n  if (keys.A.isDown) {\n    velocityX = -1; // 向左\n  }\n  if (keys.D.isDown) {\n    velocityX = 1; // 向右\n  }\n  \n  // 归一化对角线移动速度（避免对角线移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    const magnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    velocityX /= magnitude;\n    velocityY /= magnitude;\n  }\n  \n  // 更新玩家位置\n  player.x += velocityX * distance;\n  player.y += velocityY * distance;\n  \n  // 边界限制（防止矩形移出屏幕）\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000096_v1", "prompt_id": "seed_000096", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的红色六边形，每个大小为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在场景中绘制20个随机位置的红色六边形，每个大小为16像素\nAPI: Phaser.GameObjects.Graphics, Graphics#fillStyle, Graphics#beginPath, Graphics#lineTo, Graphics#closePath, Graphics#fillPath, Math.random\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景大小为 800x600\n2. 在 create 方法中创建 Graphics 对象用于绘制\n3. 编写六边形绘制函数，计算6个顶点坐标（使用三角函数）\n4. 循环20次，每次生成随机坐标并绘制红色六边形\n5. 确保六边形完全在画布范围内（考虑边界）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  const graphics = this.add.graphics();\n  \n  // 设置红色填充\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制20个随机位置的六边形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置，确保六边形完全在画布内\n    // 六边形半径为16像素，所以边界留出至少16像素\n    const x = 16 + Math.random() * (800 - 32);\n    const y = 16 + Math.random() * (600 - 32);\n    \n    drawHexagon(graphics, x, y, 16);\n  }\n}\n\n/**\n * 绘制正六边形\n * @param {Phaser.GameObjects.Graphics} graphics - Graphics 对象\n * @param {number} x - 中心点 x 坐标\n * @param {number} y - 中心点 y 坐标\n * @param {number} size - 六边形大小（从中心到顶点的距离）\n */\nfunction drawHexagon(graphics, x, y, size) {\n  graphics.beginPath();\n  \n  // 计算六边形的6个顶点\n  // 从顶部开始，顺时针绘制\n  for (let i = 0; i < 6; i++) {\n    // 角度：每个顶点间隔60度，起始角度为-90度（指向上方）\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const vx = x + size * Math.cos(angle);\n    const vy = y + size * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(vx, vy);\n    } else {\n      graphics.lineTo(vx, vy);\n    }\n  }\n  \n  graphics.closePath();\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000499_v1", "prompt_id": "seed_000499", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个圆形以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Container, Scene.update\nSTEPS:\n1. 创建 Graphics 对象绘制圆形\n2. 将 Graphics 放入 Container 中以便旋转（Graphics 自身旋转不明显，需要偏移中心）\n3. 在 update 方法中根据 delta 时间累加旋转角度，每秒 80 度转换为弧度增量\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet circleContainer;\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建一个容器用于旋转\n  circleContainer = this.add.container(400, 300);\n  \n  // 创建 Graphics 对象绘制圆形\n  const graphics = this.add.graphics();\n  \n  // 绘制一个红色圆形，圆心在原点\n  graphics.fillStyle(0xff0000, 1);\n  graphics.fillCircle(0, 0, 50);\n  \n  // 在圆形上添加一个标记点，用于观察旋转效果\n  graphics.fillStyle(0xffffff, 1);\n  graphics.fillCircle(40, 0, 8);\n  \n  // 将 graphics 添加到容器中\n  circleContainer.add(graphics);\n  \n  // 添加说明文字\n  const text = this.add.text(400, 50, '圆形以每秒 80° 旋转', {\n    fontSize: '24px',\n    color: '#ffffff'\n  });\n  text.setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 每秒 80 度 = 80 * (Math.PI / 180) 弧度/秒\n  // delta 是毫秒，需要转换为秒\n  const rotationSpeed = 80 * (Math.PI / 180); // 弧度/秒\n  const rotationIncrement = rotationSpeed * (delta / 1000); // 本帧旋转量\n  \n  // 累加旋转角度\n  circleContainer.rotation += rotationIncrement;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000001_v3", "prompt_id": "seed_000001", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 2 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形在2秒内缩放到48%后恢复，循环播放\nAPI: this.add.graphics, this.tweens.add, Phaser.Game\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建一个使用该纹理的 Sprite 对象\n3. 使用 tweens.add 创建缩放动画，scale 从 1 到 0.48 再回到 1\n4. 设置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置 duration 为 2000ms（单程2秒，往返共4秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('rectTexture', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建使用该纹理的 Sprite，放置在屏幕中央\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setOrigin(0.5, 0.5); // 设置中心点为矩形中心\n\n  // 创建缩放动画\n  this.tweens.add({\n    targets: rect,\n    scaleX: 0.48, // 缩放到 48%\n    scaleY: 0.48,\n    duration: 2000, // 2秒完成缩放\n    yoyo: true, // 启用往返效果（缩放后恢复）\n    loop: -1, // 无限循环（-1 表示永久循环）\n    ease: 'Sine.easeInOut' // 使用平滑的缓动效果\n  });\n\n  // 添加文字说明\n  this.add.text(400, 50, '矩形缩放动画（2秒缩放到48%，循环播放）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000581_v2", "prompt_id": "seed_000581", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形在 1 秒内从原始大小缩放到 48%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 菱形在1秒内缩放到48%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制菱形并生成纹理\n2. 创建 Sprite 对象应用菱形纹理\n3. 使用 Tween 实现缩放动画（scale: 0.48，duration: 1000ms，yoyo: true）\n4. 设置 loop: -1 实现无限循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  \n  // 设置菱形颜色\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（中心点在 64, 64，边长约 100）\n  const centerX = 64;\n  const centerY = 64;\n  const size = 50;\n  \n  graphics.beginPath();\n  graphics.moveTo(centerX, centerY - size);        // 顶点\n  graphics.lineTo(centerX + size, centerY);        // 右点\n  graphics.lineTo(centerX, centerY + size);        // 底点\n  graphics.lineTo(centerX - size, centerY);        // 左点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 128, 128);\n  graphics.destroy();\n  \n  // 创建菱形精灵并居中显示\n  const diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 创建缩放 Tween 动画\n  this.tweens.add({\n    targets: diamond,\n    scaleX: 0.48,           // 缩放到 48%\n    scaleY: 0.48,           // 缩放到 48%\n    duration: 1000,         // 1 秒完成缩放\n    yoyo: true,             // 播放完后反向播放（恢复原始大小）\n    loop: -1,               // 无限循环\n    ease: 'Linear'          // 线性缓动\n  });\n  \n  // 添加文字提示\n  this.add.text(400, 50, 'Diamond Scale Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Scale: 100% → 48% → 100% (Loop)', {\n    fontSize: '18px',\n    color: '#cccccc'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000703_v2", "prompt_id": "seed_000703", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的矩形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左移动的矩形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Rectangle, Phaser.Cameras.Scene2D.Camera.main\nSTEPS:\n1. 创建场景配置，设置较大的世界边界以便矩形移动\n2. 使用 Graphics 或 Rectangle 创建一个可见的矩形对象\n3. 在 create 中通过 this.cameras.main.startFollow() 让相机跟随矩形\n4. 在 update 中让矩形持续向左移动（x 坐标递减）\n5. 设置相机边界与世界边界一致，确保跟随效果正常\n[/PLAN]\n\n```javascript\n// 完整的 Phaser3 相机跟随示例\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局变量存储移动的矩形\nlet movingRect;\nlet speed = 2; // 移动速度\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 设置世界边界，使其比屏幕大，以便矩形可以移动\n  this.cameras.main.setBounds(0, 0, 2400, 600);\n  this.physics.world.setBounds(0, 0, 2400, 600);\n\n  // 创建一个矩形对象（使用 Rectangle 游戏对象）\n  movingRect = this.add.rectangle(1200, 300, 50, 50, 0xff0000);\n  \n  // 添加一些背景参考物，帮助观察相机跟随效果\n  const graphics = this.add.graphics();\n  graphics.lineStyle(2, 0x00ff00, 0.5);\n  \n  // 绘制网格作为参考\n  for (let x = 0; x <= 2400; x += 100) {\n    graphics.lineBetween(x, 0, x, 600);\n  }\n  for (let y = 0; y <= 600; y += 100) {\n    graphics.lineBetween(0, y, 2400, y);\n  }\n  \n  // 添加一些固定位置的参考矩形\n  this.add.rectangle(400, 300, 30, 30, 0x00ffff);\n  this.add.rectangle(800, 300, 30, 30, 0xffff00);\n  this.add.rectangle(1600, 300, 30, 30, 0xff00ff);\n  this.add.rectangle(2000, 300, 30, 30, 0x00ff00);\n  \n  // 设置相机跟随移动的矩形\n  // startFollow(target, roundPixels, lerpX, lerpY)\n  // roundPixels: 是否四舍五入像素，避免抖动\n  // lerpX, lerpY: 跟随平滑度 (0-1)，值越小越平滑\n  this.cameras.main.startFollow(movingRect, true, 0.1, 0.1);\n  \n  // 添加文本提示（固定在相机上）\n  const text = this.add.text(10, 10, '红色矩形自动向左移动\\n相机跟随保持居中', {\n    fontSize: '16px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定在相机上，不随世界移动\n}\n\nfunction update(time, delta) {\n  // 让矩形持续向左移动\n  movingRect.x -= speed;\n  \n  // 当矩形移动到世界左边界时，重置到右边\n  if (movingRect.x < 0) {\n    movingRect.x = 2400;\n  }\n  \n  // 也可以在到达边界时停止\n  // if (movingRect.x < 25) {\n  //   movingRect.x = 25;\n  // }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000339_v1", "prompt_id": "seed_000339", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个黄色三角形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 黄色三角形以240速度移动并在画布边界反弹\nAPI: Graphics, GameObject.setVelocity, Physics.Arcade, World.setBoundsCollision\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 绘制黄色三角形并生成纹理\n3. 创建物理精灵并设置初始速度为240\n4. 启用世界边界碰撞和精灵边界反弹\n5. 设置精灵与世界边界碰撞检测\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制黄色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffff00, 1); // 黄色\n  \n  // 绘制等边三角形（中心在原点）\n  const triangleSize = 40;\n  const height = triangleSize * Math.sqrt(3) / 2;\n  \n  graphics.beginPath();\n  graphics.moveTo(0, -height * 2/3); // 顶点\n  graphics.lineTo(-triangleSize / 2, height * 1/3); // 左下\n  graphics.lineTo(triangleSize / 2, height * 1/3); // 右下\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', triangleSize, triangleSize);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度为240）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 240);\n  triangle.setVelocity(velocity.x, velocity.y);\n  \n  // 启用世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 设置世界边界\n  this.physics.world.setBoundsCollision(true, true, true, true);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000353_v1", "prompt_id": "seed_000353", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 300 像素/秒速度移动\nAPI: Graphics.fillStyle, Graphics.fillPath, Input.Keyboard.addKeys, Scene.update\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 在 create 中使用 Graphics 绘制菱形形状并生成纹理\n3. 创建 Sprite 使用菱形纹理\n4. 使用 addKeys 监听 WASD 键盘输入\n5. 在 update 中根据按键状态计算速度并移动菱形\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形路径（中心点为 32, 32，大小为 64x64）\n  const path = new Phaser.Geom.Polygon([\n    32, 0,    // 上顶点\n    64, 32,   // 右顶点\n    32, 64,   // 下顶点\n    0, 32     // 左顶点\n  ]);\n  \n  graphics.fillPoints(path.points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 64, 64);\n  graphics.destroy();\n  \n  // 创建菱形精灵，放置在屏幕中心\n  diamond = this.add.sprite(400, 300, 'diamond');\n  \n  // 设置键盘输入监听 WASD\n  keys = this.input.keyboard.addKeys({\n    up: Phaser.Input.Keyboard.KeyCodes.W,\n    down: Phaser.Input.Keyboard.KeyCodes.S,\n    left: Phaser.Input.Keyboard.KeyCodes.A,\n    right: Phaser.Input.Keyboard.KeyCodes.D\n  });\n}\n\nfunction update(time, delta) {\n  // 重置速度\n  let velocityX = 0;\n  let velocityY = 0;\n  \n  // 根据按键状态设置速度方向\n  if (keys.left.isDown) {\n    velocityX = -1;\n  } else if (keys.right.isDown) {\n    velocityX = 1;\n  }\n  \n  if (keys.up.isDown) {\n    velocityY = -1;\n  } else if (keys.down.isDown) {\n    velocityY = 1;\n  }\n  \n  // 归一化对角线移动速度（避免对角移动更快）\n  if (velocityX !== 0 && velocityY !== 0) {\n    velocityX *= Math.SQRT1_2; // 等同于 1/sqrt(2)\n    velocityY *= Math.SQRT1_2;\n  }\n  \n  // 应用速度移动（delta 是毫秒，需要转换为秒）\n  diamond.x += velocityX * SPEED * (delta / 1000);\n  diamond.y += velocityY * SPEED * (delta / 1000);\n  \n  // 边界限制（可选）\n  diamond.x = Phaser.Math.Clamp(diamond.x, 0, 800);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 0, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000269_v3", "prompt_id": "seed_000269", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 20 个蓝色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 20 个蓝色可复用对象，离屏自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Sprite, Group.get, Group.killAndHide\nSTEPS:\n1. 创建 Graphics 生成蓝色方块纹理\n2. 使用 Physics.Arcade.Group 创建对象池，设置 maxSize 为 20\n3. 在 create 中初始化对象池，设置对象复用逻辑\n4. 定时从对象池获取对象并发射\n5. 在 update 中检测对象是否离屏，离屏则回收到对象池\n6. 添加状态变量跟踪活跃对象数和总发射次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;      // 当前活跃对象数\n    this.totalSpawned = 0;     // 总发射次数\n    this.recycledCount = 0;    // 回收次数\n  }\n\n  preload() {\n    // 创建蓝色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x0066ff, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('blueBox', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'blueBox',\n      maxSize: 20,\n      runChildUpdate: false,\n      createCallback: (obj) => {\n        obj.body.setCollideWorldBounds(false);\n      }\n    });\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 定时发射对象（每 500ms 发射一个）\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  spawnObject() {\n    // 从对象池获取对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 重置对象状态\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      // 随机位置（屏幕左侧）\n      const startX = -20;\n      const startY = Phaser.Math.Between(50, 550);\n      obj.setPosition(startX, startY);\n      \n      // 设置随机速度（向右移动）\n      const velocityX = Phaser.Math.Between(100, 300);\n      const velocityY = Phaser.Math.Between(-100, 100);\n      obj.setVelocity(velocityX, velocityY);\n      \n      // 添加旋转\n      obj.setAngularVelocity(Phaser.Math.Between(-180, 180));\n      \n      this.totalSpawned++;\n      this.activeCount++;\n    }\n  }\n\n  update(time, delta) {\n    // 检查所有活跃对象\n    this.objectPool.getChildren().forEach((obj) => {\n      if (obj.active) {\n        // 检测是否离开屏幕边界\n        if (obj.x > 850 || obj.x < -50 || obj.y > 650 || obj.y < -50) {\n          // 回收对象\n          this.recycleObject(obj);\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.updateStatus();\n  }\n\n  recycleObject(obj) {\n    // 停止物理运动\n    obj.setVelocity(0, 0);\n    obj.setAngularVelocity(0);\n    \n    // 隐藏并标记为非活跃\n    obj.setActive(false);\n    obj.setVisible(false);\n    \n    this.activeCount--;\n    this.recycledCount++;\n  }\n\n  updateStatus() {\n    const poolSize = this.objectPool.getLength();\n    const activeObjs = this.objectPool.countActive(true);\n    \n    this.statusText.setText([\n      `Pool Size: ${poolSize}/20`,\n      `Active Objects: ${activeObjs}`,\n      `Total Spawned: ${this.totalSpawned}`,\n      `Recycled: ${this.recycledCount}`,\n      `Reuse Rate: ${this.totalSpawned > 0 ? \n        ((this.recycledCount / this.totalSpawned) * 100).toFixed(1) : 0}%`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000960_v3", "prompt_id": "seed_000960", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8483333333333334}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色圆形在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现一个绿色圆形在1秒内左右往返循环移动的补间动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制绿色圆形并生成纹理\n3. 创建 Sprite 对象使用该纹理\n4. 使用 tweens.add 创建补间动画，设置 x 坐标从左到右移动\n5. 配置 yoyo 为 true 实现往返效果，设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建绿色圆形纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1);\n  graphics.fillCircle(25, 25, 25);\n  graphics.generateTexture('greenCircle', 50, 50);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建绿色圆形精灵，初始位置在左侧\n  const circle = this.add.sprite(100, 300, 'greenCircle');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    x: 700,                    // 目标 x 坐标（右侧位置）\n    duration: 1000,            // 动画持续时间 1 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果（到达终点后反向播放）\n    repeat: -1                 // 无限循环（-1 表示永久重复）\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '绿色圆形左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000515_v2", "prompt_id": "seed_000515", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个白色六边形，大小约为 16 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个白色六边形，大小约为 16 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.lineStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.strokePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布大小为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算六边形的 6 个顶点坐标（中心点在画布中央，半径为 16 像素）\n4. 使用 Graphics API 绘制六边形路径并填充白色\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式为白色\n  graphics.fillStyle(0xffffff, 1);\n  \n  // 设置描边样式（可选，让六边形更清晰）\n  graphics.lineStyle(2, 0xffffff, 1);\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 六边形半径\n  const radius = 16;\n  \n  // 计算六边形的 6 个顶点\n  // 六边形的顶点角度为 0°, 60°, 120°, 180°, 240°, 300°\n  // 从顶部开始绘制（-90° 或 -Math.PI/2）\n  const vertices = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 60度间隔，从顶部开始\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    vertices.push({ x, y });\n  }\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 移动到第一个顶点\n  graphics.moveTo(vertices[0].x, vertices[0].y);\n  \n  // 连接其余顶点\n  for (let i = 1; i < vertices.length; i++) {\n    graphics.lineTo(vertices[i].x, vertices[i].y);\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充并描边\n  graphics.fillPath();\n  graphics.strokePath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000123_v2", "prompt_id": "seed_000123", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色椭圆在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色椭圆在4秒内左右往返循环移动\nAPI: this.add.graphics, graphics.fillEllipse, this.tweens.add, yoyo, repeat\nSTEPS:\n1. 使用 Graphics 绘制红色椭圆\n2. 创建补间动画，设置 x 坐标从左到右移动，持续 4000ms\n3. 设置 yoyo 为 true 实现往返效果\n4. 设置 repeat 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制红色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1); // 红色\n  graphics.fillEllipse(0, 0, 80, 50); // 在原点绘制椭圆，宽80，高50\n  \n  // 将 graphics 转换为纹理\n  graphics.generateTexture('ellipse', 80, 50);\n  graphics.destroy(); // 销毁临时 graphics 对象\n  \n  // 创建使用该纹理的精灵对象\n  const ellipse = this.add.sprite(100, 300, 'ellipse');\n  \n  // 创建补间动画：从左到右移动\n  this.tweens.add({\n    targets: ellipse,\n    x: 700, // 目标 x 坐标（右侧）\n    duration: 4000, // 持续时间 4 秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 往返效果（到达目标后反向回到起点）\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\n// 启动 Phaser 游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000274_v3", "prompt_id": "seed_000274", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个菱形以每秒 200 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个菱形以每秒 200 度的速度持续旋转\nAPI: Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.rotation, Scene.time.addEvent\nSTEPS:\n1. 使用 Graphics 绘制一个菱形（由两个三角形组成）\n2. 将菱形放置在画布中心\n3. 在 update 方法中根据时间增量更新旋转角度（200度/秒 = 200 * delta / 1000 度/帧）\n4. 将角度转换为弧度并应用到 Graphics 的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet rotationSpeed = 200; // 每秒 200 度\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制菱形\n  diamond = this.add.graphics();\n  \n  // 设置填充颜色\n  diamond.fillStyle(0x00ff00, 1);\n  \n  // 绘制菱形（使用两个三角形组合）\n  // 菱形中心点在 (0, 0)，四个顶点分别在上下左右\n  const size = 80;\n  \n  // 上三角形\n  diamond.fillTriangle(\n    0, -size,      // 顶点\n    -size, 0,      // 左点\n    size, 0        // 右点\n  );\n  \n  // 下三角形\n  diamond.fillTriangle(\n    -size, 0,      // 左点\n    size, 0,       // 右点\n    0, size        // 底点\n  );\n  \n  // 将菱形移动到画布中心\n  diamond.x = config.width / 2;\n  diamond.y = config.height / 2;\n  \n  // 添加提示文字\n  this.add.text(10, 10, '菱形旋转速度: 200°/秒', {\n    fontSize: '20px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 根据时间增量更新旋转角度\n  // delta 是毫秒，需要转换为秒\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 将角度转换为弧度（Phaser 使用弧度）\n  const rotationRadians = Phaser.Math.DegToRad(rotationDelta);\n  \n  // 累加旋转角度\n  diamond.rotation += rotationRadians;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000465_v2", "prompt_id": "seed_000465", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个青色六边形在 4 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色六边形在4秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制青色六边形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置目标 x 坐标到右侧\n4. 配置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n5. 设置动画持续时间为 4000 毫秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色六边形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制六边形（正六边形）\n  const hexRadius = 40;\n  const sides = 6;\n  const angle = (Math.PI * 2) / sides;\n  \n  graphics.beginPath();\n  for (let i = 0; i < sides; i++) {\n    const x = hexRadius * Math.cos(angle * i - Math.PI / 2);\n    const y = hexRadius * Math.sin(angle * i - Math.PI / 2);\n    \n    if (i === 0) {\n      graphics.moveTo(x + hexRadius, y + hexRadius);\n    } else {\n      graphics.lineTo(x + hexRadius, y + hexRadius);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700,              // 目标位置（右侧）\n    duration: 4000,      // 4秒\n    yoyo: true,          // 往返效果\n    loop: -1,            // 无限循环（-1 表示永久循环）\n    ease: 'Linear'       // 线性缓动\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '青色六边形左右往返循环动画', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000119_v2", "prompt_id": "seed_000119", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 8 个金币，重力 400，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集8个金币，重力400，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力 y: 400\n2. 使用 Graphics 生成玩家纹理（蓝色方块）和金币纹理（黄色圆形）\n3. 创建地面平台和空中平台作为静态物理组\n4. 创建玩家精灵，添加碰撞检测和键盘控制\n5. 生成 8 个金币随机分布在平台上方\n6. 添加玩家与金币的重叠检测，收集时增加分数并销毁金币\n7. 创建分数文本显示，实时更新 score 变量\n[/PLAN]\n\n```javascript\nclass PlatformGame extends Phaser.Scene {\n  constructor() {\n    super('PlatformGame');\n    this.score = 0;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，不依赖外部资源\n    this.createPlayerTexture();\n    this.createCoinTexture();\n    this.createPlatformTexture();\n  }\n\n  createPlayerTexture() {\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x4a90e2, 1);\n    graphics.fillRect(0, 0, 32, 48);\n    graphics.generateTexture('player', 32, 48);\n    graphics.destroy();\n  }\n\n  createCoinTexture() {\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xffd700, 1);\n    graphics.fillCircle(16, 16, 16);\n    graphics.lineStyle(2, 0xffaa00, 1);\n    graphics.strokeCircle(16, 16, 16);\n    graphics.generateTexture('coin', 32, 32);\n    graphics.destroy();\n  }\n\n  createPlatformTexture() {\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x2d572c, 1);\n    graphics.fillRect(0, 0, 400, 32);\n    graphics.generateTexture('platform', 400, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n    this.scoreText.setScrollFactor(0);\n    this.scoreText.setDepth(100);\n\n    // 创建平台静态组\n    this.platforms = this.physics.add.staticGroup();\n\n    // 地面平台\n    this.platforms.create(400, 568, 'platform').setScale(2).refreshBody();\n\n    // 空中平台\n    this.platforms.create(600, 400, 'platform');\n    this.platforms.create(50, 350, 'platform').setScale(0.5).refreshBody();\n    this.platforms.create(750, 300, 'platform').setScale(0.5).refreshBody();\n    this.platforms.create(300, 250, 'platform').setScale(0.6).refreshBody();\n    this.platforms.create(500, 150, 'platform').setScale(0.5).refreshBody();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 450, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 玩家与平台碰撞\n    this.physics.add.collider(this.player, this.platforms);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n\n    // 在不同位置生成 8 个金币\n    const coinPositions = [\n      { x: 600, y: 330 },\n      { x: 50, y: 280 },\n      { x: 750, y: 230 },\n      { x: 300, y: 180 },\n      { x: 500, y: 80 },\n      { x: 150, y: 200 },\n      { x: 650, y: 100 },\n      { x: 400, y: 500 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.2);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 金币与平台碰撞\n    this.physics.add.collider(this.coins, this.platforms);\n\n    // 玩家收集金币\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加提示文本\n    this.add.text(400, 50, 'Use Arrow Keys to Move and Jump!', {\n      fontSize: '20px',\n      fill: '#ffff00',\n      fontFamily: 'Arial'\n    }).setOrigin(0.5);\n  }\n\n  collectCoin(player, coin) {\n    // 销毁金币\n    coin.disableBody(true, true);\n\n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.coins.countActive(true) === 0) {\n      this.add.text(400, 300, 'YOU WIN!', {\n        fontSize: '64px',\n        fill: '#00ff00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6\n      }).setOrigin(0.5);\n    }\n  }\n\n  update() {\n    // 左右移动\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃（只有在地面或平台上才能跳）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-500);\n    }\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: PlatformGame\n};\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001047_v1", "prompt_id": "seed_001047", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 椭圆在1.5秒内从透明到不透明循环渐变\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.GameObjects.Ellipse\nSTEPS:\n1. 使用 Graphics 或 Ellipse 创建椭圆图形\n2. 设置椭圆初始 alpha 为 0（完全透明）\n3. 使用 tweens 创建 alpha 补间动画，从 0 到 1，持续 1.5 秒\n4. 设置 repeat: -1 实现无限循环，yoyo: false 保持单向渐变\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 方法1: 使用 Graphics 绘制椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色椭圆\n  graphics.fillEllipse(0, 0, 150, 100); // 以中心点绘制椭圆\n  \n  // 生成纹理并创建精灵\n  graphics.generateTexture('ellipseTex', 150, 100);\n  graphics.destroy(); // 销毁 graphics 对象\n  \n  const ellipse = this.add.sprite(400, 300, 'ellipseTex');\n  ellipse.alpha = 0; // 初始完全透明\n  \n  // 创建渐变动画：从透明(0)到不透明(1)\n  this.tweens.add({\n    targets: ellipse,\n    alpha: 1, // 目标透明度\n    duration: 1500, // 1.5秒\n    ease: 'Linear', // 线性渐变\n    repeat: -1, // 无限循环\n    yoyo: true // 来回循环（透明->不透明->透明）\n  });\n  \n  // 方法2: 直接使用 Ellipse GameObject（更简洁）\n  // 注释掉上面的代码，取消下面注释即可使用\n  /*\n  const ellipse2 = this.add.ellipse(400, 300, 150, 100, 0x00ff00);\n  ellipse2.alpha = 0;\n  \n  this.tweens.add({\n    targets: ellipse2,\n    alpha: 1,\n    duration: 1500,\n    ease: 'Linear',\n    repeat: -1,\n    yoyo: true\n  });\n  */\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000346_v2", "prompt_id": "seed_000346", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现灰色敌人追踪：敌人以 80 速度追踪玩家位置，玩家速度 80*1.2 可躲避。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Math.Angle", "output": "[PLAN]\nREQ: 实现灰色敌人以80速度追踪玩家，玩家以96速度可躲避\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.ArcadePhysics#moveToObject, Phaser.Input.Keyboard.createCursorKeys\nSTEPS:\n1. 创建带物理系统的场景配置\n2. 使用Graphics生成玩家（蓝色方块）和敌人（灰色圆形）纹理\n3. 在create中创建玩家和敌人精灵，设置物理属性\n4. 在update中处理键盘输入控制玩家移动（速度96）\n5. 在update中使用moveToObject让敌人追踪玩家（速度80）\n6. 添加碰撞检测，碰撞时更新状态信号（health减少）\n7. 显示状态信息（health, distance）用于验证\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.health = 100; // 可验证的状态信号\n    this.distance = 0; // 玩家与敌人的距离\n    this.survived = 0; // 存活时间（秒）\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建敌人纹理（灰色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0x888888, 1);\n    enemyGraphics.fillCircle(20, 20, 20);\n    enemyGraphics.generateTexture('enemy', 40, 40);\n    enemyGraphics.destroy();\n\n    // 创建玩家精灵（在中心位置）\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.setDamping(true);\n    this.player.setDrag(0.8);\n\n    // 创建敌人精灵（在左上角）\n    this.enemy = this.physics.add.sprite(100, 100, 'enemy');\n    this.enemy.setCollideWorldBounds(true);\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 添加碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemy,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 创建状态文本显示\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.statusText.setDepth(100);\n\n    // 添加提示文本\n    this.add.text(400, 550, '使用方向键移动，躲避灰色敌人！', {\n      fontSize: '18px',\n      fill: '#ffff00'\n    }).setOrigin(0.5);\n\n    // 记录开始时间\n    this.startTime = this.time.now;\n    this.lastCollisionTime = 0;\n  }\n\n  update(time, delta) {\n    // 更新存活时间\n    this.survived = ((time - this.startTime) / 1000).toFixed(1);\n\n    // 玩家移动控制（速度 80 * 1.2 = 96）\n    const playerSpeed = 96;\n    const velocity = { x: 0, y: 0 };\n\n    if (this.cursors.left.isDown) {\n      velocity.x = -playerSpeed;\n    } else if (this.cursors.right.isDown) {\n      velocity.x = playerSpeed;\n    }\n\n    if (this.cursors.up.isDown) {\n      velocity.y = -playerSpeed;\n    } else if (this.cursors.down.isDown) {\n      velocity.y = playerSpeed;\n    }\n\n    // 对角线移动时归一化速度\n    if (velocity.x !== 0 && velocity.y !== 0) {\n      const factor = Math.sqrt(2) / 2;\n      velocity.x *= factor;\n      velocity.y *= factor;\n    }\n\n    this.player.setVelocity(velocity.x, velocity.y);\n\n    // 敌人追踪玩家（速度 80）\n    const enemySpeed = 80;\n    this.physics.moveToObject(this.enemy, this.player, enemySpeed);\n\n    // 计算玩家与敌人的距离\n    this.distance = Phaser.Math.Distance.Between(\n      this.player.x,\n      this.player.y,\n      this.enemy.x,\n      this.enemy.y\n    );\n\n    // 更新状态显示\n    this.updateStatus();\n\n    // 检查游戏结束\n    if (this.health <= 0) {\n      this.gameOver();\n    }\n  }\n\n  handleCollision(player, enemy) {\n    // 防止频繁碰撞扣血（每0.5秒最多扣一次）\n    const currentTime = this.time.now;\n    if (currentTime - this.lastCollisionTime > 500) {\n      this.health -= 10;\n      this.lastCollisionTime = currentTime;\n\n      // 碰撞闪烁效果\n      this.player.setTint(0xff0000);\n      this.time.delayedCall(100, () => {\n        this.player.clearTint();\n      });\n\n      // 击退效果\n      const angle = Phaser.Math.Angle.Between(\n        enemy.x,\n        enemy.y,\n        player.x,\n        player.y\n      );\n      player.setVelocity(\n        Math.cos(angle) * 200,\n        Math.sin(angle) * 200\n      );\n    }\n  }\n\n  updateStatus() {\n    const statusLines = [\n      `生命值: ${this.health}`,\n      `距离: ${Math.floor(this.distance)}`,\n      `存活时间: ${this.survived}s`,\n      `玩家速度: 96`,\n      `敌人速度: 80`\n    ];\n    this.statusText.setText(statusLines.join('\\n'));\n  }\n\n  gameOver() {\n    this.physics.pause();\n    \n    const gameOverText = this.add.text(400, 300, 'GAME OVER', {\n      fontSize: '64px',\n      fill: '#ff0000',\n      stroke: '#000000',\n      strokeThickness: 6\n    }).setOrigin(0.5);\n\n    const statsText = this.add.text(400, 380, `存活时间: ${this.survived}秒`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 4\n    }).setOrigin(0.5);\n\n    const restartText = this.add.text(400, 450, '点击重新开始', {\n      fontSize: '20px',\n      fill: '#ffff00'\n    }).setOrigin(0.5);\n\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001121_v2", "prompt_id": "seed_001121", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.835}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆以每秒 80 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆以每秒 80 度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics#fillEllipse, Phaser.GameObjects.Graphics#rotation, Phaser.Scene#update\nSTEPS:\n1. 创建 Graphics 对象并绘制椭圆\n2. 在 create 中初始化椭圆的位置和样式\n3. 在 update 中根据 delta 时间累加旋转角度（80度/秒 = 80 * (delta/1000) 度/帧）\n4. 将角度转换为弧度并应用到 Graphics 的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet ellipseGraphics;\nlet currentRotation = 0; // 当前旋转角度（弧度）\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  ellipseGraphics = this.add.graphics();\n  \n  // 设置填充颜色\n  ellipseGraphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制椭圆（相对于 Graphics 对象的原点）\n  // 参数：x, y, 水平半径, 垂直半径\n  ellipseGraphics.fillEllipse(0, 0, 120, 60);\n  \n  // 设置椭圆位置到屏幕中心\n  ellipseGraphics.setPosition(400, 300);\n  \n  // 添加提示文字\n  this.add.text(400, 50, '椭圆旋转速度: 80度/秒', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nfunction update(time, delta) {\n  // 计算旋转增量：80度/秒 转换为 弧度/毫秒\n  // 80度 = 80 * (Math.PI / 180) 弧度\n  // delta 是毫秒，所以 delta / 1000 转换为秒\n  const rotationSpeed = 80 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000);\n  \n  // 累加旋转角度\n  currentRotation += rotationDelta;\n  \n  // 应用旋转\n  ellipseGraphics.rotation = currentRotation;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000190_v2", "prompt_id": "seed_000190", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 160，重力 400。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可跳跃两次后才需落地，跳跃力度160，重力400\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.Scene\nSTEPS:\n1. 创建 Arcade 物理系统配置，设置重力为 400\n2. 使用 Graphics 生成角色和地面纹理\n3. 创建物理精灵作为角色，添加碰撞体\n4. 监听空格键输入，实现双跳逻辑（跟踪跳跃次数）\n5. 检测角色与地面碰撞，重置跳跃次数\n6. 添加状态变量显示当前剩余跳跃次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#87CEEB'\n};\n\nlet player;\nlet ground;\nlet cursors;\nlet jumpKey;\nlet jumpCount = 0; // 当前已跳跃次数\nconst MAX_JUMPS = 2; // 最大跳跃次数\nconst JUMP_VELOCITY = -160; // 跳跃速度\nlet statusText;\nlet isOnGround = false;\n\nfunction preload() {\n  // 创建角色纹理（绿色方块）\n  const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建地面纹理（棕色矩形）\n  const groundGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  groundGraphics.fillStyle(0x8B4513, 1);\n  groundGraphics.fillRect(0, 0, 800, 64);\n  groundGraphics.generateTexture('ground', 800, 64);\n  groundGraphics.destroy();\n}\n\nfunction create() {\n  // 创建地面\n  ground = this.physics.add.sprite(400, 568, 'ground');\n  ground.setImmovable(true);\n  ground.body.allowGravity = false;\n\n  // 创建玩家\n  player = this.physics.add.sprite(100, 450, 'player');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 设置碰撞检测\n  this.physics.add.collider(player, ground, () => {\n    // 当玩家接触地面时，重置跳跃次数\n    if (player.body.touching.down) {\n      isOnGround = true;\n      jumpCount = 0;\n    }\n  });\n\n  // 设置键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 创建状态文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(16, 50, '按空格键跳跃（可双跳）\\n方向键左右移动', {\n    fontSize: '16px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  updateStatusText();\n}\n\nfunction update() {\n  // 检测是否在地面上\n  if (player.body.touching.down) {\n    if (!isOnGround) {\n      isOnGround = true;\n      jumpCount = 0;\n      updateStatusText();\n    }\n  } else {\n    if (isOnGround) {\n      isOnGround = false;\n    }\n  }\n\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃逻辑（双跳）\n  if (Phaser.Input.Keyboard.JustDown(jumpKey)) {\n    if (jumpCount < MAX_JUMPS) {\n      player.setVelocityY(JUMP_VELOCITY);\n      jumpCount++;\n      updateStatusText();\n    }\n  }\n}\n\nfunction updateStatusText() {\n  const remainingJumps = MAX_JUMPS - jumpCount;\n  const status = isOnGround ? '在地面' : '在空中';\n  statusText.setText(\n    `状态: ${status}\\n` +\n    `剩余跳跃次数: ${remainingJumps}/${MAX_JUMPS}\\n` +\n    `已使用跳跃: ${jumpCount}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001197_v1", "prompt_id": "seed_001197", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 粉色玩家移出边界时从对侧出现（循环地图效果），移动速度 360。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 粉色玩家移出边界时从对侧出现，移动速度360\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard.createCursorKeys, Phaser.GameObjects.Graphics\nSTEPS:\n1. 创建物理系统配置，使用 arcade 物理引擎\n2. 使用 Graphics 绘制粉色方块纹理作为玩家\n3. 创建物理精灵并设置速度为360\n4. 使用键盘方向键控制玩家移动\n5. 在 update 中检测边界，实现循环地图效果（左出右进、右出左进、上出下进、下出上进）\n6. 添加状态变量记录玩家穿越边界次数作为可验证信号\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.crossBoundaryCount = 0; // 可验证的状态信号：穿越边界次数\n  }\n\n  preload() {\n    // 使用 Graphics 创建粉色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF69B4, 1); // 粉色\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('player', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建粉色玩家精灵，位于屏幕中央\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(false); // 不与世界边界碰撞，允许移出\n    \n    // 创建方向键控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // 添加 WASD 键支持\n    this.keys = this.input.keyboard.addKeys({\n      W: Phaser.Input.Keyboard.KeyCodes.W,\n      A: Phaser.Input.Keyboard.KeyCodes.A,\n      S: Phaser.Input.Keyboard.KeyCodes.S,\n      D: Phaser.Input.Keyboard.KeyCodes.D\n    });\n    \n    // 显示穿越边界次数\n    this.scoreText = this.add.text(16, 16, 'Boundary Crosses: 0', {\n      fontSize: '20px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    \n    // 显示控制提示\n    this.add.text(16, 50, 'Use Arrow Keys or WASD to move', {\n      fontSize: '16px',\n      fill: '#cccccc'\n    });\n  }\n\n  update(time, delta) {\n    // 重置速度\n    this.player.setVelocity(0, 0);\n    \n    // 处理键盘输入，设置移动速度为360\n    const speed = 360;\n    \n    if (this.cursors.left.isDown || this.keys.A.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown || this.keys.D.isDown) {\n      this.player.setVelocityX(speed);\n    }\n    \n    if (this.cursors.up.isDown || this.keys.W.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown || this.keys.S.isDown) {\n      this.player.setVelocityY(speed);\n    }\n    \n    // 处理对角线移动时的速度归一化\n    if (this.player.body.velocity.x !== 0 && this.player.body.velocity.y !== 0) {\n      this.player.body.velocity.normalize().scale(speed);\n    }\n    \n    // 循环地图效果：检测边界并从对侧出现\n    const playerWidth = this.player.width;\n    const playerHeight = this.player.height;\n    \n    // 左边界检测\n    if (this.player.x < -playerWidth / 2) {\n      this.player.x = this.cameras.main.width + playerWidth / 2;\n      this.crossBoundaryCount++;\n      this.updateScore();\n    }\n    \n    // 右边界检测\n    if (this.player.x > this.cameras.main.width + playerWidth / 2) {\n      this.player.x = -playerWidth / 2;\n      this.crossBoundaryCount++;\n      this.updateScore();\n    }\n    \n    // 上边界检测\n    if (this.player.y < -playerHeight / 2) {\n      this.player.y = this.cameras.main.height + playerHeight / 2;\n      this.crossBoundaryCount++;\n      this.updateScore();\n    }\n    \n    // 下边界检测\n    if (this.player.y > this.cameras.main.height + playerHeight / 2) {\n      this.player.y = -playerHeight / 2;\n      this.crossBoundaryCount++;\n      this.updateScore();\n    }\n  }\n  \n  updateScore() {\n    this.scoreText.setText('Boundary Crosses: ' + this.crossBoundaryCount);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001187_v1", "prompt_id": "seed_001187", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的粉色椭圆，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制20个随机位置的粉色椭圆，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillEllipse, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景尺寸为 800x600\n2. 在 create 方法中循环 20 次\n3. 每次循环创建一个 Graphics 对象，设置粉色填充样式\n4. 使用 fillEllipse 绘制椭圆（中心点为0,0，半径为32像素）\n5. 使用 setRandomPosition 随机设置椭圆位置在画布范围内\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 循环创建 20 个粉色椭圆\n  for (let i = 0; i < 20; i++) {\n    // 创建 Graphics 对象\n    const graphics = this.add.graphics();\n    \n    // 设置粉色填充样式 (粉色 RGB: 255, 192, 203 -> Hex: 0xFFC0CB)\n    graphics.fillStyle(0xFFC0CB, 1);\n    \n    // 绘制椭圆，中心点在 (0, 0)，宽高各为 64 像素（半径 32）\n    graphics.fillEllipse(0, 0, 64, 64);\n    \n    // 随机设置椭圆位置\n    // 确保椭圆完全在画布内，留出半径的边距\n    graphics.setRandomPosition(32, 32, this.scale.width - 64, this.scale.height - 64);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000727_v3", "prompt_id": "seed_000727", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个简易平台跳跃：角色可左右移动与跳跃，重力为 1000，移动速度 120，与地面碰撞不穿透。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现带重力的平台跳跃游戏，角色可左右移动和跳跃，与地面碰撞检测\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, this.physics.add.sprite, this.physics.add.staticGroup\nSTEPS:\n1. 配置 Arcade 物理系统，设置重力为 1000\n2. 使用 Graphics 创建玩家和地面的纹理\n3. 创建玩家精灵，设置物理属性和碰撞边界\n4. 创建静态地面平台组，添加多个平台\n5. 设置玩家与地面的碰撞检测\n6. 监听键盘输入（左右方向键和空格跳跃）\n7. 在 update 中处理移动逻辑，添加状态变量记录跳跃次数\n[/PLAN]\n\n```javascript\nclass PlatformScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformScene');\n    this.jumpCount = 0; // 可验证的状态信号：跳跃次数\n    this.isGrounded = false; // 是否在地面上\n  }\n\n  preload() {\n    // 使用 Graphics 创建纹理，无需外部资源\n  }\n\n  create() {\n    // 创建玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0088ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 48);\n    playerGraphics.generateTexture('player', 32, 48);\n    playerGraphics.destroy();\n\n    // 创建地面纹理（绿色方块）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x00ff00, 1);\n    groundGraphics.fillRect(0, 0, 200, 32);\n    groundGraphics.generateTexture('ground', 200, 32);\n    groundGraphics.destroy();\n\n    // 创建玩家精灵\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true); // 与世界边界碰撞\n    this.player.body.setGravityY(1000); // 设置重力\n    this.player.setBounce(0); // 无弹跳\n\n    // 创建静态地面平台组\n    this.platforms = this.physics.add.staticGroup();\n    \n    // 添加底部主平台\n    this.platforms.create(400, 568, 'ground').setScale(4, 1).refreshBody();\n    \n    // 添加中间平台\n    this.platforms.create(600, 400, 'ground').setScale(1, 1).refreshBody();\n    this.platforms.create(200, 450, 'ground').setScale(1, 1).refreshBody();\n    this.platforms.create(400, 300, 'ground').setScale(1, 1).refreshBody();\n\n    // 设置玩家与平台的碰撞\n    this.physics.add.collider(this.player, this.platforms, () => {\n      this.isGrounded = true;\n    });\n\n    // 设置键盘输入\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(16, 16, '', {\n      fontSize: '18px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加控制说明\n    this.add.text(16, 50, 'Controls: Arrow Keys to move, SPACE to jump', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n  }\n\n  update(time, delta) {\n    // 更新状态文本\n    this.statusText.setText([\n      `Jump Count: ${this.jumpCount}`,\n      `Grounded: ${this.isGrounded}`,\n      `Velocity Y: ${Math.round(this.player.body.velocity.y)}`,\n      `Position: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`\n    ]);\n\n    // 重置接地状态（每帧开始时）\n    this.isGrounded = false;\n\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-120); // 向左移动，速度 120\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(120); // 向右移动，速度 120\n    } else {\n      this.player.setVelocityX(0); // 停止移动\n    }\n\n    // 跳跃控制（仅在接地时可跳跃）\n    if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && this.player.body.touching.down) {\n      this.player.setVelocityY(-500); // 跳跃速度\n      this.jumpCount++; // 增加跳跃计数\n    }\n\n    // 检测是否接地（用于下一帧的跳跃判断）\n    if (this.player.body.touching.down) {\n      this.isGrounded = true;\n    }\n  }\n}\n\n// Phaser 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB', // 天空蓝背景\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 全局重力为 0，在玩家上单独设置\n      debug: false // 设为 true 可查看物理边界\n    }\n  },\n  scene: PlatformScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000930_v3", "prompt_id": "seed_000930", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9299999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个蓝色菱形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 蓝色菱形2.5秒左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.yoyo, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制蓝色菱形并生成纹理\n2. 创建精灵对象并应用菱形纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返效果\n5. 配置 loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制蓝色菱形\n  const graphics = this.add.graphics();\n  \n  // 设置蓝色填充\n  graphics.fillStyle(0x0088ff, 1);\n  \n  // 绘制菱形（四个顶点）\n  // 中心点在 (30, 30)，菱形大小为 60x60\n  graphics.beginPath();\n  graphics.moveTo(30, 0);      // 上顶点\n  graphics.lineTo(60, 30);     // 右顶点\n  graphics.lineTo(30, 60);     // 下顶点\n  graphics.lineTo(0, 30);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamond', 60, 60);\n  graphics.destroy();\n  \n  // 创建精灵对象，初始位置在左侧\n  const diamond = this.add.sprite(100, 300, 'diamond');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: diamond,           // 动画目标对象\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 2500,             // 持续时间 2.5 秒\n    yoyo: true,                 // 往返效果（到达终点后反向回到起点）\n    loop: -1,                   // 无限循环（-1 表示永久循环）\n    ease: 'Linear'              // 线性缓动，匀速移动\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000719_v1", "prompt_id": "seed_000719", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个矩形在 1 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 矩形透明度从0到1循环渐变动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个矩形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为0\n3. 使用 Tween 动画控制 alpha 属性从0到1，duration 1000ms\n4. 设置 yoyo 和 repeat -1 实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制矩形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色矩形\n  graphics.fillRect(0, 0, 200, 150);\n  graphics.generateTexture('rectTexture', 200, 150);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 创建精灵对象，放置在屏幕中心\n  const rect = this.add.sprite(400, 300, 'rectTexture');\n  rect.setAlpha(0); // 初始透明度为0\n\n  // 创建 Tween 动画，控制透明度从0到1循环渐变\n  this.tweens.add({\n    targets: rect,           // 动画目标对象\n    alpha: 1,                // 目标透明度值\n    duration: 1000,          // 动画持续时间 1秒\n    ease: 'Linear',          // 线性缓动\n    yoyo: true,              // 反向播放（1 -> 0）\n    repeat: -1               // 无限循环\n  });\n\n  // 添加文字提示\n  this.add.text(400, 50, 'Rectangle Fade Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000084_v3", "prompt_id": "seed_000084", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色星形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色星形以240速度移动并在边界反弹\nAPI: Graphics.fillStyle, Graphics.fillStar, Graphics.generateTexture, Physics.Arcade.Sprite, Physics.World.setBoundsCollision, Sprite.setVelocity, Sprite.setBounce, Sprite.setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制青色星形并生成纹理\n2. 创建启用物理的精灵对象，应用星形纹理\n3. 设置精灵速度为240（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色星形\n  const graphics = this.add.graphics();\n  \n  // 设置青色填充\n  graphics.fillStyle(0x00ffff, 1);\n  \n  // 绘制星形 (x, y, points, innerRadius, outerRadius)\n  // 中心点设为 (40, 40)，5个角，内半径20，外半径40\n  graphics.fillStar(40, 40, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 80, 80);\n  \n  // 销毁 graphics 对象（纹理已生成）\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'star');\n  \n  // 设置初始速度（斜向移动，速度大约为240）\n  // 使用勾股定理：sqrt(170^2 + 170^2) ≈ 240\n  star.setVelocity(170, 170);\n  \n  // 设置完全反弹（弹性系数为1）\n  star.setBounce(1, 1);\n  \n  // 启用与世界边界的碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 确保物理体大小与显示对象匹配\n  star.body.setSize(80, 80);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000033_v3", "prompt_id": "seed_000033", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现相机跟随：让一个自动向左移动的星形在场景中移动，相机跟随该对象并保持居中。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 实现相机跟随自动向左移动的星形对象并保持居中\nAPI: Phaser.GameObjects.Graphics, Phaser.Cameras.Scene2D.Camera#startFollow, Phaser.GameObjects.Star, Graphics#generateTexture\nSTEPS:\n1. 创建场景并使用 Graphics 绘制星形纹理\n2. 创建星形精灵对象并设置初始位置\n3. 在 create 中让星形自动向左移动（使用 setVelocity 或 tween）\n4. 使用 camera.startFollow 让相机跟随星形对象\n5. 在 update 中持续更新星形位置实现左移效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet star;\nlet moveSpeed = 150; // 每秒移动的像素数\n\nfunction preload() {\n  // 使用 Graphics 创建星形纹理\n  const graphics = this.make.graphics({ x: 0, y: 0, add: false });\n  \n  // 绘制黄色星形\n  graphics.fillStyle(0xffff00, 1);\n  graphics.fillStar(32, 32, 5, 16, 30, 0);\n  \n  // 生成纹理\n  graphics.generateTexture('star', 64, 64);\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建一个大的世界边界，让星形有足够的移动空间\n  this.cameras.main.setBounds(-2000, 0, 4000, 600);\n  \n  // 在场景右侧创建星形\n  star = this.add.sprite(400, 300, 'star');\n  star.setOrigin(0.5, 0.5);\n  \n  // 设置相机跟随星形，保持居中\n  this.cameras.main.startFollow(star, true, 0.1, 0.1);\n  \n  // 添加一些参考背景元素，帮助观察相机移动\n  const graphics = this.add.graphics();\n  \n  // 绘制网格作为参考\n  graphics.lineStyle(1, 0x444444, 0.5);\n  for (let x = -2000; x < 2000; x += 100) {\n    graphics.moveTo(x, 0);\n    graphics.lineTo(x, 600);\n  }\n  for (let y = 0; y < 600; y += 100) {\n    graphics.moveTo(-2000, y);\n    graphics.lineTo(2000, y);\n  }\n  graphics.strokePath();\n  \n  // 添加一些静态的圆形作为参考点\n  for (let i = -10; i < 10; i++) {\n    const circle = this.add.graphics();\n    circle.fillStyle(0x00ff00, 0.3);\n    circle.fillCircle(i * 200, 300, 20);\n  }\n  \n  // 添加提示文本（固定在相机上）\n  const text = this.add.text(10, 10, '相机跟随星形向左移动', {\n    fontSize: '20px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n  text.setScrollFactor(0); // 固定文本在屏幕上，不随相机移动\n}\n\nfunction update(time, delta) {\n  // 让星形持续向左移动\n  // delta 是毫秒，转换为秒\n  star.x -= moveSpeed * (delta / 1000);\n  \n  // 可选：当星形移动到很远的位置时重置（循环效果）\n  if (star.x < -1500) {\n    star.x = 1500;\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000555_v2", "prompt_id": "seed_000555", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Camera"], "quality_score": 0.8792857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个粉色椭圆在 1 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色椭圆在1秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制粉色椭圆并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 配置 yoyo 为 true 实现往返，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 创建粉色椭圆纹理\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1);\n  \n  // 绘制椭圆（中心点在 50, 30，宽度 100，高度 60）\n  graphics.fillEllipse(50, 30, 100, 60);\n  \n  // 生成纹理\n  graphics.generateTexture('pinkEllipse', 100, 60);\n  \n  // 销毁 graphics 对象\n  graphics.destroy();\n}\n\nfunction create() {\n  // 创建椭圆精灵，初始位置在左侧\n  const ellipse = this.add.sprite(100, 300, 'pinkEllipse');\n  \n  // 创建补间动画\n  this.tweens.add({\n    targets: ellipse,           // 动画目标对象\n    x: 700,                     // 目标 x 坐标（右侧）\n    duration: 1000,             // 持续时间 1 秒（1000 毫秒）\n    ease: 'Linear',             // 线性缓动\n    yoyo: true,                 // 启用往返（到达终点后反向播放）\n    loop: -1                    // 无限循环（-1 表示永久循环）\n  });\n  \n  // 添加说明文字\n  this.add.text(400, 50, '粉色椭圆左右往返循环', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000012_v2", "prompt_id": "seed_000012", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用对象池管理 12 个灰色可复用对象，对象离开屏幕后自动回收并重新使用。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 使用对象池管理 12 个灰色可复用对象，离开屏幕后自动回收重用\nAPI: Phaser.Physics.Arcade.Group, Graphics.generateTexture, Group.get, Group.killAndHide\nSTEPS:\n1. 创建灰色方块纹理（使用 Graphics.generateTexture）\n2. 使用 Physics.Arcade.Group 创建对象池，初始化 12 个对象\n3. 在 create 中设置对象池配置（maxSize, runChildUpdate）\n4. 实现对象发射逻辑，从对象池获取对象并设置随机速度\n5. 在 update 中检测对象是否离开屏幕，离开则回收到对象池\n6. 添加状态信号：activeCount（当前活跃对象数）、recycledCount（已回收次数）\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.activeCount = 0;\n    this.recycledCount = 0;\n    this.totalSpawned = 0;\n  }\n\n  preload() {\n    // 创建灰色方块纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0x808080, 1);\n    graphics.fillRect(0, 0, 32, 32);\n    graphics.generateTexture('grayBox', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理对象池\n    this.objectPool = this.physics.add.group({\n      defaultKey: 'grayBox',\n      maxSize: 12,\n      runChildUpdate: true,\n      createCallback: (obj) => {\n        obj.setActive(false);\n        obj.setVisible(false);\n      }\n    });\n\n    // 预创建 12 个对象到池中\n    for (let i = 0; i < 12; i++) {\n      const obj = this.objectPool.create(0, 0, 'grayBox');\n      obj.setActive(false);\n      obj.setVisible(false);\n    }\n\n    // 添加状态显示文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 定时发射对象\n    this.time.addEvent({\n      delay: 500,\n      callback: this.spawnObject,\n      callbackScope: this,\n      loop: true\n    });\n\n    // 添加点击重置功能\n    this.input.on('pointerdown', () => {\n      this.recycledCount = 0;\n      this.totalSpawned = 0;\n    });\n\n    // 添加说明文本\n    this.add.text(10, 550, 'Click to reset counters', {\n      fontSize: '14px',\n      fill: '#cccccc'\n    });\n  }\n\n  spawnObject() {\n    // 从对象池获取对象\n    const obj = this.objectPool.get();\n    \n    if (obj) {\n      // 随机位置生成（顶部）\n      const x = Phaser.Math.Between(50, 750);\n      obj.setPosition(x, -20);\n      \n      // 设置随机速度\n      const velocityX = Phaser.Math.Between(-100, 100);\n      const velocityY = Phaser.Math.Between(100, 300);\n      obj.setVelocity(velocityX, velocityY);\n      \n      // 激活对象\n      obj.setActive(true);\n      obj.setVisible(true);\n      \n      this.totalSpawned++;\n    }\n  }\n\n  update() {\n    // 更新活跃对象计数\n    this.activeCount = 0;\n    \n    // 检查所有对象\n    this.objectPool.children.entries.forEach((obj) => {\n      if (obj.active) {\n        this.activeCount++;\n        \n        // 检查是否离开屏幕\n        if (obj.y > 620 || obj.x < -50 || obj.x > 850) {\n          // 回收对象\n          obj.setActive(false);\n          obj.setVisible(false);\n          obj.setVelocity(0, 0);\n          this.recycledCount++;\n        }\n      }\n    });\n\n    // 更新状态显示\n    this.statusText.setText([\n      `Pool Size: 12`,\n      `Active Objects: ${this.activeCount}`,\n      `Recycled Count: ${this.recycledCount}`,\n      `Total Spawned: ${this.totalSpawned}`,\n      `Available in Pool: ${12 - this.activeCount}`\n    ]);\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001090_v1", "prompt_id": "seed_001090", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8542857142857143}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个圆形在 1.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 圆形从透明到不透明循环渐变动画\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个圆形并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画将 alpha 从 0 渐变到 1，持续 1.5 秒\n4. 设置 Tween 为循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制圆形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色圆形\n  graphics.fillCircle(50, 50, 50); // 在 (50, 50) 位置绘制半径为 50 的圆\n  graphics.generateTexture('circle', 100, 100); // 生成 100x100 的纹理\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建圆形精灵并设置初始透明度为 0\n  const circle = this.add.sprite(400, 300, 'circle');\n  circle.setAlpha(0); // 初始完全透明\n\n  // 创建渐变动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    alpha: 1,                  // 目标透明度为 1（完全不透明）\n    duration: 1500,            // 持续时间 1.5 秒（1500 毫秒）\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 往返播放（不透明后再变回透明）\n    repeat: -1                 // 无限循环\n  });\n\n  // 添加文字说明\n  this.add.text(400, 550, 'Circle fading from transparent to opaque (looping)', {\n    fontSize: '18px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000667_v2", "prompt_id": "seed_000667", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个六边形在 3 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个六边形在 3 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个六边形并生成纹理\n2. 创建一个 Sprite 使用该六边形纹理\n3. 设置 Sprite 初始 alpha 为 0（完全透明）\n4. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 3 秒，设置循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色（蓝色）\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制六边形（正六边形）\n  const hexRadius = 80;\n  const centerX = 100;\n  const centerY = 100;\n  \n  // 计算六边形的六个顶点\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push(x, y);\n  }\n  \n  // 绘制多边形\n  graphics.beginPath();\n  graphics.moveTo(points[0], points[1]);\n  for (let i = 2; i < points.length; i += 2) {\n    graphics.lineTo(points[i], points[i + 1]);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 200, 200);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建使用六边形纹理的精灵\n  const hexSprite = this.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始透明度为 0\n  hexSprite.setAlpha(0);\n  \n  // 创建 Tween 动画：从透明到不透明，3 秒内完成，循环播放\n  this.tweens.add({\n    targets: hexSprite,\n    alpha: 1, // 目标透明度为 1（完全不透明）\n    duration: 3000, // 持续 3 秒（3000 毫秒）\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（从 0 到 1，再从 1 到 0）\n    repeat: -1 // 无限循环\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000337_v1", "prompt_id": "seed_000337", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在画布中央绘制一个粉色星形，大小约为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 在画布中央绘制一个粉色星形，大小约为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布尺寸为 800x600\n2. 在 create 方法中创建 Graphics 对象\n3. 计算星形的 5 个外顶点和 5 个内顶点坐标（使用三角函数）\n4. 使用 Graphics API 绘制星形路径并填充粉色\n5. 将星形定位在画布中央 (400, 300)\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象\n  const graphics = this.add.graphics();\n  \n  // 设置粉色填充\n  graphics.fillStyle(0xff69b4, 1); // 粉色 (HotPink)\n  \n  // 画布中心坐标\n  const centerX = 400;\n  const centerY = 300;\n  \n  // 星形参数\n  const outerRadius = 32; // 外半径\n  const innerRadius = 16; // 内半径\n  const points = 5; // 五角星\n  \n  // 开始绘制路径\n  graphics.beginPath();\n  \n  // 计算并绘制星形的顶点\n  for (let i = 0; i < points * 2; i++) {\n    // 角度：每个顶点间隔 36 度（360 / 10）\n    const angle = (i * Math.PI) / points - Math.PI / 2; // 从顶部开始\n    \n    // 交替使用外半径和内半径\n    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n    \n    // 计算顶点坐标\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    // 第一个点移动到该位置，其余点连线\n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  \n  // 闭合路径\n  graphics.closePath();\n  \n  // 填充星形\n  graphics.fillPath();\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000754_v2", "prompt_id": "seed_000754", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个白色椭圆以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 白色椭圆以200速度移动并在画布边界反弹\nAPI: Graphics.fillEllipse, Scene.physics, ArcadePhysics.add.existing, Body.setBounce, Body.setCollideWorldBounds, Body.setVelocity\nSTEPS:\n1. 创建 Arcade 物理系统配置\n2. 使用 Graphics 绘制白色椭圆并生成纹理\n3. 创建 Sprite 并启用物理体\n4. 设置初始速度为 200（x和y方向各141.4，保证合速度为200）\n5. 设置边界碰撞和反弹系数为1实现完美反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: { preload, create, update },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制白色椭圆\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xffffff, 1); // 白色\n  graphics.fillEllipse(40, 30, 80, 60); // 中心点(40,30)，宽80，高60\n  \n  // 生成纹理\n  graphics.generateTexture('ellipse', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建椭圆精灵并放置在画布中心\n  this.ellipse = this.physics.add.sprite(400, 300, 'ellipse');\n  \n  // 设置初始速度（200的速度，斜向移动）\n  // 使用勾股定理：vx² + vy² = 200²\n  // 设置为45度角移动：vx = vy = 200/√2 ≈ 141.4\n  this.ellipse.setVelocity(141.4, 141.4);\n  \n  // 设置边界碰撞\n  this.ellipse.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完美反弹，不损失速度）\n  this.ellipse.setBounce(1, 1);\n}\n\nfunction update(time, delta) {\n  // 确保速度始终保持在200左右（由于浮点数误差可能会有微小变化）\n  const body = this.ellipse.body;\n  const currentSpeed = Math.sqrt(body.velocity.x ** 2 + body.velocity.y ** 2);\n  \n  // 如果速度偏离200太多，进行修正\n  if (Math.abs(currentSpeed - 200) > 1) {\n    const scale = 200 / currentSpeed;\n    body.setVelocity(body.velocity.x * scale, body.velocity.y * scale);\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000409_v2", "prompt_id": "seed_000409", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色三角形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色三角形以240速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制青色三角形并生成纹理\n2. 创建 Arcade 物理精灵并应用三角形纹理\n3. 设置精灵速度为240，启用世界边界碰撞和反弹\n4. 配置物理系统使精灵在碰到边界时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置速度为240（随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 240;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 240;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：让三角形朝向运动方向旋转\n  this.physics.world.on('worldbounds', () => {\n    // 边界碰撞时的额外处理（可选）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000256_v3", "prompt_id": "seed_000256", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个椭圆在 2.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个椭圆在 2.5 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 在 create 中使用 Graphics 绘制一个椭圆\n2. 设置椭圆初始 alpha 为 0（完全透明）\n3. 使用 tweens.add 创建一个 alpha 补间动画，从 0 到 1，持续 2500 毫秒\n4. 设置 tween 的 yoyo 为 true 或 repeat 为 -1，实现循环播放\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象绘制椭圆\n  const graphics = this.add.graphics();\n  \n  // 设置填充样式（蓝色）\n  graphics.fillStyle(0x00aaff, 1);\n  \n  // 绘制椭圆（中心位置，半径 x, 半径 y）\n  graphics.fillEllipse(400, 300, 150, 100);\n  \n  // 设置初始透明度为 0（完全透明）\n  graphics.alpha = 0;\n  \n  // 创建补间动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: graphics,\n    alpha: 1,                    // 目标透明度为 1（完全不透明）\n    duration: 2500,              // 持续时间 2.5 秒\n    ease: 'Linear',              // 线性缓动\n    repeat: -1,                  // 无限循环\n    yoyo: true                   // 来回播放（透明→不透明→透明）\n  });\n  \n  // 添加文本提示\n  this.add.text(400, 50, 'Ellipse Fade Animation', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, 'Alpha: 0 → 1 → 0 (2.5s cycle)', {\n    fontSize: '18px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000326_v3", "prompt_id": "seed_000326", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个菱形移动，速度为 200 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制菱形以 200 像素/秒速度移动\nAPI: Graphics.fillStyle, Graphics.beginPath, Graphics.moveTo, Graphics.lineTo, Graphics.closePath, Graphics.fillPath, Input.Keyboard.addKeys, GameObject.x, GameObject.y\nSTEPS:\n1. 使用 Graphics 绘制菱形形状并生成纹理\n2. 创建 Sprite 使用生成的菱形纹理\n3. 使用 addKeys 监听 WASD 键盘输入\n4. 在 update 中根据按键状态更新菱形位置，速度为 200 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet diamond;\nlet keys;\nconst SPEED = 200; // 像素/秒\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制菱形并生成纹理\n  const graphics = this.add.graphics();\n  \n  // 设置填充颜色为蓝色\n  graphics.fillStyle(0x3498db, 1);\n  \n  // 绘制菱形（中心点在 32, 32，边长约 32 像素）\n  graphics.beginPath();\n  graphics.moveTo(32, 0);      // 上顶点\n  graphics.lineTo(64, 32);     // 右顶点\n  graphics.lineTo(32, 64);     // 下顶点\n  graphics.lineTo(0, 32);      // 左顶点\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('diamondTexture', 64, 64);\n  graphics.destroy(); // 销毁 graphics 对象，因为纹理已生成\n  \n  // 创建菱形精灵，初始位置在屏幕中心\n  diamond = this.add.sprite(400, 300, 'diamondTexture');\n  \n  // 设置键盘输入 - WASD\n  keys = this.input.keyboard.addKeys({\n    w: Phaser.Input.Keyboard.KeyCodes.W,\n    a: Phaser.Input.Keyboard.KeyCodes.A,\n    s: Phaser.Input.Keyboard.KeyCodes.S,\n    d: Phaser.Input.Keyboard.KeyCodes.D\n  });\n  \n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the diamond', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧应移动的距离（速度 * 时间差 / 1000）\n  const distance = SPEED * (delta / 1000);\n  \n  // 根据按键状态更新菱形位置\n  if (keys.w.isDown) {\n    diamond.y -= distance; // 向上移动\n  }\n  if (keys.s.isDown) {\n    diamond.y += distance; // 向下移动\n  }\n  if (keys.a.isDown) {\n    diamond.x -= distance; // 向左移动\n  }\n  if (keys.d.isDown) {\n    diamond.x += distance; // 向右移动\n  }\n  \n  // 可选：限制菱形在屏幕范围内\n  diamond.x = Phaser.Math.Clamp(diamond.x, 32, 768);\n  diamond.y = Phaser.Math.Clamp(diamond.y, 32, 568);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000464_v3", "prompt_id": "seed_000464", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个绿色六边形在 2.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色六边形在2.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 创建精灵对象并设置初始位置在左侧\n3. 使用 tweens 创建补间动画，设置 yoyo 和 loop 实现往返循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制六边形（正六边形）\n  const hexRadius = 40; // 六边形半径\n  const centerX = 50;\n  const centerY = 50;\n  \n  graphics.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 60度间隔\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    \n    if (i === 0) {\n      graphics.moveTo(x, y);\n    } else {\n      graphics.lineTo(x, y);\n    }\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建精灵对象\n  const hexSprite = this.add.sprite(100, 300, 'hexagon');\n  \n  // 创建补间动画：从左到右往返循环\n  this.tweens.add({\n    targets: hexSprite,\n    x: 700, // 目标位置（右侧）\n    duration: 2500, // 2.5秒\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 启用往返效果\n    repeat: -1 // 无限循环（-1 表示永久重复）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000482_v3", "prompt_id": "seed_000482", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制5个随机位置的粉色圆形，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制5个随机位置的粉色圆形，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillCircle, Graphics.setRandomPosition\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中循环创建5个 Graphics 对象\n3. 每个 Graphics 对象绘制一个粉色圆形（半径32像素，直径64像素）\n4. 使用 setRandomPosition 方法将每个圆形放置在随机位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 粉色颜色值\n  const pinkColor = 0xff69b4;\n  // 圆形半径（直径64像素，半径32像素）\n  const radius = 32;\n  \n  // 创建5个随机位置的粉色圆形\n  for (let i = 0; i < 5; i++) {\n    // 创建 Graphics 对象\n    const circle = this.add.graphics();\n    \n    // 设置填充样式为粉色\n    circle.fillStyle(pinkColor, 1);\n    \n    // 绘制圆形（圆心在原点，半径32）\n    circle.fillCircle(0, 0, radius);\n    \n    // 设置随机位置（确保圆形完全在画布内）\n    circle.setRandomPosition(\n      radius,              // x 最小值\n      radius,              // y 最小值\n      800 - radius * 2,    // x 范围\n      600 - radius * 2     // y 范围\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000767_v1", "prompt_id": "seed_000767", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现弹性碰撞：20 个橙色小球以 360 速度在封闭空间内移动，碰到边界和彼此时弹开。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 20个橙色小球在封闭空间内以360速度移动，碰到边界和彼此时发生弹性碰撞\nAPI: Phaser.Physics.Arcade.Group, Phaser.Physics.Arcade.Components.Bounce, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.World.setBoundsCollision\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成橙色圆形纹理\n3. 创建物理组，添加 20 个小球精灵\n4. 为每个小球设置随机初始位置和随机方向的速度（速度大小为360）\n5. 设置小球的弹性系数为1（完全弹性碰撞）\n6. 启用世界边界碰撞和小球之间的碰撞检测\n7. 添加状态信号变量记录碰撞次数\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.collisionCount = 0; // 状态信号：碰撞计数\n    this.ballsCreated = 0; // 状态信号：创建的小球数量\n  }\n\n  preload() {\n    // 使用 Graphics 创建橙色圆形纹理\n    const graphics = this.add.graphics();\n    graphics.fillStyle(0xFF8800, 1); // 橙色\n    graphics.fillCircle(16, 16, 16); // 半径16的圆\n    graphics.generateTexture('orangeBall', 32, 32);\n    graphics.destroy();\n  }\n\n  create() {\n    // 创建物理组\n    this.balls = this.physics.add.group({\n      bounceX: 1,\n      bounceY: 1,\n      collideWorldBounds: true\n    });\n\n    // 创建20个小球\n    const ballCount = 20;\n    const speed = 360;\n    \n    for (let i = 0; i < ballCount; i++) {\n      // 随机位置（避免太靠近边界）\n      const x = Phaser.Math.Between(50, 750);\n      const y = Phaser.Math.Between(50, 550);\n      \n      // 创建小球\n      const ball = this.balls.create(x, y, 'orangeBall');\n      \n      // 设置圆形碰撞体\n      ball.setCircle(16);\n      ball.body.setCollideWorldBounds(true);\n      ball.body.setBounce(1, 1); // 完全弹性碰撞\n      \n      // 随机方向的速度\n      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n      const velocityX = Math.cos(angle) * speed;\n      const velocityY = Math.sin(angle) * speed;\n      \n      ball.setVelocity(velocityX, velocityY);\n      \n      this.ballsCreated++;\n    }\n\n    // 启用小球之间的碰撞\n    this.physics.add.collider(this.balls, this.balls, this.onBallCollision, null, this);\n\n    // 添加文本显示状态信息\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 监听世界边界碰撞\n    this.physics.world.on('worldbounds', () => {\n      this.collisionCount++;\n    });\n  }\n\n  onBallCollision(ball1, ball2) {\n    // 记录碰撞次数\n    this.collisionCount++;\n  }\n\n  update(time, delta) {\n    // 更新状态显示\n    this.statusText.setText([\n      `Balls: ${this.ballsCreated}`,\n      `Collisions: ${this.collisionCount}`,\n      `Active: ${this.balls.countActive()}`\n    ]);\n\n    // 确保速度恒定（补偿物理引擎的微小误差）\n    this.balls.children.entries.forEach(ball => {\n      const currentSpeed = Math.sqrt(\n        ball.body.velocity.x ** 2 + \n        ball.body.velocity.y ** 2\n      );\n      \n      // 如果速度偏差超过5%，重新标准化\n      if (Math.abs(currentSpeed - 360) > 18) {\n        const scale = 360 / currentSpeed;\n        ball.body.velocity.x *= scale;\n        ball.body.velocity.y *= scale;\n      }\n    });\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 }, // 无重力\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000963_v3", "prompt_id": "seed_000963", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色六边形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色六边形以200速度移动并在画布边界反弹\nAPI: Graphics, Polygon, Physics.Arcade, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制绿色六边形并生成纹理\n2. 启用 Arcade 物理系统创建精灵对象\n3. 设置初始速度为 200，启用世界边界碰撞和反弹\n4. 配置物理边界使对象在碰到画布边缘时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建六边形的顶点坐标（半径为30的正六边形）\n  const hexRadius = 30;\n  const hexPoints = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i - Math.PI / 2; // 从顶部开始\n    hexPoints.push({\n      x: hexRadius * Math.cos(angle),\n      y: hexRadius * Math.sin(angle)\n    });\n  }\n\n  // 使用 Graphics 绘制绿色六边形并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  graphics.lineStyle(2, 0x00cc00, 1); // 深绿色边框\n  \n  // 绘制六边形\n  graphics.beginPath();\n  graphics.moveTo(hexPoints[0].x + hexRadius, hexPoints[0].y + hexRadius);\n  for (let i = 1; i < hexPoints.length; i++) {\n    graphics.lineTo(hexPoints[i].x + hexRadius, hexPoints[i].y + hexRadius);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  graphics.strokePath();\n\n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n\n  // 创建物理精灵对象\n  const hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n\n  // 设置初始速度（随机方向，速度为200）\n  const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);\n  const velocityX = Math.cos(angle) * 200;\n  const velocityY = Math.sin(angle) * 200;\n  hexagon.setVelocity(velocityX, velocityY);\n\n  // 启用世界边界碰撞\n  hexagon.setCollideWorldBounds(true);\n\n  // 设置反弹系数为1（完全弹性碰撞）\n  hexagon.setBounce(1, 1);\n\n  // 添加说明文字\n  this.add.text(10, 10, '绿色六边形以200速度移动\\n碰到边界时反弹', {\n    fontSize: '16px',\n    color: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000710_v1", "prompt_id": "seed_000710", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个粉色三角形以 200 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 粉色三角形以200速度移动并在画布边界反弹\nAPI: Graphics.fillTriangle, Scene.physics, Physics.Arcade.Body.setBounce, Physics.Arcade.Body.setCollideWorldBounds, Physics.Arcade.Body.setVelocity\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 绘制粉色三角形并生成纹理\n3. 创建物理精灵并应用三角形纹理\n4. 设置初始速度为200（x和y方向）\n5. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制粉色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff69b4, 1); // 粉色\n  \n  // 绘制三角形（等边三角形）\n  // 三个顶点坐标：顶部中心、左下、右下\n  graphics.fillTriangle(\n    30, 10,   // 顶点\n    10, 50,   // 左下\n    50, 50    // 右下\n  );\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 60, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（200 速度，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 200;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 200;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 启用世界边界碰撞\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 可选：添加一些文字说明\n  this.add.text(10, 10, '粉色三角形以200速度移动\\n碰到边界会反弹', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000164_v1", "prompt_id": "seed_000164", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色三角形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绿色三角形以360速度移动，碰到边界反弹\nAPI: Graphics, Physics.Arcade, Sprite, setVelocity, setBounce, setCollideWorldBounds\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 启用 Arcade 物理系统创建精灵\n3. 设置初始速度为 360，启用世界边界碰撞和反弹\n4. 配置物理世界边界与画布大小一致\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制三角形（等边三角形，中心在原点）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);    // 顶点\n  graphics.lineTo(-26, 15);   // 左下角\n  graphics.lineTo(26, 15);    // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建物理精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度大小为 360）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * 360;\n  const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * 360;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞世界边界\n  triangle.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为 1（完全弹性碰撞）\n  triangle.setBounce(1, 1);\n  \n  // 确保世界边界与画布大小一致\n  this.physics.world.setBounds(0, 0, 800, 600);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000462_v1", "prompt_id": "seed_000462", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 2 秒内从原始大小缩放到 80%，然后恢复，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用缓动动画让方块在2秒内缩放到80%后恢复，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.BaseTween.loop\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象使用生成的纹理\n3. 使用 tweens 创建缩放动画，从 scale 1.0 到 0.8 再回到 1.0\n4. 设置动画循环播放（loop: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 使用 Graphics 生成方块纹理\n  const graphics = this.add.graphics();\n  \n  // 绘制一个蓝色方块\n  graphics.fillStyle(0x4a90e2, 1);\n  graphics.fillRect(0, 0, 100, 100);\n  \n  // 生成纹理并命名为 'box'\n  graphics.generateTexture('box', 100, 100);\n  \n  // 销毁 graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n}\n\nfunction create() {\n  // 在屏幕中央创建方块精灵\n  const box = this.add.sprite(400, 300, 'box');\n  \n  // 创建缩放动画\n  this.tweens.add({\n    targets: box,           // 动画目标对象\n    scaleX: 0.8,           // X轴缩放到 80%\n    scaleY: 0.8,           // Y轴缩放到 80%\n    duration: 2000,        // 动画持续时间 2 秒\n    yoyo: true,            // 启用往返效果（缩放后恢复）\n    repeat: -1,            // 无限循环（-1 表示永久重复）\n    ease: 'Sine.easeInOut' // 使用正弦缓动函数，使动画更平滑\n  });\n  \n  // 添加提示文本\n  this.add.text(400, 50, '方块缩放动画循环播放', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n  \n  this.add.text(400, 550, '缩放范围: 100% ↔ 80%，周期: 4秒', {\n    fontSize: '16px',\n    color: '#aaaaaa'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000548_v3", "prompt_id": "seed_000548", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个红色六边形以 160 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色六边形以160速度移动并在画布边界反弹\nAPI: Graphics, Physics.Arcade, Scene\nSTEPS:\n1. 使用 Graphics 绘制红色六边形并生成纹理\n2. 创建带有 Arcade 物理的精灵对象\n3. 设置初始速度为 160（使用速度向量）\n4. 在 update 中检测边界碰撞并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet hexagon;\nlet velocity = { x: 160, y: 0 }; // 初始水平移动\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色六边形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制六边形（中心点在原点）\n  const hexRadius = 30;\n  const hexPath = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i;\n    hexPath.push({\n      x: hexRadius + hexRadius * Math.cos(angle),\n      y: hexRadius + hexRadius * Math.sin(angle)\n    });\n  }\n  \n  graphics.beginPath();\n  graphics.moveTo(hexPath[0].x, hexPath[0].y);\n  for (let i = 1; i < hexPath.length; i++) {\n    graphics.lineTo(hexPath[i].x, hexPath[i].y);\n  }\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  hexagon = this.physics.add.sprite(400, 300, 'hexagon');\n  \n  // 设置初始速度（速度大小为160，方向为右上45度）\n  const speed = 160;\n  const angle = Phaser.Math.DegToRad(45);\n  hexagon.setVelocity(\n    Math.cos(angle) * speed,\n    Math.sin(angle) * speed\n  );\n  \n  // 设置碰撞边界\n  hexagon.setCollideWorldBounds(false); // 我们手动处理反弹\n}\n\nfunction update(time, delta) {\n  // 获取六边形的边界\n  const bounds = hexagon.getBounds();\n  \n  // 检测左右边界碰撞\n  if (bounds.left <= 0 || bounds.right >= config.width) {\n    hexagon.setVelocityX(-hexagon.body.velocity.x);\n  }\n  \n  // 检测上下边界碰撞\n  if (bounds.top <= 0 || bounds.bottom >= config.height) {\n    hexagon.setVelocityY(-hexagon.body.velocity.y);\n  }\n  \n  // 确保速度大小保持在160（防止浮点误差累积）\n  const currentSpeed = Math.sqrt(\n    hexagon.body.velocity.x ** 2 + \n    hexagon.body.velocity.y ** 2\n  );\n  \n  if (Math.abs(currentSpeed - 160) > 1) {\n    const scale = 160 / currentSpeed;\n    hexagon.setVelocity(\n      hexagon.body.velocity.x * scale,\n      hexagon.body.velocity.y * scale\n    );\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000643_v1", "prompt_id": "seed_000643", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9466666666666668}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个灰色方块以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 灰色方块以360速度移动并在画布边界反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Rectangle, Phaser.Physics.Arcade\nSTEPS:\n1. 创建带有 Arcade 物理系统的游戏配置\n2. 使用 Graphics 生成灰色方块纹理\n3. 创建物理精灵并设置初始速度为360\n4. 在 update 中检测边界碰撞并反转速度实现反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet square;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 创建灰色方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x808080, 1); // 灰色\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('square', 50, 50);\n  graphics.destroy();\n\n  // 创建物理精灵\n  square = this.physics.add.sprite(400, 300, 'square');\n  \n  // 设置初始速度（随机方向，速度为360）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 360);\n  square.setVelocity(velocity.x, velocity.y);\n  \n  // 设置碰撞边界\n  square.setCollideWorldBounds(false); // 手动处理边界反弹\n}\n\nfunction update() {\n  // 检测左右边界\n  if (square.x <= 25 || square.x >= 775) {\n    square.setVelocityX(-square.body.velocity.x);\n    // 修正位置防止卡在边界外\n    if (square.x <= 25) {\n      square.x = 25;\n    } else {\n      square.x = 775;\n    }\n  }\n  \n  // 检测上下边界\n  if (square.y <= 25 || square.y >= 575) {\n    square.setVelocityY(-square.body.velocity.y);\n    // 修正位置防止卡在边界外\n    if (square.y <= 25) {\n      square.y = 25;\n    } else {\n      square.y = 575;\n    }\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000149_v3", "prompt_id": "seed_000149", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕左下显示一段文字 \"Hello Phaser\"，字体大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕左下显示 \"Hello Phaser\" 文字，字体大小 64 像素\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本位置为左下角，字体大小为 64 像素\n4. 设置文本原点为左下角以便定位\n[/PLAN]\n\n```javascript\n// Phaser3 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 本任务无需预加载资源\n}\n\nfunction create() {\n  // 在屏幕左下角创建文本\n  // x: 20 (左边距), y: 580 (接近底部)\n  const text = this.add.text(20, 580, 'Hello Phaser', {\n    fontSize: '64px',\n    color: '#ffffff',\n    fontFamily: 'Arial'\n  });\n  \n  // 设置文本原点为左下角 (0, 1)\n  // 这样文本会从左下角开始绘制，便于定位\n  text.setOrigin(0, 1);\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000148_v3", "prompt_id": "seed_000148", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 120，重力 1000。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次，跳跃力度120，重力1000\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Input.Keyboard, Phaser.Graphics, this.physics.add.sprite, this.input.keyboard.addKey\nSTEPS:\n1. 创建带物理系统的场景，设置重力为1000\n2. 使用Graphics创建玩家和地面的纹理\n3. 添加玩家精灵并启用物理引擎\n4. 创建地面平台并设置碰撞\n5. 监听空格键输入，实现双跳逻辑（跟踪剩余跳跃次数）\n6. 落地时重置跳跃次数为2\n7. 添加跳跃次数显示文本作为状态信号\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87CEEB',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 1000 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet jumpsRemaining = 2; // 剩余跳跃次数\nlet jumpCount = 0; // 总跳跃次数统计\nlet statusText;\n\nfunction preload() {\n  // 使用Graphics创建玩家纹理\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 使用Graphics创建地面纹理\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x8B4513, 1);\n  groundGraphics.fillRect(0, 0, 800, 50);\n  groundGraphics.generateTexture('ground', 800, 50);\n  groundGraphics.destroy();\n}\n\nfunction create() {\n  // 创建地面\n  ground = this.physics.add.staticSprite(400, 575, 'ground');\n  ground.setOrigin(0.5, 0.5);\n  ground.refreshBody();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setBounce(0);\n\n  // 设置玩家与地面的碰撞\n  this.physics.add.collider(player, ground, () => {\n    // 当玩家与地面接触时，重置跳跃次数\n    if (player.body.touching.down) {\n      jumpsRemaining = 2;\n    }\n  });\n\n  // 添加键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 添加状态显示文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 添加说明文本\n  this.add.text(16, 60, '按空格键跳跃（可双跳）\\n左右方向键移动', {\n    fontSize: '16px',\n    fill: '#000',\n    backgroundColor: '#fff',\n    padding: { x: 10, y: 5 }\n  });\n\n  updateStatusText();\n}\n\nfunction update() {\n  // 左右移动控制\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 跳跃控制 - 使用 justDown 确保每次按键只触发一次\n  if (Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    if (jumpsRemaining > 0) {\n      // 执行跳跃\n      player.setVelocityY(-120);\n      jumpsRemaining--;\n      jumpCount++;\n      updateStatusText();\n    }\n  }\n\n  // 检测玩家是否在地面上，用于重置跳跃次数\n  // 这是额外的保险机制，主要逻辑在碰撞回调中\n  if (player.body.touching.down && player.body.velocity.y === 0) {\n    if (jumpsRemaining !== 2) {\n      jumpsRemaining = 2;\n      updateStatusText();\n    }\n  }\n}\n\nfunction updateStatusText() {\n  statusText.setText(\n    `跳跃次数剩余: ${jumpsRemaining}/2 | 总跳跃: ${jumpCount}`\n  );\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001161_v1", "prompt_id": "seed_001161", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个星形以每秒 160 度的速度持续旋转。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个星形并以每秒160度的速度持续旋转\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStar, Graphics.rotation, Scene.update\nSTEPS:\n1. 创建 Graphics 对象并绘制星形\n2. 在 create 中设置星形的初始位置和样式\n3. 在 update 中根据 delta 时间累加旋转角度（160度/秒 = 160 * (Math.PI/180) 弧度/秒）\n4. 将累加的旋转值应用到 Graphics 对象的 rotation 属性\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create, update }\n};\n\nlet star;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象并绘制星形\n  star = this.add.graphics();\n  \n  // 设置填充颜色为黄色\n  star.fillStyle(0xffff00, 1);\n  \n  // 绘制星形：中心点 (400, 300)，5个角，外半径100，内半径40\n  star.fillStar(400, 300, 5, 100, 40);\n  \n  // 设置旋转中心点为星形中心\n  star.setPosition(0, 0);\n}\n\nfunction update(time, delta) {\n  // 每秒旋转160度\n  // delta 是毫秒，需要转换为秒\n  // 160度 = 160 * (Math.PI / 180) 弧度\n  const rotationSpeed = 160 * (Math.PI / 180); // 弧度/秒\n  const rotationDelta = rotationSpeed * (delta / 1000); // 本帧旋转量\n  \n  // 累加旋转角度\n  star.rotation += rotationDelta;\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000319_v2", "prompt_id": "seed_000319", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 80 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示 \"Hello Phaser\" 文字，字体大小 80 像素\nAPI: Phaser.Game, Phaser.Scene, this.add.text\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 方法中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小为 80px\n4. 将文本定位在屏幕下方中央位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文本对象\n  const text = this.add.text(\n    400,  // x 坐标（屏幕中央）\n    520,  // y 坐标（屏幕下方）\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '80px',  // 字体大小\n      fontFamily: 'Arial',  // 字体族\n      color: '#ffffff',  // 文本颜色\n      align: 'center'  // 文本对齐\n    }\n  );\n  \n  // 设置文本的原点为中心点，使其居中显示\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000204_v3", "prompt_id": "seed_000204", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 3 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个方块在 3 秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建一个 Sprite 对象并设置初始透明度为 0\n3. 使用 Tween 动画让 alpha 从 0 渐变到 1，持续 3 秒\n4. 设置 Tween 为循环播放（yoyo 或 repeat: -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制一个方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n\n  // 创建方块精灵，放置在屏幕中央\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为 0（完全透明）\n  square.setAlpha(0);\n\n  // 创建渐变动画：从透明到不透明，持续 3 秒，循环播放\n  this.tweens.add({\n    targets: square,           // 动画目标对象\n    alpha: 1,                  // 目标透明度值（完全不透明）\n    duration: 3000,            // 持续时间 3 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 来回播放（透明->不透明->透明）\n    repeat: -1                 // 无限循环\n  });\n\n  // 添加提示文本\n  this.add.text(400, 50, 'Alpha Tween: 0 → 1 (3s loop)', {\n    fontSize: '24px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000059_v1", "prompt_id": "seed_000059", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制10个随机位置的紫色方块，每个大小为 64 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制10个随机位置的紫色方块，每个大小为64像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillRect, Math.random\nSTEPS:\n1. 创建 Phaser Game 配置，设置画布大小为 800x600\n2. 在 create 生命周期中创建 Graphics 对象\n3. 使用循环10次，每次生成随机 x、y 坐标\n4. 使用 fillStyle 设置紫色（0x800080），fillRect 绘制 64x64 方块\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制\n  const graphics = this.add.graphics();\n  \n  // 设置紫色填充\n  graphics.fillStyle(0x800080, 1);\n  \n  // 绘制10个随机位置的方块\n  for (let i = 0; i < 10; i++) {\n    // 生成随机位置，确保方块完全在画布内\n    // x 范围: 0 到 (800 - 64)\n    // y 范围: 0 到 (600 - 64)\n    const randomX = Math.random() * (config.width - 64);\n    const randomY = Math.random() * (config.height - 64);\n    \n    // 绘制 64x64 的方块\n    graphics.fillRect(randomX, randomY, 64, 64);\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000605_v3", "prompt_id": "seed_000605", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制12个随机位置的橙色六边形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 绘制12个随机位置的橙色六边形，每个大小为32像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillPoints, Graphics.generateTexture\nSTEPS:\n1. 创建 Phaser.Game 配置，设置场景和画布尺寸\n2. 在 create 方法中使用 Graphics 绘制六边形路径\n3. 计算六边形的6个顶点坐标（基于中心点和半径）\n4. 使用 fillPoints 填充六边形形状\n5. 生成纹理并销毁 Graphics 对象\n6. 循环12次，在随机位置创建六边形精灵\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制六边形\n  const graphics = this.add.graphics();\n  \n  // 设置橙色填充\n  graphics.fillStyle(0xFF8C00, 1);\n  \n  // 六边形参数\n  const hexRadius = 16; // 半径16像素，总大小32像素\n  const centerX = hexRadius;\n  const centerY = hexRadius;\n  \n  // 计算六边形的6个顶点坐标\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = (Math.PI / 3) * i; // 每个顶点间隔60度\n    const x = centerX + hexRadius * Math.cos(angle);\n    const y = centerY + hexRadius * Math.sin(angle);\n    points.push(new Phaser.Geom.Point(x, y));\n  }\n  \n  // 绘制填充的六边形\n  graphics.fillPoints(points, true);\n  \n  // 生成纹理\n  graphics.generateTexture('hexagon', hexRadius * 2, hexRadius * 2);\n  \n  // 销毁 Graphics 对象以释放资源\n  graphics.destroy();\n  \n  // 创建12个随机位置的六边形\n  for (let i = 0; i < 12; i++) {\n    // 生成随机位置（确保六边形完全在画布内）\n    const randomX = Phaser.Math.Between(hexRadius, config.width - hexRadius);\n    const randomY = Phaser.Math.Between(hexRadius, config.height - hexRadius);\n    \n    // 创建六边形精灵\n    const hexagon = this.add.image(randomX, randomY, 'hexagon');\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000500_v3", "prompt_id": "seed_000500", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8800000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 收集游戏：10 个矩形随机分布，收集完成后显示 \"恭喜通关\"。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现一个收集游戏，玩家控制角色收集10个随机分布的矩形，收集完成后显示通关提示\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.GameObjects.Graphics, Phaser.Physics.Arcade.Collider, Phaser.GameObjects.Text, Phaser.Input.Keyboard\nSTEPS:\n1. 创建物理系统场景，初始化玩家精灵和收集品组\n2. 使用 Graphics 生成玩家和收集品的纹理（矩形）\n3. 随机分布10个可收集的矩形物体，启用物理碰撞检测\n4. 实现键盘控制玩家移动（方向键）\n5. 检测玩家与收集品碰撞，收集后移除并更新计数\n6. 当收集数达到10时显示\"恭喜通关\"文本\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet winText;\nlet collectedCount = 0; // 可验证的状态信号\nconst TOTAL_COLLECTIBLES = 10;\n\nfunction preload() {\n  // 创建玩家纹理\n  const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 40, 40);\n  playerGraphics.generateTexture('player', 40, 40);\n  playerGraphics.destroy();\n\n  // 创建收集品纹理\n  const collectibleGraphics = this.make.graphics({ x: 0, y: 0, add: false });\n  collectibleGraphics.fillStyle(0xffff00, 1);\n  collectibleGraphics.fillRect(0, 0, 30, 30);\n  collectibleGraphics.generateTexture('collectible', 30, 30);\n  collectibleGraphics.destroy();\n}\n\nfunction create() {\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n  player.setVelocityDrag(500);\n  player.setMaxVelocity(300);\n\n  // 创建收集品组\n  collectibles = this.physics.add.group();\n\n  // 随机生成10个收集品\n  for (let i = 0; i < TOTAL_COLLECTIBLES; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    \n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n    \n    // 添加轻微的浮动效果\n    this.tweens.add({\n      targets: collectible,\n      y: collectible.y + 10,\n      duration: 1000 + Math.random() * 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数文本\n  scoreText = this.add.text(16, 16, '已收集: 0 / ' + TOTAL_COLLECTIBLES, {\n    fontSize: '24px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 创建通关文本（初始隐藏）\n  winText = this.add.text(400, 300, '恭喜通关！', {\n    fontSize: '64px',\n    fill: '#ffff00',\n    fontFamily: 'Arial',\n    stroke: '#000000',\n    strokeThickness: 6\n  });\n  winText.setOrigin(0.5);\n  winText.setVisible(false);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 300;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 移除收集品\n  collectible.destroy();\n  \n  // 更新收集计数\n  collectedCount++;\n  scoreText.setText('已收集: ' + collectedCount + ' / ' + TOTAL_COLLECTIBLES);\n\n  // 添加收集音效（使用视觉反馈代替）\n  const flash = this.add.graphics();\n  flash.fillStyle(0xffff00, 0.5);\n  flash.fillCircle(collectible.x, collectible.y, 40);\n  this.tweens.add({\n    targets: flash,\n    alpha: 0,\n    scale: 2,\n    duration: 300,\n    onComplete: () => flash.destroy()\n  });\n\n  // 检查是否通关\n  if (collectedCount >= TOTAL_COLLECTIBLES) {\n    winText.setVisible(true);\n    \n    // 停止玩家移动\n    player.setVelocity(0, 0);\n    cursors.left.enabled = false;\n    cursors.right.enabled = false;\n    cursors.up.enabled = false;\n    cursors.down.enabled = false;\n\n    // 添加通关动画\n    this.tweens.add({\n      targets: winText,\n      scale: 1.2,\n      duration: 500,\n      yoyo: true,\n      repeat: -1,\n      ease: 'Sine.easeInOut'\n    });\n  }\n}\n\n// 启动游戏\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000815_v1", "prompt_id": "seed_000815", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个青色星形以 240 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 青色星形以240速度移动并在边界反弹\nAPI: Graphics.fillStar, Physics.Arcade.Sprite, setCollideWorldBounds, setBounce, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制青色星形并生成纹理\n2. 创建物理精灵并应用星形纹理\n3. 设置初始速度为240（斜向移动）\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制青色星形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ffff, 1); // 青色\n  \n  // 绘制星形（中心点在 50, 50）\n  graphics.fillStar(50, 50, 5, 20, 40);\n  \n  // 生成纹理\n  graphics.generateTexture('starTexture', 100, 100);\n  graphics.destroy();\n  \n  // 创建物理精灵\n  const star = this.physics.add.sprite(400, 300, 'starTexture');\n  \n  // 设置初始速度（240速度，斜向移动）\n  const angle = Phaser.Math.DegToRad(45); // 45度角\n  star.setVelocity(\n    Math.cos(angle) * 240,\n    Math.sin(angle) * 240\n  );\n  \n  // 设置世界边界碰撞\n  star.setCollideWorldBounds(true);\n  \n  // 设置反弹系数为1（完全弹性碰撞）\n  star.setBounce(1, 1);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000033_v2", "prompt_id": "seed_000033", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 5 个黄色敌人巡逻移动，在 80 速度下左右往返，玩家接近时追踪。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.Math.Distance", "output": "[PLAN]\nREQ: 5个黄色敌人巡逻移动，速度80左右往返，玩家接近时追踪\nAPI: Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.Group, Phaser.Math.Distance.Between, this.physics.add.sprite, this.add.graphics\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家（蓝色方块）和敌人（黄色圆形）纹理\n3. 创建玩家精灵，添加键盘控制（WASD/方向键）\n4. 创建 5 个敌人精灵，设置初始位置和巡逻范围\n5. 在 update 中实现敌人巡逻逻辑（左右往返）\n6. 检测玩家与敌人距离，小于阈值时切换为追踪模式\n7. 添加状态变量（enemiesAlerted）用于验证追踪行为\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.enemiesAlerted = 0; // 状态信号：被警觉的敌人数量\n    this.totalEnemies = 5;\n    this.patrolSpeed = 80;\n    this.detectionRange = 150; // 检测玩家的距离\n  }\n\n  preload() {\n    // 不需要加载外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x0066ff, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成敌人纹理（黄色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xffff00, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n\n    // 创建敌人组\n    this.enemies = this.physics.add.group();\n\n    // 创建 5 个敌人，分布在不同位置\n    const enemyPositions = [\n      { x: 150, y: 100 },\n      { x: 650, y: 150 },\n      { x: 200, y: 400 },\n      { x: 600, y: 450 },\n      { x: 400, y: 550 }\n    ];\n\n    enemyPositions.forEach((pos, index) => {\n      const enemy = this.enemies.create(pos.x, pos.y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.setBounce(0);\n      \n      // 初始化敌人属性\n      enemy.patrolLeft = pos.x - 100; // 巡逻左边界\n      enemy.patrolRight = pos.x + 100; // 巡逻右边界\n      enemy.setVelocityX(this.patrolSpeed); // 初始向右移动\n      enemy.isAlerted = false; // 是否处于追踪状态\n      enemy.body.setDrag(0); // 无拖拽，保持恒定速度\n    });\n\n    // 键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.wasd = this.input.keyboard.addKeys({\n      up: Phaser.Input.Keyboard.KeyCodes.W,\n      down: Phaser.Input.Keyboard.KeyCodes.S,\n      left: Phaser.Input.Keyboard.KeyCodes.A,\n      right: Phaser.Input.Keyboard.KeyCodes.D\n    });\n\n    // 添加信息文本\n    this.statusText = this.add.text(10, 10, '', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n\n    // 添加说明文本\n    this.add.text(10, 570, 'Use WASD or Arrow Keys to move. Get close to enemies to alert them!', {\n      fontSize: '14px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 5, y: 3 }\n    });\n  }\n\n  update(time, delta) {\n    // 玩家移动控制\n    const playerSpeed = 200;\n    this.player.setVelocity(0);\n\n    if (this.cursors.left.isDown || this.wasd.left.isDown) {\n      this.player.setVelocityX(-playerSpeed);\n    } else if (this.cursors.right.isDown || this.wasd.right.isDown) {\n      this.player.setVelocityX(playerSpeed);\n    }\n\n    if (this.cursors.up.isDown || this.wasd.up.isDown) {\n      this.player.setVelocityY(-playerSpeed);\n    } else if (this.cursors.down.isDown || this.wasd.down.isDown) {\n      this.player.setVelocityY(playerSpeed);\n    }\n\n    // 重置警觉计数\n    this.enemiesAlerted = 0;\n\n    // 更新每个敌人的行为\n    this.enemies.getChildren().forEach(enemy => {\n      const distanceToPlayer = Phaser.Math.Distance.Between(\n        enemy.x, enemy.y,\n        this.player.x, this.player.y\n      );\n\n      // 检测玩家是否在范围内\n      if (distanceToPlayer < this.detectionRange) {\n        // 追踪模式\n        enemy.isAlerted = true;\n        this.enemiesAlerted++;\n\n        // 计算朝向玩家的方向\n        const angle = Phaser.Math.Angle.Between(\n          enemy.x, enemy.y,\n          this.player.x, this.player.y\n        );\n\n        // 设置速度朝向玩家（追踪速度略快）\n        const chaseSpeed = this.patrolSpeed * 1.2;\n        enemy.setVelocity(\n          Math.cos(angle) * chaseSpeed,\n          Math.sin(angle) * chaseSpeed\n        );\n\n        // 改变颜色表示警觉状态（红色）\n        if (enemy.tint !== 0xff0000) {\n          enemy.setTint(0xff0000);\n        }\n      } else {\n        // 巡逻模式\n        if (enemy.isAlerted) {\n          // 从追踪模式恢复，重置颜色\n          enemy.clearTint();\n          enemy.isAlerted = false;\n          // 恢复水平巡逻\n          enemy.setVelocityY(0);\n          enemy.setVelocityX(enemy.x < enemy.patrolLeft + 50 ? this.patrolSpeed : -this.patrolSpeed);\n        }\n\n        // 左右巡逻逻辑\n        if (enemy.x <= enemy.patrolLeft && enemy.body.velocity.x < 0) {\n          enemy.setVelocityX(this.patrolSpeed);\n        } else if (enemy.x >= enemy.patrolRight && enemy.body.velocity.x > 0) {\n          enemy.setVelocityX(-this.patrolSpeed);\n        }\n      }\n    });\n\n    // 更新状态文本\n    this.statusText.setText(\n      `Enemies Alerted: ${this.enemiesAlerted}/${this.totalEnemies}\\n` +\n      `Player Position: (${Math.floor(this.player.x)}, ${Math.floor(this.player.y)})`\n    );\n  }\n}\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000801_v1", "prompt_id": "seed_000801", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个橙色圆形以 120 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 橙色圆形以120速度移动并在边界反弹\nAPI: Graphics, arcade.sprite, setBounce, setCollideWorldBounds, setVelocity\nSTEPS:\n1. 使用 Graphics 绘制橙色圆形并生成纹理\n2. 创建 arcade 物理精灵并应用纹理\n3. 设置精灵初始速度为120\n4. 启用世界边界碰撞和反弹效果\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要预加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xFFA500, 1); // 橙色\n  graphics.fillCircle(25, 25, 25); // 在中心绘制半径为25的圆\n  \n  // 生成纹理\n  graphics.generateTexture('orangeCircle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，释放内存\n  \n  // 创建物理精灵，位置在画布中心\n  const circle = this.physics.add.sprite(400, 300, 'orangeCircle');\n  \n  // 设置圆形为圆形碰撞体（更精确的碰撞检测）\n  circle.setCircle(25);\n  \n  // 设置初始速度（120像素/秒，随机方向）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocity = this.physics.velocityFromAngle(angle, 120);\n  circle.setVelocity(velocity.x, velocity.y);\n  \n  // 设置完全反弹（弹性系数为1）\n  circle.setBounce(1, 1);\n  \n  // 启用世界边界碰撞\n  circle.setCollideWorldBounds(true);\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000662_v3", "prompt_id": "seed_000662", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9099999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现平台跳跃+收集：角色跳跃收集空中的 10 个金币，重力 400，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Physics.Arcade.Group", "output": "[PLAN]\nREQ: 实现平台跳跃游戏，角色收集10个金币，重力400，显示分数\nAPI: Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Scene 并配置 Arcade 物理系统，重力设为 400\n2. 使用 Graphics 生成角色和金币纹理（角色为蓝色方块，金币为黄色圆形）\n3. 创建地面平台和多个空中平台\n4. 生成 10 个金币随机分布在平台上方\n5. 添加键盘控制（左右移动+跳跃）和碰撞检测\n6. 实现金币收集逻辑，更新并显示分数\n[/PLAN]\n\n```javascript\nclass PlatformerScene extends Phaser.Scene {\n  constructor() {\n    super('PlatformerScene');\n    this.score = 0;\n  }\n\n  preload() {\n    // 创建角色纹理（蓝色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x3498db, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 创建金币纹理（黄色圆形）\n    const coinGraphics = this.add.graphics();\n    coinGraphics.fillStyle(0xffd700, 1);\n    coinGraphics.fillCircle(12, 12, 12);\n    coinGraphics.generateTexture('coin', 24, 24);\n    coinGraphics.destroy();\n\n    // 创建平台纹理（灰色矩形）\n    const platformGraphics = this.add.graphics();\n    platformGraphics.fillStyle(0x7f8c8d, 1);\n    platformGraphics.fillRect(0, 0, 200, 20);\n    platformGraphics.generateTexture('platform', 200, 20);\n    platformGraphics.destroy();\n\n    // 创建地面纹理（深灰色）\n    const groundGraphics = this.add.graphics();\n    groundGraphics.fillStyle(0x34495e, 1);\n    groundGraphics.fillRect(0, 0, 800, 40);\n    groundGraphics.generateTexture('ground', 800, 40);\n    groundGraphics.destroy();\n  }\n\n  create() {\n    // 创建地面\n    const ground = this.physics.add.staticGroup();\n    ground.create(400, 580, 'ground');\n\n    // 创建平台\n    const platforms = this.physics.add.staticGroup();\n    platforms.create(150, 450, 'platform');\n    platforms.create(400, 350, 'platform');\n    platforms.create(650, 450, 'platform');\n    platforms.create(250, 250, 'platform');\n    platforms.create(550, 250, 'platform');\n    platforms.create(400, 150, 'platform');\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(100, 500, 'player');\n    this.player.setBounce(0.1);\n    this.player.setCollideWorldBounds(true);\n\n    // 创建金币组\n    this.coins = this.physics.add.group();\n    \n    // 在平台上方生成10个金币\n    const coinPositions = [\n      { x: 150, y: 400 },\n      { x: 400, y: 300 },\n      { x: 650, y: 400 },\n      { x: 250, y: 200 },\n      { x: 550, y: 200 },\n      { x: 400, y: 100 },\n      { x: 200, y: 500 },\n      { x: 500, y: 350 },\n      { x: 300, y: 250 },\n      { x: 600, y: 150 }\n    ];\n\n    coinPositions.forEach(pos => {\n      const coin = this.coins.create(pos.x, pos.y, 'coin');\n      coin.setBounce(0.5);\n      coin.setCollideWorldBounds(true);\n    });\n\n    // 添加碰撞检测\n    this.physics.add.collider(this.player, ground);\n    this.physics.add.collider(this.player, platforms);\n    this.physics.add.collider(this.coins, ground);\n    this.physics.add.collider(this.coins, platforms);\n\n    // 金币收集检测\n    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 创建分数文本\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontSize: '32px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 4\n    });\n\n    // 创建提示文本\n    this.add.text(400, 30, 'Arrow Keys: Move | Up: Jump | Collect all 10 coins!', {\n      fontSize: '16px',\n      fill: '#ffffff',\n      fontFamily: 'Arial',\n      stroke: '#000000',\n      strokeThickness: 2\n    }).setOrigin(0.5);\n  }\n\n  collectCoin(player, coin) {\n    // 移除金币\n    coin.disableBody(true, true);\n    \n    // 增加分数\n    this.score += 10;\n    this.scoreText.setText('Score: ' + this.score);\n\n    // 检查是否收集完所有金币\n    if (this.score === 100) {\n      const winText = this.add.text(400, 300, 'YOU WIN!', {\n        fontSize: '64px',\n        fill: '#00ff00',\n        fontFamily: 'Arial',\n        stroke: '#000000',\n        strokeThickness: 6\n      }).setOrigin(0.5);\n\n      // 暂停游戏\n      this.physics.pause();\n    }\n  }\n\n  update() {\n    // 左右移动控制\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    // 跳跃控制（只有在地面或平台上才能跳跃）\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-400);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#87ceeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 400 },\n      debug: false\n    }\n  },\n  scene: PlatformerScene\n};\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001210_v2", "prompt_id": "seed_001210", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.9300000000000002}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个绿色三角形以 360 速度移动，碰到画布边界时反弹。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让一个绿色三角形以 360 速度移动，碰到画布边界时反弹\nAPI: Phaser.GameObjects.Graphics, Phaser.GameObjects.Graphics.generateTexture, Phaser.Physics.Arcade.Sprite, Phaser.Physics.Arcade.World.setBoundsCollision\nSTEPS:\n1. 使用 Graphics 绘制绿色三角形并生成纹理\n2. 创建带物理引擎的精灵对象，应用三角形纹理\n3. 设置精灵初始速度为 360\n4. 启用世界边界碰撞，设置精灵与边界碰撞时反弹\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制绿色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色\n  \n  // 绘制三角形（等边三角形，中心在 (25, 25)）\n  graphics.beginPath();\n  graphics.moveTo(25, 5);      // 顶点\n  graphics.lineTo(5, 45);       // 左下角\n  graphics.lineTo(45, 45);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 50, 50);\n  graphics.destroy(); // 销毁 graphics 对象，只保留纹理\n  \n  // 创建带物理引擎的三角形精灵\n  const triangle = this.physics.add.sprite(400, 300, 'triangle');\n  \n  // 设置初始速度（随机方向，速度大小为 360）\n  const angle = Phaser.Math.Between(0, 360);\n  const velocityX = Math.cos(angle * Math.PI / 180) * 360;\n  const velocityY = Math.sin(angle * Math.PI / 180) * 360;\n  triangle.setVelocity(velocityX, velocityY);\n  \n  // 设置碰撞边界\n  triangle.setCollideWorldBounds(true); // 启用世界边界碰撞\n  triangle.setBounce(1, 1); // 设置反弹系数为 1（完全弹性碰撞）\n  \n  // 可选：添加一些视觉反馈文本\n  this.add.text(10, 10, '绿色三角形以 360 速度移动\\n碰到边界会反弹', {\n    fontSize: '16px',\n    fill: '#ffffff'\n  });\n}\n\n// 创建游戏实例\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000462_v2", "prompt_id": "seed_000462", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个方块移动，速度为 300 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制方块以 300 像素/秒的速度移动\nAPI: Phaser.Scene, Phaser.GameObjects.Graphics, Phaser.Input.Keyboard, this.input.keyboard.addKey\nSTEPS:\n1. 创建 Scene 配置，设置画布大小\n2. 在 create 中使用 Graphics 绘制方块并生成纹理\n3. 创建 Sprite 对象作为可移动的方块\n4. 使用 addKey 监听 WASD 四个按键\n5. 在 update 中根据按键状态更新方块位置（速度 300 像素/秒）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 300; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 50, 50);\n  graphics.generateTexture('playerBlock', 50, 50);\n  graphics.destroy();\n\n  // 创建玩家方块，初始位置在屏幕中心\n  player = this.add.sprite(400, 300, 'playerBlock');\n\n  // 监听 WASD 按键\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the square', {\n    fontSize: '18px',\n    fill: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算本帧应移动的距离（速度 * 时间差）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态移动方块\n  if (keyW.isDown) {\n    player.y -= distance; // 向上移动\n  }\n  if (keyS.isDown) {\n    player.y += distance; // 向下移动\n  }\n  if (keyA.isDown) {\n    player.x -= distance; // 向左移动\n  }\n  if (keyD.isDown) {\n    player.x += distance; // 向右移动\n  }\n\n  // 限制方块在画布范围内\n  player.x = Phaser.Math.Clamp(player.x, 25, 775);\n  player.y = Phaser.Math.Clamp(player.y, 25, 575);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000688_v3", "prompt_id": "seed_000688", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9149999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 绘制20个随机位置的绿色三角形，每个大小为 32 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 Graphics 绘制 20 个随机位置的绿色三角形，每个大小为 32 像素\nAPI: Phaser.GameObjects.Graphics, Graphics.fillStyle, Graphics.fillTriangle, Graphics.generateTexture, this.add.image\nSTEPS:\n1. 在 create 中创建 Graphics 对象\n2. 使用 fillStyle 设置绿色填充\n3. 使用 fillTriangle 绘制三角形路径（等边三角形）\n4. 使用 generateTexture 将 Graphics 转换为可复用纹理\n5. 循环 20 次，使用 this.add.image 在随机位置添加三角形图像\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: { preload, create }\n};\n\nfunction preload() {\n  // 无需预加载外部资源\n}\n\nfunction create() {\n  // 创建 Graphics 对象用于绘制三角形\n  const graphics = this.add.graphics();\n  \n  // 设置绿色填充\n  graphics.fillStyle(0x00ff00, 1);\n  \n  // 绘制等边三角形（大小为 32 像素）\n  // 三角形顶点：顶部居中，底部两个角\n  const size = 32;\n  const height = size * Math.sqrt(3) / 2; // 等边三角形高度\n  \n  graphics.fillTriangle(\n    size / 2, 0,           // 顶点（顶部中心）\n    0, height,             // 左下角\n    size, height           // 右下角\n  );\n  \n  // 将 Graphics 转换为纹理\n  graphics.generateTexture('triangle', size, size);\n  \n  // 销毁 Graphics 对象（纹理已生成，不再需要）\n  graphics.destroy();\n  \n  // 在随机位置创建 20 个三角形\n  for (let i = 0; i < 20; i++) {\n    // 生成随机位置（考虑三角形大小，避免超出边界）\n    const x = Phaser.Math.Between(size / 2, config.width - size / 2);\n    const y = Phaser.Math.Between(size / 2, config.height - size / 2);\n    \n    // 使用生成的纹理创建图像\n    this.add.image(x, y, 'triangle');\n  }\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000303_v2", "prompt_id": "seed_000303", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.8899999999999999}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现一个补间动画：让一个红色三角形在 1.5 秒内从左移动到右，然后往返循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 红色三角形在1.5秒内左右往返循环移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制红色三角形并生成纹理\n2. 创建 Sprite 对象使用生成的三角形纹理\n3. 使用 tweens 创建补间动画，设置 x 坐标从左到右移动\n4. 设置 yoyo 为 true 实现往返效果，loop 为 -1 实现无限循环\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制红色三角形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff0000, 1);\n  \n  // 绘制三角形（等边三角形）\n  graphics.beginPath();\n  graphics.moveTo(0, -30);      // 顶点\n  graphics.lineTo(-26, 15);     // 左下角\n  graphics.lineTo(26, 15);      // 右下角\n  graphics.closePath();\n  graphics.fillPath();\n  \n  // 生成纹理\n  graphics.generateTexture('triangle', 52, 45);\n  graphics.destroy();\n  \n  // 创建三角形精灵，初始位置在左侧\n  const triangle = this.add.sprite(100, 300, 'triangle');\n  \n  // 创建补间动画：从左移动到右，然后往返循环\n  this.tweens.add({\n    targets: triangle,\n    x: 700,                    // 目标 x 坐标（右侧）\n    duration: 1500,            // 持续时间 1.5 秒\n    ease: 'Linear',            // 线性缓动\n    yoyo: true,                // 启用往返效果\n    loop: -1                   // 无限循环（-1 表示永久循环）\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000220_v3", "prompt_id": "seed_000220", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 在屏幕下显示一段文字 \"Hello Phaser\"，字体大小为 48 像素。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 在屏幕下方显示 \"Hello Phaser\" 文字，字体大小 48px\nAPI: Phaser.GameObjects.Text, this.add.text, Phaser.Game\nSTEPS:\n1. 创建 Phaser.Game 配置，设置画布尺寸\n2. 在 create 生命周期中使用 this.add.text 创建文本对象\n3. 设置文本内容为 \"Hello Phaser\"，字体大小 48px\n4. 将文本定位在屏幕下方中央位置\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  scene: {\n    preload: preload,\n    create: create\n  },\n  backgroundColor: '#2d2d2d'\n};\n\nfunction preload() {\n  // 无需预加载资源\n}\n\nfunction create() {\n  // 创建文本对象\n  const text = this.add.text(\n    400,  // x 坐标（屏幕中央）\n    550,  // y 坐标（屏幕下方）\n    'Hello Phaser',  // 文本内容\n    {\n      fontSize: '48px',  // 字体大小\n      color: '#ffffff',  // 文字颜色（白色）\n      fontFamily: 'Arial'  // 字体\n    }\n  );\n\n  // 设置文本原点为中心，使其居中对齐\n  text.setOrigin(0.5, 0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000022_v3", "prompt_id": "seed_000022", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 使用 WASD 键控制一个椭圆移动，速度为 160 像素/秒。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Input.Keyboard.KeyCodes\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 使用 WASD 键控制一个椭圆以 160 像素/秒的速度移动\nAPI: Phaser.GameObjects.Graphics, Phaser.Input.Keyboard.KeyCodes, Phaser.Input.Keyboard.addKey\nSTEPS:\n1. 创建 Scene 并配置 Game\n2. 使用 Graphics 绘制椭圆并生成纹理\n3. 创建精灵对象作为可移动的椭圆\n4. 添加 WASD 键盘输入监听\n5. 在 update 中根据按键状态更新椭圆位置，速度为 160 像素/秒\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet ellipse;\nlet keyW, keyA, keyS, keyD;\nconst SPEED = 160; // 像素/秒\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制椭圆并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色椭圆\n  graphics.fillEllipse(40, 40, 80, 60); // 在 (40,40) 位置绘制 80x60 的椭圆\n  graphics.generateTexture('ellipseTex', 80, 60);\n  graphics.destroy(); // 销毁 graphics 对象，因为已经生成了纹理\n\n  // 创建椭圆精灵，放置在屏幕中心\n  ellipse = this.add.sprite(400, 300, 'ellipseTex');\n\n  // 添加 WASD 键盘输入\n  keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n\n  // 添加提示文本\n  this.add.text(10, 10, 'Use WASD to move the ellipse', {\n    fontSize: '18px',\n    color: '#ffffff'\n  });\n}\n\nfunction update(time, delta) {\n  // 计算实际移动距离（速度 * 时间）\n  const distance = SPEED * (delta / 1000);\n\n  // 根据按键状态更新椭圆位置\n  if (keyW.isDown) {\n    ellipse.y -= distance; // 向上移动\n  }\n  if (keyS.isDown) {\n    ellipse.y += distance; // 向下移动\n  }\n  if (keyA.isDown) {\n    ellipse.x -= distance; // 向左移动\n  }\n  if (keyD.isDown) {\n    ellipse.x += distance; // 向右移动\n  }\n\n  // 限制椭圆在屏幕范围内\n  ellipse.x = Phaser.Math.Clamp(ellipse.x, 40, 760);\n  ellipse.y = Phaser.Math.Clamp(ellipse.y, 30, 570);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000599_v2", "prompt_id": "seed_000599", "source": "distill", "difficulty": "easy", "modules": ["Scene", "GameObjects", "Input"], "quality_score": 0.9233333333333332}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 创建一个旋转动画效果：让橙色圆形在 1 秒内完成一次旋转，然后循环。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 创建一个橙色圆形，使用 Tween 动画实现 1 秒内完成 360 度旋转并循环\nAPI: Graphics, Tween, add.graphics, tweens.add\nSTEPS:\n1. 使用 Graphics 绘制橙色圆形并生成纹理\n2. 创建 Sprite 对象使用该纹理\n3. 使用 tweens.add 创建旋转动画，设置 angle 从 0 到 360\n4. 设置动画持续时间为 1000ms，循环次数为 -1（无限循环）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制橙色圆形\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0xff8800, 1); // 橙色\n  graphics.fillCircle(50, 50, 50); // 绘制半径为 50 的圆形\n  \n  // 生成纹理\n  graphics.generateTexture('orangeCircle', 100, 100);\n  graphics.destroy(); // 销毁 graphics 对象，纹理已生成\n  \n  // 创建 Sprite 对象并放置在屏幕中心\n  const circle = this.add.sprite(400, 300, 'orangeCircle');\n  \n  // 创建旋转动画\n  this.tweens.add({\n    targets: circle,           // 动画目标对象\n    angle: 360,                // 旋转到 360 度\n    duration: 1000,            // 持续时间 1 秒\n    ease: 'Linear',            // 线性缓动，保持匀速旋转\n    repeat: -1,                // -1 表示无限循环\n    onRepeat: function() {\n      // 每次循环重置角度，避免累积\n      circle.angle = 0;\n    }\n  });\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000571_v3", "prompt_id": "seed_000571", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现双跳功能：角色可跳跃两次后才需落地，跳跃力度为 200，重力 800。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Sprite\n- Phaser.Input.Keyboard.KeyCodes", "output": "[PLAN]\nREQ: 实现双跳功能，角色可连续跳跃两次，跳跃力度200，重力800\nAPI: Phaser.Physics.Arcade, Phaser.Input.Keyboard, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建物理场景，设置重力为800\n2. 使用Graphics绘制玩家矩形和地面\n3. 监听空格键输入，实现双跳逻辑（跳跃次数<=2）\n4. 玩家落地时重置跳跃次数\n5. 添加文本显示当前跳跃状态和剩余跳跃次数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 800 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\n// 全局状态变量（可验证）\nlet jumpCount = 0;\nlet maxJumps = 2;\nlet totalJumps = 0;\nlet isOnGround = false;\n\nlet player;\nlet ground;\nlet cursors;\nlet spaceKey;\nlet statusText;\nlet jumpCountText;\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 创建地面纹理\n  const groundGraphics = this.add.graphics();\n  groundGraphics.fillStyle(0x00aa00, 1);\n  groundGraphics.fillRect(0, 0, 800, 50);\n  groundGraphics.generateTexture('groundTex', 800, 50);\n  groundGraphics.destroy();\n\n  // 创建玩家纹理\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x0088ff, 1);\n  playerGraphics.fillRect(0, 0, 40, 60);\n  playerGraphics.generateTexture('playerTex', 40, 60);\n  playerGraphics.destroy();\n\n  // 创建地面（静态物理体）\n  ground = this.physics.add.staticSprite(400, 575, 'groundTex');\n  ground.refreshBody();\n\n  // 创建玩家（动态物理体）\n  player = this.physics.add.sprite(400, 300, 'playerTex');\n  player.setBounce(0);\n  player.setCollideWorldBounds(true);\n\n  // 设置碰撞检测\n  this.physics.add.collider(player, ground, () => {\n    // 玩家落地时重置跳跃次数\n    if (player.body.touching.down) {\n      jumpCount = 0;\n      isOnGround = true;\n    }\n  });\n\n  // 创建键盘输入\n  cursors = this.input.keyboard.createCursorKeys();\n  spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\n  // 创建状态显示文本\n  statusText = this.add.text(16, 16, '', {\n    fontSize: '20px',\n    fill: '#ffffff',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  jumpCountText = this.add.text(16, 50, '', {\n    fontSize: '18px',\n    fill: '#ffff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 说明文本\n  this.add.text(16, 90, '按空格键跳跃（可双跳）', {\n    fontSize: '16px',\n    fill: '#00ff00',\n    backgroundColor: '#000000',\n    padding: { x: 10, y: 5 }\n  });\n\n  // 初始化状态\n  updateStatusText();\n}\n\nfunction update() {\n  // 检测玩家是否在地面上\n  const wasOnGround = isOnGround;\n  isOnGround = player.body.touching.down;\n\n  // 如果刚落地，重置跳跃次数\n  if (!wasOnGround && isOnGround) {\n    jumpCount = 0;\n  }\n\n  // 跳跃逻辑\n  if (Phaser.Input.Keyboard.JustDown(spaceKey)) {\n    // 只要跳跃次数小于最大跳跃次数就可以跳\n    if (jumpCount < maxJumps) {\n      player.setVelocityY(-200); // 跳跃力度为 200\n      jumpCount++;\n      totalJumps++;\n      updateStatusText();\n    }\n  }\n\n  // 左右移动\n  if (cursors.left.isDown) {\n    player.setVelocityX(-160);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(160);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  // 更新状态文本\n  updateStatusText();\n}\n\nfunction updateStatusText() {\n  const remainingJumps = maxJumps - jumpCount;\n  const groundStatus = isOnGround ? '在地面' : '在空中';\n  \n  statusText.setText(`状态: ${groundStatus} | 总跳跃次数: ${totalJumps}`);\n  jumpCountText.setText(`剩余跳跃次数: ${remainingJumps}/${maxJumps} (当前已跳: ${jumpCount})`);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000881_v1", "prompt_id": "seed_000881", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "Input"], "quality_score": 0.94}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现收集物品玩法：场景中生成 5 个青色可收集物体，玩家碰到后消失并加分，显示 score。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n\n必须使用的 API:\n- Phaser.Physics.Arcade.Group\n- Phaser.GameObjects.Text", "output": "[PLAN]\nREQ: 实现收集物品玩法，场景中生成5个青色可收集物体，玩家碰撞后消失并加分\nAPI: Phaser.Physics.Arcade.Factory#group, Phaser.Physics.Arcade.ArcadePhysics#overlap, Phaser.GameObjects.Text, Phaser.Physics.Arcade.Sprite\nSTEPS:\n1. 创建物理系统配置，启用 arcade 物理引擎\n2. 使用 Graphics 生成玩家和可收集物的纹理（玩家用绿色方块，收集物用青色圆形）\n3. 创建玩家精灵，添加键盘控制（方向键移动）\n4. 创建物理组，随机位置生成5个青色收集物\n5. 使用 overlap 检测玩家与收集物碰撞，碰撞后销毁收集物并加分\n6. 创建文本显示当前分数\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: {\n    preload: preload,\n    create: create,\n    update: update\n  }\n};\n\nlet player;\nlet collectibles;\nlet cursors;\nlet scoreText;\nlet score = 0;\n\nfunction preload() {\n  // 使用 Graphics 创建纹理，无需外部资源\n}\n\nfunction create() {\n  // 创建玩家纹理（绿色方块）\n  const playerGraphics = this.add.graphics();\n  playerGraphics.fillStyle(0x00ff00, 1);\n  playerGraphics.fillRect(0, 0, 32, 32);\n  playerGraphics.generateTexture('player', 32, 32);\n  playerGraphics.destroy();\n\n  // 创建收集物纹理（青色圆形）\n  const collectibleGraphics = this.add.graphics();\n  collectibleGraphics.fillStyle(0x00ffff, 1);\n  collectibleGraphics.fillCircle(16, 16, 16);\n  collectibleGraphics.generateTexture('collectible', 32, 32);\n  collectibleGraphics.destroy();\n\n  // 创建玩家\n  player = this.physics.add.sprite(400, 300, 'player');\n  player.setCollideWorldBounds(true);\n\n  // 创建收集物组\n  collectibles = this.physics.add.group();\n\n  // 随机生成5个收集物\n  for (let i = 0; i < 5; i++) {\n    const x = Phaser.Math.Between(50, 750);\n    const y = Phaser.Math.Between(50, 550);\n    const collectible = collectibles.create(x, y, 'collectible');\n    collectible.setCollideWorldBounds(true);\n  }\n\n  // 设置碰撞检测\n  this.physics.add.overlap(player, collectibles, collectItem, null, this);\n\n  // 创建键盘控制\n  cursors = this.input.keyboard.createCursorKeys();\n\n  // 创建分数显示\n  scoreText = this.add.text(16, 16, 'Score: 0', {\n    fontSize: '32px',\n    fill: '#ffffff',\n    fontFamily: 'Arial'\n  });\n\n  // 添加提示文本\n  this.add.text(400, 550, 'Use Arrow Keys to Move and Collect Cyan Circles', {\n    fontSize: '16px',\n    fill: '#aaaaaa',\n    fontFamily: 'Arial'\n  }).setOrigin(0.5);\n}\n\nfunction update() {\n  // 玩家移动控制\n  const speed = 200;\n\n  if (cursors.left.isDown) {\n    player.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.setVelocityX(speed);\n  } else {\n    player.setVelocityX(0);\n  }\n\n  if (cursors.up.isDown) {\n    player.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.setVelocityY(speed);\n  } else {\n    player.setVelocityY(0);\n  }\n}\n\nfunction collectItem(player, collectible) {\n  // 销毁收集物\n  collectible.destroy();\n\n  // 增加分数\n  score += 10;\n\n  // 更新分数显示\n  scoreText.setText('Score: ' + score);\n\n  // 检查是否收集完所有物品\n  if (collectibles.countActive(true) === 0) {\n    scoreText.setText('Score: ' + score + ' - ALL COLLECTED!');\n  }\n}\n\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_001091_v1", "prompt_id": "seed_001091", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Physics", "GameObjects"], "quality_score": 0.9050000000000001}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 让一个方块在 0.5 秒内从透明渐变到完全不透明，循环播放。\n\n难度: 基础\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Tweens.Tween\n- Phaser.GameObjects.Graphics", "output": "[PLAN]\nREQ: 让方块在0.5秒内从透明渐变到完全不透明，循环播放\nAPI: Phaser.GameObjects.Graphics, Phaser.Tweens.TweenManager#add, Phaser.Tweens.Tween\nSTEPS:\n1. 使用 Graphics 绘制一个方块并生成纹理\n2. 创建 Sprite 对象并设置初始透明度为0\n3. 使用 Tween 动画让 alpha 从0变化到1，持续0.5秒\n4. 设置 Tween 循环播放（yoyo 或 repeat -1）\n[/PLAN]\n\n```javascript\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  scene: {\n    preload: preload,\n    create: create\n  }\n};\n\nfunction preload() {\n  // 不需要加载外部资源\n}\n\nfunction create() {\n  // 使用 Graphics 绘制方块并生成纹理\n  const graphics = this.add.graphics();\n  graphics.fillStyle(0x00ff00, 1); // 绿色方块\n  graphics.fillRect(0, 0, 100, 100);\n  graphics.generateTexture('square', 100, 100);\n  graphics.destroy(); // 生成纹理后销毁 graphics 对象\n\n  // 创建方块精灵并设置初始位置\n  const square = this.add.sprite(400, 300, 'square');\n  \n  // 设置初始透明度为0（完全透明）\n  square.setAlpha(0);\n\n  // 创建渐变动画：从透明到不透明，循环播放\n  this.tweens.add({\n    targets: square,\n    alpha: 1, // 目标透明度为1（完全不透明）\n    duration: 500, // 持续时间0.5秒（500毫秒）\n    ease: 'Linear', // 线性缓动\n    yoyo: true, // 来回播放（透明->不透明->透明）\n    repeat: -1 // 无限循环\n  });\n\n  // 添加提示文本\n  this.add.text(400, 500, '方块渐变动画（循环播放）', {\n    fontSize: '20px',\n    color: '#ffffff'\n  }).setOrigin(0.5);\n}\n\nnew Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000349_v2", "prompt_id": "seed_000349", "source": "distill", "difficulty": "easy", "modules": ["Scene", "Animations"], "quality_score": 0.9566666666666666}}
{"instruction": "你是一个 Phaser3 游戏开发专家。请根据用户的任务描述，先输出结构化计划 [PLAN]，然后输出完整的 Phaser3 代码。\n\n输出格式要求：\n1. 先输出 [PLAN]...[/PLAN] 块，包含需求摘要、API 列表和步骤\n2. 然后输出完整的 JavaScript 代码（使用 ```javascript 包裹）\n3. 代码必须可独立运行，包含完整的 Game 配置和 Scene 生命周期", "input": "任务: 实现追踪镜头与震屏：玩家与敌人碰撞时触发 camera shake 1 秒，并扣减生命值显示。\n\n难度: 中等\n\n约束:\n- 使用 Phaser3\n- 不得依赖外部资源（优先用 Graphics/内置形状/纯色纹理）\n- 必须包含 preload/create 生命周期\n- 输出代码需可独立运行（包含 Phaser.Game 配置与 Scene）\n- 需要包含可验证的状态信号（例如 score/health/level 等变量）\n- 不得使用外部图片资源，需程序化生成纹理\n\n必须使用的 API:\n- Phaser.Cameras.Scene2D.Camera\n- Phaser.Physics.Arcade.Sprite", "output": "[PLAN]\nREQ: 实现玩家与敌人碰撞时触发相机震动1秒并扣减生命值显示\nAPI: Phaser.Cameras.Scene2D.Camera#shake, Phaser.Physics.Arcade, Phaser.GameObjects.Graphics, Phaser.GameObjects.Text\nSTEPS:\n1. 创建 Scene 并配置 Arcade 物理系统\n2. 使用 Graphics 生成玩家和敌人的纹理（不同颜色区分）\n3. 创建物理精灵对象，设置玩家键盘控制\n4. 添加碰撞检测，触发时调用 camera.shake() 并扣减生命值\n5. 创建生命值文本显示，实时更新状态\n6. 相机跟随玩家移动实现追踪效果\n[/PLAN]\n\n```javascript\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super('GameScene');\n    this.health = 100;\n    this.isShaking = false;\n  }\n\n  preload() {\n    // 使用 Graphics 生成纹理，无需外部资源\n  }\n\n  create() {\n    // 生成玩家纹理（绿色方块）\n    const playerGraphics = this.add.graphics();\n    playerGraphics.fillStyle(0x00ff00, 1);\n    playerGraphics.fillRect(0, 0, 32, 32);\n    playerGraphics.generateTexture('player', 32, 32);\n    playerGraphics.destroy();\n\n    // 生成敌人纹理（红色圆形）\n    const enemyGraphics = this.add.graphics();\n    enemyGraphics.fillStyle(0xff0000, 1);\n    enemyGraphics.fillCircle(16, 16, 16);\n    enemyGraphics.generateTexture('enemy', 32, 32);\n    enemyGraphics.destroy();\n\n    // 创建更大的世界边界以便相机追踪\n    this.physics.world.setBounds(0, 0, 1600, 1200);\n\n    // 创建玩家\n    this.player = this.physics.add.sprite(400, 300, 'player');\n    this.player.setCollideWorldBounds(true);\n    this.player.body.setSize(32, 32);\n\n    // 创建多个敌人\n    this.enemies = this.physics.add.group();\n    for (let i = 0; i < 5; i++) {\n      const x = Phaser.Math.Between(100, 1500);\n      const y = Phaser.Math.Between(100, 1100);\n      const enemy = this.enemies.create(x, y, 'enemy');\n      enemy.setCollideWorldBounds(true);\n      enemy.body.setSize(32, 32);\n      \n      // 给敌人随机速度\n      enemy.setVelocity(\n        Phaser.Math.Between(-100, 100),\n        Phaser.Math.Between(-100, 100)\n      );\n      enemy.setBounce(1, 1);\n    }\n\n    // 设置碰撞检测\n    this.physics.add.overlap(\n      this.player,\n      this.enemies,\n      this.handleCollision,\n      null,\n      this\n    );\n\n    // 创建键盘控制\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // 相机追踪玩家\n    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);\n    this.cameras.main.setBounds(0, 0, 1600, 1200);\n\n    // 创建生命值显示（固定在屏幕左上角）\n    this.healthText = this.add.text(16, 16, `Health: ${this.health}`, {\n      fontSize: '24px',\n      fill: '#ffffff',\n      backgroundColor: '#000000',\n      padding: { x: 10, y: 5 }\n    });\n    this.healthText.setScrollFactor(0); // 固定在相机视野中\n\n    // 创建提示文本\n    this.infoText = this.add.text(16, 50, 'Use Arrow Keys to Move', {\n      fontSize: '16px',\n      fill: '#ffff00',\n      backgroundColor: '#000000',\n      padding: { x: 8, y: 4 }\n    });\n    this.infoText.setScrollFactor(0);\n\n    // 状态文本（用于验证）\n    this.statusText = this.add.text(16, 80, 'Status: Normal', {\n      fontSize: '16px',\n      fill: '#00ff00',\n      backgroundColor: '#000000',\n      padding: { x: 8, y: 4 }\n    });\n    this.statusText.setScrollFactor(0);\n\n    // 碰撞计数器（用于验证）\n    this.collisionCount = 0;\n    this.collisionText = this.add.text(16, 110, `Collisions: ${this.collisionCount}`, {\n      fontSize: '16px',\n      fill: '#ff9900',\n      backgroundColor: '#000000',\n      padding: { x: 8, y: 4 }\n    });\n    this.collisionText.setScrollFactor(0);\n  }\n\n  handleCollision(player, enemy) {\n    // 防止重复触发（震动期间不再扣血）\n    if (this.isShaking) {\n      return;\n    }\n\n    // 标记震动状态\n    this.isShaking = true;\n\n    // 扣减生命值\n    this.health -= 10;\n    if (this.health < 0) {\n      this.health = 0;\n    }\n\n    // 更新生命值显示\n    this.healthText.setText(`Health: ${this.health}`);\n    \n    // 更新碰撞计数\n    this.collisionCount++;\n    this.collisionText.setText(`Collisions: ${this.collisionCount}`);\n\n    // 触发相机震动 1 秒\n    // shake(duration, intensity)\n    this.cameras.main.shake(1000, 0.01);\n\n    // 更新状态文本\n    this.statusText.setText('Status: SHAKING!');\n    this.statusText.setStyle({ fill: '#ff0000' });\n\n    // 玩家闪烁效果\n    this.tweens.add({\n      targets: player,\n      alpha: 0.3,\n      duration: 100,\n      yoyo: true,\n      repeat: 9\n    });\n\n    // 1 秒后解除震动状态\n    this.time.delayedCall(1000, () => {\n      this.isShaking = false;\n      this.statusText.setText('Status: Normal');\n      this.statusText.setStyle({ fill: '#00ff00' });\n    });\n\n    // 检查游戏结束\n    if (this.health <= 0) {\n      this.handleGameOver();\n    }\n  }\n\n  handleGameOver() {\n    this.physics.pause();\n    \n    const gameOverText = this.add.text(\n      this.cameras.main.centerX,\n      this.cameras.main.centerY,\n      'GAME OVER\\nClick to Restart',\n      {\n        fontSize: '48px',\n        fill: '#ff0000',\n        backgroundColor: '#000000',\n        padding: { x: 20, y: 10 },\n        align: 'center'\n      }\n    );\n    gameOverText.setOrigin(0.5);\n    gameOverText.setScrollFactor(0);\n\n    this.input.once('pointerdown', () => {\n      this.scene.restart();\n    });\n  }\n\n  update(time, delta) {\n    if (this.health <= 0) {\n      return;\n    }\n\n    // 玩家移动控制\n    const speed = 200;\n    \n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-speed);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(speed);\n    } else {\n      this.player.setVelocityX(0);\n    }\n\n    if (this.cursors.up.isDown) {\n      this.player.setVelocityY(-speed);\n    } else if (this.cursors.down.isDown) {\n      this.player.setVelocityY(speed);\n    } else {\n      this.player.setVelocityY(0);\n    }\n  }\n}\n\n// 游戏配置\nconst config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#2d2d2d',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  },\n  scene: GameScene\n};\n\n// 创建游戏实例\nconst game = new Phaser.Game(config);\n```", "metadata": {"id": "distill_seed_000839_v2", "prompt_id": "seed_000839", "source": "distill", "difficulty": "medium", "modules": ["Scene", "Camera", "Physics"], "quality_score": 0.8966666666666667}}
